import { TestDriverBase, getTimeouts, Keys } from '@oracle/oraclejet-testing/UNSAFE_Driver';
import { Key, By } from 'selenium-webdriver';

const modifierKeys = {
    SHIFT: Key.SHIFT,
    CONTROL: Key.CONTROL,
    CONTROL_COMMAND: Key.CONTROL,
    ALT: Key.ALT
};
const keyMap = {
    ...modifierKeys,
    BACKSPACE: Key.BACK_SPACE,
    TAB: Key.TAB,
    ENTER: Key.ENTER,
    ESCAPE: Key.ESCAPE,
    PAGE_UP: Key.PAGE_UP,
    PAGE_DOWN: Key.PAGE_DOWN,
    END: Key.END,
    HOME: Key.HOME,
    ARROW_LEFT: Key.ARROW_LEFT,
    ARROW_UP: Key.ARROW_UP,
    ARROW_RIGHT: Key.ARROW_RIGHT,
    ARROW_DOWN: Key.ARROW_DOWN,
    DELETE: Key.DELETE,
    F1: Key.F1,
    F2: Key.F2,
    F3: Key.F3,
    F4: Key.F4,
    F5: Key.F5,
    F6: Key.F6,
    F7: Key.F7,
    F8: Key.F8,
    F9: Key.F9,
    F10: Key.F10,
    F11: Key.F11,
    F12: Key.F12
};
let currentScriptTimeout;
class SeleniumDriver extends TestDriverBase {
    constructor(driver) {
        super();
        this._platform = '';
        this._waitForElement = async (locator, parent) => {
            try {
                const el = await this.waitFor(() => parent.findElement(By.css(locator.css)), {
                    timeout: getTimeouts().elementExistsTimeout
                });
                return Promise.resolve(wrapElement(el, this._waitForElement, this._waitForElements));
            }
            catch {
                throw Error(`No element matching query "${JSON.stringify(locator)}"`);
            }
        };
        this._waitForElements = async (locator, parent) => {
            let matches;
            try {
                // loop to find at least 1 match
                matches = await this.waitFor(async () => {
                    const all = await parent.findElements(By.css(locator.css));
                    if (all.length) {
                        return all;
                    }
                    return;
                }, {
                    timeout: getTimeouts().elementExistsTimeout
                });
            }
            catch {
                return [];
            }
            return Promise.resolve(Array.from(matches || []).map((m) => wrapElement(m, this._waitForElement, this._waitForElements)));
        };
        this._driver = driver;
    }
    async executeScript(script, ...args) {
        await this._setDriverTimeouts();
        return this._driver.executeScript(script, ...args);
    }
    async waitForElement(locator) {
        return this._waitForElement(locator, this._driver);
    }
    async waitForElements(locator) {
        return this._waitForElements(locator, this._driver);
    }
    /**
     * Get a TestElement for the given WebElement
     * @param from The WebElement
     * @returns A TestElement
     */
    getTestElement(from) {
        return wrapElement(from, this._waitForElement, this._waitForElements);
    }
    async sendKeys(element, ...text) {
        await this._ensurePlatform();
        return this.unwrapElement(element).sendKeys(...text.map(this._getPlatformKey.bind(this)));
    }
    async click(element, options = {}) {
        await this._ensurePlatform();
        const modifiers = options.modifiers || [];
        const actions = this._driver.actions();
        if (modifiers) {
            modifiers.map(this._getPlatformKey.bind(this)).forEach((m) => actions.keyDown(m));
            await actions.perform();
        }
        await this.unwrapElement(element).click();
        return actions.clear();
    }
    unwrapElement(element) {
        return element._el;
    }
    async _ensurePlatform() {
        if (!this._platform) {
            this._platform = (await this._driver.getCapabilities()).getPlatform() || 'unknown';
        }
    }
    /**
     * Get the platform-specific key value for the key, if available.
     * @param key The key value
     * @returns A platform-specific value for the key, or the original key if none exists
     */
    _getPlatformKey(key) {
        if (typeof key === 'object') {
            return Keys.CONTROL_COMMAND === key
                ? this._platform === 'mac'
                    ? Key.COMMAND
                    : Key.CONTROL
                : keyMap[key.key];
        }
        return key;
    }
    _setDriverTimeouts() {
        const { scriptTimeout } = getTimeouts();
        if (scriptTimeout !== currentScriptTimeout) {
            currentScriptTimeout = scriptTimeout;
            // set script timeout
            // we don't set implicit (waitForElement) because we want to enforce our own behavior
            return this._driver.manage().setTimeouts({
                script: scriptTimeout
            });
        }
        return;
    }
}
function wrapElement(element, waitForElement, waitForElements) {
    return new TestElementImpl(element, waitForElement, waitForElements);
}
class TestElementImpl {
    constructor(element, waitForElement, waitForElements) {
        this._el = element;
        this._waitForElement = waitForElement;
        this._waitForElements = waitForElements;
    }
    waitForElement(locator) {
        return this._waitForElement(locator, this._el);
    }
    waitForElements(locator) {
        return this._waitForElements(locator, this._el);
    }
    getAttribute(attrName) {
        return this._el.getAttribute(attrName);
    }
}

export { SeleniumDriver };
//# sourceMappingURL=SeleniumDriver.mjs.map
