'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var seleniumWebdriver = require('selenium-webdriver');

/**
 * @private
 */
const defaultConfigName = '';
/**
 * @private
 */
const defaultCapabilities = new seleniumWebdriver.Capabilities({
    autoWebview: true,
    browserName: 'chrome'
});
/**
 * @private
 */
const defaultTimeouts = {
    implicit: 0,
    pageLoad: 30000,
    script: 30000
};
/**
 * @private
 */
const configs = {};
/**
 * @private
 */
let currentInstance = {
    configName: undefined,
    driver: undefined
};
/**
 * The delay, in milliseconds, that the manager will wait after the driver is
 * release to see if there are pending requests for a driver instance.  If no
 * requests exist, then the driver is closed, and subsequent requests will
 * receive a new instance.
 * @private
 */
const quitDelay = 500;
/**
 * @private
 */
let builder;
/**
 * The NodeJS.Timer used to cleanup the driver instance if no subsequent test
 * asks for the driver. The type (NodeJS.Timer) cannot be defined here because
 * typedoc cannot resolve the NodeJS namespace, so we infer it by calling
 * setTimeout instead.
 * @private
 */
let releaseTimer = setTimeout(() => true, 0);
/**
 * Manage instances of [WebDriver](index._internal_.WebDriver.html)
 * to be used by the tests. DriverManager
 * allows a single place where the WebDriver instance can be configured and
 * reused. Traditionally, tests instantiate the WebDriver instance on their own,
 * passing configurations such as the browser to use:
 * ```javascript
 * let driver = new Builder().withCapabilities({
 *   browserName: "chrome"
 * }).build()
 * ```
 * This boilerplate code then has to be copied to every test. Additionally, if
 * the capabilities need to change (say, running against a different browser),
 * that change must be applied to all test files.
 *
 * DriverManager addresses this problem by centralizing the place whereby
 * the configuration is done, and persists that configuration for all
 * subsequent requests for the WebDriver instance. The configuration only needs
 * to be set once in a "setup" file, and tests retrieve the configured instance
 * without needing to define anything else.
 *
 * A sample <code>mocha-setup.ts</code> file which configures DriverManager
 * ```javascript
 * import { DriverManager } from "@oracle/oraclejet-selenium-driver/DriverManager";
 *
 * DriverManager.registerConfig({
 *   capabilities: new Capabilities({
 *     browserName: "chrome"
 *   })
 * })
 * ```
 * This setup test script should be run before any other tests.
 * ```bash
 * $ node node_modules/mocha/bin/mocha --require=ts-node/register mocha-setup.ts other-test.spec.ts ...
 * ```
 * Test files are agnostic of the driver configuration, and simply get the instance
 * by calling <code>getDriver()</code>
 * ```javascript
 * import { DriverManager } from "@oracle/oraclejet-selenium-driver/DriverManager";
 *
 * describe("My test suite", function() {
 *   let driver: WebDriver;
 *
 *   before(async function() {
 *     driver = await DriverManager.getDriver();
 *   })
 *   it("open a page to test", async function() {
 *     await driver.get("...")
 *   })
 *   after(async function() {
 *     await DriverManager.releaseDriver(driver);
 *   })
 * })
 * ```
 *
 * ## Set default timeouts for WebDriver from Mocha.
 * When Mocha is used to start the WebDriver tests, there are two sets of timeout
 * values--one from Mocha and one from WebDriver. This causes some confusion as
 * the command-line argument <code>--timeout=nnn</code> is typically the only one
 * set and assumed to be the only timeout value in play. However, WebDriver has
 * its own set of timeout values whose defaults are sometimes longer than what's
 * set for Mocha. When this happens, WebDriver may be waiting on a condition to
 * timeout, but Mocha has errored the test because its own timeout was exceeded.
 * To ensure that WebDriver timeout conditions are properly reported to the test
 * runner (Mocha), its timeout values must be set to a value shorter than the
 * runner's. This is typically done in the setup test, and set to some factor of
 * the Mocha timeout.
 *
 * ### Set WebDriver timeout to 1/4 of Mocha
 * ```javascript
 * const mochaTimeout = this.timeouts();
 * const wdTimeout = mochaTimeout / 4;
 * DriverManager.registerConfig({
 *   timeouts: {
 *     pageLoad: wdTimeout,
 *     script: wdTimeout,
 *     implicit: wdTimeout
 *   }
 * });
 * ```
 *
 */
class DriverManager {
    /**
     * Optionally set the {@link Builder}
     * instance used by DriverManager to create WebDriver.
     * The Builder allows different settings for thigns such as the remote server,
     * proxies, and other runtime options often needed when running in distributed
     * environments.
     * The instance can be preconfigured with capabilities, and any additional
     * capabilities from [[registerConfig]] will also be applied during the
     * creation process.  If no Builder is explicitly passed, a default one will
     * be used.
     * If setting a custom Builder, this function must be called before the first
     * test calls [[getDriver]], and must only be called once per test run. If called
     * multiple times or after [[getDriver]], an error will be thrown.
     * @param b A builder instance
     */
    static setBuilder(b) {
        if (builder) {
            throw Error('DriverManager Builder instance has already been set, and cannot be set again');
        }
        builder = b;
    }
    /**
     * Register a configuration for WebDriver instances. Configurations consist of
     * {@link Capabilities} and/or {@link Timeouts}.
     * This configuration is used by [[getDriver]] to retrieve a configured WebDriver
     * instance.
     * @param config The driver configuration
     * @param name An optional name to assocaite with the config. If no name is given,
     * the config will be the default. If a name is given, its configuration is merged with the default
     * with its values taking precedence.
     *
     * ### Register a default config
     * ```javascript
     * DriverManager.registerConfig(
     *   {
     *     capabilities: new Capabilities({
     *       browserName: "chrome"
     *     }),
     *     timeouts: {
     *       implicit: 5000
     *     }
     *   }
     * );
     * ```
     * ### Register a Firefox config. These capabilities override any matching ones set in the default
     * ```javascript
     * DriverManager.registerConfig(
     *   {
     *     capabilities: new Capabilities({
     *       browserName: "firefox",
     *       hideAlerts: true
     *     })
     *   },
     *   "firefox-no-alerts"
     * );
     * ```
     */
    static registerConfig(config, name) {
        configs[name || defaultConfigName] = config;
    }
    /**
     * Get a {@link WebDriver}
     * instance for a given configuration. If no configName is given, the returned
     * driver will use the default configuration.
     * @see [[registerConfig]]
     *
     * ### Get driver with default capabilities
     * ```javascript
     * let driver = await DriverManager.getDriver();
     * ```
     * ### Configure and get Firefox driver
     * ```javascript
     * // mocha-setup.ts
     * DriverManager.registerConfig(
     *   {
     *     browserName: "firefox"
     *   },
     *   "firefox-config");
     * // test.spec.ts
     * let driver = await DriverManager.getDriver("firefox-config");
     * ```
     * @param configName An optional configuration name, registered through
     * [[registerConfig]], whose set will be applied to the driver instance. If no
     * name is given, the default configuration with the "chrome" browser
     * will be used. If the given configName doesn't exist, an error will be thrown.
     * @return A Promise that resolves to a WebDriver instance, configured with
     * custom capabilities for the given configName, or the default capabilities
     * if none is specified.
     */
    static async getDriver(configName) {
        clearTimeout(releaseTimer);
        configName = configName || defaultConfigName;
        if (configName === currentInstance.configName) {
            // Test if current driver is still valid
            try {
                if (currentInstance.driver) {
                    await currentInstance.driver.getCurrentUrl();
                    return currentInstance.driver;
                }
            }
            catch {
                // no driver or already quit
            }
        }
        await quitCurrentDriver();
        return createDriver(configName);
    }
    /**
     * Gets the current driver instance, if one exists, otherwise create and
     * return the default one. This method is useful for test setups which evaluate
     * the outcome of the previous test to capture screenshots on failures. After-
     * scripts call <code>getCurrentDriver</code> to get the instance of the driver
     * that experienced the test failure, then capture the screenshot from it.
     */
    static async getCurrentDriver() {
        return DriverManager.getDriver(currentInstance.configName);
    }
    /**
     * Release the WebDriver instance from use.  Called when each test is done
     * with its driver usage, typically, in the <code>after/afterAll</code> function.
     * If `immediate` is not given, this method will delay a brief time before telling
     * the driver to quit, allowing subsequent tests to reuse the same instance.
     * If a call to {@link getDriver} is called before the timeout is reached,
     * then the release is aborted.
     * If `immediate` is true, then a Promise<void> will be returned and the driver
     * told to quit immediately.
     * @param driver The WebDriver instance
     * @param immediate Immediately release the driver without delay
     * @returns Promise<void> A Promise that will resolve when the driver is released if
     * `immediate` is true, otherwise, void
     */
    static releaseDriver(driver, immediate = false) {
        clearTimeout(releaseTimer);
        return new Promise((resolve) => {
            if (immediate) {
                resolve(quitDriver(driver));
            }
            else {
                releaseTimer = setTimeout(() => quitDriver(driver), quitDelay);
                resolve();
            }
        });
    }
}
DriverManager.registerConfig({ capabilities: defaultCapabilities, timeouts: defaultTimeouts });
/**
 * Create a WebDriver instance from the given configuration name. The config should
 * already be registered via [registerConfig].
 * @param configName The configuration name used to retrieve the configuration
 * object for the driver instance
 * @return A Promise which resolves to the configured WebDriver instance
 * @private
 */
async function createDriver(configName) {
    const config = configs[configName];
    if (!config) {
        throw Error(`No driver configuration exists for "${configName}"`);
    }
    // Merge default capabilities with custom ones
    const caps = new seleniumWebdriver.Capabilities(configs[defaultConfigName].capabilities);
    if (config.capabilities) {
        caps.merge(config.capabilities);
    }
    // Merge default timeouts with custom ones
    const timeouts = Object.assign({}, configs[defaultConfigName].timeouts, config.timeouts);
    if (!builder) {
        builder = new seleniumWebdriver.Builder();
    }
    const driver = builder.withCapabilities(caps).build();
    currentInstance = { configName, driver };
    await driver.manage().setTimeouts(timeouts);
    return driver;
}
/**
 * @private
 */
function quitCurrentDriver() {
    return quitDriver(currentInstance.driver);
}
/**
 * @private
 */
function quitDriver(driver) {
    if (driver) {
        currentInstance = {
            configName: undefined,
            driver: undefined
        };
        return driver.quit().catch(console.warn);
    }
    return Promise.resolve();
}

exports.DriverManager = DriverManager;
//# sourceMappingURL=DriverManager.cjs.map
