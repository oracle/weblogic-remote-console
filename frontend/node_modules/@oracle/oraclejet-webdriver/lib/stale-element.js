"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.requeryElement = requeryElement;
/**
 * Requery the WebElement using its stored locator
 * @private
 * @param el The WebElement to requery
 * @return A Promise with the re-queried WebElement
 */
async function requeryElement(el) {
    const driver = el.getDriver();
    const locators = el._locators;
    if (!locators) {
        // not possible to re-query without locators
        return el;
    }
    let requeried;
    // If parentEl exists, find it first before locating element
    const parentEl = locators.parentEl ? await requeryElement(locators.parentEl) : driver;
    if (locators.elementsIndex === undefined) {
        // Element found with findElement (single)
        requeried = (await parentEl.findElement(locators.elLocator));
    }
    else {
        // Element found with findElements (multiple)
        const elements = await parentEl.findElements(locators.elLocator);
        requeried = elements[locators.elementsIndex];
    }
    if (!requeried) {
        // If element not found return the original element to throw StaleElementReferenceError in sub sequent call
        return el;
    }
    const reTagName = await requeried.getTagName();
    // Check that the requeried element is of the same type as the original.
    if (el.constructor !== requeried.constructor || locators.tagName !== reTagName) {
        throw Error(`Expected to find <${locators.tagName}> but got <${reTagName}>`);
    }
    return requeried;
}
//# sourceMappingURL=stale-element.js.map