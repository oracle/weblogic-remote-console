"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TEST_OBJ_NAME = void 0;
exports.executeWithModules = executeWithModules;
exports.hasProxy = hasProxy;
const selenium_webdriver_1 = require("selenium-webdriver");
const no_require_jet_1 = require("./no-require-jet");
exports.TEST_OBJ_NAME = '__ojwebdrivertest_proxy';
let _BROWSER_NAME;
/**
 * Run a remote script on the browser utilizing the requested modules. If JET runtime modules are
 * needed, test adapters should only use this script to access them. Never do direct imports/requires
 * in remote scripts.
 *
 * Only modules made available by ojs/ojwebdrivertest-proxy may be used.
 *
 * @param {WebDriver} driver
 * @param {string[]} moduleNames An array of strings of the modules to be made available
 * @param {any[]} scriptArgs An array of arguments to pass to the script. Pass blank array if no args
 * @param {() => T} remoteFunction The remote function to be executed. The function should take the
 * arguments containg: each requested module as separate parameters, and each script argument as
 * separate parameters after the modules.
 * @return {Promise<T>} Anything returned from the remote function
 * @template T
 */
async function executeWithModules(driver, moduleNames, scriptArgs = [], remoteFunction) {
    if (!(await hasProxy(driver))) {
        throw new Error('executeWithModules called on a non-JET page');
    }
    if (!_BROWSER_NAME) {
        const caps = await driver.getCapabilities();
        _BROWSER_NAME = caps.get(selenium_webdriver_1.Capability.BROWSER_NAME);
    }
    if (_BROWSER_NAME === selenium_webdriver_1.Browser.FIREFOX) {
        return _executeWithModulesFirefox(driver, moduleNames, scriptArgs, remoteFunction);
    }
    const s = `
    const args = Array.from(arguments);

    console.log('${exports.TEST_OBJ_NAME} importing modules ${moduleNames}');
    return ${exports.TEST_OBJ_NAME}.getProxy(...${JSON.stringify(moduleNames)}).then((modules) => {
      console.log('${exports.TEST_OBJ_NAME} running script');
      return (${remoteFunction})(...modules.concat(args));
    })
    `;
    return driver.executeScript(s, ...scriptArgs);
}
/**
 * Test if the current page has oj-module-proxy loaded
 * @param driver The WebDriver instance
 * @returns A Promise resolving to true if the page has oj-module-proxy, false otherwse
 */
function hasProxy(driver) {
    const testProxyScript = getTestProxyScript();
    return driver.executeAsyncScript(testProxyScript, exports.TEST_OBJ_NAME);
}
/**
 * Workaround https://github.com/mozilla/geckodriver/issues/1701 where properties defined via a getter are not returned
 * a) via executeAsyncScript
 * b) via a Promise returned from executeScript
 *
 * @param driver
 * @param moduleNames
 * @param scriptArgs
 * @param script
 * @returns
 */
async function _executeWithModulesFirefox(driver, moduleNames, scriptArgs = [], remoteFunction) {
    await driver.executeScript((testObjName, moduleNames) => {
        console.log(`${testObjName} importing modules ${moduleNames}`);
        // We don't actually need the returned module values here, we just want to
        // trigger the imports.  Throw away the return values so that we don't run
        // into problems trying to encode them
        return window[testObjName].getProxy(...moduleNames).then(() => { });
    }, exports.TEST_OBJ_NAME, moduleNames);
    const s2 = `
    const args = Array.from(arguments);
    const modules = ${exports.TEST_OBJ_NAME}.getCachedModules(...${JSON.stringify(moduleNames)});
    console.log('${exports.TEST_OBJ_NAME} running script');
    return (${remoteFunction})(...modules.concat(args));
  `;
    return driver.executeScript(s2, ...scriptArgs);
}
function getTestProxyScript() {
    let func;
    if ((0, no_require_jet_1.isNoRequireJet)()) {
        func = function pollForProxy(testObjectName, done) {
            if (`${testObjectName}` in window) {
                done(true);
            }
            setTimeout(() => pollForProxy(testObjectName, done), 100);
        };
    }
    else {
        func = function (_testObjectName, done) {
            function success() {
                done(true);
            }
            function failure() {
                done(false);
            }
            if (typeof require === 'function') {
                // Try sync require first
                try {
                    require('ojs/ojcore-base');
                    success();
                }
                catch (ex) {
                    require(['ojs/ojcore-base'], success, failure);
                    return;
                }
            }
            else {
                failure();
            }
        };
    }
    return func;
}
//# sourceMappingURL=oj-module-proxy.js.map