import { By, Condition, ILocation, IRectangle, ISize, Locator, WebElement, WebElementPromise } from 'selenium-webdriver';
import { DriverLike } from '../';
/**
 * The base WebElement class from which all cusom WebElements should extend.
 * This class can also be used (instantiated) directly if no component-specific
 * WebElement exists for a custom component.
 * All WebElement commands which call remote operations on the browser are
 * overidden to first:
 * <ul>
 *   <li>
 *     Capture screenshots prior to command execution. This aids in debugging if
 *     the command should fail.
 *   </li>
 *   <li>
 *     Wait for the page-level BusyContext to clear. This ensures any asynchronous
 *     activity in the application is complete before the test continues. Note
 *     that commands which interact with the DOM (such as click, sendKeys, etc)
 *     will also wait for the element to be present and have a size in the DOM
 *     (whenReady), while other "read" methods (getAttribute, isEnabled, etc) only
 *     wait for the BusyContext to clear (whenBusyContextReady).
 *   </li>
 *   <li>
 *     Trap StaleElementException and retry. This automatic trapping and retrying
 *     for StaleElementExceptions allow tests to be more resilient against UI
 *     activities which may move/recreate DOM nodes, typically resulting in failed
 *     old references from WebElements to DOM nodes. If a StaleElementException is
 *     encountered for any remote command, OjWebElement will requery the DOM node
 *     and try the command again. <i>This is implemented for all remote commands
 *     except <code>getTagName</code> because, interally, WebDriver uses that
 *     command in its <code>until.stalenessOf</code> test condition.</i>
 *   </li>
 * </ul>
 */
export declare class OjWebElement extends WebElement {
    /**
     * The ElementLocators object, used when trapping for Stale Element exceptions
     */
    private _locators;
    /**
     * Used by whenReady to avoid whenBusyContextReady being repeatedly called
     */
    private _skipBusyContext;
    /**
     * Constructor.  Pass an instance of WebDriver's WebElement that
     * represents the DOM node on which we"ll perform operations.
     * @param el The basic WebElement with which this WebElement will
     * work.
     */
    constructor(el: WebElement, locators: ElementLocators);
    /**
     * @inheritdoc
     */
    clear(): Promise<void>;
    /**
     * @inheritdoc
     */
    click(): Promise<void>;
    /**
     * @inheritdoc
     */
    getAttribute(attributeName: string): Promise<string>;
    /**
     * @inheritdoc
     */
    getCssValue(cssStyleProperty: string): Promise<string>;
    /**
     * @inheritdoc
     */
    getLocation(): Promise<ILocation>;
    /**
     * @inheritdoc
     */
    getRect(): Promise<IRectangle>;
    /**
     * @inheritdoc
     */
    getSize(): Promise<ISize>;
    /**
     * @inheritdoc
     */
    getText(): Promise<string>;
    /**
     * @inheritdoc
     */
    isDisplayed(): Promise<boolean>;
    /**
     * @inheritdoc
     */
    isEnabled(): Promise<boolean>;
    /**
     * @inheritdoc
     */
    isSelected(): Promise<boolean>;
    /**
     * @inheritdoc
     */
    sendKeys(...varArgs: Array<string | number | Promise<string | number>>): Promise<void>;
    /**
     * @inheritdoc
     */
    submit(): Promise<void>;
    /**
     * @inheritdoc
     */
    findElement(locator: Locator): WebElementPromise;
    /**
     * @inheritdoc
     */
    findElements(locator: Locator): Promise<WebElement[]>;
    /**
     * @inheritdoc
     */
    takeScreenshot(optScroll?: boolean): Promise<string>;
    /**
     * Returns a Promise that is resolved when the element is ready
     * for interaction--it is visible, has a size, and the app's
     * busy context is ready. Operations on the DOM which rely on its physical
     * location and size to be in a "ready" state should use this command, such as
     * clicking, sending keys, locating child elements, and so on.
     * @return A Promise that's resolved when all conditions
     * are met.
     */
    whenReady(): Promise<void>;
    /**
     * Returns a Promise that is resolved when the application's busy
     * state reports ready. This method checks only that the application's busy
     * context is ready, and not that the DOM element is actually displayed or has
     * a physical size, such as is the case with {@link #whenReady}. Operations
     * which are read-only in nature should call this method prior to execution.
     * @return A Promise which is resolved when the
     * page's busy state is ready.
     */
    whenBusyContextReady(): Promise<void>;
    /**
     * Get a named property value from this component.  This function
     * will wait for the application's busy context to complete before
     * attempting to get the property value.
     * @param {string} propertyName The name of the property
     * @return A Promise that yields a value for the named property.
     */
    getProperty<T = string>(propertyName: string): Promise<T>;
    /**
     * Set a property value on the remote element.  This function first waits for
     * the BusyContext to clear before setting the property, then after setting,
     * waits again to ensure that no additional busy states were created due to
     * the property setting.
     * @param {string} propertyName The property name to set
     * @param {T} value The value to set for the property
     * @return A Promise which resolves when the remote
     * property has been set to the value.  Any value returned from
     * the call to set the remote property is returned in the Promise.
     */
    protected setProperty<T = string>(propertyName: string, value: T): Promise<void>;
    /**
     * Create a wait condition that is satisfied when the element's
     * DOM has a non-zero size.
     * @return The Condition to be used with driver.wait()
     * that's satisfied when the element's DOM has a non-zero size.
     * @deprecated Since 11.0.0. Call the appropriate WebElement method to test
     * the size of the element.
     */
    protected hasSize(): Condition<Promise<boolean>>;
    /**
     * Create a wait condition that is satisfid when the element is
     * visible.  The condition is satisfied when the element is displayed,
     * as reported by {@link #isDisplayed}, and is scrolled into view.
     * This is method is deprecated. Use {@link WebElement.isDisplayed} instead to
     * test the display of the element, and scroll it into view if necessary.
     * @deprecated
     */
    protected hasVisibility(): Condition<Promise<boolean>>;
    /**
     * Private accessor to get the component property value. This is for
     * trapStaleElement to call and handle the stale element exception when calling
     * getProperty.
     * @param propertyName The name of the property
     * @return A Promise that yields a value for the named property.
     * @typeparam T The value type of the property
     */
    private _getProperty;
    /**
     * Private mutator to set the component property value. This is trapStaleElement
     * to call and handle the stale element exception when calling setProperty.
     * @param propertyName The name of the property
     * @param value The value to set for the property
     * @typeparam T The value type of the property
     */
    private _setProperty;
    /**
     * Trap commands against OjWebElement and look for stale element exceptions. If
     * found, re-query the element and try the command again.
     * @private
     * @typeparam T The type of value returned from the command.
     * @typeparam P The type of parameters passed to the command.
     * @param el The OjWebElement instance on which the command will work
     * @param cmd The command on the OjWebElement to execute
     * @param cmdParams Any parameters to pass to the command
     * @return A Promise with the results of the command, if any.
     */
    private static trapStaleElement;
}
/**
 * An interface defining the element location criteria for the original OjWebElement.
 * The properties are used by OjWebElement when trapping for stale element references
 * so that it can requery the original DOM element.
 * These values are typically set by the OjWebElement creation process and not
 * called directly by other WebElement or test code.
 * @private
 */
export interface ElementLocators {
    /**
     * The original locator for the WebElement. This can be an absolute locator
     * (used by WebDriver.findElement) or relative to the parent element (used by
     * WebElement.findElement). If absolute, a parentEl should not be specified;
     * if relative, a parentEl must be specified.
     */
    readonly elLocator: Locator;
    /**
     * The parent OjWebElement from which the elLocator was queried. This should
     * only be specified if the elLocator was used by WebElement.findElement.
     */
    readonly parentEl?: OjWebElement;
    /**
     * The original index within the array of elements returned from findElements.
     * This value should only be set when the element was queried using findElements.
     * All other rules regarding setting elLocator and parentEl still apply when
     * setting this index.
     */
    readonly elementsIndex?: number;
    /**
     * The original tag name of the element. This is used to compare the original
     * tag name against the tag name of the re-queried element.
     */
    readonly tagName: string;
}
/**
 * Create an instance of [[OjWebElement]].  This function will first wait for
 * the element to appear in the DOM before trying to locate it.
 * @param driver A WebDriver/WebElement instance used to locate the component
 * element.
 * @param by The By locator with which to find the element
 */
export declare function ojWebElement(driver: DriverLike, by: By): Promise<OjWebElement>;
