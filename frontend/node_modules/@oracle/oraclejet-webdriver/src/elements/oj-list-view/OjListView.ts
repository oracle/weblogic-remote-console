import { OjListViewBase } from './OjListViewBase';
import { slotProxy, SlotProxy } from '../../';
import { By, WebElement } from 'selenium-webdriver';
import { executeWithModules } from '../../lib/oj-module-proxy';

/**
 * The component WebElement for [oj-list-view](../../jsdocs/oj.ojListView.html).
 * Do not instantiate this class directly, instead, use
 * [ojListView](../functions/elements.ojListView-1.html).
 */
export class OjListView extends OjListViewBase {
  /**
   * Sets the value of "selected" property.
   * Specifies the current selected items in the listview. See the Help documentation for more information.
   * @param selected The value to set for "selected"
   * @override
   * @typeparam K Type of keys
   */
  async changeSelected<K>(selected: Array<K>) {
    await this.whenReady();
    return executeWithModules(
      this.getDriver(),
      ['KeySet'],
      [this, selected],
      ({ KeySetImpl }, ele, selected) => {
        ele.selected = new KeySetImpl(selected);
      }
    );
  }

  /**
   * Gets the value of "selected" property.
   * Retrieves the current selected items in the listview. See the Help documentation for more information.
   * @override
   * @typeparam K Type of keys
   * @return The value of "selected" property.
   */
  async getSelected<K>(): Promise<Array<K>> {
    await this.whenReady();
    const selected: Array<K> = await this.getDriver().executeScript((ele: any) => {
      return Array.from(ele.selected.values());
    }, this);
    return selected;
  }

  /**
   * Retrieve a SlotProxy which represents a single listview item.
   * @param key The key within the Collection's dataset associated with the item.
   */
  async findItem<T>(itemLocator: { key: T }): Promise<SlotProxy> {
    // explicitly override scrollToKey to ensure changeScrollPosition regardless
    // of DataProvider or existing scrollToKey value
    await this.setProperty('scrollToKey', 'always');
    // Call changeScrollPosition to scroll the row into view and ensure it's
    // rendere in DOM
    // TODO: Base class should mark position properties as optional
    // @ts-ignore
    await this.changeScrollPosition({
      key: itemLocator.key
    });
    await this.whenBusyContextReady();
    const display = await this.getProperty('display');
    let el = await this.getDriver().executeScript<WebElement>(
      (ele: any, key: T) => ele.getNodeBySubId({ subId: 'oj-listview-item', key }),
      this,
      itemLocator.key
    );
    if (display === 'list') {
      if (el) {
        el = el.findElement(By.css('[role="gridcell"]'));
      } else {
        throw new Error('The key specified is invalid or does not exist');
      }
    }
    return slotProxy(el, this);
  }

  /**
   * Move an item specified by key to the specified position.
   * @param key key of the item to be reordered
   * @param position the position where the item should be move to, the value can be one of:
   * <ul>
   * <li>key - the key of the item to move in front of. If the key is null, the item will be move to the end of the list</li>
   * <li>index - the index of the item relative to the root node to move in front of</li>
   * <li>groupKey with itemIndex - the key of the group to move the item inside. The itemIndex indicates the index of the item relative to the group in which to move in front of. If not specified, then it will be moved to the end of the group</li>
   * <li>groupIndex with itemIndex - an array of indexes to locate the group to move the item inside. The itemIndex indicates the index of the item relative to the group in which to move in front of. If not specified, then it will be moved to the end of the group</li>
   * </ul>
   * @override
   * @typeparam K Type of keys
   * @typeparam number Type of index
   */
  async doReorder<K>(
    key: K,
    position:
      | { index: number }
      | { key: K | null }
      | { groupIndex: number[]; itemIndex?: number }
      | { groupKey: K; itemIndex?: number }
  ) {
    await this.whenReady();
    await executeWithModules<void>(
      this.getDriver(),
      ['CustomElementUtils'],
      [this, key, position],
      ({ getElementBridge }, element, key, position) => {
        const bridge = getElementBridge(element);
        const widget = bridge._WIDGET_INSTANCE;
        return widget.listview._doReorderHelper(null, key, position);
      }
    );
  }
}
