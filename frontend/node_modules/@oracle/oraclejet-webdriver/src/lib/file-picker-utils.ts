import * as fs from 'fs';
import * as path from 'path';
import { WebDriver, WebElement } from 'selenium-webdriver';
import { whenBusyContextReady } from './busy-context-utils';

const filestoreName = '__oj_filepicker_files';
const filenamePrefix = 'file_';

// Define extension to browser window object so that we can define new properties under
// which to store file data
type WebDriverWindow = typeof window & { [key: string]: { [key: string]: any } };

type FileData = {
  bytes: number[];
  path: string;
  type: string;
};

type File = FileData & {
  numberChunks: number;
  chunkNumber: number;
  fileNumber: number;
};

/**
 * This method should be called right before ojfilepickerutils.pickFiles
 * Takes the webdriver and an Array of objects containing file paths + types.
 * These files will be read from the local filesystem and then sent
 * to the pickFiles method to simulate user file selection. Only the basename of
 * the file will be sent, not the entire path to make it consistent with how
 * the browser sets the value.
 * @param driver the Webdriver of the test
 * @param files An array of objects containing the path and type of selected files
 */
export const setupPickFiles = async (
  driver: WebDriver,
  files: Array<{ path: string; type: string }>
) => {
  await whenBusyContextReady(driver);
  //create a buffer with the files
  const dataList = files.map(({ path: filePath, type }) => {
    const fileSizeInMB = fs.statSync(filePath).size / (1024 * 1024);
    // webdriver has limit of 8MB per transfer; split file into 8MB chunks
    const numberChunks = Math.ceil(fileSizeInMB / 8);
    const fileContent = Array.from(fs.readFileSync(filePath));
    const chunkSize = Math.floor(fileContent.length / numberChunks);
    const fileChunks = [];
    for (let i = 0; i < numberChunks; i++) {
      if (i + 1 == numberChunks) {
        fileChunks.push(fileContent.slice(i * chunkSize));
      } else {
        fileChunks.push(fileContent.slice(i * chunkSize, (i + 1) * chunkSize));
      }
    }

    return {
      bytes: fileChunks, //split it into 8MB chunks
      path: path.basename(filePath),
      type,
      numberChunks
    };
  });

  for (let i = 0; i < dataList.length; i++) {
    const { bytes, path, type, numberChunks } = dataList[i];
    for (let j = 0; j < bytes.length; j++) {
      const file: File = {
        bytes: bytes[j],
        path,
        type,
        numberChunks,
        chunkNumber: j,
        fileNumber: i
      };
      await driver.executeScript(
        (file: File, filestoreName: string, filenamePrefix: string) => {
          // create the filestore object if not already exists
          const filestore = ((window as WebDriverWindow)[filestoreName] =
            (window as WebDriverWindow)[filestoreName] || {});
          const chunkNumber = file.chunkNumber;
          const data = {
            bytes: file.bytes,
            path: file.path,
            type: file.type
          };
          const fileKey = filenamePrefix + file.fileNumber;
          if (chunkNumber == 0) {
            filestore[fileKey] = [data];
          } else {
            filestore[fileKey].push(data);
          }
        },
        file,
        filestoreName,
        filenamePrefix
      );
    }
  }

  driver.executeScript(
    (numFiles: number, filestoreName: string, filenamePrefix: string) => {
      const filestore = (window as WebDriverWindow)[filestoreName];
      const list: FileData[] = [];
      for (let i = 0; i < numFiles; i++) {
        const fileKey = filenamePrefix + i;
        const chunks: File[] = filestore[fileKey];
        delete filestore[fileKey];
        list.push({
          bytes: chunks.reduce<number[]>((acc, chunk) => acc.concat(chunk.bytes), []),
          path: chunks[0].path,
          type: chunks[0].type
        });
      }
      const fileList = list.map((data) => {
        return new File([Uint8Array.from(data.bytes)], data.path, { type: data.type });
      });
      // Only if setupPickFiles has not been called yet
      if (!(HTMLInputElement as any).prototype._pickerTestData) {
        //Save the native click method
        const clickMethod = HTMLInputElement.prototype.click;
        //Overwrite the click method
        HTMLInputElement.prototype.click = function () {
          const event = new CustomEvent('change');
          this.dispatchEvent(event);
          delete (HTMLInputElement as any).prototype._pickerTestData;
          HTMLInputElement.prototype.click = clickMethod;
        };
      }
      (HTMLInputElement as any).prototype._pickerTestData = fileList;
    },
    dataList.length,
    filestoreName,
    filenamePrefix
  );
};

/**
 * Takes an Array of objects containing file paths + types.
 * These files will be read from the local filesystem and then sent
 * to the oj-file-picker to simulate user file selection. Only the basename of
 * the file will be sent, not the entire path to make it consistent with how
 * the browser sets the value.
 * @param picker The file picker element
 * @param files An array of objects containing the path and type of selected files
 */
export const doSelect = async (
  picker: WebElement,
  files: Array<{ path: string; type: string }>
) => {
  const driver = picker.getDriver();
  await setupPickFiles(driver, files);
  await driver.executeScript((el: any) => el.firstChild.click(), picker);
  return whenBusyContextReady(driver);
};
