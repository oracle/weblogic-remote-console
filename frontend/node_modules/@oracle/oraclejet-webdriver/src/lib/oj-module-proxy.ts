import { Browser, Capability, WebDriver } from 'selenium-webdriver';
import { isNoRequireJet } from './no-require-jet';

export const TEST_OBJ_NAME = '__ojwebdrivertest_proxy';

let _BROWSER_NAME: string;

/**
 * Run a remote script on the browser utilizing the requested modules. If JET runtime modules are
 * needed, test adapters should only use this script to access them. Never do direct imports/requires
 * in remote scripts.
 *
 * Only modules made available by ojs/ojwebdrivertest-proxy may be used.
 *
 * @param {WebDriver} driver
 * @param {string[]} moduleNames An array of strings of the modules to be made available
 * @param {any[]} scriptArgs An array of arguments to pass to the script. Pass blank array if no args
 * @param {() => T} remoteFunction The remote function to be executed. The function should take the
 * arguments containg: each requested module as separate parameters, and each script argument as
 * separate parameters after the modules.
 * @return {Promise<T>} Anything returned from the remote function
 * @template T
 */
export async function executeWithModules<T>(
  driver: WebDriver,
  moduleNames: string[],
  scriptArgs: any[] = [],
  remoteFunction: (...args: any[]) => T
) {
  if (!(await hasProxy(driver))) {
    throw new Error('executeWithModules called on a non-JET page');
  }
  if (!_BROWSER_NAME) {
    const caps = await driver.getCapabilities();
    _BROWSER_NAME = caps.get(Capability.BROWSER_NAME);
  }
  if (_BROWSER_NAME === Browser.FIREFOX) {
    return _executeWithModulesFirefox<T>(driver, moduleNames, scriptArgs, remoteFunction);
  }

  const s = `
    const args = Array.from(arguments);

    console.log('${TEST_OBJ_NAME} importing modules ${moduleNames}');
    return ${TEST_OBJ_NAME}.getProxy(...${JSON.stringify(moduleNames)}).then((modules) => {
      console.log('${TEST_OBJ_NAME} running script');
      return (${remoteFunction})(...modules.concat(args));
    })
    `;
  return driver.executeScript<T>(s, ...scriptArgs);
}

/**
 * Test if the current page has oj-module-proxy loaded
 * @param driver The WebDriver instance
 * @returns A Promise resolving to true if the page has oj-module-proxy, false otherwse
 */
export function hasProxy(driver: WebDriver) {
  const testProxyScript = getTestProxyScript();
  return driver.executeAsyncScript<boolean>(testProxyScript, TEST_OBJ_NAME);
}

/**
 * Workaround https://github.com/mozilla/geckodriver/issues/1701 where properties defined via a getter are not returned
 * a) via executeAsyncScript
 * b) via a Promise returned from executeScript
 *
 * @param driver
 * @param moduleNames
 * @param scriptArgs
 * @param script
 * @returns
 */
async function _executeWithModulesFirefox<T>(
  driver: WebDriver,
  moduleNames: string[],
  scriptArgs: any[] = [],
  remoteFunction: (...args: any[]) => T
) {
  await driver.executeScript<T>(
    (testObjName: any, moduleNames: string[]) => {
      console.log(`${testObjName} importing modules ${moduleNames}`);
      // We don't actually need the returned module values here, we just want to
      // trigger the imports.  Throw away the return values so that we don't run
      // into problems trying to encode them
      return (window[testObjName] as any).getProxy(...moduleNames).then(() => {});
    },
    TEST_OBJ_NAME,
    moduleNames
  );
  const s2 = `
    const args = Array.from(arguments);
    const modules = ${TEST_OBJ_NAME}.getCachedModules(...${JSON.stringify(moduleNames)});
    console.log('${TEST_OBJ_NAME} running script');
    return (${remoteFunction})(...modules.concat(args));
  `;
  return driver.executeScript<T>(s2, ...scriptArgs);
}

function getTestProxyScript() {
  let func: Function;
  if (isNoRequireJet()) {
    func = function pollForProxy(testObjectName: string, done: (hasProxy: boolean) => void) {
      if (`${testObjectName}` in window) {
        done(true);
      }
      setTimeout(() => pollForProxy(testObjectName, done), 100);
    };
  } else {
    func = function (_testObjectName: string, done: (hasProxy: boolean) => void) {
      function success() {
        done(true);
      }
      function failure() {
        done(false);
      }
      if (typeof require === 'function') {
        // Try sync require first
        try {
          require('ojs/ojcore-base');
          success();
        } catch (ex) {
          (require as any)(['ojs/ojcore-base'], success, failure);
          return;
        }
      } else {
        failure();
      }
    };
  }
  return func;
}
