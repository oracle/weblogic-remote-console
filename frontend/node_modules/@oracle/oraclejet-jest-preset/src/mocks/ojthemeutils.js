const { parse } = require('@adobe/css-tools');
const fs = require('fs');
const path = require('path');

let rules;
let cssVars;
const fontFamilyJsons = {};
function parseRules() {
  if (!rules) {
    const cssPath = require.resolve('__oj-theme-css');
    const contents = fs.readFileSync(cssPath).toString();
    rules = parse(contents).stylesheet.rules.filter((rule) => rule.selectors);
  }
}

function parseJSONFromFontFamily(className) {
  parseRules();
  let config = fontFamilyJsons[className];
  if (!config) {
    const selector = `.${className}`;
    // Find the rule matching selector and declaration with 'font-family'
    const rule = rules.find(
      (rule) =>
        rule.selectors.includes(selector) &&
        rule.declarations.find((decl) => decl.property === 'font-family')
    );
    const ff = rule.declarations.find((decl) => decl.property === 'font-family');
    // Remove !important and start/ending quotes
    const ffValue = ff.value
      .replace(/\s*!important;?/, '')
      .replace(/^'/, '')
      .replace(/'$/, '');
    config = fontFamilyJsons[className] = JSON.parse(ffValue);
  }
  return config;
}

function getCachedCSSVarValues(names) {
  parseRules();
  if (!cssVars) {
    // Find all :root declarations
    cssVars = rules.reduce((accum, rule) => {
      if (rule.selectors.includes(':root')) {
        return {
          ...accum,
          ...rule.declarations.reduce((acc2, decl) => ({ ...acc2, [decl.property]: decl }), {})
        };
      }
      return accum;
    }, {});
  }
  const matches = names.map((name) => cssVars[name]).filter(Boolean);
  // Remove leading/trailing quotes
  return matches.map((match) => match.value.replace(/^'/, '').replace(/'$/, ''));
}

module.exports = {
  clearCache: function () {},
  getThemeName: function () {},
  getThemeTargetPlatform: function () {},
  parseJSONFromFontFamily,
  verifyThemeVersion: function () {},
  getCachedCSSVarValues
};
