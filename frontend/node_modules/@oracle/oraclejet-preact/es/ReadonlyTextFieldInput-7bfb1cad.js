/* @oracle/oraclejet-preact: undefined */
import { jsx } from 'preact/jsx-runtime';
import { u as useAccessibleContext } from './useAccessibleContext-5744de8b.js';
import { u as useComponentTheme } from './useComponentTheme-d2f9e47f.js';
import './FormContext-55fb8000.js';
import { u as useFormContext } from './useFormContext-bb9dc478.js';
import './FormFieldContext-47ca0c20.js';
import { u as useFormFieldContext } from './useFormFieldContext-daf7a676.js';
import './TabbableModeContext-7d8ad946.js';
import { u as useTabbableMode } from './useTabbableMode-a2fdbb06.js';
import { u as useTranslationBundle } from './useTranslationBundle-25469f1c.js';
import { c as classNames } from './classNames-4e12b00d.js';
import { t as textInterpolations } from './textAlign-ad252afa.js';
import { m as mergeInterpolations } from './mergeInterpolations-30cd9a69.js';
import { formControlInheritTextAlign } from './UNSAFE_TextField/themes/FormControlUtilsStyles.css.js';
import { ReadonlyTextFieldInputRedwoodTheme } from './UNSAFE_TextField/themes/redwood/ReadonlyTextFieldInputTheme.js';

/**
 * Merge multiple ids into a space-separated list
 * @param ids The ids to be merged
 * @returns The space separated string of ids
 */
function mergeIDs(...ids) {
    return ids.filter(Boolean).join(' ') || undefined;
}
function ReadonlyTextFieldInput({ 'aria-describedby': ariaDescribedBy, 'aria-label': ariaLabel, 'aria-labelledby': inputLabelledBy, autoFocus, as = 'div', elementRef, formVariant, hasEmptyLabel, hasInsideLabel = false, inlineUserAssistance, innerReadonlyField, onBlur, onFocus, rows, type, value = '', variant, ...props }) {
    const translations = useTranslationBundle('@oracle/oraclejet-preact');
    const loadingAriaLabel = translations.formControl_loading();
    const { isFormLayout, isReadonly: isReadonlyForm } = useFormContext();
    const { isLoading } = useFormFieldContext();
    const ariaLabelForReadonly = isLoading ? loadingAriaLabel : ariaLabel;
    const focusProps = { onBlur, onFocus };
    // get classes for text align
    const interpolations = [...Object.values(textInterpolations)];
    const styleInterpolations = mergeInterpolations(interpolations);
    const { class: styleInterpolationClasses } = styleInterpolations(props);
    const { classes: themeClasses } = useComponentTheme(ReadonlyTextFieldInputRedwoodTheme, {
        textarea: variant === 'textarea' ? 'isTextArea' : 'notTextArea',
        formLayout: isFormLayout ? 'isFormLayout' : 'notFormLayout',
        readonlyForm: isReadonlyForm ? 'isReadonlyForm' : 'notReadonlyForm',
        insideLabel: hasInsideLabel ? 'hasInsideLabel' : 'noInsideLabel'
    });
    const readonlyDivClasses = classNames([
        themeClasses,
        styleInterpolationClasses,
        // JET-72775 - Form control alignment in tables
        // When we are in legacy collection components, we want to inherit the text align
        // when it is not set explicitly.
        formVariant === 'legacyEmbedded' && props.textAlign === undefined && formControlInheritTextAlign
    ]);
    // JET-52914 - Implement Tabbable mode API contract in InputText
    // spread tabbableModeProps on component
    const { isTabbable, tabbableModeProps } = useTabbableMode();
    // JET-52089: add unsafe API for specifying an external label which is added to ariaLabelledBy on the input or div,
    // only when labelEdge is 'none' and label is ''. Since ariaLabelledBy takes precedence over all other
    // kinds of labels, this helps to ensure we don't override a meaningful label.
    const { UNSAFE_ariaLabelledBy } = useAccessibleContext();
    const ariaLabelledBy = hasEmptyLabel
        ? mergeIDs(inputLabelledBy, UNSAFE_ariaLabelledBy)
        : inputLabelledBy;
    if (as === 'input') {
        return (jsx("input", { "aria-describedby": ariaDescribedBy, "aria-label": ariaLabelForReadonly, "aria-labelledby": ariaLabelledBy, autofocus: autoFocus, class: readonlyDivClasses, readonly: true, 
            // @ts-expect-error TS cannot infer the type correctly for the polymorphed ref
            ref: elementRef, type: type, value: value, ...(!isTabbable && tabbableModeProps), ...(hasInsideLabel && focusProps) }));
    }
    if (as === 'textarea') {
        return (jsx("textarea", { "aria-describedby": ariaDescribedBy, "aria-label": ariaLabelForReadonly, "aria-labelledby": ariaLabelledBy, autofocus: autoFocus, class: readonlyDivClasses, readonly: true, 
            // @ts-expect-error TS cannot infer the type correctly for the polymorphed ref
            ref: elementRef, rows: rows, ...(!isTabbable && tabbableModeProps), ...(hasInsideLabel && focusProps), children: value }));
    }
    return (jsx("div", { "aria-describedby": ariaDescribedBy, "aria-label": ariaLabelForReadonly, "aria-labelledby": ariaLabelledBy, "aria-readonly": true, autofocus: autoFocus, class: readonlyDivClasses, 
        // @ts-expect-error TS cannot infer the type correctly for the polymorphed ref
        ref: elementRef, role: "textbox", ...tabbableModeProps, ...(hasInsideLabel && focusProps), children: value }));
}

export { ReadonlyTextFieldInput as R };
//# sourceMappingURL=ReadonlyTextFieldInput-7bfb1cad.js.map
