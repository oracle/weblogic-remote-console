{"version":3,"file":"timeUtils-81fd753c.js","sources":["../../src/utils/UNSAFE_timeUtils/timeUtils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { EditableTimeSegmentType, OrderedTimeSegmentsArray } from '#UNSAFE_InputTimeMask/types';\nimport { BCP47Locale, DateTimeUtils } from '#UNSAFE_IntlDateTime';\nimport { TimeISOStr } from '#UNSAFE_IntlDateTime/types';\nimport { checkNoCalendarExtension } from '#utils/UNSAFE_calendarDateUtils';\nimport {\n  AmPmLocalizedValues,\n  FilteredDateTimeFormatPart,\n  Hour,\n  Millisecond,\n  MillisecondPlaceholder,\n  Minute,\n  Second,\n  Time,\n  TimeGranularity,\n  TimePlaceholders,\n  TimeWithValidIsoStrParts\n} from './types';\n\n// For locales that start with 'en', we use these placeholders.\nconst EN_LOCALE_PLACEHOLDER_HOUR = 'hh';\nconst EN_LOCALE_PLACEHOLDER_MINUTE = 'mm';\nconst EN_LOCALE_PLACEHOLDER_SECOND = 'ss';\nconst EN_LOCALE_PLACEHOLDER_MILLISECOND = 'sss';\n// For locales that do not start with 'en', we use these placeholders.\nconst NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER = '--';\nconst NON_EN_LOCALE_THREE_DIGIT_PLACEHOLDER = '---';\n\nconst AM_VALUE = 0;\nconst PM_VALUE = 12;\n\n/**\n * Given an ISO 8601 time-only string without zulu or offset e.g., 'T01:00:00.000' or 'T01:00', this method returns a Time object\n * containing 'hour' and 'minute', with optional 'second' and 'millisecond'.\n *\n * If the input is invalid (empty, null, undefined, or incorrectly formatted), this function returns undefined.\n * @param {TimeISOStr} isoTime - The ISO 8601 time string that starts with 'T'. (e.g., \"T12:30:45.123\")\n * @returns  (TimeWithValidIsoStrParts | undefined)\n * Returns a Time object with hour and minute, and optionally second and millisecond if they are in the input ISO string.\n * If the input is invalid, return undefined.\n */\nconst getTimeObjFromTimeOnlyISOStr = (isoTime: TimeISOStr | undefined | null) => {\n  // Ensure the input is defined and properly formatted.\n  if (isoTime === undefined || isoTime === null || !DateTimeUtils.isTimeOnlyIsoString(isoTime)) {\n    return undefined;\n  }\n\n  // Remove 'T' prefix and split into time and optional millisecond parts.\n  // A valid time-only ISO string must have hour and minute, and may optionally have second and millisecond.\n  const timePart = isoTime.substring(1);\n  const [fullTime, milliPart] = timePart.split('.');\n  const [hour, minute, second] = fullTime.split(':').map((num) => parseInt(num, 10));\n\n  let result: TimeWithValidIsoStrParts;\n\n  if (milliPart !== undefined) {\n    const millisecond = parseInt(milliPart, 10);\n    if (second === undefined) {\n      throw new Error('millisecond is set, but second is missing. This is an invalid iso string');\n    }\n    result = {\n      hour: hour as Hour,\n      minute: minute as Minute,\n      second: second as Second,\n      millisecond: millisecond as Millisecond\n    };\n  } else if (second !== undefined) {\n    result = {\n      hour: hour as Hour,\n      minute: minute as Minute,\n      second: second as Second\n    };\n  } else {\n    result = {\n      hour: hour as Hour,\n      minute: minute as Minute\n    };\n  }\n  return result;\n};\n\n/**\n * Given a Time object with hour, minute, and optionally second and millisecond, return a time-only ISO string that starts with 'T'.\n * @param {Time | undefined} Time object or undefined. The hour and minute must be defined, otherwise this function returns undefined.\n * @returns {TimeISOStr | undefined} Time-only ISO string that starts with 'T'. If the time is undefined, or the hour or minute are undefined, returns undefined.\n * @throws {Error} throws an error if milliseconds is defined but its value is out of the valid range of 0-999. The allowed range is too large to express in Typescript.\n */\nconst getTimeOnlyISOStrFromTimeObj = (time: Time | undefined) => {\n  if (time === undefined) {\n    return undefined;\n  }\n\n  const { hour, minute, second, millisecond } = time;\n\n  if (hour === undefined || minute === undefined) {\n    return undefined;\n  }\n\n  if (millisecond !== undefined && !checkIsValidIsoMillisecond(millisecond)) {\n    throw new Error(\n      'milliseconds is defined but it is out of range to be a valid iso string value. Must be 0-999.'\n    );\n  }\n\n  // Hour and minute must be 2 digits to be a valid ISO 8601 string.\n  const parts = [hour.toString().padStart(2, '0'), minute.toString().padStart(2, '0')];\n  let isoTime = parts.join(':');\n\n  if (second !== undefined) {\n    const secondPart = second.toString().padStart(2, '0');\n    isoTime += ':' + secondPart;\n\n    if (millisecond !== undefined) {\n      const msPart = millisecond.toString().padStart(3, '0');\n      if (msPart) {\n        isoTime += '.' + msPart;\n      }\n    }\n  }\n  return `T${isoTime}`;\n};\n\n/**\n * Returns a new array where the value in the masks array of type/value objects is replaced\n * with the string placeholders based on the locale.\n * For example, [{type='hour', value='hh'}, {type='minute', value='mm'} for 'en' locales,\n * or value='--' for non-'en' locales.\n * @param {BCP47Locale} locale - The locale.\n * @param {TimePlaceholders} masks - The TimePlaceholder masks\n * @returns A new array where the value in the masks array of type/value objects is replaced with\n * the string placeholders based on the locale.\n */\nconst replaceCustomMasksValuesWithPlaceholders = (\n  locale: BCP47Locale,\n  masks: TimePlaceholders\n): TimePlaceholders => {\n  const {\n    hourPlaceholder,\n    minutePlaceholder,\n    secondPlaceholder,\n    millisecondPlaceholder,\n    dayPeriodPlaceholder\n  } = getTimePlaceholderValuesFromLocale(locale);\n\n  return masks.map((p) => {\n    switch (p.type) {\n      case 'hour':\n        return { ...p, value: hourPlaceholder };\n      case 'minute':\n        return { ...p, value: minutePlaceholder };\n      case 'second':\n        return { ...p, value: secondPlaceholder };\n      case 'millisecond':\n        return { ...p, value: millisecondPlaceholder };\n      case 'dayPeriod':\n        return { ...p, value: dayPeriodPlaceholder };\n      default:\n        return { ...p };\n    }\n  }) as TimePlaceholders;\n};\n\n/**\n * Retrieves the TimePlaceholders masks where value has the placeholder (e.g., 'hh' or '--')\n * by using a new instance of Intl.DateTimeFormat with the locale, granularity, and hour12.\n *\n * @param {BCP47Locale} locale - The locale\n * @param {TimeGranularity} granularity - The granularity of the desired time mask.\n * @param hour12 - passes through to Intl.DateTimeFormat's hour12, which indicates\n * if the hour is a 12-hour (as opposed to 24-hour) clock.\n * E.g., new Intl.DateTimeFormat('en-GB', {timeStyle: 'short', hour12: true}).format(date)\n * @returns Returns the TimePlaceholder masks where value has the placeholders (e.g., 'hh' or '--').\n */\nconst getTimeMasksFromLocaleAndOptions = (\n  locale: BCP47Locale = 'en-US',\n  granularity: TimeGranularity,\n  hour12?: boolean\n) => {\n  checkNoCalendarExtension(locale);\n\n  // Filter out anything not related to a time mask.\n  // This does not filter out spaces, e.g., the literal space between the time and the dayPeriod.\n  const filterByTimeType = (parts: Intl.DateTimeFormatPart[]) => {\n    return parts.filter(\n      (p): p is FilteredDateTimeFormatPart =>\n        p.type === 'minute' ||\n        p.type === 'hour' ||\n        p.type === 'second' ||\n        p.type === 'dayPeriod' ||\n        p.type === 'literal'\n    );\n  };\n\n  const testDateWithTime = new Date('2022-11-30T00:00:00');\n  // If granularity is milliseconds, we use timeStyle: 'medium'. Later we stitch in the literal and millisecond part to medium since\n  // there is not a timeStyle for milliseconds, and you cannot use fractionalSecond: 3 with timeStyle in Intl.DateTimeFormat.\n  const timeStyle = granularity === 'minute' ? 'short' : 'medium';\n  const formatter = getTimeFormatterShortMedium(locale, timeStyle, hour12);\n\n  const parts = formatter.formatToParts(testDateWithTime);\n\n  const timeParts = filterByTimeType(parts);\n\n  // If granularity is millisecond, then add a separator and fractionalSecond to the array after seconds.\n  let allTimeParts;\n  if (granularity === 'millisecond') {\n    allTimeParts = insertFractionalSecond(locale, timeParts);\n  } else {\n    allTimeParts = timeParts;\n  }\n\n  // map it so that it has the same type as InputTimeMask's masks type of TimePlaceholders\n  const masks = allTimeParts.map((part) => {\n    switch (part.type) {\n      case 'fractionalSecond':\n        return { type: 'millisecond', value: part.value } as MillisecondPlaceholder;\n      case 'hour':\n      case 'minute':\n      case 'second':\n      case 'dayPeriod':\n      case 'literal':\n        return { ...part };\n    }\n  });\n\n  // replace part value with placeholder\n  return replaceCustomMasksValuesWithPlaceholders(locale, masks as TimePlaceholders);\n};\n\nconst cachedFractionalSecondsDigitFormatter = new Map<BCP47Locale, Intl.DateTimeFormat>();\n/**\n * Returns a new array with the fractionalSecond part\n * and its preceding separator part merged into the parts array after the seconds part.\n *\n * There is not an Intl.DateTimeFormat timeStyle option that displays milliseconds,\n * and you cannot use fractionalSecond: 3 with a timeStyle option at the same time in Intl.DateTimeFormat.\n * Therefore to get the parts for granularity: 'millisecond',\n * get parts from timeStyle: 'medium' and call this function with those parts. This function will stitch in\n * the separator and fractionalSecond parts after the 'second' part.\n *\n * @param {BCP47Locale} locale\n * @param {FilteredDateTimeFormatPart[]} parts - The parts from calling Intl.DateTimeFormat with timeStyle: 'medium'.\n * @returns a new parts array with the fractionalSecond and its preceding separator stitched into the parts array\n * after the 'second' part.\n */\nconst insertFractionalSecond = (locale: BCP47Locale, parts: FilteredDateTimeFormatPart[]) => {\n  const index = parts.findIndex((part) => part.type === 'second');\n  if (index === -1) {\n    // 'second' not found, return the array as is\n    return parts;\n  }\n\n  const cacheKey = `${locale}`;\n  let formatter = cachedFractionalSecondsDigitFormatter.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.DateTimeFormat(locale, {\n      hour: 'numeric',\n      minute: 'numeric',\n      second: '2-digit',\n      fractionalSecondDigits: 3,\n      numberingSystem: 'latn'\n    });\n    cachedFractionalSecondsDigitFormatter.set(cacheKey, formatter);\n  }\n\n  // get separatorValue that comes before the fractionalSecond part.\n  const partsWithFractionalSeconds = formatter.formatToParts(new Date());\n  const separatorPart = getLiteralBeforeFractionalSecond(partsWithFractionalSeconds);\n  if (separatorPart === null) {\n    return parts;\n  }\n  const newParts: FilteredDateTimeFormatPart[] = [\n    { type: 'literal', value: separatorPart.value },\n    { type: 'fractionalSecond', value: 'sss' }\n  ];\n\n  return [...parts.slice(0, index + 1), ...newParts, ...parts.slice(index + 1)];\n};\n\n/**\n * Finds and returns the 'literal' part immediately before the first 'fractionalSecond' part in an\n * array of Intl.DateTimeFormatPart objects. If not found, returns null.\n * @param {Intl.DateTimeFormatPart[]} parts\n * @returns {Intl.DateTimeFormatPart[]|null} - The literal part before the 'fractionalSecond' part.\n */\nconst getLiteralBeforeFractionalSecond = (parts: Intl.DateTimeFormatPart[]) => {\n  const index = parts.findIndex((part) => part.type === 'fractionalSecond');\n  if (index > 0 && parts[index - 1].type === 'literal') {\n    return parts[index - 1];\n  }\n  return null;\n};\n\n/**\n * Creates an object with the time segment placeholders based on the locale.\n * For locales that start with 'en', we use 'hh', 'mm', 'ss', 'sss', for\n * other locales we use '--' or '---' if millisecond.\n *\n * @param {BCP47Locale} locale\n * @returns An object with the time segment placeholders.\n */\nconst getTimePlaceholderValuesFromLocale = (locale: BCP47Locale) => {\n  const { am } = getAmPmStringsForLocale(locale);\n\n  if (locale.startsWith('en')) {\n    return {\n      hourPlaceholder: EN_LOCALE_PLACEHOLDER_HOUR,\n      minutePlaceholder: EN_LOCALE_PLACEHOLDER_MINUTE,\n      secondPlaceholder: EN_LOCALE_PLACEHOLDER_SECOND,\n      millisecondPlaceholder: EN_LOCALE_PLACEHOLDER_MILLISECOND,\n      dayPeriodPlaceholder: am\n    };\n  }\n\n  return {\n    hourPlaceholder: NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER,\n    minutePlaceholder: NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER,\n    secondPlaceholder: NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER,\n    millisecondPlaceholder: NON_EN_LOCALE_THREE_DIGIT_PLACEHOLDER,\n    dayPeriodPlaceholder: am\n  };\n};\n\n/**\n * Creates a time formatter using new Intl.DateTimeFormat for the locale.\n * @param {BCP47Locale} locale - The locale to format the time.\n * @param {'short'|'medium'} timeStyle - The timeStyle formatting option.\n * @param {boolean} hour12 - Whether to use 12-hour time format.\n * @returns A new formatter instance for the specified locale and options.\n */\nconst getTimeFormatterShortMedium = (\n  locale: BCP47Locale,\n  timeStyle: 'short' | 'medium',\n  hour12?: boolean\n) => {\n  const options =\n    hour12 === undefined\n      ? { timeStyle, numberingSystem: 'latn' }\n      : { timeStyle, hour12, numberingSystem: 'latn' };\n\n  return new Intl.DateTimeFormat(locale, options);\n};\n\n/**\n * Gets the day period value strings for AM and PM.\n *\n * @param {BCP47Locale} locale - The locale to format the time.\n * @returns An object containing the AM and PM strings for the locale.\n */\nconst getAmPmStringsForLocale = (locale: BCP47Locale): AmPmLocalizedValues => {\n  const am = getDayPeriodValueStr(locale, 0); // 0 is 12 AM\n  const pm = getDayPeriodValueStr(locale, 13); // 13 is 1 PM\n  return { am, pm };\n};\n\nconst cachedDayPeriodString = new Map<string, string>();\n\n/**\n * Retrieves the day period string for a specific locale and hour.\n * This uses a cache so a new instance of Intl.DateTimeFormat with hour12: true so even if the locale\n * does not have a 1-12 hour time by default, the hour12: true parameter will force it.\n * For example, for 'en-US' if the hour is 0, this returns 'AM'. If the hour is 13, this returns 'PM'.\n * For 'ms', if the hour is 0, this returns 'PG'.\n *\n * @param {BCP47Locale} locale - The locale to format the time.\n * @param {Hour} hour - The hour for which to get the day period (0-23).\n * @returns {string} The locale's day period value for the hour. All locales have a dayPeriod string, but\n * just in case we default to 'AM' and 'PM'.\n */\nconst getDayPeriodValueStr = (locale: BCP47Locale = 'en-US', hour: Hour) => {\n  const morningIsoHourStr = '00';\n  const eveningIsoHourStr = '23';\n  const isoHourStr = hour < 12 ? morningIsoHourStr : eveningIsoHourStr;\n\n  // is locale + isoHourStr in the cache? If so, return it.\n  const dayPeriod = cachedDayPeriodString.get(`${locale}-${isoHourStr}`);\n  if (!dayPeriod) {\n    // This sets hour12 to true.\n    const formatter = getTimeFormatterShortMedium(locale, 'short', true);\n    // Cache both am and pm values at the same time in order to use the same formatter for performance sake.\n    [morningIsoHourStr, eveningIsoHourStr].forEach((hourToCache) => {\n      const isoStr = `2022-11-30T${hourToCache}:00:00`;\n      const date = new Date(isoStr);\n      const parts = formatter.formatToParts(date);\n      const dayPeriodPart = parts.find((p) => p.type === 'dayPeriod');\n      // All locales I tested have a dayPeriod string when hour12: true,\n      // but just in case there is a locale for Intl.DateTimeFormat with no dayPeriod string, we default to one.\n      const defaultDayPeriodToCache = hourToCache === morningIsoHourStr ? 'AM' : 'PM';\n      const dayPeriodToCache = dayPeriodPart ? dayPeriodPart.value : defaultDayPeriodToCache;\n      cachedDayPeriodString.set(`${locale}-${hourToCache}`, dayPeriodToCache);\n    });\n    // return the dayPeriod for the hour requested that we just cached.\n    return cachedDayPeriodString.get(`${locale}-${isoHourStr}`)!;\n  }\n  return dayPeriod;\n};\n\nconst getDayPeriodValueFromHour = (hour: Hour) => {\n  return hour > 11 ? PM_VALUE : AM_VALUE;\n};\n\n/**\n * Formats a Time object into a string based on the provided masks.\n * Handles hour conversion (12-hour/24-hour) since the Time object is in 24-hour format,\n * and the mask, if it has the dayPeriod, is in 12-hour format. Applies leading\n * zeros to hour if leadingZeroForHour is true. Pads zeros to minute, second, and millisecond so\n * that the digits equal two for minute/second and three for millisecond.\n * The timeMasks must have the correct segments to match the granularity before calling this function.\n * @param locale\n * @param time\n * @param granularity\n * @param timeMasks\n * @param leadingZeroForHour\n * @returns a formatted time string\n */\nconst formatTimeFromMasks = (\n  locale: BCP47Locale,\n  time: Time,\n  granularity: TimeGranularity,\n  timeMasks: TimePlaceholders,\n  leadingZeroForHour: boolean\n) => {\n  checkNoCalendarExtension(locale);\n  // First, the time must be complete.\n  if (\n    time.hour === undefined ||\n    time.minute === undefined ||\n    (granularity === 'second' && time.second === undefined) ||\n    (granularity === 'millisecond' && time.millisecond === undefined)\n  ) {\n    return '';\n  }\n\n  const hasDayPeriod = timeMasks.some((part) => part.type === 'dayPeriod');\n  const dayPeriodToDisplay = hasDayPeriod ? getDayPeriodValueStr(locale, time.hour) : ''; // e.g., 'AM' or 'PM' for 'en-US'\n\n  // Format hour with optional leading zero\n  const timeHour = hasDayPeriod ? to12Hour(time.hour) : time.hour;\n  const hourToDisplay = leadingZeroForHour ? padWithZero(timeHour, 2) : timeHour.toString();\n\n  // Format minute, second, and millisecond with necessary padding\n  const minuteToDisplay = padWithZero(time.minute, 2);\n  const secondToDisplay = padWithZero(time.second, 2);\n  const millisecondToDisplay = padWithZero(time.millisecond, 3);\n\n  // Map timeMasks to their corresponding values and join them into a formatted time string.\n  const timeValues = timeMasks.map(({ type, value }) =>\n    type === 'hour'\n      ? hourToDisplay\n      : type === 'minute'\n      ? minuteToDisplay\n      : type === 'second'\n      ? secondToDisplay\n      : type === 'millisecond'\n      ? millisecondToDisplay\n      : type === 'dayPeriod'\n      ? dayPeriodToDisplay\n      : value\n  );\n  return timeValues.join('');\n};\n\n/**\n * Retrieves the hour string. If the display has a day period, then the hour string\n * will be 1-12, otherwise it will be 0-23.\n * @param hour\n * @param hasDayPeriod true if the time to display has a day period segment (e.g., a segment that shows AM or PM).\n * This means the time field has a 1-12 hour time.\n * @param leadingZeroForHour If true, the hour string will have length of 2, with leading zeros if necessary to pad it out.\n * @returns\n */\nconst getHourValueStr = (hour: Hour, hasDayPeriod: boolean, leadingZeroForHour: boolean) => {\n  // If hasDayPeriod, the hour to display is in the range of 1-12. E.g., 1:00 AM.\n  // Since the hour parameter is 0-23, the hour to display needs to be converted to a 1-12 hour string.\n  // If hasDayPeriod is false, the hour to display is in the range of 0-23. E.g., 01:00.\n  const timeHour = hasDayPeriod ? to12Hour(hour) : hour;\n  return leadingZeroForHour ? padWithZero(timeHour, 2) : timeHour.toString();\n};\n\nconst cachedTimeStyleShortHasLeadingZero = new Map<BCP47Locale, boolean>();\n/**\n * Returns true if the locale's hour has a leading zero by default.\n *\n * This method uses a cached new Intl.DateTimeFormat(locale),\n * and uses formatToParts for hour\n * to figure out if the hour has a leading zero.\n *\n * @param {BCP47Locale} locale - the locale\n * @returns true if hour starts with 0 for the specific locale.\n */\nconst getLeadingZeroForHour = (locale: BCP47Locale) => {\n  // check timeStyle short for the locale\n  // and see if the hour starts with 0.\n  // if so, return true;\n  const value = new Date('1995-12-17T09:30:00');\n  const cacheKey = `${locale}`;\n  let isLeadingZero = cachedTimeStyleShortHasLeadingZero.get(cacheKey);\n  if (isLeadingZero === undefined) {\n    const formatter = new Intl.DateTimeFormat(locale, {\n      timeStyle: 'short',\n      numberingSystem: 'latn'\n    });\n    const parts = formatter.formatToParts(value);\n    const hourPart = parts.find((part) => part.type === 'hour');\n    const hourValue = hourPart?.value;\n    isLeadingZero = hourValue!.startsWith('0');\n    cachedTimeStyleShortHasLeadingZero.set(cacheKey, isLeadingZero);\n  }\n\n  return isLeadingZero;\n};\n\n/**\n * Converts the 24-hour hour to a 12-hour hour.\n * @param {Hour} hour24\n * @returns\n */\nconst to12Hour = (hour24: Hour) => {\n  const hour12 = hour24 % 12 === 0 ? 12 : hour24 % 12;\n  return hour12;\n};\n\nconst padWithZero = (num: number | undefined, length: number) => {\n  return num !== undefined ? num.toString().padStart(length, '0') : '';\n};\n\n/**\n * Returns true if the time params represent two different times.\n * This is useful to call before we call onInput or onCommit.\n * @param t1\n * @param t2\n * @returns true if the time params represent two different times.\n */\nconst timesAreDifferent = (t1: Time | undefined, t2: Time | undefined) => {\n  const isEmpty = (time: Time | undefined) => {\n    return (\n      !time || // if time is undefined\n      (time.hour === undefined &&\n        time.minute === undefined &&\n        time.second === undefined &&\n        time.millisecond === undefined)\n    );\n  };\n\n  // Both are empty/undefined, return false (same)\n  if (isEmpty(t1) && isEmpty(t2)) return false;\n\n  // If one is empty/undefined and the other isn't, return true (different)\n  if (isEmpty(t1) !== isEmpty(t2)) return true;\n\n  // Return true if any of the segment values don't match.\n  if (\n    t1?.hour !== t2?.hour ||\n    t1?.minute !== t2?.minute ||\n    t1?.second !== t2?.second ||\n    t1?.millisecond !== t2?.millisecond\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Compares two TimeWithValidIsoStrParts objects and returns a number indicating their relative order.\n * @param {TimeWithValidIsoStrParts} time1 The first time to compare.\n * @param {TimeWithValidIsoStrParts} time2 The second time to compare.\n * @returns {number} A negative number if time1 is before time2, a positive number if time1 is after time2, or 0 if they are the same.\n */\nconst compareTimes = (time1: TimeWithValidIsoStrParts, time2: TimeWithValidIsoStrParts) => {\n  if (time1.hour !== time2.hour) {\n    return time1.hour - time2.hour;\n  }\n  if (time1.minute !== time2.minute) {\n    return time1.minute - time2.minute;\n  }\n  // fill second and millisecond to 0 if it isn't filled in.\n  const time1Second = time1.second ?? 0;\n  const time2Second = time2.second ?? 0;\n  if (time1Second !== time2Second) {\n    return time1Second - time2Second;\n  }\n  const time1Millisecond = time1.millisecond ?? 0;\n  const time2Millisecond = time2.millisecond ?? 0;\n  return time1Millisecond - time2Millisecond;\n};\n\n/**\n * Determines whether the input string matches the start of the 'am' and/or 'pm' strings in the given am/pm object.\n *\n * The match is case-insensitive and ignores leading and trailing whitespace.\n *\n * If the input matches with only the start of the 'am' string, 'am' is returned.\n * If the input matches with only the start of the 'pm' string, 'pm' is returned.\n * If the input matches the start of both the 'am' and 'pm strings (e.g., the 'am'/'pm' strings have the same starting letter(s) and the input is too short to disambiguate),\n * 'both is returned.\n * If the input does not match the start of either string, 'none' is returned.\n * @param {AmPmLocalizedValues} amPmObj - An object containing the am and pm strings for the current locale.\n * @param {string} input - The user provided string to match against the am an pm strings.\n * @returns {('am' | 'pm' | 'none' | 'both')}\n */\nconst getAmPmMatchType = (amPmObj: AmPmLocalizedValues, input: string) => {\n  const trimmedInput = input.trim().toLowerCase();\n\n  // If input is empty after trimming, return 'none'\n  if (trimmedInput === '') {\n    return 'none';\n  }\n\n  // Check if the input matches as a prefix in either property (am or pm)\n  const matchesAM = amPmObj.am.toLowerCase().startsWith(trimmedInput);\n  const matchesPM = amPmObj.pm.toLowerCase().startsWith(trimmedInput);\n\n  // If both match, return 'both'\n  if (matchesAM && matchesPM) {\n    return 'both';\n  }\n\n  // If only one matches, return that\n  if (matchesAM) {\n    return 'am';\n  }\n\n  if (matchesPM) {\n    return 'pm';\n  }\n\n  // If neither matches\n  return 'none';\n};\n\n/**\n * Check if the value has segments in it that are not displayed to the user.\n * E.g., originalValue: {hour: 1, minute: 30, second: 59, millisecond: 599}, and the segments are: ['hour', 'minute'], returns true.\n * originalValue: {millisecond: 599}, and the segments are: ['hour', 'minute'], returns true.\n * originalValue: {second: 599}, and the segments are: ['hour', 'minute'], returns true.\n * originalValue: {second: 599}, and the segments are: ['hour', 'minute'], returns true.\n * originalValue: {hour: 1, minute: 30, second: 599}, and the segments are: ['hour', 'minute', 'second'], returns false.\n * @param orderedSegments {OrderedTimeSegmentsArray} - The segments that are displayed to the user\n * @param originalValue {Time|undefined} - The original Time value.\n * @returns {boolean} returns true if the originalValue has segments that are not displayed to the user.\n */\nconst hasSegmentsNotDisplayed = (\n  orderedSegments: OrderedTimeSegmentsArray,\n  originalValue: Time | undefined\n) => {\n  if (originalValue === undefined) {\n    return false;\n  }\n  // orderedSegments are the segments that are displayed to the user.\n  // filter out the 'dayPeriod' since that is not part of the Time object.\n  const filteredSegments = orderedSegments.filter((item) => item !== 'dayPeriod');\n\n  // loop through each key in the original value and see if it exists in the filteredSegments\n  const hasExtraSegmentsCondition = (key: string) =>\n    (key === 'hour' || key === 'minute' || key === 'second' || key === 'millisecond') &&\n    !filteredSegments.includes(key);\n  return Object.keys(originalValue).some(hasExtraSegmentsCondition);\n};\n\n/**\n * Returns true if any one of the displayed time segments has a different value in initialTime vs updatedTime.\n * @param orderedSegments {OrderedTimeSegmentsArray} the time segments that are displayed to the user\n * @param initialTime {Time} The initial time.\n * @param updatedTime {Time} The updated time.\n * @returns true if the displayed time segments have different values\n */\nconst displayedTimeSegmentsAreDifferent = (\n  orderedSegments: OrderedTimeSegmentsArray,\n  initialTime: Time,\n  updatedTime: Time\n) => {\n  // orderedSegments are the segments that are displayed to the user.\n  // filter out the 'dayPeriod' since that is not part of the Time object.\n  const filteredSegments = orderedSegments.filter((item) => item !== 'dayPeriod') as Array<\n    Exclude<EditableTimeSegmentType, 'dayPeriod'>\n  >;\n  for (const key of filteredSegments) {\n    const value1 = initialTime[key]; // might be undefined. In which case, this will return true if value2 also has undefined for this key.\n    const value2 = updatedTime[key];\n    if (value1 !== value2) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if millisecond is a valid ISO value (0-999).\n * The allowed range is too large to express using Typescript.\n */\nconst checkIsValidIsoMillisecond = (millisecond: number) => {\n  return millisecond >= 0 && millisecond <= 999;\n};\n\n/**\n * Format an example TimeISOStr to show in an error message.\n */\nconst formatIsoTimeStrAsExample = (\n  str: TimeISOStr,\n  locale: BCP47Locale,\n  granularity: TimeGranularity,\n  leadingZeroForHour: boolean,\n  masks: TimePlaceholders\n) => {\n  const timeObj = getTimeObjFromTimeOnlyISOStr(str);\n  return timeObj === undefined\n    ? ''\n    : formatTimeFromMasks(locale, timeObj, granularity, masks, leadingZeroForHour);\n};\n\n// Given a pattern, return a TimePlaceholder array.\nconst getTimePlaceholdersFromPattern = (pattern: string) => {\n  const arr = getTimeMaskArrayFromPattern(pattern);\n  const timePlaceholders = convertMaskArrayToTimePlaceholders(arr);\n  return timePlaceholders;\n};\n\n// Given a pattern, like 'h:ss a', return an array like ['h', ':', 'ss', ' ', 'a'].\n// We only support pattern for FA User Preferences, and none of the FA time patterns have milliseconds.\nconst getTimeMaskArrayFromPattern = (pattern: string) => {\n  const result: Array<string> = [];\n  let currentSegmentStr = '';\n  let currentLiteral = '';\n\n  const addSegment = () => {\n    if (currentSegmentStr !== '') {\n      result.push(currentSegmentStr);\n      currentSegmentStr = '';\n    }\n  };\n\n  const addLiteral = () => {\n    if (currentLiteral !== '') {\n      // InputTimeMask wants spaces in its literals, like the space between the time and dayPeriod.\n      result.push(currentLiteral);\n      currentLiteral = '';\n    }\n  };\n\n  for (let i = 0; i < pattern.length; i++) {\n    const char = pattern[i];\n\n    // if we get a character that is not a literal, then push the literal, if any.\n    // This also handles the case where the pattern does not have a space between the 'a' (dayPeriod)\n    // and the hour, minute, or second, like 'ahh:mm:ss' or 'hh:mma' or 'hh:mm:ssa'; These dayPeriod\n    // and hour, minute, second are different segments even though there is no space.\n    // Currently there are no user preference patterns with 'a' at the end with no space before it,\n    // but we handle it just the same.\n    // None of the FA User Preference patterns have milliseconds, so we do not support that here.\n    if (\n      char.toLowerCase() === 'h' ||\n      char.toLowerCase() === 'm' ||\n      char.toLowerCase() === 's' ||\n      char.toLowerCase() === 'a'\n    ) {\n      addLiteral();\n      if (currentSegmentStr[0] === char) {\n        currentSegmentStr += char;\n      } else {\n        addSegment();\n        currentSegmentStr = char;\n      }\n    } else {\n      addSegment();\n      currentLiteral += char;\n    }\n  }\n\n  // Add the last components\n  addSegment();\n  addLiteral();\n\n  return result;\n};\n\n// converts an array into the object that is needed to set on the InputTimeMask's masks property, TimePlaceholders type;\n// This is used when converting a pattern into a masks property.\n// None of the FA User Preference patterns have milliseconds, so we do not support that here.\nconst convertMaskArrayToTimePlaceholders = (array: Array<string>) => {\n  return array.map((item) => {\n    if (item.toLowerCase()[0] === 'h') {\n      return { type: 'hour', value: EN_LOCALE_PLACEHOLDER_HOUR };\n    } else if (item.toLowerCase()[0] === 'm') {\n      return { type: 'minute', value: EN_LOCALE_PLACEHOLDER_MINUTE };\n    } else if (item.toLowerCase()[0] === 's') {\n      return { type: 'second', value: EN_LOCALE_PLACEHOLDER_SECOND };\n    } else if (item.toLowerCase()[0] === 'a') {\n      return { type: 'dayPeriod', value: 'am/pm' };\n    } else {\n      // Default to literal for anything else\n      return { type: 'literal', value: item };\n    }\n  }) as TimePlaceholders;\n};\n\nexport {\n  AM_VALUE,\n  PM_VALUE,\n  compareTimes,\n  displayedTimeSegmentsAreDifferent,\n  formatIsoTimeStrAsExample,\n  formatTimeFromMasks,\n  getAmPmMatchType,\n  getAmPmStringsForLocale,\n  getDayPeriodValueFromHour,\n  getDayPeriodValueStr,\n  getHourValueStr,\n  getLeadingZeroForHour,\n  getTimeOnlyISOStrFromTimeObj,\n  getTimePlaceholdersFromPattern,\n  getTimeObjFromTimeOnlyISOStr,\n  getTimeMasksFromLocaleAndOptions,\n  hasSegmentsNotDisplayed,\n  padWithZero,\n  replaceCustomMasksValuesWithPlaceholders,\n  timesAreDifferent\n};\n"],"names":["DateTimeUtils.isTimeOnlyIsoString"],"mappings":"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"}