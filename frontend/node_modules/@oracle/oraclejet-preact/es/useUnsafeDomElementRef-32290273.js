/* @oracle/oraclejet-preact: undefined */
import { useRef } from 'preact/hooks';
import { U as UNSAFE_DOM_ACCESS } from './unsafeDomAccess-453eb74e.js';

/**
 * This hook converts a ref of type UnsafeDomHandle to a ref that directly exposes
 * the unsafe DOM element.
 *
 * The intention is that this can be used internally in JET Preact to simplify
 * cases where we receive and UnsafeDomHandle but need to pass this to code
 * that operates an an element-based ref.
 *
 * An alternative approach would be to rewrite any code that currently operates
 * on element-based refs to also support UnsafeDomHandle.  While we can do that
 * at any point, the advantage of this hook is that it limits the scope of code
 * that needs to be aware of unsafe DOM handles.
 *
 * For typing purposes, this function exposes two type parameters:
 *
 * - ElementType: this is the type of the unsafe DOM element that will be
 *   extracted and placed in the returned ref.
 * - ExtraType: in some cases refs may support additional types beyond
 *   just UnsafeDomHandle.  For example, Floating's anchorRef has the
 *   type  RefObject<Element | Coords | UnsafeDomHandle<Element>>.  The
 *   ExtraType type parameter would be used to convey that <Element | Coords> are
 *   also valid types for the ref handle.
 */
function useUnsafeDomElementRef(unsafeRootElementRef) {
    const extractedRef = useRef(null);
    // Note that in theory we should be able to populate the extractedRef's value via
    // useImperativeHandle.  In practice, this does not work due to Popup + Floating's
    // handling of anchorRef.  In particular, the Popup component writes the anchorRef.current
    // value during rendering.  The Floating component reads the anchorRef.current value
    // during rendering.  However, useImperativeHandle does its work in a layout effect.
    // If we attempt to true up the extractedRef with the provided unsafeRootElementRef via
    // an imperative handle, extractedRef will only be updated after Floating has already read
    // the stale value.
    //
    // Note that React discourages reading/writing refs during rendering.  See the "Pitfall"
    // section under:
    //
    // https://react.dev/reference/react/useRef#referencing-a-value-with-a-ref
    //
    // While we should probably revisit our ref handling in Popup/Floating, for the moment I
    // am working around this by avoiding useImperativeHandle and instead directly modifying
    // ref.current (which, ironically, also violates React's recommendations).
    let current = unsafeRootElementRef.current;
    const unsafeDomHandle = current;
    if (unsafeDomHandle?.[UNSAFE_DOM_ACCESS]) {
        current = unsafeDomHandle[UNSAFE_DOM_ACCESS];
    }
    if (extractedRef.current !== current) {
        extractedRef.current = current;
    }
    return extractedRef;
}

export { useUnsafeDomElementRef as u };
//# sourceMappingURL=useUnsafeDomElementRef-32290273.js.map
