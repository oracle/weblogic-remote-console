/* @oracle/oraclejet-preact: undefined */
import { jsxs, jsx, Fragment } from 'preact/jsx-runtime';
import { useRef, useState, useCallback } from 'preact/hooks';
import { styles } from './PRIVATE_VisOverview/themes/VisOverview.css.js';
import { a as getElementData } from './eventsUtils-e96290df.js';
import './accUtils-f6657e8e.js';
import { S as SvgDragH } from './DragH-bbf55c85.js';
import { i as isTouch } from './clientUtils-cccff45f.js';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const OVERVIEW_MIN_SIZE = 20;
function useOverviewEvents({ x, width, windowX, windowWidth, rootRef, windowHeight, windowY, onWindowDimsChange }) {
    const pointerDownPointRef = useRef();
    const [lastPoint, setLastPoint] = useState();
    const onPointerDown = useCallback((event) => {
        pointerDownPointRef.current = { x: event.offsetX, y: event.offsetY };
        event.target.setPointerCapture(event.pointerId);
        setLastPoint({ x: event.offsetX, y: event.offsetY });
    }, [pointerDownPointRef]);
    const onPointerUp = useCallback((event) => {
        const { offsetX: clickX, offsetY: clickY } = event;
        const isPointerUpFar = Math.abs(pointerDownPointRef.current.x - clickX) > OVERVIEW_MIN_SIZE / 4;
        pointerDownPointRef.current = undefined;
        setLastPoint(undefined);
        if ((clickX <= windowX + windowWidth &&
            clickX >= windowX &&
            clickY <= windowY + windowHeight &&
            clickY >= windowY) ||
            isPointerUpFar) {
            return;
        }
        const newX = Math.min(x + width - windowWidth, Math.max(clickX - windowWidth / 2, x));
        onWindowDimsChange?.({ deltaX: newX - windowX, deltaWidth: 0 });
    }, [pointerDownPointRef, windowHeight, windowX, windowY, windowWidth, width, x, onWindowDimsChange]);
    const onPointerMove = useCallback((event) => {
        const targetType = getElementData(rootRef, event.target)?.['ojPrivateObject'];
        if (!pointerDownPointRef.current ||
            event.target == null ||
            targetType == null ||
            lastPoint == null) {
            return;
        }
        let deltaX = 0;
        let deltaWidth = 0;
        if (targetType === 'window') {
            const delta = event.offsetX - lastPoint.x;
            deltaX = Math.min(x + width - windowWidth, Math.max(x, windowX + delta)) - windowX;
        }
        else if (targetType === 'leftHandle' &&
            event.offsetX <= windowX + windowWidth - OVERVIEW_MIN_SIZE / 2 &&
            event.offsetX > x) {
            deltaX = Math.max(x, windowX + event.offsetX - lastPoint.x) - windowX;
            deltaWidth = -1 * deltaX;
        }
        else if (targetType === 'rightHandle' &&
            event.offsetX >= windowX + OVERVIEW_MIN_SIZE / 2 &&
            event.offsetX < x + width) {
            deltaWidth = Math.min(event.offsetX - lastPoint.x, x + width - windowX);
        }
        setLastPoint({ x: event.offsetX, y: event.offsetY });
        onWindowDimsChange?.({ deltaX, deltaWidth });
        event.stopPropagation();
    }, [pointerDownPointRef, rootRef, x, lastPoint, width, windowX, windowWidth, onWindowDimsChange]);
    return {
        onPointerDown,
        onPointerUp,
        onPointerMove
    };
}

const OVERVIEW_HANDLE_SIZE = 16;
const OVERVIEW_HANDLE_ACTIVATION_SIZE = isTouch() ? 30 : 10;
function OverviewSlidingWindow({ x, width, height, y, windowX, windowHeight, windowWidth, windowY, hasHandles, onWindowDimsChange }) {
    const rootRef = useRef(null);
    const overviewProps = useOverviewEvents({
        x,
        y,
        width,
        height,
        windowHeight,
        windowWidth,
        windowX,
        windowY,
        rootRef,
        onWindowDimsChange
    });
    const handleIconY = windowY + 0.5 * (windowHeight - OVERVIEW_HANDLE_SIZE);
    return (jsxs("g", { ref: rootRef, ...(hasHandles ? overviewProps : {}), children: [jsx("rect", { x: x, y: y, width: width, height: height, fill: "transparent" }), jsx("rect", { "data-oj-private-object": "window", cursor: "move", x: windowX, y: windowY, height: windowHeight - 1, width: windowWidth - 1, class: styles.overviewWindow }), hasHandles && (jsxs(Fragment, { children: [jsx("g", { transform: `translate(${windowX} ${handleIconY})`, children: jsx(SvgDragH, { color: "primary" }) }), jsx("g", { transform: `translate(${windowX + windowWidth - OVERVIEW_HANDLE_SIZE} ${handleIconY})`, children: jsx(SvgDragH, { color: "primary" }) }), jsx("rect", { x: windowX, y: windowY, height: windowHeight, width: OVERVIEW_HANDLE_ACTIVATION_SIZE, strokeWidth: "1", "data-oj-private-object": "leftHandle", fill: "transparent", stroke: "transparent", cursor: "col-resize" }), jsx("rect", { x: windowX + windowWidth - OVERVIEW_HANDLE_ACTIVATION_SIZE, y: windowY, strokeWidth: "1", height: windowHeight, "data-oj-private-object": "rightHandle", width: OVERVIEW_HANDLE_ACTIVATION_SIZE, stroke: "transparent", fill: "transparent", cursor: "col-resize" })] }))] }));
}

export { OverviewSlidingWindow as O };
//# sourceMappingURL=OverviewSlidingWindow-36d20536.js.map
