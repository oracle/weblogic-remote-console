/* @oracle/oraclejet-preact: undefined */
import { jsx, jsxs, Fragment } from 'preact/jsx-runtime';
import { T as TrackResizeContainer } from './TrackResizeContainer-4411f745.js';
import { labelStyles, buttonStyle, layerStyles, itemStyles, panZoomStyles, outerStyles, dimensionStyle } from './PRIVATE_ContainerDiagram/themes/DiagramStyles.css.js';
import { u as useResizeObserver } from './useResizeObserver-13641643.js';
import { useRef, useCallback, useState } from 'preact/hooks';
import { g as generateAriaLabel } from './accUtils-f6657e8e.js';
import { c as classNames } from './classNames-4e12b00d.js';
import { u as useTranslationBundle } from './useTranslationBundle-25469f1c.js';
import { u as useUser } from './useUser-df8ae011.js';
import { S as SvgMinus } from './Minus-3b70b768.js';
import { S as SvgPlus } from './Plus-19b8c4e4.js';
import { g as getRandomId, c as calculateOffset } from './layoutUtils-895c6de8.js';
import { u as useVisHover } from './useVisHover-d7a0b2f3.js';
import { m as mergeProps } from './mergeProps-88ea8306.js';
import { u as useDatatip } from './useDatatip-c7727336.js';
import { u as useTextDimensions } from './useTextDimensions-45f79df4.js';
import { i as isTouch } from './clientUtils-cccff45f.js';
import { u as useVisDragModeControls } from './useVisDragModeControls-92ddac92.js';
import { u as useSelection } from './useSelection-8a26bc9e.js';
import { u as useVisTouchResponse } from './useVisTouchResponse-a59ab166.js';
import { l } from './stringUtils-0fe25200.js';
import { u as useContextMenu } from './useContextMenu-6aa8193e.js';
import './SelectMenuGroupContext-0c1a7603.js';
import 'preact';
import './logger-c92f309c.js';
import './LayerHost-12489cef.js';
import 'preact/compat';
import './TooltipContentStyles.styles.css';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentBaseTheme.styles.css';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js';
import './tooltipUtils-466c63c4.js';
import './IconStyle.styles.css';
import './UNSAFE_Menu/themes/MenuItemStyles.css.js';
import './UNSAFE_Separator/themes/SeparatorStyles.css.js';
import './MenuSeparatorStyles.styles.css';
import './UNSAFE_Menu/themes/redwood/MenuSeparatorBaseTheme.styles.css';
import './UNSAFE_Menu/themes/redwood/MenuSeparatorVariants.css.js';
import './MenuStyles.styles.css';
import './useSize-3b5c56f5.js';
import './size-a3d3aeaf.js';
import './utils-cfef1929.js';
import './themeContract.css-2b5a42e2.js';
import './colorUtils-b3804ee8.js';
import './_curry1-63949a9b.js';
import './DiagramStyles.styles.css';
import './useAddBusyState-7a6af61f.js';
import './BusyStateContext-9ee9751d.js';
import './useBusyStateContext-4d3c27c0.js';
import './unsafeDomAccess-453eb74e.js';
import './clientHints-a42b510c.js';
import './Icon-ef2ac069.js';
import './useTooltip-f442fedb.js';
import './useTooltipControlled-d7724623.js';
import './useId-03dbfdf0.js';
import './useHover-85077adb.js';
import './useToggle-8b7fcefe.js';
import './useFocus-38c95977.js';
import './useTouch-4828df25.js';
import './useAnimation-a5eb7604.js';
import './useComponentTheme-d2f9e47f.js';
import './useTestId-e5d44ab1.js';
import './useThemeInterpolations-4b48d878.js';
import './useColorScheme-96cce6a1.js';
import './useScale-0ebe15ed.js';
import './theme-63551f30.js';
import './Theme-e6dec6db.js';
import './mergeInterpolations-30cd9a69.js';
import './mergeDeepWithKey-33e3d1be.js';
import './_curry3-577eb45e.js';
import './_curry2-01c87f61.js';
import './_isObject-1fab0f5b.js';
import './useDensity-d06ae84a.js';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentTheme.js';
import './hooks/UNSAFE_useTooltip/themes/TooltipContentStyles.css.js';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentBaseTheme.css.js';
import './TooltipContentVariants.styles.css';
import './vanilla-extract-recipes-createRuntimeFn.esm-2aaf8c98.js';
import './UNSAFE_Icon/themes/IconStyle.css.js';
import './datatipUtils-0a36125e.js';
import './Layer-7d3dc8c7.js';
import './UNSAFE_Layer/themes/LayerStyles.css.js';
import './LayerStyles.styles.css';
import './Floating-6023b41d.js';
import './useFloating-e1167cb9.js';
import './positionUtils-f26caad9.js';
import './refUtils-76275c69.js';
import './useOutsideClick-73a51e1d.js';
import './arrayUtils-35a58161.js';
import './useModal-953082f2.js';
import './UNSAFE_Floating/themes/redwood/FloatingTheme.js';
import './UNSAFE_Floating/themes/FloatingStyles.css.js';
import './FloatingStyles.styles.css';
import './UNSAFE_Floating/themes/redwood/FloatingBaseTheme.css.js';
import './UNSAFE_Floating/themes/redwood/FloatingBaseTheme.styles.css';
import './UNSAFE_Floating/themes/redwood/FloatingVariants.css.js';
import './vanilla-extract-dynamic.esm-c909758c.js';
import './UNSAFE_Floating/themes/FloatingContract.css.js';
import './useUnsafeDomElementRef-32290273.js';
import './hooks/PRIVATE_useDatatip/themes/useDatatip.css.js';
import './useDatatip.styles.css';
import './Button-c374b855.js';
import './Move-195dc0bd.js';
import './hooks/PRIVATE_useVisDragModeControls/themes/useVisDragModeControls.css.js';
import './useVisDragModeControls.styles.css';
import './ZoomAlt-7725545a.js';
import './ButtonSetSingle-659479b0.js';
import './useButtonSetContext-6a483d7f.js';
import './ButtonSet-220507f5.js';
import './dimensions-ddde0eee.js';
import './UNSAFE_ButtonSet/themes/ButtonSetStyles.css.js';
import './ButtonSetStyles.styles.css';
import './ButtonSetPositionContext-5730d367.js';
import './toggleButtonUtils-75e3d781.js';
import './useRovingTabIndexContainer-3903d005.js';
import './TabbableModeContext-7d8ad946.js';
import './useTabbableMode-a2fdbb06.js';
import './buttonUtils-55fb1df7.js';
import './id-83adac50.js';
import './ButtonSetItem-6ef8402d.js';
import './ButtonSetButton-a34aeeb0.js';
import './BaseButton-c2fbaa6d.js';
import './useActive-fb6d4d52.js';
import './UNSAFE_BaseButton/themes/redwood/BaseButtonTheme.js';
import './UNSAFE_BaseButton/themes/BaseButtonStyles.css.js';
import './BaseButtonStyles.styles.css';
import './UNSAFE_BaseButton/themes/redwood/BaseButtonVariants.css.js';
import './UNSAFE_BaseButton/themes/redwood/BaseButtonBaseTheme.styles.css';
import './BareButton-0954f33d.js';
import './useBareButton-07a3eef9.js';
import './usePress-051f5adb.js';
import './usePressClick-2ec8e098.js';
import './ToggleButtonLabel-802339c7.js';
import './ButtonLabelLayout-d449261a.js';
import './Text-983c749e.js';
import './UNSAFE_Text/themes/TextStyles.css.js';
import './TextStyles.styles.css';
import './useButtonLabelLayoutTheme-a1b95a52.js';
import './UNSAFE_ButtonLabelLayout/themes/redwood/ButtonLabelLayoutTheme.js';
import './UNSAFE_ButtonLabelLayout/themes/ButtonLabelLayoutStyles.css.js';
import './ButtonLabelLayoutStyles.styles.css';
import './UNSAFE_ButtonLabelLayout/themes/redwood/ButtonLabelLayoutBaseTheme.css.js';
import './UNSAFE_ButtonLabelLayout/themes/redwood/ButtonLabelLayoutBaseTheme.styles.css';
import './UNSAFE_ButtonLabelLayout/themes/redwood/ButtonLabelLayoutVariants.css.js';
import './ButtonLabelLayoutVariants.styles.css';
import './HiddenAccessible-61197e7c.js';
import './HiddenAccessibleStyles.styles.css';
import './ButtonSetIconButton-1beb1197.js';
import './useButtonSetPositionContext-1dc5156a.js';
import './IconToggleButton-2ac4cd72.js';
import './useToggleAction-fc0f5399.js';
import './eventsUtils-e96290df.js';
import './hooks/PRIVATE_useVisSelection/themes/ClearSelection.css.js';
import './ClearSelection.styles.css';
import './useContextMenuGesture-906cf78d.js';
import './textSelectionUtils-a6554a42.js';
import './Sheet-24c3e407.js';
import './Modal-678575d5.js';
import './UNSAFE_Modal/themes/ModalStyles.css.js';
import './ModalStyles.styles.css';
import './tabbableUtils-ce19b388.js';
import './head-8f89fe66.js';
import './_arity-be492b9e.js';
import './_isArray-694cc52d.js';
import './_isString-675f1de9.js';
import './popupUtils-4edf62b5.js';
import './WindowOverlay-b380ce51.js';
import './UNSAFE_WindowOverlay/themes/WindowOverlayStyles.css.js';
import './WindowOverlayStyles.styles.css';
import './UNSAFE_WindowOverlay/themes/WindowOverlayContract.css.js';
import './UNSAFE_WindowOverlay/themes/redwood/WindowOverlayTheme.js';
import './UNSAFE_WindowOverlay/themes/redwood/WindowOverlayBaseTheme.css.js';
import './UNSAFE_WindowOverlay/themes/redwood/WindowOverlayBaseTheme.styles.css';
import './UNSAFE_WindowOverlay/themes/redwood/WindowOverlayVariants.css.js';
import './UNSAFE_Sheet/themes/SheetStyles.css.js';
import './SheetStyles.styles.css';
import './useAnimationStatus-072d6a98.js';
import './animationUtils-5f409a6c.js';
import './Dropdown-ead9e679.js';
import './keyboardUtils-986fe923.js';
import './usePopupAnimation-66b186ad.js';
import './popupAnimationUtils-175151d9.js';
import './CollectionInteractionContext-7cf19abc.js';
import './UNSAFE_Dropdown/themes/dropdownStyles.css.js';
import './dropdownStyles.styles.css';
import './useOutsideMousedown-39d7c9a6.js';
import './UNSAFE_Menu/themes/MenuStyles.css.js';
import './UNSAFE_Menu/themes/DropdownMenuStyles.css.js';
import './DropdownMenuStyles.styles.css';
import './Flex-5befe411.js';
import './boxalignment-51b42a0f.js';
import './boxalignment.styles.css';
import './vanilla-extract-sprinkles-createRuntimeSprinkles.esm-2d655d37.js';
import './flexbox-529f25da.js';
import './flexbox.styles.css';
import './flexitem-7b7f7920.js';
import './flexitem.styles.css';
import './FlexStyles.styles.css';
import './Skeleton-a06f4f74.js';
import './borders-98a63040.js';
import './UNSAFE_Skeleton/themes/redwood/SkeletonTheme.js';
import './UNSAFE_Skeleton/themes/SkeletonStyles.css.js';
import './SkeletonStyles.styles.css';
import './UNSAFE_Skeleton/themes/redwood/SkeletonBaseTheme.css.js';
import './UNSAFE_Skeleton/themes/redwood/SkeletonBaseTheme.styles.css';
import './UNSAFE_Skeleton/themes/redwood/SkeletonVariants.css.js';
import './UNSAFE_Menu/themes/MenuSkeletonStyles.css.js';
import './MenuSkeletonStyles.styles.css';
import './LiveRegion-79ffc814.js';
import './LiveRegionStyles.styles.css';
import './UNSAFE_Menu/themes/redwood/MenuItemTheme.js';
import './UNSAFE_Menu/themes/redwood/MenuItemBaseTheme.css.js';
import './UNSAFE_Menu/themes/redwood/MenuItemBaseTheme.styles.css';
import './UNSAFE_Menu/themes/redwood/MenuItemVariants.css.js';
import './MenuItemStyles.styles.css';
import './MenuItemVariants.styles.css';
import './useInteractionStyle-99e32c23.js';
import './index-3e2e69c4.js';
import './UNSAFE_Layer/themes/LayerHostStyles.css.js';
import './LayerHostStyles.styles.css';
import './EnvironmentProvider-546b7ebd.js';
import './LayerManager-a62e619b.js';
import './SeparatorStyles.styles.css';

const ZOOM_TO_FIT_PADDING = 20;
/**
 * Returns the pan properties for the diagram.
 */
function getPanProps(props, contentBounds, userDragMode, isDeviceTouch) {
    return {
        panning: isDeviceTouch
            ? userDragMode === 'pan' && props.panning
                ? props.panning
                : 'off'
            : props.panning
                ? props.panning
                : 'off',
        panDirection: props.panDirection ? props.panDirection : 'any',
        centerX: props.centerX !== undefined ? props.centerX : contentBounds.width / 2 + contentBounds.x,
        centerY: props.centerY !== undefined ? props.centerY : contentBounds.height / 2 + contentBounds.y,
        onPan: props.onPan
    };
}
/**
 * Returns the zoom properties for the diagram.
 */
function getZoomProps(props, width, height, contentBounds) {
    const zoomTofitZoom = getZoomToFitZoom(width, height, contentBounds);
    const maxZoom = props.maxZoom || 1;
    const minZoom = props.minZoom || Math.min(maxZoom, zoomTofitZoom);
    const zoom = props.zoomValue ? props.zoomValue : zoomTofitZoom;
    return {
        zooming: props.zooming ? props.zooming : 'off',
        // default value of 0 indicates zoom-to-fit level
        minZoom: minZoom,
        maxZoom: maxZoom,
        // zoom value of 0 will default to zoom to fit
        zoomValue: constrainZoom(zoom, minZoom, maxZoom),
        onZoom: props.onZoom
    };
}
/**
 * Constructs the json object to be passed into the layout function
 */
function constructLayoutJSON(nodeItems, linkItems, promotedLinks, dimensions, width, height, nodeBounds, zoom, nodeIdToParentMap, nodeBoundsRef, rootRef, getTextDimensions) {
    const labelDims = new Map();
    const nodeValues = Array.from(nodeItems.values());
    const linkValues = Array.from(linkItems.values());
    if (getTextDimensions) {
        getLabelProps(nodeValues, linkValues, labelDims, getTextDimensions);
    }
    const linkKeys = Array.from(linkItems.keys());
    for (const id of linkKeys) {
        const item = linkItems.get(id);
        if (item && getTextDimensions && item.label) {
            const label = item.label;
            const fontProps = _getFontProps(item.labelStyle);
            labelDims.set(id, getTextDimensions(label, fontProps));
        }
    }
    const getLabelDimensions = function (data) {
        return labelDims.get(data.id);
    };
    const getNodeDimensions = function (data) {
        return dimensions.get(data.id);
    };
    const getRelativeNodeBounds = function (id, containerId) {
        const absPos = getAbsoluteItemPosition(id, containerId, rootRef);
        const bounds = nodeBounds.get(id);
        if (absPos && bounds) {
            return {
                x: absPos.x / zoom,
                y: absPos.y / zoom,
                width: bounds.width,
                height: bounds.height
            };
        }
        else {
            return undefined;
        }
    };
    const getContainerId = function (startNode, endNode) {
        return getCommonAncestorId(startNode, endNode, nodeIdToParentMap);
    };
    const getNodeBounds = function (data) {
        const id = data.id;
        const linkBounds = nodeBoundsRef.get(id);
        const bounds = nodeBounds.get(id);
        if (linkBounds) {
            if (rootRef && rootRef.current) {
                const childElement = rootRef.current.querySelector(`[data-oj-child=${id}]`);
                const nodeContainer = rootRef.current.querySelector(`[data-oj-private-node=${id}]`);
                const dims = nodeBounds.get(id);
                if (childElement && nodeContainer && dims) {
                    const childBoundingRect = normalizeBounds(childElement.getBoundingClientRect(), zoom);
                    const nodeBoundingRect = normalizeBounds(nodeContainer.getBoundingClientRect(), zoom);
                    const extraWidth = Math.max(childBoundingRect.x -
                        nodeBoundingRect.x +
                        (linkBounds.width + linkBounds.x) -
                        nodeBoundingRect.width, 0);
                    const extraHeight = Math.max(childBoundingRect.y -
                        nodeBoundingRect.y +
                        (linkBounds.height + linkBounds.y) -
                        nodeBoundingRect.height, 0);
                    return {
                        x: childBoundingRect.x - nodeBoundingRect.x + linkBounds.x,
                        y: childBoundingRect.y - nodeBoundingRect.y + linkBounds.y,
                        width: nodeBoundingRect.width + extraWidth,
                        height: nodeBoundingRect.height + extraHeight
                    };
                }
            }
        }
        else if (bounds) {
            return {
                x: 0,
                y: 0,
                width: bounds.width,
                height: bounds.height
            };
        }
        return undefined;
    };
    const getPromotedLinks = function () {
        return promotedLinks;
    };
    return {
        layoutJSON: {
            getNodeDimensions: getNodeDimensions,
            getLabelDimensions: getLabelDimensions,
            getContainerId,
            getNodeBounds,
            getRelativeNodeBounds,
            getPromotedLinks,
            componentSize: {
                width: width,
                height: height
            }
        },
        labelDims: labelDims
    };
}
function normalizeBounds(bounds, zoom) {
    return {
        x: bounds.x / zoom,
        y: bounds.y / zoom,
        width: bounds.width / zoom,
        height: bounds.height / zoom
    };
}
function getAbsoluteLinkBounds(itemId, referenceId, bounds, zoom, rootRef) {
    if (rootRef && rootRef.current) {
        const linkElement = rootRef.current.querySelector(`[data-oj-private-link=${itemId}]`);
        let nodeContainer;
        if (referenceId) {
            nodeContainer = rootRef.current.querySelector(`[data-oj-private-node=${referenceId}]`);
        }
        const dims = bounds.get(itemId);
        if (linkElement && nodeContainer && dims) {
            const linkBoundingRect = normalizeBounds(linkElement.getBoundingClientRect(), zoom);
            const diagramBoundingRect = normalizeBounds(nodeContainer.getBoundingClientRect(), zoom);
            return {
                x: linkBoundingRect.x - diagramBoundingRect.x,
                y: linkBoundingRect.y - diagramBoundingRect.y,
                width: dims.width,
                height: dims.height
            };
        }
    }
    return null;
}
function getBounds(nodes, links, promotedLinks, nodeBounds, linkDimensions, promotedLinkDimensions, zoom, rootRef) {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let id;
    let topId;
    let leftId;
    for (let i = 0; i < nodes.length; i++) {
        id = nodes[i].id;
        const bounds = nodeBounds.get(id);
        if (bounds) {
            if (minX > bounds.x) {
                minX = bounds.x;
                leftId = id;
            }
            if (minY > bounds.y) {
                minY = bounds.y;
                topId = id;
            }
            if (maxX < bounds.x + bounds.width) {
                maxX = bounds.x + bounds.width;
            }
            if (maxY < bounds.y + bounds.height) {
                maxY = bounds.y + bounds.height;
            }
        }
    }
    const nodeMinX = minX;
    const nodeMinY = minY;
    let linkMinX = Infinity;
    let linkMinY = Infinity;
    let linkMaxX = -Infinity;
    let linkMaxY = -Infinity;
    for (let i = 0; i < links.length; i++) {
        id = links[i].id;
        //Top and left bounds are relative to the current most top and left nodes
        const topBounds = getAbsoluteLinkBounds(id, topId, linkDimensions, zoom, rootRef);
        const leftBounds = getAbsoluteLinkBounds(id, leftId, linkDimensions, zoom, rootRef);
        if (leftBounds) {
            if (leftBounds.x < linkMinX) {
                linkMinX = leftBounds.x;
            }
            if (linkMaxX < leftBounds.x + leftBounds.width) {
                linkMaxX = leftBounds.x + leftBounds.width;
            }
        }
        if (topBounds) {
            if (topBounds.y < linkMinY) {
                linkMinY = topBounds.y;
            }
            if (linkMaxY < topBounds.y + topBounds.height) {
                linkMaxY = topBounds.y + topBounds.height;
            }
        }
    }
    for (let i = 0; i < promotedLinks.length; i++) {
        id = promotedLinks[i].id;
        //Top and left bounds are relative to the current most top and left nodes
        const topBounds = getAbsoluteLinkBounds(id, topId, promotedLinkDimensions, zoom, rootRef);
        const leftBounds = getAbsoluteLinkBounds(id, leftId, promotedLinkDimensions, zoom, rootRef);
        if (leftBounds) {
            if (leftBounds.x < linkMinX) {
                linkMinX = leftBounds.x;
            }
            if (linkMaxX < leftBounds.x + leftBounds.width) {
                linkMaxX = leftBounds.x + leftBounds.width;
            }
        }
        if (topBounds) {
            if (topBounds.y < linkMinY) {
                linkMinY = topBounds.y;
            }
            if (linkMaxY < topBounds.y + topBounds.height) {
                linkMaxY = topBounds.y + topBounds.height;
            }
        }
    }
    return {
        minX: nodeMinX,
        minY: nodeMinY,
        contentWidth: maxX - minX,
        contentHeight: maxY - minY,
        linkBounds: linkMinX !== Infinity
            ? { x: linkMinX, y: linkMinY, width: linkMaxX - linkMinX, height: linkMaxY - linkMinY }
            : undefined
    };
}
function getAbsoluteItemPosition(nodeId, containerId, rootRef) {
    if (rootRef && rootRef.current) {
        const nodeElement = rootRef.current.querySelector(`[data-oj-private-node=${nodeId}]`);
        let nodeContainer;
        if (containerId) {
            nodeContainer = rootRef.current.querySelector(`[data-oj-child=${containerId}]`);
        }
        else {
            nodeContainer = rootRef.current.querySelector('[data-node-container]');
        }
        if (nodeElement && nodeContainer) {
            const nodeBoundingRect = nodeElement.getBoundingClientRect();
            const diagramBoundingRect = nodeContainer.getBoundingClientRect();
            return {
                x: nodeBoundingRect.x - diagramBoundingRect.x,
                y: nodeBoundingRect.y - diagramBoundingRect.y
            };
        }
    }
    return null;
}
function getLabelProps(nodeItems, linkItems, labelDims, getTextDimensions) {
    nodeItems.forEach((value) => {
        if (value.children) {
            getNodeLabelProps(value.children, labelDims, getTextDimensions);
        }
        if (value.label) {
            const label = value.label;
            const fontProps = _getFontProps(value.labelStyle);
            labelDims.set(value.id, getTextDimensions(label, fontProps));
        }
    });
    linkItems.forEach((value) => {
        if (value.label) {
            const label = value.label;
            const fontProps = _getFontProps(value.labelStyle);
            labelDims.set(value.id, getTextDimensions(label, fontProps));
        }
    });
}
function getNodeLabelProps(nodeItems, labelDims, getTextDimensions) {
    nodeItems.forEach((value) => {
        if (value.children) {
            getNodeLabelProps(value.children, labelDims, getTextDimensions);
        }
        if (value.label) {
            const label = value.label;
            const fontProps = _getFontProps(value.labelStyle);
            labelDims.set(value.id, getTextDimensions(label, fontProps));
        }
    });
}
/**
 * Deconstructs the output of the layout function
 */
function deconstructLayoutJSON(layoutJSON, nodeData, linkData) {
    //const nodes = layoutJSON.nodes;
    const links = layoutJSON.links;
    //const promotedLinks = layoutJSON.promotedLinks;
    const positions = new Map();
    const nodeLabelPos = new Map();
    const linkLabelPos = new Map();
    //let hasNodeLabels = false;
    // hasLinkLabels = false;
    let link;
    findPoints(layoutJSON, nodeData, positions, nodeLabelPos);
    if (links) {
        for (let i = 0; i < linkData.length; i++) {
            link = links[linkData[i].id];
            if (link && link.label)
                linkLabelPos.set(linkData[i].id, link.label);
        }
    }
    return {
        nodePoints: positions,
        nodeLabelPos: nodeLabelPos,
        linkLabelPos: linkLabelPos
    };
}
function findPoints(output, nodeData, positions, nodeLabelPos) {
    const nodes = output.nodes;
    let node;
    if (nodes) {
        for (let i = 0; i < nodeData.length; i++) {
            const data = nodeData[i];
            const id = data.id;
            if (data.children) {
                findPoints(output, data.children, positions, nodeLabelPos);
            }
            node = nodes[id];
            if (node) {
                positions.set(id, node.position);
                if (node.label) {
                    nodeLabelPos.set(id, node.label);
                }
            }
        }
    }
}
/**
 * Merges the node points into the dimensions
 */
function mergeDimensions(dimensions, nodePoints) {
    const newBounds = new Map();
    dimensions.forEach((value, key) => {
        const point = nodePoints.get(key);
        if (point) {
            newBounds.set(key, { x: point.x, y: point.y, width: value.width, height: value.height });
        }
    });
    return newBounds;
}
/**
 * Deep equality check for whether two arrays of bounds are the same
 */
function isEqualBounds(bounds1, bounds2) {
    if (bounds1.size !== bounds2.size)
        return false;
    let equal = true;
    bounds1.forEach((value, key) => {
        const b2Value = bounds2.get(key);
        if (!b2Value)
            equal = false;
        else if (Math.abs(value.x - b2Value.x) > 0.5 ||
            Math.abs(value.y - b2Value.y) > 0.5 ||
            Math.abs(value.width - b2Value.width) > 0.5 ||
            Math.abs(value.height - b2Value.height) > 0.5)
            equal = false;
    });
    return equal;
}
/**
 * Deep equality check for whether two arrays of bounds are the same
 */
function isEqualLabelBounds(bounds1, bounds2) {
    return (bounds1.x === bounds2.x &&
        bounds1.y === bounds2.y &&
        bounds1.width === bounds2.width &&
        bounds1.height === bounds2.height);
}
/**
 * Returns the text for the diagram datatip.
 */
function getDatatipContent(nodesMap, linksMap, focusedItem, hoveredItem, datatip) {
    let itemInfo;
    const isPointerActive = hoveredItem?.isCurrent;
    if (isPointerActive && hoveredItem.id != null) {
        itemInfo = hoveredItem;
    }
    if (focusedItem && focusedItem.isCurrent) {
        itemInfo = focusedItem;
    }
    if (itemInfo && datatip) {
        return datatip(itemInfo.type === 'node'
            ? { data: nodesMap.get(itemInfo.id), type: 'node' }
            : { data: linksMap.get(itemInfo.id), type: 'link' });
    }
    if (itemInfo) {
        const text = (itemInfo.type === 'node' ? nodesMap.get(itemInfo.id) : linksMap.get(itemInfo.id))?.accessibleLabel;
        return {
            content: text
        };
    }
    return;
}
/**
 * Creates a map with key id and value node or link data
 */
function createLinksMap(items) {
    const itemIdToDataMap = new Map();
    const itemIdToIndexMap = new Map();
    const itemIndexToIdMap = new Map();
    const itemIdToParentMap = new Map();
    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        itemIdToDataMap.set(item.id, item);
        itemIdToIndexMap.set(item.id, i);
        itemIndexToIdMap.set(i, item.id);
    }
    return {
        itemIdToDataMap,
        itemIdToIndexMap,
        itemIndexToIdMap,
        itemIdToParentMap
    };
}
/**
 * Creates a map with key id and value node or link data
 */
function createPromotedLinksMap(items) {
    const itemIdToDataMap = new Map();
    const itemIdToIndexMap = new Map();
    const itemIndexToIdMap = new Map();
    const itemIdToParentMap = new Map();
    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        itemIdToDataMap.set(item.id, item);
        itemIdToIndexMap.set(item.id, i);
        itemIndexToIdMap.set(i, item.id);
    }
    return {
        itemIdToDataMap,
        itemIdToIndexMap,
        itemIndexToIdMap,
        itemIdToParentMap
    };
}
/**
 * Creates a map with key id and value node or link data
 */
function createNodesMap(items) {
    const itemIdToDataMap = new Map();
    const itemIdToIndexMap = new Map();
    const itemIndexToIdMap = new Map();
    const itemIdToParentMap = new Map();
    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const index = String(i);
        itemIdToDataMap.set(item.id, item);
        itemIdToIndexMap.set(item.id, index);
        itemIndexToIdMap.set(index, item.id);
        if (item.children) {
            _createItemMap(item.children, itemIdToDataMap, itemIdToIndexMap, itemIndexToIdMap, itemIdToParentMap, item.id, String(i));
        }
    }
    return {
        itemIdToDataMap,
        itemIdToIndexMap,
        itemIndexToIdMap,
        itemIdToParentMap
    };
}
function _createItemMap(items, itemIdToDataMap, itemIdToIndexMap, itemIndexToIdMap, itemIdToParentMap, parentId, parentIndex) {
    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const index = `${parentIndex}_${i}`;
        itemIdToDataMap.set(item.id, item);
        itemIdToIndexMap.set(item.id, index);
        itemIndexToIdMap.set(index, item.id);
        itemIdToParentMap.set(item.id, parentId);
        if (item.children) {
            _createItemMap(item.children, itemIdToDataMap, itemIdToIndexMap, itemIndexToIdMap, itemIdToParentMap, item.id, index);
        }
    }
}
/**
 * Filter out links with no start or end nodes
 */
function filterLinksWithNoEndNodes(links, nodesMap) {
    const newLinks = [];
    for (let i = 0; i < links.length; i++) {
        const link = links[i];
        if (nodesMap.get(link.startNode) && nodesMap.get(link.endNode)) {
            newLinks.push(link);
        }
    }
    return newLinks;
}
/**
 * Pulls out the dimensions from an array of bounds
 */
function getDimensionsFromBounds(bounds) {
    const dims = new Map();
    bounds.forEach((value, key) => {
        dims.set(key, { width: value.width, height: value.height });
    });
    return dims;
}
/**
 * Returns the center position of the node or link
 * For links, draws a straight line between the centers of the start/end node
 * and returns the center of that line
 */
function getFocusedItemBounds(focusedItemInfo, bounds, links, linkIdToIndexMap, rootRef) {
    if (focusedItemInfo.type === 'node') {
        // Return the first element if cannot find the Node index
        const position = getAbsoluteItemPosition(focusedItemInfo.id, undefined, rootRef);
        const nodeBounds = bounds.get(focusedItemInfo.id) || bounds.values().next().value;
        return {
            x: position ? position.x : nodeBounds.x,
            y: position ? position.y : nodeBounds.y,
            width: nodeBounds.width,
            height: nodeBounds.height
        };
    }
    else {
        // Center of a straight line between start/end node centers
        const link = links[linkIdToIndexMap.get(focusedItemInfo.id) || 0];
        const startNB = bounds.get(link.startNode) || bounds.values().next().value;
        const endNB = bounds.get(link.endNode) || bounds.values().next().value;
        const startPosition = getAbsoluteItemPosition(link.startNode, undefined, rootRef);
        const endPosition = getAbsoluteItemPosition(link.endNode, undefined, rootRef);
        const startNCenter = {
            x: startPosition.x + startNB.width / 2,
            y: startPosition.y + startNB.height / 2
        };
        const endNCenter = { x: endPosition.x + endNB.width / 2, y: endPosition.y + endNB.height / 2 };
        const minX = Math.min(startNCenter.x, endNCenter.x);
        const minY = Math.min(startNCenter.y, endNCenter.y);
        return {
            x: minX,
            y: minY,
            width: Math.abs(startNCenter.x - endNCenter.x),
            height: Math.abs(startNCenter.y - endNCenter.y)
        };
    }
}
/**
 * Returns the bounds of the diagram content
 */
function getContentBounds(nodeBounds, labelBounds) {
    if (nodeBounds.size === 0)
        return { x: 0, width: Infinity, y: 0, height: Infinity };
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let dims;
    nodeBounds.forEach((value) => {
        dims = value;
        minX = dims.x < minX ? dims.x : minX;
        minY = dims.y < minY ? dims.y : minY;
        maxX = dims.x + dims.width > maxX ? dims.x + dims.width : maxX;
        maxY = dims.y + dims.height > maxY ? dims.y + dims.height : maxY;
    });
    if (labelBounds) {
        minX = labelBounds.x < minX ? labelBounds.x : minX;
        minY = labelBounds.y < minY ? labelBounds.y : minY;
        maxX = labelBounds.x + labelBounds.width > maxX ? labelBounds.x + labelBounds.width : maxX;
        maxY = labelBounds.y + labelBounds.height > maxY ? labelBounds.y + labelBounds.height : maxY;
    }
    return { x: minX, width: maxX - minX, y: minY, height: maxY - minY };
}
/**
 * Returns the label bounds
 */
function getAllLabelBounds(labelDims, nodeLabelPos = new Map(), 
//linkLabelPos: Map<K2, DiagramLabelPosition> = new Map(),
isRTL) {
    if (nodeLabelPos.size === 0)
        return undefined;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    let dims;
    nodeLabelPos.forEach((value, key) => {
        dims = getLabelBounds(value, labelDims.get(key), isRTL);
        minX = dims.x < minX ? dims.x : minX;
        minY = dims.y < minY ? dims.y : minY;
        maxX = dims.x + dims.width > maxX ? dims.x + dims.width : maxX;
        maxY = dims.y + dims.height > maxY ? dims.y + dims.height : maxY;
    });
    /*linkLabelPos.forEach((value, key)=> {
      dims = getLabelBounds(value, labelDims.get(key)!, isRTL);
      minX = dims.x < minX ? dims.x : minX;
      minY = dims.y < minY ? dims.y : minY;
      maxX = dims.x + dims.width > maxX ? dims.x + dims.width : maxX;
      maxY = dims.y + dims.height > maxY ? dims.y + dims.height : maxY;
    })*/
    return { x: minX, width: maxX - minX, y: minY, height: maxY - minY };
}
function getLabelBounds(label, dims, isRTL) {
    const labelPos = getLabelPosition(dims, label, isRTL);
    const isRotating = label.rotationAngle;
    if (!isRotating) {
        return { x: labelPos.x, y: labelPos.y, width: dims.width, height: dims.height };
    }
    else {
        // Find the 4 corners of the label bounds relative to the rotation point
        const rotationPoint = label.rotationPoint
            ? label.rotationPoint
            : { x: dims.width / 2, y: dims.height / 2 };
        const angle = label.rotationAngle;
        const topLeft = getCoordsRelToRotPoint({ x: 0, y: 0 }, rotationPoint);
        const topRight = getCoordsRelToRotPoint({ x: dims.width, y: 0 }, rotationPoint);
        const bottomLeft = getCoordsRelToRotPoint({ x: 0, y: dims.height }, rotationPoint);
        const bottomRight = getCoordsRelToRotPoint({ x: dims.width, y: dims.height }, rotationPoint);
        const rotTopLeft = rotatePoint(topLeft, angle);
        const rotBotLeft = rotatePoint(bottomLeft, angle);
        const rotTopRight = rotatePoint(topRight, angle);
        const rotBotRight = rotatePoint(bottomRight, angle);
        const points = [rotTopLeft, rotBotLeft, rotTopRight, rotBotRight].map((pos) => {
            return {
                x: pos.x + labelPos.x + rotationPoint.x,
                y: pos.y + labelPos.y + rotationPoint.y
            };
        });
        return getBoundsFromPoints(points);
    }
}
function getCoordsRelToRotPoint(labelPoint, rotPoint) {
    return { x: labelPoint.x - rotPoint.x, y: labelPoint.y - rotPoint.y };
}
function rotatePoint(pos, angle) {
    return {
        x: pos.x * Math.cos(angle) - pos.y * Math.sin(angle),
        y: pos.x * Math.sin(angle) + pos.y * Math.cos(angle)
    };
}
function getBoundsFromPoints(points) {
    let minX = points[0].x;
    let minY = points[0].y;
    let maxX = points[0].x;
    let maxY = points[0].y;
    for (let i = 1; i < points.length; i++) {
        const point = points[i];
        if (point.x < minX)
            minX = point.x;
        else if (point.x > maxX)
            maxX = point.x;
        if (point.y < minY)
            minY = point.y;
        else if (point.y > maxY)
            maxY = point.y;
    }
    return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
    };
}
/**
 * Returns the position of the label
 * @param dimensions
 * @param positionProps
 * @returns position of the label
 */
function getLabelPosition(dimensions, positionProps, isRTL) {
    const position = positionProps.position;
    const hAlign = positionProps.hAlign ? positionProps.hAlign : isRTL ? 'right' : 'left';
    const vAlign = positionProps.vAlign;
    let x, y;
    if (hAlign === 'center') {
        x = position.x - dimensions.width / 2;
    }
    else if (hAlign === 'right') {
        x = position.x - dimensions.width;
    }
    else {
        x = position.x;
    }
    if (vAlign === 'middle') {
        y = position.y - dimensions.height / 2;
    }
    else if (vAlign === 'bottom') {
        y = position.y - dimensions.height;
    }
    else if (vAlign === 'baseline') {
        y = position.y + dimensions.y;
    }
    else {
        y = position.y;
    }
    return {
        x: x,
        y: y
    };
}
/**
 * Converts centerX,Y coordinates to panX,Y coordinates
 */
function centerXYToPanXY(centerX, centerY, zoom, width, height) {
    return {
        panX: width / 2 - centerX * zoom,
        panY: height / 2 - centerY * zoom
    };
}
/**
 * Converts panX,Y coordinates to centerX,Y coordinates
 */
function panXYToCenterXY(panX, panY, zoom, width, height) {
    return {
        centerX: (width / 2 - panX) / zoom,
        centerY: (height / 2 - panY) / zoom
    };
}
/**
 * Compares if two ItemInfo are equal
 */
function isEqualItem(item1, item2) {
    return item1?.id === item2?.id && item1?.type === item2?.type;
}
/**
 * Returns the item info of the data-oj-node or data-oj-link attribute for a given element.
 */
function getNavigableInfo(element, rootElementRef) {
    let type;
    let elem = element;
    let navigableId;
    while (!navigableId) {
        navigableId = elem.dataset['ojPrivateNode'];
        if (navigableId) {
            type = 'node';
        }
        else {
            navigableId = elem.dataset['ojPrivateLink'];
            type = 'link';
        }
        if (!navigableId) {
            if (elem.parentElement && elem.parentElement !== rootElementRef?.current) {
                elem = elem.parentElement;
            }
            else {
                break;
            }
        }
    }
    return {
        id: navigableId,
        type: type
    };
}
/**
 * Returns the item info of the data-oj-node or data-oj-link attribute for a given element.
 */
function expCollapseButtonId(element, rootElementRef) {
    let elem = element;
    let id;
    while (!id) {
        id = elem.dataset['ojButton'];
        if (!id) {
            if (elem.parentElement &&
                !elem.parentElement.dataset['ojPrivateNode'] &&
                elem.parentElement !== rootElementRef?.current) {
                elem = elem.parentElement;
            }
            else {
                break;
            }
        }
    }
    return id;
}
/**
 * Returns the aria label
 */
function getItemAriaLabel(translations, supportsSelection, isSelected, accessibleLabel) {
    return generateAriaLabel(translations, accessibleLabel || '', {
        isSelected: !supportsSelection ? undefined : isSelected
    });
}
/**
 * Returns the zoom to fit zoom level
 */
function getZoomToFitZoom(width, height, contentBounds) {
    const zoomX = (width - 2 * ZOOM_TO_FIT_PADDING) / contentBounds.width;
    const zoomY = (height - 2 * ZOOM_TO_FIT_PADDING) / contentBounds.height;
    return Math.min(zoomX, zoomY);
}
/**
 * Constrains the zoom level
 */
function constrainZoom(zoom, minZoom, maxZoom) {
    let newZoom = Math.max(minZoom, zoom);
    newZoom = Math.min(maxZoom, newZoom);
    return newZoom;
}
/**
 * Returns the font props for a node or link
 */
function _getFontProps(styles) {
    const fontProps = {};
    if (!styles)
        return fontProps;
    if (styles.fontFamily)
        fontProps.fontFamily = styles.fontFamily;
    if (styles.fontSize)
        fontProps.fontSize = styles.fontSize;
    if (styles.fontStyle)
        fontProps.fontStyle = styles.fontStyle;
    if (styles.fontWeight)
        fontProps.fontWeight = styles.fontWeight;
    return fontProps;
}
/**
 * Returns the panX, panY, and zoom when zooming and centering an item
 */
function zoomAndCenterItemFromInfo(info, linkIdToDataMap, bounds, width, height, maxZoom) {
    const type = info.type;
    let totalBounds;
    if (type === 'node') {
        totalBounds = bounds.get(info.id);
    }
    else {
        const link = linkIdToDataMap.get(info.id);
        const startNodeBounds = bounds.get(link.startNode);
        const endNodeBounds = bounds.get(link.endNode);
        const minX = Math.min(startNodeBounds.x, endNodeBounds.x);
        const minY = Math.min(startNodeBounds.y, endNodeBounds.y);
        const maxX = Math.max(startNodeBounds.x + startNodeBounds.width, endNodeBounds.x + startNodeBounds.width);
        const maxY = Math.max(startNodeBounds.y + startNodeBounds.height, endNodeBounds.y + endNodeBounds.height);
        totalBounds = { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    }
    return getPanZoomToCenterNode(totalBounds, maxZoom, width, height);
}
/**
 * Returns the pan and zoom values in order
 * to center a node or link
 */
function getPanZoomToCenterNode(bounds, maxZoom, width, height) {
    const zoomX = (width - 2 * ZOOM_TO_FIT_PADDING) / bounds.width;
    const zoomY = (height - 2 * ZOOM_TO_FIT_PADDING) / bounds.height;
    const zoom = Math.min(zoomX, zoomY, maxZoom);
    const cX = bounds.width / 2 + bounds.x;
    const cY = bounds.height / 2 + bounds.y;
    return { centerX: cX, centerY: cY, zoom: zoom };
}
/**
 * Returns whether the node is a leaf node
 */
function isLeafNode(nodeData) {
    return !nodeData.children;
}
function isContainerReady(nodeData, nodeBounds, links, promotedLinks, linkDimensions, promotedLinkDimensions) {
    const children = nodeData.children;
    for (let i = 0; i < children?.length; i++) {
        const child = children[i].id;
        if (!nodeBounds.get(child)) {
            return false;
        }
    }
    for (let i = 0; i < links.length; i++) {
        const link = links[i].id;
        const linkDims = linkDimensions.get(link);
        if (!linkDims || linkDims.width === 0 || linkDims.height === 0) {
            return false;
        }
    }
    for (let i = 0; i < promotedLinks.length; i++) {
        const link = promotedLinks[i].id;
        const linkDims = promotedLinkDimensions.get(link);
        if (!linkDims || linkDims.width === 0 || linkDims.height === 0) {
            return false;
        }
    }
    return true;
}
function getCommonAncestorId(startId, endId, nodeIdToParentMap) {
    const startAnc = _getAncestorIds(startId, nodeIdToParentMap);
    const endAnc = _getAncestorIds(endId, nodeIdToParentMap);
    for (let i = 0; i < startAnc.length; i++) {
        if (endAnc.indexOf(startAnc[i]) > -1) {
            return startAnc[i];
        }
    }
    return undefined;
}
function getLinksForNode(containerId, links, promotedLinks, nodeIdToParentMap) {
    const containerLinks = [];
    for (let i = 0; i < links.length; i++) {
        const link = links[i];
        const ancId = getCommonAncestorId(link.startNode, link.endNode, nodeIdToParentMap);
        if (ancId === containerId) {
            containerLinks.push(link);
        }
    }
    const containerPromotedLinks = [];
    for (let i = 0; i < promotedLinks.length; i++) {
        const link = promotedLinks[i];
        const ancId = getCommonAncestorId(link.startNode, link.endNode, nodeIdToParentMap);
        if (ancId === containerId) {
            containerPromotedLinks.push(link);
        }
    }
    return { containerLinks, containerPromotedLinks };
}
function _getAncestorIds(nodeId, nodes) {
    const ancestors = [];
    let anc = nodes.get(nodeId);
    while (anc !== undefined) {
        ancestors.push(anc);
        anc = nodes.get(anc);
    }
    return ancestors;
}
function containerLinksReady(containerLinks, layoutOutput) {
    const nodes = layoutOutput.nodes;
    //if (!links) return false;
    for (let i = 0; i < containerLinks.length; i++) {
        const link = containerLinks[i];
        if (!(nodes[link.startNode] && nodes[link.endNode])) {
            return false;
        }
    }
    return true;
}
function changeExpanded(id, expanded) {
    const index = expanded.indexOf(id);
    if (index === -1) {
        expanded.push(id);
    }
    else if (expanded.includes(id)) {
        expanded.splice(index, 1);
    }
    return expanded;
}
function getPromotedLinks(nodeIdToParentMap, links, expanded) {
    const promotedLinks = [];
    const linkToPromotedMap = new Map();
    const promotedToLinkMap = new Map();
    for (let i = 0; i < links.length; i++) {
        const link = links[i];
        const linkId = link.id;
        if (!hasCollapsedParent(link, nodeIdToParentMap, expanded)) {
            continue;
        }
        const startVisible = firstVisibleAncestor(link.startNode, nodeIdToParentMap, expanded);
        const endVisible = firstVisibleAncestor(link.endNode, nodeIdToParentMap, expanded);
        const promotedLinkId = `${startVisible}_${endVisible}`;
        let subLinks = promotedToLinkMap.get(promotedLinkId);
        if (subLinks) {
            subLinks.push(link);
        }
        else {
            const promotedLink = {
                id: promotedLinkId,
                startNode: startVisible,
                endNode: endVisible
            };
            promotedLinks.push(promotedLink);
            subLinks = [link];
        }
        promotedToLinkMap.set(promotedLinkId, subLinks);
        linkToPromotedMap.set(linkId, promotedLinkId);
    }
    return {
        promotedLinks,
        linkToPromotedMap,
        promotedToLinkMap
    };
}
function hasCollapsedParent(link, nodeIdToParentMap, expanded) {
    if ((nodeIdToParentMap.get(link.startNode) &&
        expanded.includes(nodeIdToParentMap.get(link.startNode))) ||
        (nodeIdToParentMap.get(link.endNode) && expanded.includes(nodeIdToParentMap.get(link.endNode)))) {
        return false;
    }
    return true;
}
function firstVisibleAncestor(nodeId, nodeIdToParentMap, expanded) {
    let visibleAnc = nodeId;
    let parentId = nodeIdToParentMap.get(nodeId);
    let currentId = nodeId;
    while (parentId) {
        if (expanded.includes(parentId)) {
            visibleAnc = currentId;
        }
        else {
            visibleAnc = undefined;
            currentId = parentId;
        }
        parentId = nodeIdToParentMap.get(parentId);
    }
    return visibleAnc || currentId;
}

const DiagramLabel = ({ text, position, styles, dimensions, isRTL }) => {
    const { labelStyle, labelBorderStyle } = labelStyles;
    const labelPosition = getLabelPosition(dimensions, position, isRTL);
    const labelRotation = getLabelRotation(position);
    return (jsx("div", { class: classNames([labelStyle, styles && styles.borderColor && labelBorderStyle]), style: {
            top: labelPosition.y,
            left: labelPosition.x,
            ...styles,
            ...labelRotation
        }, children: text }));
};
/**
 * Returns the label rotation props
 * @param position
 * @returns rotation props
 */
function getLabelRotation(position) {
    const rotationAngle = position.rotationAngle;
    const rotationPoint = position.rotationPoint;
    const rotation = {};
    if (rotationAngle) {
        rotation['transform'] = `rotate(${rotationAngle}deg)`;
    }
    if (rotationPoint) {
        rotation['transform-origin'] = `${rotationPoint.x}px ${rotationPoint.y}px`;
    }
    return rotation;
}

const DiagramExpandCollapseButton = ({ type, id }) => {
    return (jsx("div", { "data-oj-button": id, class: buttonStyle, style: {
            top: 0,
            left: 0,
            width: '5x',
            height: '5x',
            border: '1px solid black'
        }, children: type == 'collapse' ? jsx(SvgPlus, { size: '5x' }) : jsx(SvgMinus, { size: '5x' }) }));
};

const DiagramNodeElement = ({ id, state, previousState, position, activeId, nodeRenderer, onNodeSizeChanged, data, accessibleLabel, isDimmed, supportsSelection, content, labelPosition, labelDimensions }) => {
    const { nodeStyles, dimmedItemStyle } = itemStyles;
    const context = {
        state: state,
        previousState: previousState,
        data: data,
        content: content
    };
    const translations = useTranslationBundle('@oracle/oraclejet-preact');
    const ref = useRef(null);
    // TODO JET-62472 change to one resize observer function
    const optionsRef = useRef({ box: 'border-box' });
    useResizeObserver(ref, useCallback((entry) => {
        const boxSize = entry.borderBoxSize;
        const width = boxSize[0].inlineSize;
        const height = boxSize[0].blockSize;
        onNodeSizeChanged(width, height, id);
    }, [id, onNodeSizeChanged]), optionsRef.current);
    const nodePos = position ? position : { x: 0, y: 0 };
    const { direction } = useUser();
    const hasLabel = data.label && labelPosition && labelDimensions;
    return (jsxs("div", { ref: ref, class: classNames([nodeStyles, isDimmed ? dimmedItemStyle : undefined]), "data-oj-private-node": id, role: "img", "aria-label": getItemAriaLabel(translations, supportsSelection, state.selected, accessibleLabel), style: {
            top: nodePos.y,
            left: nodePos.x
        }, id: state.focused || state.hovered ? activeId : undefined, children: [nodeRenderer(context), hasLabel ? (jsx("div", { class: layerStyles, children: jsx(DiagramLabel, { styles: data.labelStyle, text: data.label, position: labelPosition, dimensions: labelDimensions.get(id), isRTL: direction === 'rtl' }) })) : undefined, data.children && data.showDisclosure !== 'off' ? (jsx(DiagramExpandCollapseButton, { type: content ? 'expand' : 'collapse', isRTL: direction === 'rtl', id: id })) : undefined] }, id));
};

const DiagramLinkElement = ({ id, state, previousState, activeId, data, linkRenderer, accessibleLabel, isDimmed, supportsSelection, layoutOutput, onLinkSizeChanged, isPromoted, promotedToLinkMap } //labelPosition,
) => {
    const translations = useTranslationBundle('@oracle/oraclejet-preact');
    const { dimmedItemStyle, linkStyles } = itemStyles;
    const context = (isPromoted
        ? {
            state: state,
            previousState: previousState,
            data: promotedToLinkMap.get(id),
            layoutOutput: layoutOutput,
            startNode: data.startNode,
            endNode: data.endNode,
            type: 'promotedLink'
        }
        : {
            state: state,
            previousState: previousState,
            data: data,
            layoutOutput: layoutOutput,
            type: 'link'
        });
    const ref = useRef(null);
    const optionsRef = useRef({ box: 'border-box' });
    useResizeObserver(ref, useCallback((entry) => {
        const boxSize = entry.borderBoxSize;
        const width = boxSize[0].inlineSize;
        const height = boxSize[0].blockSize;
        onLinkSizeChanged(width, height, id);
    }, [id, onLinkSizeChanged]), optionsRef.current);
    //const hasLabel = data.label && labelPosition && labelDimensions;
    return (jsx("g", { ref: ref, id: state.focused ? activeId : undefined, "aria-label": getItemAriaLabel(translations, supportsSelection, state.selected, accessibleLabel), "data-oj-private-link": id, role: "img", class: classNames([linkStyles, isDimmed && dimmedItemStyle]), children: linkRenderer(context) }, id));
};

function DiagramLabelLayer({ labelPosition, itemProps, labelDimensions }) {
    const { direction } = useUser();
    return (jsx("div", { class: layerStyles, children: itemProps.map((item) => {
            if (item.label && labelPosition.get(item.id)) {
                return (jsx(DiagramLabel, { styles: item.labelStyle, text: item.label, position: labelPosition.get(item.id), dimensions: labelDimensions.get(item.id), isRTL: direction === 'rtl' }));
            }
            return undefined;
        }) }));
}

function DiagramLinkLayer({ links, states, previousStates, linkRenderer, width, height, supportsSelection, onLinkSizeChanged, layoutOutput, combinedNodeBounds, linkLabelPositions, labelDimensions, isPromoted, promotedToLinkMap }) {
    const zoom = getZoomToFitZoom(width, height, combinedNodeBounds);
    return (jsxs("div", { children: [jsx("svg", { width: width / zoom, height: height / zoom, class: layerStyles, overflow: "visible", children: links.map((link) => {
                    const state = {
                        selected: isPromoted
                            ? states.selectedPromotedLinkIds.includes(link.id)
                            : states.selectedLinkIds.includes(link.id),
                        focused: states.focusedId === link.id,
                        hovered: states.hoveredId === link.id,
                        zoom: states.zoom
                    };
                    const previousState = {
                        selected: isPromoted
                            ? previousStates.selectedPromotedLinkIds.includes(link.id)
                            : previousStates.selectedLinkIds.includes(link.id),
                        focused: previousStates.focusedId === link.id,
                        hovered: previousStates.hoveredId === link.id,
                        zoom: previousStates.zoom
                    };
                    return (jsx(DiagramLinkElement, { id: link.id, label: link.label, state: state, previousState: previousState, isDimmed: states.highlightedLinkIds.length !== 0 &&
                            !states.highlightedLinkIds.includes(link.id), activeId: states.activeId, accessibleLabel: link.accessibleLabel, data: link, linkRenderer: linkRenderer, supportsSelection: supportsSelection, layoutOutput: layoutOutput, onLinkSizeChanged: onLinkSizeChanged, promotedToLinkMap: promotedToLinkMap, isPromoted: isPromoted }));
                }) }), labelDimensions ? (jsx("div", { children: links && linkLabelPositions ? (jsx(DiagramLabelLayer, { labelPosition: linkLabelPositions, itemProps: links, labelDimensions: labelDimensions })) : undefined })) : undefined] }));
}

const DiagramPromotedLinkElement = ({ id, state, previousState, activeId, data, linkRenderer, isDimmed, layoutOutput, onLinkSizeChanged, promotedToLinkMap } //labelPosition,
) => {
    const { dimmedItemStyle, linkStyles } = itemStyles;
    const context = {
        state: state,
        previousState: previousState,
        data: promotedToLinkMap.get(id),
        layoutOutput: layoutOutput,
        startNode: data.startNode,
        endNode: data.endNode,
        type: 'promotedLink',
        id: id
    };
    const ref = useRef(null);
    const optionsRef = useRef({ box: 'border-box' });
    useResizeObserver(ref, useCallback((entry) => {
        const boxSize = entry.borderBoxSize;
        const width = boxSize[0].inlineSize;
        const height = boxSize[0].blockSize;
        onLinkSizeChanged(width, height, id);
    }, [id, onLinkSizeChanged]), optionsRef.current);
    //const hasLabel = data.label && labelPosition && labelDimensions;
    return (jsx("g", { ref: ref, id: state.focused ? activeId : undefined, "data-oj-private-link": id, role: "img", class: classNames([linkStyles, isDimmed && dimmedItemStyle]), children: linkRenderer(context) }, id));
};

function DiagramPromotedLinkLayer({ links, states, previousStates, linkRenderer, width, height, supportsSelection, onLinkSizeChanged, layoutOutput, combinedNodeBounds, promotedToLinkMap }) {
    const zoom = getZoomToFitZoom(width, height, combinedNodeBounds);
    return (jsx("div", { children: jsx("svg", { width: width / zoom, height: height / zoom, class: layerStyles, overflow: "visible", children: links.map((link) => {
                const state = {
                    selected: states.selectedPromotedLinkIds.includes(link.id),
                    focused: states.focusedId === link.id,
                    hovered: states.hoveredId === link.id,
                    zoom: states.zoom
                };
                const previousState = {
                    selected: previousStates.selectedPromotedLinkIds.includes(link.id),
                    focused: previousStates.focusedId === link.id,
                    hovered: previousStates.hoveredId === link.id,
                    zoom: previousStates.zoom
                };
                return (jsx(DiagramPromotedLinkElement, { id: link.id, state: state, previousState: previousState, isDimmed: states.highlightedPromotedLinkIds.length !== 0 &&
                        !states.highlightedPromotedLinkIds.includes(link.id), activeId: states.activeId, data: link, linkRenderer: linkRenderer, supportsSelection: supportsSelection, layoutOutput: layoutOutput, onLinkSizeChanged: onLinkSizeChanged, promotedToLinkMap: promotedToLinkMap, isPromoted: true }));
            }) }) }));
}

function DiagramNodeLayer({ nodes, states, previousStates, nodeRenderer, linkRenderer, nodeBounds, width, height, onNodeSizeChanged, onLinkSizeChanged, onPromotedLinkSizeChanged, supportsSelection, nodeLabelPositions, linkLabelPositions, labelDimensions, minX = 0, minY = 0, parentId, links, promotedLinks, layoutOutput, zoom, nodeIdToParentMap, linkDimensions, promotedLinkDimensions, rootRef, combinedNodeBounds, nodeBoundsRef, promotedToLinkMap }) {
    const { containerLinks: containerParentLinks, containerPromotedLinks: containerParentPromotedLinks } = getLinksForNode(parentId, links, promotedLinks, nodeIdToParentMap);
    return (jsxs("div", { class: layerStyles, "data-node-container": true, children: [nodes.map((node) => {
                // this is for initial render before the layout function so render all nodes at 0,0
                const position = nodeBounds && nodeBounds.get(node.id)
                    ? { x: nodeBounds.get(node.id).x - minX, y: nodeBounds.get(node.id).y - minY }
                    : undefined;
                const state = {
                    selected: states.selectedNodeIds.includes(node.id),
                    focused: states.focusedId === node.id,
                    hovered: states.hoveredId === node.id,
                    zoom: states.zoom,
                    expanded: states.expanded && states.expanded.includes(node.id)
                };
                const previousState = {
                    selected: previousStates.selectedNodeIds.includes(node.id),
                    focused: previousStates.focusedId === node.id,
                    hovered: previousStates.hoveredId === node.id,
                    zoom: previousStates.zoom,
                    expanded: previousStates.expanded && previousStates.expanded.includes(node.id)
                };
                const { containerLinks, containerPromotedLinks } = getLinksForNode(node.id, links, promotedLinks, nodeIdToParentMap);
                // Leaf node or node is collapsed
                if (isLeafNode(node) || !states.expanded.includes(node.id)) {
                    return (jsx(DiagramNodeElement, { id: node.id, position: position, state: state, previousState: previousState, isDimmed: states.highlightedNodeIds.length !== 0 &&
                            !states.highlightedNodeIds.includes(node.id), activeId: states.activeId, nodeRenderer: nodeRenderer, onNodeSizeChanged: onNodeSizeChanged, accessibleLabel: node.accessibleLabel, data: node, isExpanded: false, supportsSelection: supportsSelection, labelDimensions: labelDimensions, labelPosition: nodeLabelPositions?.get(node.id) }));
                    // Expanded container where children are ready
                }
                else if (nodeBounds &&
                    isContainerReady(node, nodeBounds, containerLinks, containerPromotedLinks, linkDimensions, promotedLinkDimensions)) {
                    //const links = linkAncestors.get(node.id);
                    const childContent = getContent(node, states, previousStates, nodeRenderer, onNodeSizeChanged, onLinkSizeChanged, onPromotedLinkSizeChanged, supportsSelection, links, promotedLinks, nodeIdToParentMap, width, height, zoom, node.id, nodeBounds, linkDimensions, promotedLinkDimensions, combinedNodeBounds, nodeBoundsRef, nodeLabelPositions, linkLabelPositions, labelDimensions, promotedToLinkMap, linkRenderer, layoutOutput, rootRef);
                    return (jsx(DiagramNodeElement, { id: node.id, position: position, state: state, previousState: previousState, isDimmed: states.highlightedNodeIds.length !== 0 &&
                            !states.highlightedNodeIds.includes(node.id), activeId: states.activeId, nodeRenderer: nodeRenderer, onNodeSizeChanged: onNodeSizeChanged, accessibleLabel: node.accessibleLabel, data: node, isExpanded: true, supportsSelection: supportsSelection, content: childContent, labelDimensions: labelDimensions, labelPosition: nodeLabelPositions?.get(node.id) }));
                }
                else {
                    const childContent = getContent(node, states, previousStates, nodeRenderer, onNodeSizeChanged, onLinkSizeChanged, onPromotedLinkSizeChanged, supportsSelection, links, promotedLinks, nodeIdToParentMap, width, height, zoom, node.id, nodeBounds, linkDimensions, promotedLinkDimensions, combinedNodeBounds, nodeBoundsRef, nodeLabelPositions, linkLabelPositions, labelDimensions, promotedToLinkMap, linkRenderer, layoutOutput, rootRef);
                    return jsx("div", { children: childContent.element });
                }
            }), links.length > 0 &&
                layoutOutput &&
                linkRenderer &&
                width !== Infinity &&
                containerParentLinks.length > 0 &&
                containerLinksReady(containerParentLinks, layoutOutput) && (jsx(DiagramLinkLayer, { links: containerParentLinks, states: states, previousStates: previousStates, linkRenderer: linkRenderer, width: width / zoom, height: height, supportsSelection: supportsSelection, labelDimensions: labelDimensions, layoutOutput: layoutOutput, onLinkSizeChanged: onLinkSizeChanged, linkLabelPositions: linkLabelPositions, combinedNodeBounds: combinedNodeBounds, minX: minX, minY: minY, promotedToLinkMap: promotedToLinkMap })), promotedLinks.length > 0 &&
                layoutOutput &&
                linkRenderer &&
                width !== Infinity &&
                containerParentPromotedLinks.length > 0 &&
                containerLinksReady(containerParentPromotedLinks, layoutOutput) && (jsx(DiagramPromotedLinkLayer, { links: containerParentPromotedLinks, states: states, previousStates: previousStates, linkRenderer: linkRenderer, width: width / zoom, height: height, supportsSelection: supportsSelection, layoutOutput: layoutOutput, onLinkSizeChanged: onPromotedLinkSizeChanged, combinedNodeBounds: combinedNodeBounds, minX: minX, minY: minY, promotedToLinkMap: promotedToLinkMap }))] }));
}
function getContent(nodeData, states, previousStates, nodeRenderer, onNodeSizeChanged, onLinkSizeChanged, onPromotedLinkSizeChanged, supportsSelection, links, promotedLinks, nodeIdToParentMap, width, height, zoom, parentId, nodeBounds, linkDimensions, promotedLinkDimensions, combinedNodeBounds, nodeBoundsRef, nodeLabelPositions, linkLabelPositions, labelDimensions, promotedToLinkMap, linkRenderer, layoutOutput, rootRef) {
    //let minX;
    //let minY;
    //let maxX;
    //let maxY;
    //let validBounds;
    const children = nodeData.children;
    const { containerLinks, containerPromotedLinks } = getLinksForNode(parentId, links, promotedLinks, nodeIdToParentMap);
    const { minX, minY, contentWidth, contentHeight, linkBounds } = getBounds(children, containerLinks, containerPromotedLinks, nodeBounds, linkDimensions, promotedLinkDimensions, zoom, rootRef);
    if (linkBounds) {
        const nodeFullBounds = nodeBoundsRef.current;
        nodeFullBounds?.set(nodeData.id, linkBounds);
        nodeBoundsRef.current = nodeFullBounds;
    }
    //console.log('children', minX, minY, contentWidth, contentHeight);
    const element = (jsx("div", { "data-oj-child": parentId, style: { position: 'relative' }, children: jsx(DiagramNodeLayer, { nodes: children, nodeBounds: nodeBounds, states: states, minX: nodeBounds ? minX : undefined, minY: nodeBounds ? minY : undefined, previousStates: previousStates, nodeRenderer: nodeRenderer, onNodeSizeChanged: onNodeSizeChanged, onLinkSizeChanged: onLinkSizeChanged, onPromotedLinkSizeChanged: onPromotedLinkSizeChanged, supportsSelection: supportsSelection, nodeLabelPositions: nodeLabelPositions, linkLabelPositions: linkLabelPositions, labelDimensions: labelDimensions, links: links, promotedLinks: promotedLinks, nodeIdToParentMap: nodeIdToParentMap, linkRenderer: linkRenderer, layoutOutput: layoutOutput, width: width, height: height, zoom: zoom, parentId: parentId, linkDimensions: linkDimensions, promotedLinkDimensions: promotedLinkDimensions, rootRef: rootRef, combinedNodeBounds: combinedNodeBounds, nodeBoundsRef: nodeBoundsRef, promotedToLinkMap: promotedToLinkMap }) }));
    return {
        element,
        width: contentWidth ? contentWidth : 0,
        height: contentHeight ? contentHeight - minY : 0,
        linkBounds
    };
}

function DiagramLayers({ nodes, links, promotedLinks, nodeRenderer, linkRenderer, states, previousStates, nodeBounds, width, height, onNodeSizeChanged, onLinkSizeChanged, onPromotedLinkSizeChanged, labelDimensions, nodeLabelPositions, linkLabelPositions, supportsSelection, layoutOutput, zoom, nodeIdToParentMap, linkDimensions, promotedLinkDimensions, rootRef, combinedNodeBounds, nodeBoundsRef, promotedToLinkMap }) {
    const { containerLinks, containerPromotedLinks } = getLinksForNode(undefined, links, promotedLinks, nodeIdToParentMap);
    const { minX, minY } = getBounds(nodes, containerLinks, containerPromotedLinks, nodeBounds, linkDimensions, promotedLinkDimensions, zoom, rootRef);
    return (jsx(Fragment, { children: jsx(DiagramNodeLayer, { nodes: nodes, nodeBounds: nodeBounds, states: states, previousStates: previousStates, nodeRenderer: nodeRenderer, onNodeSizeChanged: onNodeSizeChanged, onLinkSizeChanged: onLinkSizeChanged, onPromotedLinkSizeChanged: onPromotedLinkSizeChanged, supportsSelection: supportsSelection, nodeLabelPositions: nodeLabelPositions, linkLabelPositions: linkLabelPositions, labelDimensions: labelDimensions, linkDimensions: linkDimensions, promotedLinkDimensions: promotedLinkDimensions, rootRef: rootRef, links: links, promotedLinks: promotedLinks, nodeIdToParentMap: nodeIdToParentMap, linkRenderer: linkRenderer, layoutOutput: layoutOutput, width: width, height: height, zoom: zoom, minX: nodeBounds && minX !== Infinity ? minX : undefined, minY: nodeBounds && minY !== Infinity ? minY : undefined, combinedNodeBounds: combinedNodeBounds, nodeBoundsRef: nodeBoundsRef, promotedToLinkMap: promotedToLinkMap }) }));
}

function DiagramPanZoomContainer({ centerX, centerY, children, zoom, width, height }) {
    const panValues = centerXYToPanXY(centerX, centerY, zoom, width, height);
    return (jsx("div", { class: panZoomStyles, style: {
            //TODO JET-62471 look at using matrices or both in transform instead
            translate: `${panValues.panX}px ${panValues.panY}px`,
            transform: `scale(${zoom})`
        }, children: children }));
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Returns the node data based on node info in a diagram.
 * @param itemInfo
 * @returns
 */
function getNodeDetailFromInfo(itemInfo, nodes) {
    let node;
    for (let i = 0; i < nodes.length; i++) {
        node = nodes[i];
        if (itemInfo.id === node.id) {
            return node;
        }
    }
    return undefined;
}
/**
 * Returns the link data based on link info in a diagram.
 * @param itemInfo
 * @returns
 */
function getLinkDetailFromInfo(itemInfo, links) {
    let link;
    for (let i = 0; i < links.length; i++) {
        link = links[i];
        if (itemInfo.id === link.id) {
            return link;
        }
    }
    return undefined;
}
/**
 * Utility method that adds sorting attributes of each link to an array
 */
function addSortingAttributes(node, listOfLinks, nodes, nodeBounds) {
    let angle, distance, direction;
    const linkDetail = [];
    for (let i = 0; i < listOfLinks.length; i++) {
        const link = listOfLinks[i];
        angle = _getClockwiseAngle(node, link, nodes, nodeBounds);
        distance = _getNodesDistance(link, nodes, nodeBounds);
        direction = _getLinkDirection(node, link);
        linkDetail.push({ id: link.id, angle: angle, distance: distance, direction: direction });
    }
    return linkDetail;
}
/**
 * Returns a function that compares two link around a given node
 * The links are analyzed by angle, distance from the node and direction. The sorting attributes are added to the links before sorting.
 */
function getLinkComparator() {
    return (link1, link2) => {
        const { angle: linkAngle1, distance: linkDistance1, direction: linkDirection1 } = link1;
        const { angle: linkAngle2, distance: linkDistance2, direction: linkDirection2 } = link2;
        let res = -1;
        if (!_anglesAreEqualWithinTolerance(linkAngle1, linkAngle2) && linkAngle1 > linkAngle2) {
            res = 1;
        }
        else if (_anglesAreEqualWithinTolerance(linkAngle1, linkAngle2)) {
            //check distance and direction
            if (linkDistance1 > linkDistance2) {
                res = 1;
            }
            else if (linkDistance2 == linkDistance1 && linkDirection1 > linkDirection2) {
                //outgoing to ingoing
                res = 1;
            }
            else if (linkDistance2 == linkDistance1 && linkDirection1 == linkDirection2) {
                res = 0;
            }
        }
        return res;
    };
}
/**
 * Returns navigable links for a given node
 */
function getNavigableLinksForNodeId(nodeId, listOfLinks) {
    const links = [];
    listOfLinks.forEach((link) => {
        const startId = link.startNode;
        const endId = link.endNode;
        if (startId == nodeId || endId == nodeId)
            links.push(link);
    });
    return links;
}
/**
 * Get the clockwise angle for the link given node as a center
 */
function _getClockwiseAngle(node, link, nodes, nodeBounds) {
    //find opposite node
    let currNode;
    let startNode = nodes[0];
    let endNode = nodes[0];
    for (let i = 0; i < nodes.length; i++) {
        currNode = nodes[i];
        if (currNode.id === link.startNode) {
            startNode = currNode;
        }
        else if (currNode.id === link.endNode) {
            endNode = currNode;
        }
    }
    const oppositeNode = node.id == startNode.id ? endNode : startNode;
    const p1 = _getNodeCenter(node, nodeBounds);
    const p2 = _getNodeCenter(oppositeNode, nodeBounds);
    let angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
    angle = angle < 0 ? angle + Math.PI * 2 : angle;
    return angle;
}
/**
 * Get the distance between start and end nodes for the given link
 */
function _getNodesDistance(link, nodes, nodeBounds) {
    let currNode;
    let startNode = nodes[0];
    let endNode = nodes[0];
    for (let i = 0; i < nodes.length; i++) {
        currNode = nodes[i];
        if (currNode.id === link.startNode) {
            startNode = currNode;
        }
        else if (currNode.id === link.endNode) {
            endNode = currNode;
        }
    }
    const p1 = _getNodeCenter(startNode, nodeBounds);
    const p2 = _getNodeCenter(endNode, nodeBounds);
    return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}
/**
 * Get link direction for the given node.  1 if the node is the end node
 * and 0 if it is the start node
 */
function _getLinkDirection(node, link) {
    if (link.endNode === node.id) {
        return 1;
    }
    return 0;
}
/**
 * Get node center
 */
function _getNodeCenter(node, nodeBounds) {
    const nodeBB = nodeBounds.get(node.id);
    return { x: nodeBB.x + nodeBB.width / 2, y: nodeBB.y + nodeBB.height / 2 };
}
/**
 * Calculates the angle weighted by distance
 */
function calcDistanceAngleWeighted(objectBB, currentBB, direction) {
    // Variables used for calculating penalties when calculating distances between two navigables.
    const optimalAngle1 = (15 / 180) * Math.PI;
    const optimalAngle2 = (40 / 180) * Math.PI;
    const suboptimalAnglePenalty1 = 2; // multiplier to the distance
    const suboptimalAnglePenalty2 = 6; // multiplier to the distance
    const objCenterX = objectBB.x + objectBB.width / 2;
    const objCenterY = objectBB.y + objectBB.height / 2;
    const curCenterX = currentBB.x + currentBB.width / 2;
    const curCenterY = currentBB.y + currentBB.height / 2;
    const x_dist = Math.abs(objCenterX - curCenterX);
    const y_dist = Math.abs(objCenterY - curCenterY);
    const angle = Math.atan2(y_dist, x_dist);
    let distance = Math.sqrt(x_dist * x_dist + y_dist * y_dist);
    // Angle penalty based on direction
    if ((angle > optimalAngle1 && (direction == 'right' || direction == 'left')) ||
        (angle < Math.PI / 2 - optimalAngle1 && (direction == 'up' || direction == 'down'))) {
        if ((angle > optimalAngle2 && (direction == 'right' || direction == 'left')) ||
            (angle < Math.PI / 2 - optimalAngle2 && (direction == 'up' || direction == 'down'))) {
            distance *= suboptimalAnglePenalty2;
        }
        else {
            distance *= suboptimalAnglePenalty1;
        }
    }
    return distance;
}
/**
 * Given a direction, is a certain node is a valid destination to navigate to
 */
function isValidDestination(objBB, curBB, direction, compareCenters) {
    // compare the centers of the navigable and to be valid, the navigable must be in the right direction
    // without tolerance
    if (compareCenters) {
        const objCenterX = objBB.x + 0.5 * objBB.width;
        const curCenterX = curBB.x + 0.5 * curBB.width;
        const objCenterY = objBB.y + 0.5 * objBB.height;
        const curCenterY = curBB.y + 0.5 * curBB.height;
        switch (direction) {
            case 'up':
                return objCenterY < curCenterY;
            case 'down':
                return objBB.y > curCenterY;
            case 'right':
                return objCenterX > curCenterX;
            case 'left':
                return objCenterX < curCenterX;
        }
        return true;
    }
    switch (direction) {
        case 'up':
            return objBB.y < curBB.y || _areEqualWithinTolerance(objBB.y, curBB.y);
        case 'down':
            return objBB.y > curBB.y || _areEqualWithinTolerance(objBB.y, curBB.y);
        case 'right':
            return objBB.x > curBB.x || _areEqualWithinTolerance(objBB.x, curBB.x);
        case 'left':
            return objBB.x < curBB.x || _areEqualWithinTolerance(objBB.x, curBB.x);
    }
    return true;
}
/**
 * Returns true if two nodes are in contact
 */
function calcInContact(objRect, curRect, direction) {
    switch (direction) {
        case 'up':
            return (_isVerticallyAligned(objRect, curRect) &&
                (curRect.y <= objRect.y + objRect.height ||
                    _areEqualWithinTolerance(curRect.y, objRect.y + objRect.height)));
        case 'down':
            return (_isVerticallyAligned(objRect, curRect) &&
                (objRect.y <= curRect.y + curRect.height ||
                    _areEqualWithinTolerance(objRect.y, curRect.y + curRect.height)));
        case 'right':
            return (_isHorizontallyAligned(objRect, curRect) &&
                (objRect.x <= curRect.x + curRect.width ||
                    _areEqualWithinTolerance(objRect.x, curRect.x + curRect.width)));
        case 'left':
            return (_isHorizontallyAligned(objRect, curRect) &&
                (curRect.x <= objRect.x + objRect.width ||
                    _areEqualWithinTolerance(curRect.x, objRect.x + objRect.width)));
    }
    return false;
}
function _isVerticallyAligned(rect1, rect2) {
    return ((rect1.x >= rect2.x && rect1.x <= rect2.x + rect2.width) ||
        (rect2.x >= rect1.x && rect2.x <= rect1.x + rect1.width));
}
function _isHorizontallyAligned(rect1, rect2) {
    return ((rect1.y >= rect2.y && rect1.y <= rect2.y + rect2.height) ||
        (rect2.y >= rect1.y && rect2.y <= rect1.y + rect1.height));
}
function _areEqualWithinTolerance(a, b) {
    return Math.abs(a - b) <= 0.0000001;
}
function _anglesAreEqualWithinTolerance(a1, a2) {
    let res = Math.abs(a1 - a2) <= 0.0000001;
    if (!res) {
        res = Math.abs(Math.PI * 2 + Math.min(a1, a2) - Math.max(a1, a2)) <= 0.0000001;
    }
    return res;
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
function useDiagramNavigation(nodes, links, bounds, linkIdToDataMap) {
    const currentKeyboardFocusNode = useRef();
    const nodeBoundsById = bounds;
    function getNextNavigableNode(direction, compareCenters, current, listOfObjects) {
        if (!listOfObjects)
            return current;
        if (!current)
            return listOfObjects[0];
        const currBB = nodeBoundsById.get(current.id);
        if (!currBB)
            return listOfObjects[0];
        let nextObject = current; //init to current object
        let nextDistance = Number.MAX_VALUE;
        // If an object is in contact it overrules all other attributes
        // Only another in contact object with better attributes will have higher precedence
        let nextInContact = false;
        // Whether or not the for loop has encountered the current object
        let hasFoundCurrent = false;
        let object, inContact, distance;
        for (let i = 0; i < listOfObjects.length; i++) {
            object = listOfObjects[i];
            if (object === current) {
                hasFoundCurrent = true;
                continue;
            }
            const objBB = nodeBoundsById.get(object.id);
            if (!objBB)
                continue;
            const objBounds = { x: objBB.x, y: objBB.y, width: objBB.width, height: objBB.height };
            const currBounds = { x: currBB.x, y: currBB.y, width: currBB.width, height: currBB.height };
            if (!isValidDestination(objBounds, currBounds, direction, compareCenters))
                continue;
            inContact = calcInContact(objBounds, currBounds, direction);
            if (nextInContact && !inContact)
                continue;
            distance = calcDistanceAngleWeighted(objBounds, currBounds, direction);
            if (distance == 0 && !hasFoundCurrent)
                continue;
            // Make sure incontact flag have highest precedence
            if ((!nextInContact && inContact) ||
                (distance < nextDistance && ((nextInContact && inContact) || !nextInContact))) {
                nextDistance = distance;
                nextObject = object;
                nextInContact = inContact;
            }
        }
        return nextObject;
    }
    /**
     * Get next navigavle link depending on direction - clockwise or conter clockwise.
     * The decision is made based on location of nodes centers rather than link paths or link angles.
     */
    function getNextNavigableLink(direction, listOfNodes, currentLink, listOfLinks) {
        if (!listOfLinks)
            return currentLink;
        if (!currentLink)
            return listOfLinks[0];
        const keyboardFocusNode = currentKeyboardFocusNode.current;
        const nodeId = keyboardFocusNode ? keyboardFocusNode : currentLink.startNode;
        const node = getNodeDetailFromInfo({ id: nodeId, type: 'node' }, listOfNodes);
        if (!node)
            return currentLink;
        const adjLinks = getNavigableLinksForNodeId(node.id, listOfLinks);
        listOfLinks = adjLinks;
        const linksWithSortingAttributes = addSortingAttributes(node, listOfLinks, listOfNodes, nodeBoundsById);
        linksWithSortingAttributes.sort(getLinkComparator());
        //clockwise direction
        const bForward = direction == 'down' ? true : false;
        let index = 0;
        for (let i = 0; i < linksWithSortingAttributes.length; i++) {
            const link = linksWithSortingAttributes[i];
            if (link.id === currentLink.id) {
                if (bForward)
                    index = i == linksWithSortingAttributes.length - 1 ? 0 : i + 1;
                else
                    index = i == 0 ? linksWithSortingAttributes.length - 1 : i - 1;
                break;
            }
        }
        return linksWithSortingAttributes[index];
    }
    /**
     * Returns the link detail when a node to link navigation occurs
     */
    function navigateFromNodeToLink(listOfLinks, event, node) {
        if (!node)
            return undefined;
        const adjLinks = getNavigableLinksForNodeId(node.id, listOfLinks);
        if (adjLinks.length < 1)
            return undefined;
        let link = adjLinks[0];
        const nodeBB = nodeBoundsById.get(node.id);
        let object, currNode, currNodeBB, currNodeBBCenterX;
        const nodeCenterX = nodeBB.x + nodeBB.width / 2;
        currentKeyboardFocusNode.current = node.id;
        for (let i = 0; i < adjLinks.length; i++) {
            object = adjLinks[i];
            currNode = object.startNode === node.id ? object.endNode : object.startNode;
            currNodeBB = nodeBoundsById.get(currNode);
            currNodeBBCenterX = currNodeBB.x + currNodeBB.width / 2;
            if (
            // equivalent of  and 
            (event.altKey && event.code === 'Comma' && currNodeBBCenterX <= nodeCenterX) ||
                (event.altKey && event.code === 'Period' && currNodeBBCenterX >= nodeCenterX)) {
                link = object;
                break;
            }
        }
        return { id: link.id, type: 'link' };
    }
    /**
     * Returns the node detail when a link to node navigation occurs
     */
    function navigateFromLinkToNode(linkId, event) {
        const key = event.key;
        const linkData = linkIdToDataMap.get(linkId);
        const startNodeBB = nodeBoundsById.get(linkData.startNode);
        const endNodeBB = nodeBoundsById.get(linkData.endNode);
        if (!startNodeBB || !endNodeBB)
            return undefined;
        const startNodeCenterX = startNodeBB.x + startNodeBB.width / 2;
        const endNodeCenterX = endNodeBB.x + endNodeBB.width / 2;
        const newNode = (endNodeCenterX > startNodeCenterX && key === 'ArrowRight') ||
            (endNodeCenterX < startNodeCenterX && key === 'ArrowLeft')
            ? linkData.endNode
            : linkData.startNode;
        return { id: newNode, type: 'node' };
    }
    return {
        isNode: (itemInfo) => {
            let node, link;
            for (let i = 0; i < nodes.length; i++) {
                node = nodes[i];
                link = links[i];
                if (itemInfo.id === node.id) {
                    return true;
                }
                if (itemInfo.id === link.id) {
                    return true;
                }
            }
            return false;
        },
        getNextNavigableNode,
        getNextNavigableLink,
        navigateFromNodeToLink,
        navigateFromLinkToNode
    };
}

const DEFAULT_KB_PAN = 15;
const DEFAULT_KB_ZOOM = 0.15;
function useEvents(touchResponse, initNode, nodes, links, nodeBounds, linkIdToDataMap, nodeIdToDataMap, promotedLinkIdToDataMap, width, height, maxZoom, expanded, itemIdToParentMap, onItemHover, onItemFocus, kbPanCallback, kbZoomCallback, onExpandedChange) {
    const { getNextNavigableNode, getNextNavigableLink, navigateFromNodeToLink, navigateFromLinkToNode } = useDiagramNavigation(nodes, links, nodeBounds, linkIdToDataMap);
    const [focusedItemInfo, setfocusedItemInfo] = useState({
        id: initNode.id,
        type: 'node'
    });
    const [hoveredItemInfo, sethoveredItemInfo] = useState();
    const activeId = useRef();
    const cancelEvent = (event) => {
        event.preventDefault();
        event.stopPropagation();
    };
    const keyDownHandler = (event) => {
        const key = event.key;
        let eventConsumed = false;
        // tabbing out of the diagram
        if (key === 'TAB') {
            return;
        }
        // if this a switch from node to link or vice versa
        if (isChangeItemType(event)) {
            const nextItemInfo = (focusedItemInfo.type === 'node'
                ? navigateFromNodeToLink(links, event, getNodeDetailFromInfo(focusedItemInfo, nodes))
                : navigateFromLinkToNode(focusedItemInfo.id, event));
            handleKeyboardInput(nextItemInfo);
            eventConsumed = true;
        }
        else if (isNavigationEvent(key)) {
            const nextItemInfo = handleKeyboardNavigationEvent(key);
            handleKeyboardInput(nextItemInfo);
            eventConsumed = true;
        }
        else {
            switch (key) {
                case 'PageUp': {
                    kbPanCallback &&
                        kbPanCallback({
                            dPan: {
                                dx: event.shiftKey ? -DEFAULT_KB_PAN : 0,
                                dy: event.shiftKey ? 0 : -DEFAULT_KB_PAN
                            }
                        });
                    eventConsumed = true;
                    break;
                }
                case 'PageDown': {
                    kbPanCallback &&
                        kbPanCallback({
                            dPan: {
                                dx: event.shiftKey ? DEFAULT_KB_PAN : 0,
                                dy: event.shiftKey ? 0 : DEFAULT_KB_PAN
                            }
                        });
                    eventConsumed = true;
                    eventConsumed = true;
                    break;
                }
                case '+':
                case '=': {
                    kbZoomCallback && kbZoomCallback({ dZoom: DEFAULT_KB_ZOOM });
                    eventConsumed = true;
                    break;
                }
                case '-':
                case '_': {
                    kbZoomCallback && kbZoomCallback({ dZoom: -DEFAULT_KB_ZOOM });
                    eventConsumed = true;
                    break;
                }
                case '0': {
                    if (event.ctrlKey && event.altKey) {
                        const { centerX, centerY, zoom } = zoomAndCenterItemFromInfo(focusedItemInfo, linkIdToDataMap, nodeBounds, width, height, maxZoom);
                        kbZoomCallback && kbZoomCallback({ nZoom: zoom });
                        kbPanCallback && kbPanCallback({ nPan: { cx: centerX, cy: centerY } });
                    }
                    else {
                        // zoom to fit
                        kbZoomCallback && kbZoomCallback({});
                        kbPanCallback && kbPanCallback({ center: true });
                    }
                    eventConsumed = true;
                    break;
                }
                case ' ': {
                    if (event.ctrlKey && event.shiftKey) {
                        if (focusedItemInfo.type === 'node') {
                            const id = focusedItemInfo.id;
                            const newExpanded = changeExpanded(id, expanded);
                            const data = [];
                            newExpanded.forEach((id) => {
                                data.push(nodeIdToDataMap.get(id));
                            });
                            onExpandedChange && onExpandedChange(newExpanded);
                        }
                    }
                    break;
                }
                case '[': {
                    if (focusedItemInfo.type === 'node') {
                        const child = getChildInfo(focusedItemInfo.id);
                        if (child) {
                            const item = { id: child.id, type: 'node' };
                            handleKeyboardInput(item);
                        }
                    }
                    eventConsumed = true;
                    break;
                }
                case ']': {
                    if (focusedItemInfo.type === 'node') {
                        const parentId = itemIdToParentMap.get(focusedItemInfo.id);
                        if (parentId) {
                            const item = { id: parentId, type: 'node' };
                            handleKeyboardInput(item);
                        }
                    }
                    eventConsumed = true;
                    break;
                }
            }
        }
        if (eventConsumed) {
            cancelEvent(event);
        }
    };
    const getChildInfo = (id) => {
        const children = nodeIdToDataMap.get(id)?.children;
        if (children && children.length > 0) {
            return children[0];
        }
        return undefined;
    };
    const keyUpHandler = (event) => {
        const key = event.code;
        switch (key) {
            case 'Tab': {
                updatefocusedItemInfo({
                    ...focusedItemInfo,
                    isCurrent: true,
                    isFocusVisible: true
                });
                break;
            }
        }
    };
    const blurHandler = () => {
        if (hoveredItemInfo != null || focusedItemInfo.isCurrent) {
            onItemFocus?.({ id: undefined, data: undefined });
        }
        const itemInfo = { ...focusedItemInfo, isCurrent: false, isFocusVisible: false };
        setfocusedItemInfo(itemInfo);
    };
    const onHover = (event) => {
        const itemInfo = getNavigableInfo(event.target);
        if (itemInfo && !isEqualItem(itemInfo, hoveredItemInfo)) {
            sethoveredItemInfo({ ...itemInfo, isCurrent: true });
            activeId.current = getRandomId();
            setfocusedItemInfo({ ...focusedItemInfo, isCurrent: false });
            if (itemInfo.type === 'node') {
                onItemHover?.({
                    id: itemInfo.id,
                    type: 'node',
                    data: nodeIdToDataMap.get(itemInfo.id)
                });
            }
            else if (itemInfo.type === 'link') {
                onItemHover?.({
                    id: itemInfo.id,
                    type: 'link',
                    data: linkIdToDataMap.get(itemInfo.id)
                });
            }
            else if (itemInfo.type === 'promotedLink') {
                onItemHover?.({
                    id: itemInfo.id,
                    type: 'promotedLink',
                    data: promotedLinkIdToDataMap.get(itemInfo.id)
                });
            }
        }
    };
    const onHoverLeave = () => {
        sethoveredItemInfo(undefined);
        activeId.current = undefined;
        onItemHover?.({ id: undefined, data: undefined });
    };
    const hoverHandlers = useVisHover(onHover, undefined, onHoverLeave, touchResponse);
    const pointerUpHandler = (event) => {
        const itemInfo = getNavigableInfo(event.target);
        if (itemInfo.id != null) {
            let buttonId;
            if (itemInfo.type === 'node') {
                buttonId = expCollapseButtonId(event.target);
                if (buttonId) {
                    console.log('button');
                    const newExpanded = changeExpanded(buttonId, expanded);
                    const data = [];
                    newExpanded.forEach((id) => {
                        data.push(nodeIdToDataMap.get(id));
                    });
                    onExpandedChange && onExpandedChange(newExpanded);
                    console.log(newExpanded);
                    event.preventDefault();
                    event.stopPropagation();
                    return;
                }
            }
            console.log(itemInfo);
            console.log(event.target);
            setfocusedItemInfo(itemInfo);
            activeId.current = getRandomId();
        }
    };
    function updatefocusedItemInfo(itemInfo) {
        if (itemInfo.type === 'node') {
            onItemFocus?.({
                id: itemInfo.id,
                type: 'node',
                data: nodeIdToDataMap.get(itemInfo.id)
            });
        }
        else if (itemInfo.type === 'link') {
            onItemFocus?.({
                id: itemInfo.id,
                type: 'link',
                data: linkIdToDataMap.get(itemInfo.id)
            });
        }
        else if (itemInfo.type === 'promotedLink') {
            onItemFocus?.({
                id: itemInfo.id,
                type: 'promotedLink',
                data: promotedLinkIdToDataMap.get(itemInfo.id)
            });
        }
        activeId.current = getRandomId();
        setfocusedItemInfo(itemInfo);
    }
    function handleKeyboardInput(item) {
        if (!item)
            return;
        if (!isEqualItem(item, focusedItemInfo)) {
            item.isCurrent = true;
            item.isFocusVisible = true;
            if (hoveredItemInfo) {
                sethoveredItemInfo({ ...hoveredItemInfo, isCurrent: false });
            }
            updatefocusedItemInfo(item);
        }
    }
    function isNavigationEvent(key) {
        switch (key) {
            case 'ArrowDown':
            case 'ArrowUp':
            case 'ArrowRight':
            case 'ArrowLeft': {
                return true;
            }
        }
        return false;
    }
    function isChangeItemType(event) {
        const key = event.code;
        // check if switching from node to link
        // equivalent of  and 
        if (focusedItemInfo.type === 'node' && event.altKey && (key === 'Period' || key === 'Comma')) {
            return true;
            // check if switching from link to node
        }
        else if (!(focusedItemInfo.type === 'node') &&
            (key === 'ArrowLeft' || key === 'ArrowRight')) {
            return true;
        }
        return false;
    }
    function handleKeyboardNavigationEvent(key) {
        let direction = 'down';
        switch (key) {
            case 'ArrowDown': {
                direction = 'down';
                break;
            }
            case 'ArrowUp': {
                direction = 'up';
                break;
            }
            case 'ArrowRight': {
                direction = 'right';
                break;
            }
            case 'ArrowLeft': {
                direction = 'left';
                break;
            }
        }
        if (focusedItemInfo.type === 'node') {
            const parent = itemIdToParentMap.get(focusedItemInfo.id);
            const navigableNodes = parent && nodeIdToDataMap.get(parent) ? nodeIdToDataMap.get(parent).children : nodes;
            const itemDetail = getNextNavigableNode(direction, true, nodeIdToDataMap.get(focusedItemInfo.id), navigableNodes);
            return itemDetail ? { id: itemDetail.id, type: 'node' } : focusedItemInfo;
        }
        else {
            const linkDetail = getLinkDetailFromInfo(focusedItemInfo, links);
            const itemDetail = getNextNavigableLink(direction, nodes, linkDetail, links);
            return itemDetail
                ? { id: itemDetail.id, type: 'link' }
                : { id: focusedItemInfo.id, type: 'link' };
        }
    }
    const onContextMenuDismissed = (gesture) => {
        if (gesture === 'keyboard') {
            updatefocusedItemInfo({
                ...focusedItemInfo,
                isFocusVisible: true,
                isCurrent: true
            });
        }
    };
    return {
        focusedItemInfo,
        hoveredItemInfo,
        activeId: activeId.current,
        onContextMenuDismissed,
        eventsProps: mergeProps(hoverHandlers, {
            onKeyUp: keyUpHandler,
            onKeyDown: keyDownHandler,
            onBlur: blurHandler,
            onPointerUp: pointerUpHandler
        })
    };
}

/**
 * Returns the datatip.
 * @param text The text string for the diagram item.
 * @param rootRef The ref for root of the diagram.
 * @param focusedItemBoundsRef The ref for focused item bounds.
 * @param focusedItemInfo The ItemInfo for focused item.
 * @returns
 */
const useDiagramDatatip = ({ touchResponse, datatip, focusedItemBoundsRef, focusedItemInfo, panState, zoom, width, nodesMap, linksMap, hoveredItem }) => {
    const { direction } = useUser();
    const isRtl = direction === 'rtl';
    const datatipC = getDatatipContent(nodesMap, linksMap, focusedItemInfo, hoveredItem, datatip);
    const elementBounds = focusedItemBoundsRef.current
        ? {
            x: focusedItemBoundsRef.current.x * zoom + panState.panX,
            y: focusedItemBoundsRef.current.y * zoom + panState.panY,
            width: focusedItemBoundsRef.current.width * zoom,
            height: focusedItemBoundsRef.current.height * zoom
        }
        : undefined;
    const offset = focusedItemInfo.isCurrent
        ? calculateOffset(isRtl, width, elementBounds)
        : calculateOffset(isRtl, width);
    const { datatipContent, datatipProps } = useDatatip({
        content: datatipC?.content,
        borderColor: datatipC?.borderColor,
        placement: 'top-start',
        offset,
        anchor: focusedItemInfo?.isCurrent ? 'element' : 'pointer',
        touchResponse
    });
    return { datatipContent: datatipContent, datatipProps: datatipProps };
};

const usePointerGesture = ({ captureTargetRef, numPointers = 1, onPointerGestureDown, onPointerGestureMove, onPointerGestureEnd, onExtraneousPointerDown, isDisabled = false }) => {
    const activePointers = useRef([]);
    if (isDisabled) {
        activePointers.current = [];
    }
    const onPointerDown = (e) => {
        activePointers.current.push(e);
        if (activePointers.current.length === numPointers) {
            onPointerGestureDown && onPointerGestureDown({ pointers: activePointers.current });
        }
        else if (activePointers.current.length > numPointers) {
            onExtraneousPointerDown && onExtraneousPointerDown({ pointers: activePointers.current });
        }
    };
    const onPointerMove = (e) => {
        if (activePointers.current.length === 0)
            return;
        const index = activePointers.current.findIndex((pointerEvent) => pointerEvent.pointerId === e.pointerId);
        if (index === -1)
            return;
        activePointers.current[index] = e;
        if (activePointers.current.length === numPointers) {
            activePointers.current.forEach((e) => captureTargetRef.current.setPointerCapture(e.pointerId));
            onPointerGestureMove && onPointerGestureMove({ pointers: activePointers.current });
        }
    };
    const onPointerUp = (e) => {
        const index = activePointers.current.findIndex((pointerEvent) => pointerEvent.pointerId === e.pointerId);
        if (index === -1)
            return;
        activePointers.current[index] = e;
        if (activePointers.current.length === numPointers) {
            onPointerGestureEnd && onPointerGestureEnd({ pointers: activePointers.current });
        }
        activePointers.current.splice(index, 1);
    };
    const onPointerCancel = onPointerUp;
    const onPointerLeave = onPointerUp;
    return isDisabled
        ? {}
        : {
            onPointerDown,
            onPointerMove,
            onPointerUp,
            onPointerCancel,
            onPointerLeave
        };
};

/**
 * Whether point with coordinates are in the draggable region
 */
const inDraggableRegion = (x, y, region) => {
    if (!region)
        return true;
    const { xMin, xMax, yMin, yMax } = region;
    return x >= xMin && x <= xMax && y >= yMin && y <= yMax;
};
/**
 * Returns region offset
 */
const getRegionOffset = (x, y, region) => {
    if (!region)
        return { regionOffsetX: x, regionOffsetY: y };
    return { regionOffsetX: x - region.xMin, regionOffsetY: y - region.yMin };
};
const useDrag = ({ captureTargetRef, draggableRegion, onDragStart, onDragMove, onDragEnd, isDisabled = false }) => {
    const inactiveState = { isDragging: false, x0: -1, y0: -1, regionOffsetX: -1, regionOffsetY: -1 };
    const dragState = useRef(inactiveState);
    const handlePointerEvent = (e, cb) => {
        const { isDragging, x0, y0, regionOffsetX, regionOffsetY } = dragState.current;
        if (!isDragging)
            return;
        const x = e.pageX;
        const y = e.pageY;
        cb && cb({ x, y, dx: x - x0, dy: y - y0, regionOffsetX, regionOffsetY, originalEvent: e });
    };
    const dragProps = usePointerGesture({
        captureTargetRef,
        numPointers: 1, // Only allow 1 pointer dragging
        onExtraneousPointerDown: () => {
            dragState.current = inactiveState;
        },
        onPointerGestureDown: ({ pointers: [e] }) => {
            const x = e.pageX;
            const y = e.pageY;
            if (e.button !== 0 || !inDraggableRegion(x, y, draggableRegion))
                return;
            const { regionOffsetX, regionOffsetY } = getRegionOffset(x, y, draggableRegion);
            dragState.current = { isDragging: true, x0: x, y0: y, regionOffsetX, regionOffsetY };
            onDragStart && onDragStart({ x, y, regionOffsetX, regionOffsetY, originalEvent: e });
        },
        onPointerGestureMove: ({ pointers: [e] }) => {
            handlePointerEvent(e, onDragMove);
        },
        onPointerGestureEnd: ({ pointers: [e] }) => {
            handlePointerEvent(e, onDragEnd);
            dragState.current = inactiveState;
        }
    });
    return isDisabled ? {} : dragProps;
};

const constrainPan = (previousPan, nextPan, panBounds, panDirection) => {
    const panX = panDirection !== 'y' ? nextPan.panX : previousPan.panX;
    const panY = panDirection !== 'x' ? nextPan.panY : previousPan.panY;
    return {
        panX: panX > panBounds.maxX ? panBounds.maxX : panX < panBounds.minX ? panBounds.minX : panX,
        panY: panY > panBounds.maxY ? panBounds.maxY : panY < panBounds.minY ? panBounds.minY : panY
    };
};
const pan = (previousPan, nextPan, panDirection, zoom, width, height, panBounds, onPanChange) => {
    if (!panBounds) {
        //On initial render before nodes are rendered
        return { newPan: { panX: 0, panY: 0 } };
    }
    const newPan = constrainPan(previousPan, nextPan, panBounds, panDirection);
    const isPanChanged = newPan.panX !== previousPan.panX || newPan.panY !== previousPan.panY;
    const center = panXYToCenterXY(newPan.panX, newPan.panY, zoom, width, height);
    isPanChanged &&
        onPanChange &&
        onPanChange({
            centerX: center.centerX,
            centerY: center.centerY
        });
    return { newPan };
};
const getPanBounds = (dWidth, dHeight, elemBounds, zoom, minZoom, initPanZoomState, panType) => {
    const { x, y, width, height } = elemBounds;
    let minX, maxX, minY, maxY;
    if (panType === 'centerContent') {
        minX = dWidth / 2 - (width + x) * zoom;
        minY = dHeight / 2 - (height + y) * zoom;
        maxX = dWidth / 2 - x * zoom;
        maxY = dHeight / 2 - y * zoom;
    }
    else {
        // panType equals fixed
        const zoomRatio = zoom / minZoom;
        // Find left corner of the content at min zoom and content is centered
        const minZoomX = (dWidth - width * minZoom) / 2 - x * minZoom;
        const minZoomY = (dHeight - height * minZoom) / 2 - y * minZoom;
        // When we pan all the way to the right, the left corner of displayable area is 0,0 as in min zoom.
        // When we pan all the way to the left, lets find the corner of the displayable area
        const leftCornerX = dWidth - dWidth * zoomRatio;
        const leftCornerY = dHeight - dHeight * zoomRatio;
        // Now we have everything to calculate pan zoom constraints
        minX = leftCornerX + minZoomX * zoomRatio;
        minY = leftCornerY + minZoomY * zoomRatio;
        maxX = minZoomX * zoomRatio;
        maxY = minZoomY * zoomRatio;
    }
    const initZoom = initPanZoomState.zoom;
    const initCenterX = initPanZoomState.centerX;
    const initCenterY = initPanZoomState.centerY;
    // If an initial panZoomState is set, should expand pan bounds to include it
    let dx, dy;
    if (initCenterX) {
        const boundsX = initCenterX * initZoom - dWidth / 2;
        if (-boundsX * initZoom < minX) {
            dx = minX - boundsX * initZoom;
            minX -= dx;
            maxX += dx;
        }
        else if (-boundsX * initZoom > maxX) {
            dx = -boundsX * initZoom - maxX;
            minX -= dx;
            maxX += dx;
        }
    }
    if (initCenterY) {
        const boundsY = initCenterY * initZoom - dHeight / 2;
        if (-boundsY * initZoom < minY) {
            dy = minY - boundsY * initZoom;
            minY -= dy;
            maxY += dy;
        }
        else if (-boundsY * initZoom > maxY) {
            dy = -boundsY * initZoom - maxY;
            minY -= dy;
            maxY += dy;
        }
    }
    return {
        minX: minX,
        maxX: maxX,
        minY: minY,
        maxY: maxY
    };
};

const useDragPan = ({ panProps, captureTargetRef, panBounds, width, height, zoom, onDragPanStart, onDragPanEnd }) => {
    const prevPanState = useRef({ panX: 0, panY: 0 });
    const initialPanState = useRef({ panX: 0, panY: 0 });
    const dragProps = useDrag({
        captureTargetRef,
        onDragStart: () => {
            const panValues = centerXYToPanXY(panProps.centerX, panProps.centerY, zoom, width, height);
            initialPanState.current = {
                panX: panValues.panX,
                panY: panValues.panY
            };
            onDragPanStart && onDragPanStart();
        },
        onDragMove: ({ dx, dy }) => {
            const nextPan = {
                panX: initialPanState.current.panX + dx,
                panY: initialPanState.current.panY + dy
            };
            const { newPan } = pan(prevPanState.current, nextPan, panProps.panDirection, zoom, width, height, panBounds, panProps.onPan);
            prevPanState.current = newPan;
        },
        onDragEnd: ({ originalEvent }) => {
            // If panning occurred, call preventDefault to prevent selection from occurring
            if (initialPanState.current.panX !== prevPanState.current.panX ||
                initialPanState.current.panY !== prevPanState.current.panY)
                originalEvent.preventDefault();
            onDragPanEnd && onDragPanEnd();
        },
        isDisabled: panProps.panning === 'off'
    });
    return dragProps;
};

const PX_FACTOR_PER_LINE = 15; // Value used in Toolkit
const PX_FACTOR_PER_PAGE = 40; // Value copied from datagrid; this is not handled in Toolkit
const getNormalizedDelta = (e) => {
    const { deltaX, deltaY, deltaMode } = e;
    switch (deltaMode) {
        case e.DOM_DELTA_PIXEL:
            return { deltaX: -deltaX, deltaY: -deltaY };
        case e.DOM_DELTA_LINE:
            return { deltaX: -deltaX * PX_FACTOR_PER_LINE, deltaY: -deltaY * PX_FACTOR_PER_LINE };
        case e.DOM_DELTA_PAGE:
            return { deltaX: -deltaX * PX_FACTOR_PER_PAGE, deltaY: -deltaY * PX_FACTOR_PER_PAGE };
        default:
            return { deltaX: -deltaX, deltaY: -deltaY };
    }
};
const useWheel = ({ onWheel: onWheelCallback, preventDefault = true, isDisabled = false }) => {
    const onWheel = (e) => {
        const { deltaX, deltaY } = getNormalizedDelta(e);
        if (preventDefault)
            e.preventDefault();
        onWheelCallback({
            x: e.offsetX,
            y: e.offsetY,
            deltaX,
            deltaY,
            ctrlKey: e.ctrlKey || e.metaKey
        });
    };
    return isDisabled ? {} : { onWheel };
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const ZOOM_INCREMENT = 0.05;
const zoom = (nextZoom, zoom, minZoom, maxZoom, onZoomChange) => {
    const newZoom = nextZoom > maxZoom || nextZoom < minZoom ? zoom : nextZoom;
    const isZoomChanged = newZoom !== zoom;
    isZoomChanged &&
        onZoomChange &&
        onZoomChange({
            zoomValue: newZoom
        });
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const useWheelZoom = ({ zooming, minZoom, maxZoom, zoomValue, onZoom }) => {
    const wheelProps = useWheel({
        onWheel: ({ deltaY }) => {
            const newZoom = zoomValue * (1 + ZOOM_INCREMENT * deltaY);
            zoom(newZoom, zoomValue, minZoom, maxZoom, onZoom);
        },
        isDisabled: zooming === 'off'
    });
    return wheelProps;
};

const getMidpoint = (p1, p2) => ({ x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 });
const getDistance = (p1, p2) => Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p2.y) ** 2);
const usePinch = ({ captureTargetRef, onPinchZoomStart, onPinchZoomChange, onPinchZoomEnd, isDisabled = false }) => {
    const origin = useRef({ x: -1, y: -1 });
    const prevDistance = useRef(-1);
    const reset = () => {
        origin.current = { x: -1, y: -1 };
        prevDistance.current = -1;
    };
    if (isDisabled)
        reset();
    const pinchProps = usePointerGesture({
        captureTargetRef,
        numPointers: 2, // Pinch gesture requires 2 pointers
        onPointerGestureDown: ({ pointers: [pointer1, pointer2] }) => {
            const p1 = { x: pointer1.offsetX, y: pointer1.offsetY };
            const p2 = { x: pointer2.offsetX, y: pointer2.offsetY };
            origin.current = getMidpoint(p1, p2);
            prevDistance.current = getDistance(p1, p2);
            onPinchZoomStart &&
                onPinchZoomStart({
                    origin: origin.current,
                    delta: 0
                });
        },
        onPointerGestureMove: ({ pointers: [pointer1, pointer2] }) => {
            const p1 = { x: pointer1.offsetX, y: pointer1.offsetY };
            const p2 = { x: pointer2.offsetX, y: pointer2.offsetY };
            const distance = getDistance(p1, p2);
            const delta = distance - prevDistance.current;
            prevDistance.current = distance;
            onPinchZoomChange &&
                onPinchZoomChange({
                    origin: origin.current,
                    delta
                });
        },
        onPointerGestureEnd: () => {
            reset();
            onPinchZoomEnd && onPinchZoomEnd();
        }
    });
    return isDisabled ? {} : pinchProps;
};

const usePinchZoom = ({ captureTargetRef, zooming, minZoom, maxZoom, zoomValue, onZoom }) => {
    const pinchProps = usePinch({
        captureTargetRef,
        onPinchZoomChange: ({ delta }) => {
            const newZoom = zoomValue * (1 + ZOOM_INCREMENT * delta);
            zoom(newZoom, zoomValue, minZoom, maxZoom, onZoom);
        },
        isDisabled: zooming === 'off'
    });
    return pinchProps;
};

const usePanZoom = ({ props, captureTargetRef, width, height, contentBounds, isRtl }) => {
    const [cursor, setCursor] = useState();
    const zoomProps = getZoomProps(props, width, height, contentBounds);
    const panBounds = useRef();
    const prevZoom = useRef();
    const panning = useRef();
    const initPanZoomState = useRef({
        zoom: props.zoomValue || 0,
        centerX: props.centerX,
        centerY: props.centerY
    });
    const isDeviceTouch = isTouch();
    const plotArea = {
        width: width,
        height: height,
        x: 0,
        y: 0
    };
    const showPanButton = isDeviceTouch ? props.panning && props.panning !== 'off' : undefined;
    const dragModeOptions = {
        isZoomScroll: true,
        plotAreaSpace: plotArea,
        componentWidth: width,
        isRtl,
        showPanButton: showPanButton ?? false,
        showZoomButton: false,
        showSelectButton: false,
        isDisabled: !isDeviceTouch
    };
    const { toggleButtonContent, userDragMode } = useVisDragModeControls(dragModeOptions);
    const panProps = getPanProps(props, contentBounds, userDragMode, isDeviceTouch);
    if (contentBounds.width !== Infinity &&
        (zoomProps.zoomValue !== prevZoom.current || panProps.panning !== panning.current)) {
        panBounds.current = getPanBounds(width, height, contentBounds, zoomProps.zoomValue, zoomProps.minZoom, initPanZoomState.current, panProps.panning);
        prevZoom.current = zoomProps.zoomValue;
        panning.current = panProps.panning;
    }
    const dragPanProps = useDragPan({
        panProps: panProps,
        captureTargetRef: captureTargetRef,
        panBounds: panBounds.current,
        zoom: zoomProps.zoomValue,
        width,
        height,
        onDragPanStart: () => setCursor('grabbing'),
        onDragPanEnd: () => setCursor('auto')
    });
    //dZoom or nZoom is required
    const kbZoomCallback = (props) => {
        const newZoom = props.dZoom
            ? zoomProps.zoomValue + props.dZoom
            : getZoomToFitZoom(width, height, contentBounds);
        zoom(props.nZoom ? props.nZoom : newZoom, zoomProps.zoomValue, zoomProps.minZoom, zoomProps.maxZoom, zoomProps.onZoom);
    };
    const prevPanState = useRef({ panX: 0, panY: 0 });
    // dPan or nPan is required
    const kbPanCallback = (props) => {
        let centerX;
        let centerY;
        if (props.center) {
            centerX = contentBounds.x + contentBounds.width / 2;
            centerY = contentBounds.y + contentBounds.height / 2;
        }
        else if (props.dPan) {
            centerX = panProps.centerX + props.dPan.dx;
            centerY = panProps.centerY + props.dPan.dy;
        }
        else {
            centerX = props.nPan.cx;
            centerY = props.nPan.cy;
        }
        const panValues = centerXYToPanXY(centerX, centerY, zoomProps.zoomValue, width, height);
        const { newPan } = pan(prevPanState.current, panValues, panProps.panDirection, zoomProps.zoomValue, width, height, panBounds.current, panProps.onPan);
        prevPanState.current = newPan;
    };
    const wheelZoomProps = useWheelZoom(zoomProps);
    const pinchZoomProps = usePinchZoom({
        captureTargetRef,
        zooming: zoomProps.zooming,
        minZoom: zoomProps.minZoom,
        maxZoom: zoomProps.maxZoom,
        zoomValue: zoomProps.zoomValue,
        onZoom: zoomProps.onZoom
    });
    const panZoomProps = mergeProps(dragPanProps, wheelZoomProps, pinchZoomProps);
    return {
        panZoomProps,
        panProps,
        zoomProps,
        toggleButtonContent,
        cursor,
        centerX: panProps.centerX,
        centerY: panProps.centerY,
        zoomValue: zoomProps.zoomValue,
        kbPanCallback: panProps.panning !== 'off' ? kbPanCallback : undefined,
        kbZoomCallback: zoomProps.zooming !== 'off' ? kbZoomCallback : undefined
    };
};

function useDiagramSelection({ selectedIds, selectionMode, nodeMap, linkMap, promotedLinkMap, focusedItemInfo, onSelectionChange, rootRef }) {
    const nodeIdToIndexMap = nodeMap.itemIdToIndexMap;
    const nodeIndexToIdMap = nodeMap.itemIndexToIdMap;
    const nodeIdToDataMap = nodeMap.itemIdToDataMap;
    const linkIdToIndexMap = linkMap.itemIdToIndexMap;
    const linkIndexToIdMap = linkMap.itemIndexToIdMap;
    const linkIdToDataMap = linkMap.itemIdToDataMap;
    const promotedLinkIdToIndexMap = promotedLinkMap.itemIdToIndexMap;
    const promotedLinkIndexToIdMap = promotedLinkMap.itemIndexToIdMap;
    const promotedLinkIdToDataMap = promotedLinkMap.itemIdToDataMap;
    const encodeNodeId = (id) => `N_${nodeIdToIndexMap.get(id)}`;
    const decodeNodeId = (id) => nodeIndexToIdMap.get(id.slice(2));
    const encodeLinkId = (id) => `L_${linkIdToIndexMap.get(id)}`;
    const decodeLinkId = (id) => linkIndexToIdMap.get(Number(id.slice(2)));
    const encodePromotedLinkId = (id) => `P_${promotedLinkIdToIndexMap.get(id)}`;
    const decodePromotedLinkId = (id) => promotedLinkIndexToIdMap.get(Number(id.slice(2)));
    const encodedNodesSelection = selectedIds.nodes ? selectedIds.nodes.map(encodeNodeId) : [];
    const encodedLinksSelection = selectedIds.links ? selectedIds.links.map(encodeLinkId) : [];
    const encodedPromotedLinksSelection = selectedIds.promotedLinks
        ? selectedIds.promotedLinks.map(encodePromotedLinkId)
        : [];
    const encodedSelection = [
        ...encodedNodesSelection,
        ...encodedLinksSelection,
        ...encodedPromotedLinksSelection
    ];
    const idExtracter = (event) => {
        // return encodeNodeId(id) or encodeLinkId(id) depending on node or link selection or undefined if clicked on empty space
        const info = event.type === 'keyup'
            ? focusedItemInfo
            : getNavigableInfo(event.target, rootRef);
        return info.id !== undefined
            ? info.type === 'node'
                ? encodeNodeId(info.id)
                : info.type === 'link'
                    ? encodeLinkId(info.id)
                    : encodePromotedLinkId(info.id)
            : undefined;
    };
    const onEncodedSelectionChange = (detail) => {
        const newNodeIds = detail.ids
            .filter((encId) => encId[0] === 'N')
            .map((encId) => decodeNodeId(encId));
        const newLinkIds = detail.ids
            .filter((encId) => encId[0] === 'L')
            .map((encId) => decodeLinkId(encId));
        const newPromotedLinkIds = detail.ids
            .filter((encId) => encId[0] === 'P')
            .map((encId) => decodePromotedLinkId(encId));
        const newSelectedNodeIds = newNodeIds.filter((id) => nodeIdToDataMap.get(id)?.selectable !== 'off');
        const newSelectedLinkIds = newLinkIds.filter((id) => linkIdToDataMap.get(id)?.selectable !== 'off');
        const nodeData = newSelectedNodeIds.map((selectedId) => {
            return nodeIdToDataMap.get(selectedId);
        });
        const linkData = newSelectedLinkIds.map((selectedId) => {
            return linkIdToDataMap.get(selectedId);
        });
        const promotedLinkData = newPromotedLinkIds.map((selectedId) => {
            return promotedLinkIdToDataMap.get(selectedId);
        });
        return (onSelectionChange &&
            onSelectionChange({
                nodes: newSelectedNodeIds,
                links: newSelectedLinkIds,
                promotedLinks: newPromotedLinkIds,
                nodeData,
                linkData,
                promotedLinkData
            }));
    };
    const getDataById = (id) => {
        let data;
        if (id[0] === 'N') {
            const nodeId = decodeNodeId(id);
            data = nodeMap.itemIdToDataMap.get(nodeId);
        }
        else if (id[0] === 'L') {
            const linkId = decodeLinkId(id);
            data = linkMap.itemIdToDataMap.get(linkId);
        }
        else if (id[0] === 'P') {
            const linkId = decodePromotedLinkId(id);
            data = promotedLinkMap.itemIdToDataMap.get(linkId);
        }
        return data;
    };
    const { selectionContent, selectionProps } = useSelection({
        selection: encodedSelection,
        idExtracter,
        selectionMode,
        getDataById,
        onChange: onEncodedSelectionChange
    });
    return { selectionContent, selectionProps };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
function getDiagramContextMenuContext(nodesMap, linksMap, type, idx) {
    let context;
    if (type === 'node') {
        context = {
            data: nodesMap.get(idx),
            type
        };
    }
    else if (type === 'link') {
        context = {
            data: linksMap.get(idx),
            type
        };
    }
    else {
        context = {
            type: 'background'
        };
    }
    return {
        context: context
    };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const useDiagramContextMenu = ({ focusedItemInfo, rootRef, contextMenuConfig, onContextMenuDismissed, nodesMap, linksMap }) => {
    const { contextMenuProps, contextMenuContent } = useContextMenu({
        onContextMenuHandler: ({ gesture, target }) => {
            let idx;
            let elementType = 'background';
            const currentTarget = target;
            if (gesture === 'keyboard') {
                idx = focusedItemInfo.id;
                if (focusedItemInfo.type === 'node') {
                    elementType = 'node';
                }
                else if (idx !== undefined) {
                    elementType = 'link';
                }
            }
            else if (currentTarget.closest('[data-oj-private-node]')?.dataset['ojPrivateNode']) {
                idx = currentTarget.closest('[data-oj-private-node]')?.dataset['ojPrivateNode'];
                elementType = 'node';
            }
            else if (currentTarget.closest('[data-oj-private-link]')?.dataset['ojPrivateLink']) {
                idx = currentTarget.closest('[data-oj-private-link]')?.dataset['ojPrivateLink'];
                elementType = 'link';
            }
            const { context } = getDiagramContextMenuContext(nodesMap, linksMap, elementType, idx);
            if (gesture === 'keyboard') {
                let element;
                if (focusedItemInfo.type === 'node') {
                    element = rootRef.current?.querySelector(`[data-oj-private-node="${idx}"]`);
                }
                else {
                    element = rootRef.current?.querySelector(`[data-oj-private-link="${idx}"]`);
                }
                return {
                    type: 'element',
                    context,
                    elem: element ? element : null
                };
            }
            return { type: 'pointer', context };
        },
        contextMenuOptions: {
            isDisabled: !contextMenuConfig //If there is not a context menu renderer we disable the hook
        },
        rootRef,
        contextMenuConfig,
        onContextMenuDismissed
    });
    return { contextMenuContent, contextMenuProps };
};

function ContainerDiagramWithDimensions({ nodes = [], links = [], width, height, selectedIds = {}, selectionMode = 'none', layout, nodeRenderer, linkRenderer, onSelectionChange, onItemHover, onItemFocus, highlightedIds = {}, datatip, expanded = [], onExpandedChange, contextMenuConfig, ...otherProps }) {
    const focusedItemBoundsRef = useRef(null);
    const rootRef = useRef(null);
    //TODO JET-62563 change bounds to a MAP
    const [bounds, setBounds] = useState(new Map());
    const linkDimensions = useRef(new Map());
    const promotedLinkDimensions = useRef(new Map());
    const [combinedLabelBounds, setCombinedLabelBounds] = useState();
    const { direction } = useUser();
    const isRtl = direction === 'rtl';
    const diagramNodes = nodes;
    const nodeMap = createNodesMap(diagramNodes);
    const nodeIdToParentMap = nodeMap.itemIdToParentMap;
    const nodeIdToDataMap = nodeMap.itemIdToDataMap;
    const diagramLinks = filterLinksWithNoEndNodes(links, nodeIdToDataMap);
    const linkMap = createLinksMap(diagramLinks);
    const linkIdToDataMap = linkMap.itemIdToDataMap;
    const resizeThrottling = useRef(false);
    const newDimensions = getDimensionsFromBounds(bounds);
    const { textMeasureContent, getTextDimensions } = useTextDimensions();
    const labelDimensions = useRef(new Map());
    const linkDimsChanged = useRef(false);
    const nodeLabelPosRef = useRef(new Map());
    const linkLabelPosRef = useRef(new Map());
    const [layoutOutput, setLayoutOutput] = useState();
    const nodeBoundsRef = useRef(new Map());
    const { promotedLinks, 
    //linkToPromotedMap,
    promotedToLinkMap } = getPromotedLinks(nodeIdToParentMap, links, expanded);
    const promotedLinkMap = createPromotedLinksMap(promotedLinks);
    const contentBounds = getContentBounds(bounds, combinedLabelBounds);
    const { panZoomProps, panProps, zoomProps, toggleButtonContent, cursor, centerX, centerY, zoomValue, kbPanCallback, kbZoomCallback } = usePanZoom({
        props: otherProps,
        captureTargetRef: rootRef,
        width: width,
        height: height,
        contentBounds,
        isRtl
    });
    const { touchResponse, touchResponseStyle } = useVisTouchResponse({
        type: 'auto',
        supportsTouchDragGestures: zoomProps.zooming === 'on' || panProps.panning !== 'off',
        rootRef
    });
    const { onContextMenuDismissed, focusedItemInfo, hoveredItemInfo, activeId, eventsProps } = useEvents(touchResponse, diagramNodes[0], diagramNodes, diagramLinks, bounds, linkIdToDataMap, nodeIdToDataMap, promotedLinkMap.itemIdToDataMap, width, height, otherProps.maxZoom || 1, expanded, nodeIdToParentMap, onItemHover, onItemFocus, kbPanCallback, kbZoomCallback, onExpandedChange);
    const { selectionProps, selectionContent } = useDiagramSelection({
        selectedIds,
        selectionMode,
        nodeMap,
        linkMap,
        promotedLinkMap,
        focusedItemInfo,
        onSelectionChange,
        rootRef
    });
    // This is for the datatip kb position
    if (focusedItemInfo && bounds.size > 0) {
        focusedItemBoundsRef.current = getFocusedItemBounds(focusedItemInfo, bounds, diagramLinks, linkMap.itemIdToIndexMap, rootRef);
    }
    const { datatipContent, datatipProps: { 'aria-describedby': datatipAriaDescribedby, ...datatipProps } } = useDiagramDatatip({
        touchResponse,
        datatip,
        focusedItemInfo,
        focusedItemBoundsRef,
        panState: centerXYToPanXY(centerX, centerY, zoomValue, width, height),
        zoom: zoomValue,
        width: width,
        nodesMap: nodeIdToDataMap,
        linksMap: linkIdToDataMap,
        hoveredItem: hoveredItemInfo
    });
    const [visibility, setVisibility] = useState('hidden');
    const style = {
        width: width,
        height: height,
        cursor: cursor,
        visibility: visibility,
        ...touchResponseStyle
    };
    const states = useRef();
    const previousState = states.current // states.current is previous state
        ? states.current
        : {
            selectedNodeIds: [],
            selectedLinkIds: [],
            selectedPromotedLinkIds: [],
            focusedId: undefined,
            hoveredId: undefined,
            activeId: undefined,
            highlightedNodeIds: [],
            highlightedLinkIds: [],
            highlightedPromotedLinkIds: [],
            zoom: 0,
            expanded: []
        };
    states.current = {
        // update states to new state
        selectedNodeIds: selectedIds.nodes ?? [],
        selectedLinkIds: selectedIds.links ?? [],
        selectedPromotedLinkIds: selectedIds.promotedLinks ?? [],
        focusedId: focusedItemInfo.isCurrent && focusedItemInfo.isFocusVisible ? focusedItemInfo.id : undefined,
        hoveredId: hoveredItemInfo?.isCurrent ? hoveredItemInfo.id : undefined,
        activeId,
        highlightedNodeIds: highlightedIds.nodes ?? [],
        highlightedLinkIds: highlightedIds.links ?? [],
        highlightedPromotedLinkIds: highlightedIds.promotedLinks ?? [],
        zoom: zoomValue,
        expanded: expanded || []
    };
    const { contextMenuContent, contextMenuProps } = useDiagramContextMenu({
        focusedItemInfo,
        rootRef,
        contextMenuConfig: nodes.length > 0 ? contextMenuConfig : undefined,
        onContextMenuDismissed,
        nodesMap: nodeIdToDataMap,
        linksMap: linkIdToDataMap
    });
    const mergedEventProps = mergeProps(panZoomProps, eventsProps, selectionProps, datatipProps, contextMenuProps);
    // Called anytime node changes size
    const onNodeSizeChanged = (nodeWidth, nodeHeight, id) => {
        newDimensions.set(id, { width: nodeWidth, height: nodeHeight });
        if (resizeThrottling.current) {
            return;
        }
        resizeThrottling.current = true;
        // performs layout at the next available animation frame when all measurements should be ready
        window.requestAnimationFrame(() => {
            const { labelDims, layoutJSON } = constructLayoutJSON(nodeIdToDataMap, linkIdToDataMap, promotedLinks, newDimensions, width, height, bounds, zoomValue, nodeIdToParentMap, nodeBoundsRef.current, rootRef, getTextDimensions);
            labelDimensions.current = labelDims;
            const layoutOutput = layout(layoutJSON);
            const { nodePoints, nodeLabelPos, linkLabelPos } = deconstructLayoutJSON(layoutOutput, diagramNodes, diagramLinks);
            nodeLabelPosRef.current = nodeLabelPos;
            linkLabelPosRef.current = linkLabelPos;
            const nodeBounds = mergeDimensions(newDimensions, nodePoints);
            const labelBounds = getAllLabelBounds(labelDims, nodeLabelPos, direction === 'rtl');
            const equalBounds = isEqualBounds(nodeBounds, bounds);
            if (!equalBounds ||
                linkDimsChanged.current ||
                (combinedLabelBounds &&
                    labelBounds &&
                    !isEqualLabelBounds(combinedLabelBounds, labelBounds))) {
                setBounds(nodeBounds);
                setCombinedLabelBounds(labelBounds);
                setLayoutOutput(layoutOutput);
                linkDimsChanged.current = false;
                setVisibility('hidden');
            }
            else if (visibility == 'hidden') {
                setVisibility('visible');
            }
            resizeThrottling.current = false;
        });
    };
    const onLinkSizeChanged = (linkWidth, linkHeight, id) => {
        const linkDims = linkDimensions.current.get(id);
        if (!linkDims ||
            (linkDims &&
                (Math.abs(linkWidth - linkDims.width) > 0.5 ||
                    Math.abs(linkHeight - linkDims.height) > 0.5))) {
            linkDimensions.current.set(id, { width: linkWidth, height: linkHeight });
            linkDimsChanged.current = true;
        }
    };
    const onPromotedLinkSizeChanged = (linkWidth, linkHeight, id) => {
        const linkDims = promotedLinkDimensions.current.get(id);
        if (!linkDims ||
            (linkDims &&
                (Math.abs(linkWidth - linkDims.width) > 0.5 ||
                    Math.abs(linkHeight - linkDims.height) > 0.5))) {
            promotedLinkDimensions.current.set(id, { width: linkWidth, height: linkHeight });
            linkDimsChanged.current = true;
        }
    };
    return (jsxs("div", { ref: rootRef, class: outerStyles, ...mergedEventProps, style: style, tabIndex: 0, role: "application", "aria-label": otherProps['aria-label'], "aria-labelledby": otherProps['aria-labelledby'], "aria-describedby": l([otherProps['aria-describedby'], datatipAriaDescribedby]), "aria-activedescendant": activeId, children: [getTextDimensions ? (jsx(DiagramPanZoomContainer, { centerX: centerX, centerY: centerY, zoom: zoomValue, width: width, height: height, children: jsx(DiagramLayers, { nodes: diagramNodes, links: diagramLinks, zoom: zoomValue, nodeRenderer: nodeRenderer, linkRenderer: linkRenderer, width: width, height: height, nodeBounds: bounds, linkDimensions: linkDimensions.current, promotedLinkDimensions: promotedLinkDimensions.current, states: states.current, previousStates: previousState, onNodeSizeChanged: onNodeSizeChanged, onLinkSizeChanged: onLinkSizeChanged, onPromotedLinkSizeChanged: onPromotedLinkSizeChanged, nodeLabelPositions: nodeLabelPosRef.current, linkLabelPositions: linkLabelPosRef.current, labelDimensions: labelDimensions.current, supportsSelection: selectionMode !== 'none' ||
                        !!(selectedIds?.nodes && selectedIds.nodes.length > 0) ||
                        !!(selectedIds?.links && selectedIds.links.length > 0), layoutOutput: layoutOutput, nodeIdToParentMap: nodeIdToParentMap, rootRef: rootRef, combinedNodeBounds: contentBounds, nodeBoundsRef: nodeBoundsRef, promotedLinks: promotedLinks, promotedToLinkMap: promotedToLinkMap }) })) : undefined, textMeasureContent, datatipContent, contextMenuContent, selectionContent, toggleButtonContent] }));
}

/**
 * Diagrams are used to display a set of nodes and the links between them.
 */
function ContainerDiagram({ width, height, ...otherProps }) {
    return otherProps.nodes && otherProps.nodes.length > 0 ? (jsx(TrackResizeContainer, { width: width, height: height, class: dimensionStyle, children: (width, height) => (jsx(ContainerDiagramWithDimensions, { width: width, height: height, ...otherProps })) })) : null;
}

export { ContainerDiagram };
//# sourceMappingURL=PRIVATE_ContainerDiagram.js.map
