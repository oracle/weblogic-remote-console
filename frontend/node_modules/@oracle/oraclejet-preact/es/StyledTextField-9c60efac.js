/* @oracle/oraclejet-preact: undefined */
import { jsx, jsxs } from 'preact/jsx-runtime';
import { useRef, useLayoutEffect, useState } from 'preact/hooks';
import { u as useAccessibleContext } from './useAccessibleContext-5744de8b.js';
import { u as useComponentTheme } from './useComponentTheme-d2f9e47f.js';
import './FormFieldContext-47ca0c20.js';
import { u as useFormFieldContext } from './useFormFieldContext-daf7a676.js';
import './TabbableModeContext-7d8ad946.js';
import { u as useTabbableMode } from './useTabbableMode-a2fdbb06.js';
import { u as useTextFieldInputHandlers } from './useTextFieldInputHandlers-8122048f.js';
import { u as useTranslationBundle } from './useTranslationBundle-25469f1c.js';
import { i as isEmbeddedVariant } from './formControlUtils-84e2af0e.js';
import { c as classNames } from './classNames-4e12b00d.js';
import { t as textInterpolations } from './textAlign-ad252afa.js';
import { m as mergeInterpolations } from './mergeInterpolations-30cd9a69.js';
import { m as mergeProps } from './mergeProps-88ea8306.js';
import { i as isInputPlaceholderShown } from './TextFieldUtils-8232bca7.js';
import { formControlInheritTextAlign } from './UNSAFE_TextField/themes/FormControlUtilsStyles.css.js';
import { TextFieldInputRedwoodTheme } from './UNSAFE_TextField/themes/redwood/TextFieldInputTheme.js';
import { LabelRedwoodTheme } from './UNSAFE_Label/themes/redwood/LabelTheme.js';
import { L as LabelValueLayout } from './LabelValueLayout-d7a71947.js';
import { SkeletonRedwoodTheme } from './UNSAFE_Skeleton/themes/redwood/SkeletonTheme.js';
import { u as useTestId } from './useTestId-e5d44ab1.js';
import { l as layoutSpanStyles } from './LayoutStyles.css-6b02421a.js';
import { forwardRef } from 'preact/compat';
import './FormContext-55fb8000.js';
import { u as useFormContext } from './useFormContext-bb9dc478.js';
import { F as Flex } from './Flex-5befe411.js';
import './InputGroupContext-20bdbd6e.js';
import { u as useInputGroupContext } from './useInputGroupContext-1d19411e.js';
import { u as useTooltipControlled } from './useTooltipControlled-d7724623.js';
import { u as useUser } from './useUser-df8ae011.js';
import { TextFieldRedwoodTheme } from './UNSAFE_TextField/themes/redwood/TextFieldTheme.js';
import { ReadonlyTextFieldRedwoodTheme } from './UNSAFE_TextField/themes/redwood/ReadonlyTextFieldTheme.js';
import { FormLayoutRedwoodTheme } from './UNSAFE_TextField/themes/redwood/FormLayoutTheme.js';

const interpolations = [...Object.values(textInterpolations)];
const styleInterpolations = mergeInterpolations(interpolations);
// The WHATWG forms spec specifies the following input types that support setSelectedRange
const supportsSetSelection = ['text', 'search', 'url', 'tel', 'password', 'textarea'];
/**
 * Merge multiple ids into a space-separated list
 * @param ids The ids to be merged
 * @returns The space separated string of ids
 */
function mergeIDs(...ids) {
    return ids.filter(Boolean).join(' ') || undefined;
}
const TextFieldInput = ({ as = 'input', 'aria-autocomplete': ariaAutoComplete, 'aria-controls': ariaControls, 'aria-describedby': ariaDescribedBy, 'aria-expanded': ariaExpanded, 'aria-invalid': ariaInvalid, 'aria-label': ariaLabel, 'aria-labelledby': inputLabelledBy, 'aria-valuemax': ariaValueMax, 'aria-valuemin': ariaValueMin, 'aria-valuenow': ariaValueNow, 'aria-valuetext': ariaValueText, autoComplete, autoFocus, currentCommitValue, hasEmptyLabel, hasEndContent = false, hasInsideLabel = false, hasPrefix = false, hasStartContent = false, hasSuffix = false, id, inputRef, placeholder, isRequired, role, rows, spellcheck, type, value = '', variant = 'default', onInput, onCommit, onKeyDown, onKeyUp, onBlur, onFocus, ...props }) => {
    const { isDisabled, isFocused, isLoading, isReadonly } = useFormFieldContext();
    const { class: styleInterpolationClasses } = styleInterpolations(props);
    const hasValue = value !== '';
    const isTextArea = as === 'textarea';
    const isInput = as === 'input';
    const isPassword = type === 'password';
    const renderPrefix = !isDisabled && hasPrefix;
    const renderSuffix = !isDisabled && hasSuffix;
    const myPlaceholder = isInputPlaceholderShown(hasInsideLabel, hasValue, isFocused)
        ? placeholder
        : undefined;
    const { classes } = useComponentTheme(TextFieldInputRedwoodTheme, {
        type: isPassword ? 'isPassword' : 'notPassword',
        styleVariant: isEmbeddedVariant(variant) ? 'embedded' : 'default',
        textarea: isTextArea ? 'isTextArea' : 'notTextArea',
        input: isInput ? 'isInput' : 'notInput',
        div: 'notDiv',
        prefix: renderPrefix ? 'hasPrefix' : 'noPrefix',
        suffix: renderSuffix ? 'hasSuffix' : 'noSuffix',
        startContent: hasStartContent ? 'hasStartContent' : 'noStartContent',
        endContent: hasEndContent ? 'hasEndContent' : 'noEndContent',
        insideLabel: hasInsideLabel ? 'hasInsideLabel' : 'noInsideLabel',
        value: hasValue ? 'hasValue' : 'noValue',
        focused: isFocused ? 'isFocused' : 'notFocused',
        disabled: isDisabled ? 'isDisabled' : 'notDisabled'
    });
    const inputClasses = classNames([
        classes,
        styleInterpolationClasses,
        // JET-72775 - Form control alignment in tables
        // When we are in legacy collection components, we want to inherit the text align
        // when it is not set explicitly.
        variant === 'legacyEmbedded' && props.textAlign === undefined && formControlInheritTextAlign
    ]);
    const Comp = as || 'input';
    // ref to hold the text selection to restore.
    const selectionRef = useRef({
        start: 0,
        end: 0
    });
    const textFieldInputHandlers = useTextFieldInputHandlers({
        currentCommitValue,
        // Enter should not commit for textarea.
        isCommitOnEnter: as === 'input',
        value,
        onInput,
        onCommit,
        onKeyDown,
        selectionRef
    });
    const handlers = mergeProps(textFieldInputHandlers, { onBlur, onFocus });
    // the implicit default for tabindex on an input is 0, so do not explicitly set it.
    // JET-52914 - Implement Tabbable mode API contract in InputText
    // if not tabbable, spread tabbableModeProps on component
    const { isTabbable, tabbableModeProps } = useTabbableMode();
    // TODO: for autoComplete='off', need to configure attrs appropriately to make sure it
    // works across browsers and versions  (from review on 3/11/22)
    // JET-52089: add unsafe API for specifying an external label which is added to ariaLabelledBy on the input,
    // only when labelEdge is 'none' and label is ''. Since ariaLabelledBy takes precedence over all other
    // kinds of labels, this helps to ensure we don't override a meaningful label.
    const { UNSAFE_ariaLabelledBy } = useAccessibleContext();
    const ariaLabelledBy = hasEmptyLabel
        ? mergeIDs(inputLabelledBy, UNSAFE_ariaLabelledBy)
        : inputLabelledBy;
    const translations = useTranslationBundle('@oracle/oraclejet-preact');
    const loadingAriaLabel = translations.formControl_loading();
    // Restore the saved selection when the value changes.  See JET-62763 for info on why this is needed.
    useLayoutEffect(() => {
        // This should never be a function in this case, This is here because of the Ref type.
        if (typeof inputRef !== 'function') {
            const inpElem = inputRef?.current;
            // only set the selection range if the element has focus
            // only set the selection range on supported types.
            if (document.activeElement === inpElem &&
                inpElem &&
                supportsSetSelection.includes(inpElem.type)) {
                inpElem.setSelectionRange(selectionRef.current.start, selectionRef.current.end);
            }
        }
    }, [value, inputRef]);
    return (jsx(Comp, { "aria-autocomplete": ariaAutoComplete, "aria-controls": ariaControls, "aria-describedby": ariaDescribedBy, "aria-expanded": ariaExpanded, "aria-invalid": ariaInvalid, "aria-label": isLoading ? loadingAriaLabel : ariaLabel ? ariaLabel : undefined, "aria-labelledby": ariaLabelledBy, "aria-required": isRequired ? true : undefined, "aria-valuemax": ariaValueMax, "aria-valuemin": ariaValueMin, "aria-valuenow": ariaValueNow, "aria-valuetext": ariaValueText, autocomplete: autoComplete, autofocus: autoFocus, class: inputClasses, disabled: isDisabled, id: id, onKeyUp: onKeyUp, placeholder: myPlaceholder, readonly: isReadonly, 
        // @ts-expect-error TS cannot infer the type correctly for the polymorphed ref
        ref: inputRef, role: role, rows: rows, spellcheck: spellcheck, type: type, value: value, ...handlers, ...(!isTabbable && tabbableModeProps) }));
};

/**
 * A hook that calls useTooltipControlled and uses a logical focus strategy to control the tooltip.
 * When hasTruncatedLabel is true, we call onLogicalFocus to make the tooltip appear; otherwise we
 * call onLogicalBlur to dismiss it. See useTextField.ts for how we set the value of hasTruncatedLabel.
 */
const useTextFieldTooltip = ({ fieldRef, hasTruncatedLabel, isDisabled, label }) => {
    const [isOpen, setOpen] = useState(false);
    const { tooltipProps, tooltipContent } = useTooltipControlled({
        dismissOnClick: false,
        displayOnHover: false,
        focusStrategy: 'logical',
        isDisabled,
        isOpen: isOpen,
        offset: { mainAxis: 4 },
        onToggle: ({ value }) => {
            setOpen(value);
        },
        position: 'top-start',
        text: label
    });
    // The label already has a for-id association with the input
    // and is read by AT, so we don't need aria-describedby.
    const { 'aria-describedby': notNeeded, onLogicalBlur, onLogicalFocus, ...tooltipEventHandlerProps } = tooltipProps;
    if (!isDisabled) {
        if (hasTruncatedLabel) {
            onLogicalFocus?.(fieldRef?.current);
        }
        else {
            onLogicalBlur?.();
        }
    }
    return { tooltipContent, tooltipEventHandlerProps };
};

// Renders the oj-text-field-container dom which includes the
// main (where the inside label and inputElem goes),
// and end pieces of the form component.
// This does not include user assistance because that is rendered outside the
// oj-text-field-container; that is rendered in the TextField component.
const ReadonlyTextFieldContent = ({ variant, insideLabel, labelText, mainContent, endContent, rootRef, resize, startContent }) => {
    const { isFormLayout, isReadonly: isReadonlyForm } = useFormContext();
    const { hasTruncatedLabel, isLoading } = useFormFieldContext();
    const { direction } = useUser();
    const isLtr = direction === 'ltr';
    const isInsideNonReadonlyForm = isFormLayout && !isReadonlyForm;
    const hasInsideLabel = insideLabel !== undefined;
    const inputGroupContext = useInputGroupContext();
    const hasGroupContext = inputGroupContext !== null;
    // depending on browser direction, apply the appropriate styling.
    // when 'rtl' the flex row direction is reversed.
    const inputGroupPosition = inputGroupContext
        ? inputGroupContext.last
            ? isLtr
                ? 'groupRight'
                : 'groupLeft'
            : inputGroupContext.index === 0
                ? isLtr
                    ? 'groupLeft'
                    : 'groupRight'
                : 'groupMiddle'
        : undefined;
    const { variantClasses: middleStyles, styles: { textFieldEndContent } } = useComponentTheme(TextFieldRedwoodTheme, {
        middleContent: variant,
        textAreaResizeDirection: resize && variant === 'textarea' ? direction : undefined
    });
    const { classes: readonlyClassNames, styles: { readonlyTextFieldMiddleBase, readonlyTextFieldMiddleNotInEnabledForm, readonlyTextFieldMiddleInEnabledForm, readonlyTextFieldMiddleInEnabledFormNotTextarea, startContentInsideLabel, startContentMarginEnd, startContentMarginStart, startContentStartTopLabel } } = useComponentTheme(ReadonlyTextFieldRedwoodTheme, {
        insideNonReadonlyForm: isInsideNonReadonlyForm
            ? 'isInsideNonReadonlyForm'
            : 'notInsideNonReadonlyForm',
        insideLabel: hasInsideLabel ? 'hasInsideLabel' : 'noInsideLabel',
        textarea: variant === 'textarea' ? 'isTextArea' : 'notTextArea',
        loading: isLoading ? 'isLoading' : 'notLoading',
        withinGroup: hasGroupContext ? 'isWithinGroup' : undefined,
        inputGroupPosition,
        resize: resize ?? 'none'
    });
    // JET-73911: Temporarily use style classes directly instead of getting
    // startContent styles from theming.
    const readonlyTextFieldStartContentStyles = classNames([
        hasInsideLabel ? startContentInsideLabel : startContentStartTopLabel,
        isInsideNonReadonlyForm ? startContentMarginStart : startContentMarginEnd
    ]);
    const middleClasses = classNames([
        middleStyles,
        readonlyTextFieldMiddleBase,
        isInsideNonReadonlyForm && readonlyTextFieldMiddleInEnabledForm,
        isInsideNonReadonlyForm &&
            variant !== 'textarea' &&
            readonlyTextFieldMiddleInEnabledFormNotTextarea,
        !isInsideNonReadonlyForm && readonlyTextFieldMiddleNotInEnabledForm
    ]);
    const fieldRef = useRef(null);
    const ref = rootRef ?? fieldRef;
    const { tooltipContent, tooltipEventHandlerProps } = useTextFieldTooltip({
        hasTruncatedLabel,
        fieldRef: ref,
        isDisabled: !hasInsideLabel,
        label: labelText
    });
    return (jsxs("div", { role: "presentation", class: readonlyClassNames, ref: ref, ...tooltipEventHandlerProps, children: [startContent && (jsx("span", { class: readonlyTextFieldStartContentStyles, children: jsx(Flex, { justify: "center", align: "center", hasZeroMargins: true, children: startContent }) })), jsxs("div", { class: middleClasses, children: [insideLabel, mainContent] }), endContent && (jsx("span", { class: textFieldEndContent, children: jsx(Flex, { justify: "center", align: "center", hasZeroMargins: true, children: endContent }) })), tooltipContent] }));
};

const StartTopLabelReadonlyTextField = forwardRef(({ outerClassNames, columnSpan, label, labelEdge, labelStartWidth, compactUserAssistance, inlineUserAssistance, mainContent, endContent, rootRef, variant, resize, startContent, ...props }, ref) => {
    const parentComponentVariant = variant === 'textarea' ? 'textArea' : 'textField';
    return (jsxs("div", { ...props, ref: ref, class: outerClassNames, children: [compactUserAssistance, jsxs(LabelValueLayout, { columnSpan: columnSpan, label: label, labelEdge: labelEdge, labelStartWidth: labelStartWidth, parentComponentVariant: parentComponentVariant, children: [jsx(ReadonlyTextFieldContent, { mainContent: mainContent, endContent: endContent, rootRef: rootRef, startContent: startContent, ...(variant ? { variant, resize } : {}) }), inlineUserAssistance] })] }));
});
const InsideLabelReadonlyTextField = forwardRef(({ outerClassNames, compactUserAssistance, inlineUserAssistance, labelText, mainContent, endContent, label, rootRef, variant, resize, startContent, ...props }, ref) => {
    return (jsxs("div", { ...props, ref: ref, class: outerClassNames, children: [compactUserAssistance, jsx(ReadonlyTextFieldContent, { insideLabel: label, labelText: labelText, mainContent: mainContent, endContent: endContent, rootRef: rootRef, startContent: startContent, ...(variant ? { variant, resize } : {}) }), inlineUserAssistance] }));
});
const ReadonlyTextField = forwardRef(({ columnSpan = 1, label, labelEdge, labelText, mainContent, endContent, variant, mainFieldRef, startContent, testId, ...props }, ref) => {
    const testIdProps = useTestId(testId);
    const { classes, styles } = useComponentTheme(TextFieldRedwoodTheme, {
        readonly: 'isReadonly'
    });
    const { baseTheme: labelBaseTheme } = useComponentTheme(LabelRedwoodTheme);
    const { baseTheme: formLayoutTheme } = useComponentTheme(FormLayoutRedwoodTheme);
    const { formControlBase } = styles;
    // because TextField components reference Skeleton scoped vars, we need to bring in the Skeleton base theme
    // to pick up the scoped var definitions.
    const { baseTheme: skeletonBaseTheme } = useComponentTheme(SkeletonRedwoodTheme);
    const outerClassNames = classNames([
        classes,
        skeletonBaseTheme,
        formControlBase,
        formLayoutTheme,
        labelBaseTheme,
        layoutSpanStyles.layoutSpanColumn[columnSpan]
    ]);
    if (label !== undefined && (labelEdge === 'start' || labelEdge === 'top')) {
        return (jsx(StartTopLabelReadonlyTextField, { columnSpan: columnSpan, outerClassNames: outerClassNames, label: label, labelEdge: labelEdge, ref: ref, mainContent: mainContent, endContent: endContent, rootRef: mainFieldRef, startContent: startContent, variant: variant, ...props, ...testIdProps }));
    }
    return (jsx(InsideLabelReadonlyTextField, { outerClassNames: outerClassNames, ref: ref, label: label, labelText: labelText, mainContent: mainContent, endContent: endContent, rootRef: mainFieldRef, startContent: startContent, variant: variant, ...props, ...testIdProps }));
});

const StyledTextField = forwardRef(({ columnSpan = 1, variant = 'default', ...props }, ref) => {
    // because of the mismatch of height for inputs with inside labels and no labels,
    // we'll have to set everything to the same min-height while within an input group context.
    // Here we'll look to see if it's present and apply the style as needed
    const groupContext = useInputGroupContext();
    const { isReadonly } = useFormFieldContext();
    const { baseTheme: formLayoutTheme } = useComponentTheme(FormLayoutRedwoodTheme);
    const { baseTheme: labelBaseTheme } = useComponentTheme(LabelRedwoodTheme);
    const { classes: textFieldClasses, styles } = useComponentTheme(TextFieldRedwoodTheme, {
        readonly: isReadonly ? 'isReadonly' : 'notReadonly',
        withinGroup: groupContext !== null ? 'isWithinGroup' : undefined
    });
    const { formControlBase, textFieldBase, textFieldEmbedded } = styles;
    // because TextField components reference Skeleton scoped vars, we need to bring in the Skeleton base theme
    // to pick up the scoped var definitions.
    const { baseTheme: skeletonBaseTheme } = useComponentTheme(SkeletonRedwoodTheme);
    const classes = classNames([
        skeletonBaseTheme,
        formControlBase,
        textFieldBase,
        isEmbeddedVariant(variant) && textFieldEmbedded,
        textFieldClasses,
        formLayoutTheme,
        labelBaseTheme,
        layoutSpanStyles.layoutSpanColumn[columnSpan]
    ]);
    return jsx("div", { ...props, class: classes, ref: ref });
});

export { ReadonlyTextField as R, StyledTextField as S, TextFieldInput as T, useTextFieldTooltip as u };
//# sourceMappingURL=StyledTextField-9c60efac.js.map
