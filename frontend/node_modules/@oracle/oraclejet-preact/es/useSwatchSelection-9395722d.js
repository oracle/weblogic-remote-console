/* @oracle/oraclejet-preact: undefined */
import { useRef, useCallback } from 'preact/hooks';
import { c as containsKey, r as removeKey } from './keys-49c92dbb.js';
import { g as getIsSelectionPending } from './textSelectionUtils-a6554a42.js';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const handleSelect = (event, keyExtractor, selectedKeys, selectionBehavior, isSelectionRequired, onChange) => {
    const itemKey = keyExtractor(event.target);
    if (itemKey == null) {
        return;
    }
    const selected = containsKey(selectedKeys, itemKey);
    let keySet = selectedKeys;
    if (!selected) {
        // should only contains this item key
        keySet = { all: false, keys: new Set([itemKey]) };
    }
    else if (event.key !== 'Enter') {
        // no de-select for enter key
        if (selectionBehavior === 'toggle' ||
            event.ctrlKey ||
            event.metaKey ||
            event.key === ' ') {
            // de-select only when ctrl/meta key is pressed or selectionBehavior is
            // explicitly set to toggle
            keySet = removeKey(selectedKeys, itemKey, isSelectionRequired);
        }
    }
    // only invoke callback if there is really a change
    // note onSelectionChange should never be null here
    if (selectedKeys != keySet && onChange) {
        onChange({ value: keySet, target: event.target });
        if (event.type === 'click') {
            event.stopPropagation();
        }
    }
};
/**
 * Hook for handling various selection mode.  Customized for color swatch support.
 * @param keyExtractor function to extract the key based on provided element
 * @param selectedKeys the currently selected keys
 * @param isSelectionRequired true if empty selected key is not allowed, false otherwise
 * @param selectionBehavior the selection behavior.  If the value is 'toggle', then the key is
 *                          added/removed from the current selected keys.  If the value is 'replace',
 *                          then the current selected keys are cleared first before the key is added
 *                          unless the ctrl/shift/meta key is pressed.
 * @param onChange callback function that is invoked when selection has changed.
 * @returns an event map that the consumer can register as event listeners
 */
function useSwatchSelection(keyExtractor, selectedKeys, isSelectionRequired, selectionBehavior, onChange) {
    const isTouchPointerRef = useRef(false);
    const onClick = useCallback((event) => {
        if (!getIsSelectionPending()) {
            handleSelect(event, keyExtractor, selectedKeys, isTouchPointerRef.current ? 'toggle' : selectionBehavior, isSelectionRequired, onChange);
        }
    }, [keyExtractor, selectedKeys, isSelectionRequired, selectionBehavior, onChange]);
    // general keyboard events listen to keyUp for a11y
    const onKeyUp = useCallback((event) => {
        // older browser that we don't support returns 'Spacebar' for space key
        if (event.key === ' ' || event.key === 'Enter') {
            handleSelect(event, keyExtractor, selectedKeys, selectionBehavior, isSelectionRequired, onChange);
        }
    }, [keyExtractor, selectedKeys, selectionBehavior, isSelectionRequired, onChange]);
    const selectionProps = onChange == null ? {} : { onClick, onKeyUp };
    return { selectionProps };
}

export { useSwatchSelection as u };
//# sourceMappingURL=useSwatchSelection-9395722d.js.map
