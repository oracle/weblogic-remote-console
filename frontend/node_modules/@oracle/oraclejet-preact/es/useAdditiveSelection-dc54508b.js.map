{"version":3,"file":"useAdditiveSelection-dc54508b.js","sources":["../../src/hooks/PRIVATE_useSelection/useAdditiveSelection.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback, useRef } from 'preact/hooks';\nimport { Keys, containsKey, addKey, removeKey, addKeys, removeKeys } from '#utils/UNSAFE_keys';\nimport { getIsSelectionPending } from '#utils/PRIVATE_textSelectionUtils';\nimport { SelectionDetail, SelectionMode } from '#UNSAFE_Collection';\nimport { SelectionRangeDetail } from './Selection.types';\n\n/**\n * The hook for handling selection for collection ListView that is used as itemRenderer inside SelectSingle/SelectMultiple.\n *\n * @param keyExtractor function to extract the key based on provided element\n * @param selectedKeys the currently selected keys\n * @param selectionMode the selection mode\n * @param isSelectionRequired true if empty selected key is not allowed, false otherwise\n * @param getIndexByKey function to get the index based on the given key\n * @param getKeysByRange function to get the keys based on the given startIndex and endIndex\n * @param getPrevNextKey function to get the previous/next key in the vertical direction based on the current key\n * @param currentKey the current key\n * @param onChange callback function that is invoked when selection has changed.\n * @param onRangeChange callback function that is invoked when the selection range has changed.\n */\nexport function useAdditiveSelection<K>(\n  keyExtractor: (element: HTMLElement) => K | null,\n  selectedKeys: Keys<K>,\n  selectionMode: SelectionMode,\n  isSelectionRequired: boolean,\n  getIndexByKey: (key: K) => number,\n  getKeysByRange: (startIndex: number, endIndex: number) => K[],\n  getPrevNextKey: (currentKey: K | undefined, isPrev: boolean) => () => K | null,\n  currentKey?: K,\n  onChange?: (detail: SelectionDetail<K>) => void,\n  onRangeChange?: (detail: SelectionRangeDetail<K>) => void,\n  allowEnterKey = true\n) {\n  // the start key of the range selection\n  const anchorKey = useRef<K>();\n  // the previous end key of the range selection, i.e. the last key during shift+click/arrow keys\n  const cursorKey = useRef<K>();\n\n  // reset anchorKey and cursorKey when a new range happen (e.g. after arrow key, click on item/selector)\n  const setAdditiveSelectionACKey = (key: K | undefined) => {\n    anchorKey.current = key;\n    cursorKey.current = undefined;\n  };\n\n  const onClick = useCallback(\n    (event: MouseEvent) => {\n      if (getIsSelectionPending()) {\n        return;\n      }\n\n      const itemKey = keyExtractor(event.target as HTMLElement);\n      if (itemKey == null) {\n        return;\n      }\n\n      if (selectionMode === 'single') {\n        toggleSelection(event, selectedKeys, selectionMode, isSelectionRequired, itemKey, onChange);\n      } else if (selectionMode === 'multiple') {\n        // when anchorKey is undefined, i.e. shift+click is the first interaction, we should do toggle selection instead\n        if (!event.shiftKey || anchorKey.current === undefined) {\n          // reset anchorKey and cursorKey, a new range could happen after the click\n          setAdditiveSelectionACKey(itemKey);\n\n          toggleSelection(\n            event,\n            selectedKeys,\n            selectionMode,\n            isSelectionRequired,\n            itemKey,\n            onChange\n          );\n        } else {\n          const newCursorKey = rangeSelection(\n            event,\n            selectedKeys,\n            isSelectionRequired,\n            anchorKey.current,\n            cursorKey.current,\n            itemKey,\n            getIndexByKey,\n            getKeysByRange,\n            onChange,\n            onRangeChange\n          );\n\n          if (newCursorKey !== undefined) {\n            cursorKey.current = itemKey;\n          }\n        }\n      }\n    },\n    [\n      keyExtractor,\n      selectedKeys,\n      selectionMode,\n      isSelectionRequired,\n      getIndexByKey,\n      getKeysByRange,\n      onChange,\n      onRangeChange\n    ]\n  );\n\n  const onKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      // prevent default (propagation) for keyDown to space bar causing container to scroll\n      if (event.key === ' ') {\n        event.preventDefault();\n        return;\n      }\n\n      if (selectionMode === 'multiple') {\n        if (event.key !== 'ArrowUp' && event.key !== 'ArrowDown') {\n          return;\n        }\n\n        const itemKey = getPrevNextKey(currentKey, event.key === 'ArrowUp')();\n        if (itemKey == null) {\n          return;\n        }\n\n        if (!event.shiftKey) {\n          // reset anchorKey and cursorKey, a new range could happen after the arrow keys\n          setAdditiveSelectionACKey(itemKey);\n        } else {\n          // Avoid increasing range of selection text selection with arrow keys\n          event.preventDefault();\n\n          // when anchorKey is undefined, i.e. shift+arrow was the first interaction\n          if (anchorKey.current === undefined) {\n            anchorKey.current = currentKey;\n          }\n\n          const newCursorKey = rangeSelection(\n            event,\n            selectedKeys,\n            isSelectionRequired,\n            anchorKey.current,\n            cursorKey.current,\n            itemKey,\n            getIndexByKey,\n            getKeysByRange,\n            onChange,\n            onRangeChange\n          );\n\n          if (newCursorKey !== undefined) {\n            cursorKey.current = newCursorKey;\n          }\n        }\n      }\n    },\n    [\n      getPrevNextKey,\n      currentKey,\n      selectedKeys,\n      selectionMode,\n      isSelectionRequired,\n      getIndexByKey,\n      getKeysByRange,\n      onChange,\n      onRangeChange\n    ]\n  );\n\n  const onKeyUp = useCallback(\n    (event: KeyboardEvent) => {\n      if (event.key === ' ' || (allowEnterKey && event.key === 'Enter')) {\n        const itemKey = keyExtractor(event.target as HTMLElement);\n        if (itemKey == null) {\n          return;\n        }\n\n        toggleSelection(event, selectedKeys, selectionMode, isSelectionRequired, itemKey, onChange);\n      }\n    },\n    [keyExtractor, allowEnterKey, selectedKeys, selectionMode, isSelectionRequired, onChange]\n  );\n\n  const onPointerDown = useCallback(\n    (event: PointerEvent) => {\n      if (anchorKey.current !== undefined && event.shiftKey && selectionMode === 'multiple') {\n        // Avoid text selection during shift+click, unless when anchorKey is undefined, i.e. shift+click\n        // is the first interaction, which should do toggle selection and update currentKey during initial focus\n        event.preventDefault();\n      }\n    },\n    [selectionMode]\n  );\n\n  const additiveSelectionProps =\n    selectionMode === 'none' || onChange == null\n      ? {}\n      : { onClick, onKeyDown, onKeyUp, onPointerDown };\n  return {\n    eventProps: additiveSelectionProps,\n    setAdditiveSelectionACKey\n  };\n}\n\n/**\n * The helper function for range selection\n */\nconst rangeSelection = <K>(\n  event: MouseEvent | KeyboardEvent,\n  selectedKeys: Keys<K>,\n  isSelectionRequired: boolean,\n  anchorKey: K | undefined,\n  cursorKey: K | undefined,\n  itemKey: K,\n  getIndexByKey: (key: K) => number,\n  getKeysByRange: (startIndex: number, endIndex: number) => K[],\n  onChange?: (detail: SelectionDetail<K>) => void,\n  onRangeChange?: (detail: SelectionRangeDetail<K>) => void\n) => {\n  if (anchorKey !== undefined) {\n    if (cursorKey !== undefined && cursorKey !== itemKey) {\n      let keySet = selectedKeys;\n\n      const startIndex = getIndexByKey(anchorKey);\n      const endIndex = getIndexByKey(itemKey);\n      const previousEndIndex = getIndexByKey(cursorKey);\n      if (startIndex === -1 || endIndex === -1 || previousEndIndex === -1) {\n        return undefined;\n      }\n\n      const minIndex = Math.min(startIndex, endIndex);\n      const maxIndex = Math.max(startIndex, endIndex);\n\n      // add keys that are within the range\n      const keys = getKeysByRange(minIndex, maxIndex + 1);\n      keySet = addKeys(keySet, keys);\n\n      // only remove keys when previousEndIndex is out of range\n      if (previousEndIndex < minIndex || previousEndIndex > maxIndex) {\n        const keys =\n          previousEndIndex < minIndex\n            ? getKeysByRange(previousEndIndex, minIndex)\n            : getKeysByRange(maxIndex + 1, previousEndIndex + 1);\n        keySet = removeKeys(keySet, keys, isSelectionRequired);\n      }\n\n      if (selectedKeys != keySet && onChange) {\n        onChange({ value: keySet, target: event.target });\n        if (event.type === 'click') {\n          event.stopPropagation();\n        }\n      }\n    } else {\n      // if no cursorKey was set, meaning the previous interaction was not shift+click/arrow,\n      // we can do range selection directly\n      onRangeChange?.({\n        value: { start: anchorKey, end: itemKey },\n        eventType: event.type === 'click' ? 'shiftClick' : 'shiftArrowKeys'\n      });\n    }\n    return itemKey;\n  }\n\n  return undefined;\n};\n\nconst toggleSelection = <K>(\n  event: MouseEvent | KeyboardEvent,\n  selectedKeys: Keys<K>,\n  selectionMode: SelectionMode,\n  isSelectionRequired: boolean,\n  itemKey: K,\n  onChange?: (detail: SelectionDetail<K>) => void\n) => {\n  let keySet = selectedKeys;\n  const selected = containsKey(keySet, itemKey);\n  if (!selected) {\n    if (selectionMode === 'single') {\n      keySet = { all: false, keys: new Set([itemKey]) };\n    } else {\n      keySet = addKey(keySet, itemKey);\n    }\n  } else {\n    keySet = removeKey(keySet, itemKey, isSelectionRequired);\n  }\n\n  if (selectedKeys != keySet && onChange) {\n    onChange({ value: keySet, target: event.target });\n    if (event.type === 'click') {\n      event.stopPropagation();\n    }\n  }\n};\n"],"names":[],"mappings":"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"}