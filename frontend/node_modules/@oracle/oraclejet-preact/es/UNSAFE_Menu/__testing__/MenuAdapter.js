/* @oracle/oraclejet-preact: undefined */
import { TestAdapter } from '@oracle/oraclejet-testing/UNSAFE_TestAdapter';
import { waitFor } from '@oracle/oraclejet-testing/UNSAFE_Driver';
import { byCss } from '@oracle/oraclejet-testing/UNSAFE_Locators';

class MenuAdapter extends TestAdapter {
    /**
     * Click a MenuItem based on a label/key path
     * @param path Path that consist of the label/key of the menu item and the label/key of the submenu that leads to the menu item.
     * @returns Promise<void>
     */
    async doMenuAction(path) {
        return this._doMenuActionClick(path);
    }
    /**
     * Click a SelectMenuItem on a menu group based on a label/key path
     * @param path Path that consist of the label/key of the menu item and the label/key of the submenu that leads to the menu item. If key is specified it also include item value of the select menu item that is going to be clicked.
     * @returns Promise<void>
     */
    async doMenuGroupAction(path) {
        return this._doMenuActionClick(path);
    }
    /**
     * doMenuActionClick - Coordinates clicking of menu item based on path type.
     */
    async _doMenuActionClick(path) {
        const pathIdentifier = path.label ? 'label' : 'key';
        const specificPath = path[pathIdentifier];
        // We convert path into an array so we handle it in one way for strings and arrays
        const arraySpecificPath = Array.isArray(specificPath) ? specificPath : [specificPath];
        for (const [index, identifier] of Object.entries(arraySpecificPath)) {
            const indexNumber = Number(index);
            // We verify if there are no menu skeletons
            await waitFor(async () => {
                const menu = await this.getElement();
                return !(await menu.waitForElements(byCss(`[oj-menu-skeleton]`))).length;
            });
            const menuSearchElement = (await this._getMenuElements())[indexNumber];
            if (path.itemValue && indexNumber === arraySpecificPath.length - 1) {
                await this._clickSelectMenuItemByKey(identifier, menuSearchElement, path.itemValue);
            }
            else {
                await this._clickActionMenuItem({ [pathIdentifier]: identifier }, menuSearchElement);
            }
        }
    }
    /**
     * getMenuElements - Returns list of menus available based on the locator of the "main menu".
     */
    async _getMenuElements() {
        const el = await this.getElement();
        const testId = await el.getAttribute('data-testid');
        return this.getTestDriver().waitForElements(byCss(`[data-oj-layer]:has([data-testid=${testId}]) [role=menu]`));
    }
    /**
     * clickActionMenuItem - Click menu item by label or key
     */
    async _clickActionMenuItem(path, searchElement) {
        const pathType = path.label ? 'label' : 'key';
        return this._clickingMenuItem(`a[data-oj-${pathType}=${JSON.stringify(path[pathType])}]`, searchElement, `The ${pathType} ${path[pathType]} is invalid or does not exist`);
    }
    /**
     * clickSelectMenuItemByKey - Click a select menu item by group key and value inside an specific menu container. It includes clicking on SelectMenuItem
     */
    async _clickSelectMenuItemByKey(groupKey, searchElement, itemValue) {
        return this._clickingMenuItem(`a[data-oj-key=${groupKey}-${itemValue}]`, searchElement, `The group key ${groupKey} or itemValue ${itemValue} is invalid or does not exist`);
    }
    /**
     * clickingMenuItem - Click menu item based on a query. It also handle errors.
     */
    async _clickingMenuItem(query, searchElement, errMessage) {
        try {
            const item = await searchElement.waitForElement(byCss(query));
            return this.getTestDriver().click(item);
        }
        catch {
            throw new Error(errMessage);
        }
    }
}

export { MenuAdapter };
//# sourceMappingURL=MenuAdapter.js.map
