/* @oracle/oraclejet-preact: undefined */
import { useState, useLayoutEffect } from 'preact/hooks';
import { u as useColorScheme } from './useColorScheme-96cce6a1.js';
import { u as useScale } from './useScale-0ebe15ed.js';
import { t as themeInterpolations } from './theme-63551f30.js';
import { m as mergeInterpolations } from './mergeInterpolations-30cd9a69.js';
import { D as DefaultEnvironment } from './LayerHost-12489cef.js';
import { I as INVERT_CLASS, D as DARK_CLASS } from './Theme-e6dec6db.js';
import { u as useDensity } from './useDensity-d06ae84a.js';
import { U as UNSAFE_DOM_ACCESS } from './unsafeDomAccess-453eb74e.js';

/**
 * Extracts and returns an element from an element-based ref
 *
 * @returns the element or null if no element can be extracted
 */
function toUnsafeDomElement(elementRef) {
    const current = elementRef?.current;
    if (current) {
        return current instanceof Element ? current : current[UNSAFE_DOM_ACCESS];
    }
    return null;
}

// This hook encapsulates the logic required to determine which theme style classes are needed
// for the current environment context's colorScheme, density, and scale value.  This would be used when
// rendering dom outside of the current dom tree, but desire to match the colorScheme, density, and scale
// of the original dom tree.
function useThemeInterpolations(logicalParentRef) {
    const [colorScheme, setColorScheme] = useState(undefined);
    const currentColorScheme = useColorScheme();
    const currentDensity = useDensity();
    const currentScale = useScale();
    // We don't want to interpolate the default environment values for scale or density. Those should get picked up by default.
    // This fixes an issue for core pack components that utilize the Layer component, when in a legacy cookbook page.
    const density = currentDensity !== DefaultEnvironment.density ? currentDensity : undefined;
    const scale = currentScale !== DefaultEnvironment.scale ? currentScale : undefined;
    // We want to use useLayoutEffect instead of useEffect here. Otherwise there could be
    // flashing due to light colorScheme initial render then dark colorScheme after useEffect.
    useLayoutEffect(() => {
        // for colorScheme in Legacy, things are a bit more complicated because unlike scale which is always applied to
        // the root dom element, we can switch to dark theme by adding the .oj-color-invert class to any dom element where
        // we want the dark theme to start.  In Legacy, you can't switch back to light theme once you switch to dark (no nesting).
        // The problem with our core pack Components that use Layer to display the dropdown, it is not in the same dom
        // tree as the parent component.  It is in its own dom tree off of the root dom element, so it won't see the
        // .oj-color-invert class in the dom tree of the select single.
        // Since in legacy .oj-color-invert can appear anywhere, not just on the root dom element, if the colorScheme
        // is the same as the default colorScheme then we need to look at the ref to determine if it or any of its
        // ancestors has the .oj-color-invert class.  If it does(and doesn't have the preact .oj-c-colorscheme-dark class),
        // use 'dark' colorScheme.
        // We only want to do this for legacy, so if the closest element that has the .oj-color-invert also has .oj-c-colorscheme-dark,
        // then we don't want to override since this isn't a legacy color change and we already handle it in our environment context
        // so the color scheme nesting will work in Preact/Core Pack.
        const logicalParent = toUnsafeDomElement(logicalParentRef);
        const closestElementWithColorInvertClass = logicalParent?.closest(`.${INVERT_CLASS}:not(.${DARK_CLASS})`);
        setColorScheme(currentColorScheme !== DefaultEnvironment.colorScheme
            ? currentColorScheme
            : closestElementWithColorInvertClass
                ? 'dark'
                : undefined);
    }, [logicalParentRef, currentColorScheme]);
    const interpolations = mergeInterpolations([...Object.values(themeInterpolations)]);
    const { class: classes } = interpolations({ colorScheme, scale, density });
    return classes;
}

export { toUnsafeDomElement as t, useThemeInterpolations as u };
//# sourceMappingURL=useThemeInterpolations-4b48d878.js.map
