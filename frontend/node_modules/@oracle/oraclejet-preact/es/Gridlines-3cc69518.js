/* @oracle/oraclejet-preact: undefined */
import { jsx, Fragment, jsxs } from 'preact/jsx-runtime';
import { styles } from './PRIVATE_PlotArea/themes/PlotAreaStyles.css.js';
import { styles as styles$1 } from './hooks/PRIVATE_useVisDnd/themes/VisDndStyles.css.js';
import { c as classNames } from './classNames-4e12b00d.js';
import { u as useColorScheme } from './useColorScheme-96cce6a1.js';

function PlotArea({ color, availSpace, cursor, dragOverStyle }) {
    const dragClass = [];
    switch (dragOverStyle) {
        case 'accept':
            dragClass.push(styles$1.dndDragOverSvgStyle);
            break;
        case 'reject':
            dragClass.push(styles$1.dndRejectedStyle);
            dragClass.push(styles.plotAreaStyle);
            break;
        case 'none':
            dragClass.push(styles.plotAreaStyle);
            break;
    }
    return (jsx(Fragment, { children: jsx("rect", { ...availSpace, className: classNames(dragClass), style: { fill: dragOverStyle === 'accept' ? undefined : color, cursor } }) }));
}

function getXAxisLineProps(availSpace, axisPosition, axisLine) {
    return {
        x1: axisPosition === 'right' ? availSpace.x + availSpace.width : availSpace.x,
        x2: axisPosition === 'left' ? availSpace.x : availSpace.x + availSpace.width,
        y1: axisPosition === 'bottom' ? availSpace.y + availSpace.height : availSpace.y,
        y2: axisPosition === 'top' ? availSpace.y : availSpace.y + availSpace.height,
        stroke: axisLine?.lineColor,
        strokeWidth: axisLine?.lineWidth
    };
}
function getYAxisLineProps(availSpace, axisPosition, isRtl, axisLine) {
    let x1, x2, y1, y2;
    if (axisPosition === 'bottom') {
        x1 = isRtl ? availSpace.x + availSpace.width : availSpace.x;
        x2 = isRtl ? availSpace.x + availSpace.width : availSpace.x;
        y1 = availSpace.y;
        y2 = availSpace.y + availSpace.height;
    }
    else {
        x1 = availSpace.x;
        x2 = availSpace.x + availSpace.width;
        y1 = isRtl ? availSpace.y : availSpace.y + availSpace.height;
        y2 = isRtl ? availSpace.y : availSpace.y + availSpace.height;
    }
    return {
        x1,
        x2,
        y1,
        y2,
        stroke: axisLine?.lineColor,
        strokeWidth: axisLine?.lineWidth
    };
}
function getY2AxisLineProps(availSpace, axisPosition, isRtl, axisLine) {
    let x1, x2, y1, y2;
    if (axisPosition === 'bottom') {
        x1 = isRtl ? availSpace.x : availSpace.x + availSpace.width;
        x2 = isRtl ? availSpace.x : availSpace.x + availSpace.width;
        y1 = availSpace.y;
        y2 = availSpace.y + availSpace.height;
    }
    else {
        x1 = availSpace.x;
        x2 = availSpace.x + availSpace.width;
        y1 = isRtl ? availSpace.y + availSpace.height : availSpace.y;
        y2 = isRtl ? availSpace.y + availSpace.height : availSpace.y;
    }
    return {
        x1,
        x2,
        y1,
        y2,
        stroke: axisLine?.lineColor,
        strokeWidth: axisLine?.lineWidth
    };
}
function getBaseLineCoords(isHoriz, coord, range1, range2, isYAxis) {
    let x1, x2, y1, y2;
    if (isHoriz) {
        if (isYAxis) {
            x1 = coord;
            x2 = coord;
            y1 = range1;
            y2 = range2;
        }
        else {
            x1 = range1;
            x2 = range2;
            y1 = coord;
            y2 = coord;
        }
    }
    else {
        if (isYAxis) {
            x1 = range1;
            x2 = range2;
            y1 = coord;
            y2 = coord;
        }
        else {
            x1 = coord;
            x2 = coord;
            y1 = range1;
            y2 = range2;
        }
    }
    return { x1, x2, y1, y2 };
}

const TICK_DEFAULT = {
    yMajorTick: {
        isRendered: true
    },
    y2MajorTick: {
        isRendered: false
    },
    yMinorTick: {
        isRendered: false
    },
    y2MinorTick: {
        isRendered: false
    },
    xMajorTick: {
        isRendered: false
    },
    xMinorTick: {
        isRendered: false
    }
};
function Gridlines({ plotArea, yMinorTicks, xMinorTicks, xScale, yScale, y2Scale, isLog, yTicks, y2Ticks, xTicks, yAxisPosition, isDataXAxis, xAxis, yAxis, y2Axis, availSpace, xAxisPosition, isRtl, hasAxisLine, y2MinorTicks, isSplitDualY }) {
    const isHoriz = yAxisPosition === 'top' || yAxisPosition === 'bottom';
    const hasY2 = !!y2Axis?.isRendered;
    const [x1, x2] = xScale.range();
    const [y1, y2] = hasY2 ? y2Scale.range() : yScale.range();
    const xAxisBaselineStyle = {
        stroke: isDataXAxis ? plotArea?.xMajorTick?.baselineColor : plotArea?.xMajorTick?.lineColor,
        strokeWidth: isDataXAxis ? plotArea?.xMajorTick?.baselineWidth : plotArea?.xMajorTick?.lineWidth
    };
    const yAxisBaselineStyle = {
        stroke: plotArea?.yMajorTick?.baselineColor,
        strokeWidth: plotArea?.yMajorTick?.baselineWidth
    };
    const y2AxisBaselineStyle = {
        stroke: plotArea?.y2MajorTick?.baselineColor,
        strokeWidth: plotArea?.y2MajorTick?.baselineWidth
    };
    let yLinesPath = '';
    let y2LinesPath = '';
    let xLinesPath = '';
    let yMinorPath = '';
    let xMinorPath = '';
    let y2MinorPath = '';
    const yMajorTick = { ...TICK_DEFAULT.yMajorTick, ...plotArea?.yMajorTick };
    const yMinorTick = { ...TICK_DEFAULT.yMinorTick, ...plotArea?.yMinorTick };
    const y2MinorTick = { ...TICK_DEFAULT.y2MinorTick, ...plotArea?.y2MinorTick };
    const xMinorTick = { ...TICK_DEFAULT.xMinorTick, ...plotArea?.xMinorTick };
    const xMajorTick = { ...TICK_DEFAULT.xMajorTick, ...plotArea?.xMajorTick };
    const y2MajorTick = {
        ...TICK_DEFAULT.y2MajorTick,
        isRendered: isSplitDualY,
        ...plotArea?.y2MajorTick
    };
    const isYMinorRendered = yMinorTick?.isRendered === true || isLog;
    const isY2MinorRendered = y2MinorTick?.isRendered === true || isLog;
    const isXMajorRendered = xMajorTick?.isRendered === true || (plotArea?.xMajorTick?.isRendered === false && isDataXAxis);
    const xAxisLineProps = getXAxisLineProps(availSpace, xAxisPosition);
    const xAxisLineStyle = {
        stroke: plotArea?.xAxisLine?.lineColor,
        strokeWidth: plotArea?.xAxisLine?.lineWidth
    };
    const yAxisLineStyle = {
        stroke: plotArea?.yAxisLine?.lineColor,
        strokeWidth: plotArea?.yAxisLine?.lineWidth
    };
    const y2AxisLineStyle = {
        stroke: plotArea?.y2AxisLine?.lineColor,
        strokeWidth: plotArea?.y2AxisLine?.lineWidth
    };
    const yBaseLine = yAxis?.scale === 'log' ? yTicks[0] : 0;
    const yBaseLineCoords = getBaseLineCoords(isHoriz, yScale.transform(yBaseLine), x1, x2, true);
    const y2BaseLine = y2Axis?.scale === 'log' ? y2Ticks[0] : 0;
    const y2BaseLineCoords = getBaseLineCoords(isHoriz, y2Scale.transform(y2BaseLine), x1, x2, true);
    const xBaseLine = xAxis?.scale === 'log' ? xTicks[0] : 0;
    const xBaseLineCoords = getBaseLineCoords(isHoriz, xScale.transform(xBaseLine), y1, y2, false);
    if (yMajorTick?.isRendered) {
        for (let i = 0; i < yTicks.length; i++) {
            if (yTicks[i] === 0) {
                // zero is skipped for majorTick. baseline is rendered at 0
                continue;
            }
            let y = yScale.transform(yTicks[i]);
            // last grid line get's clipped due to plot area clippath. Slightly adjust
            // coord so that it's not clipped.
            if (i === yTicks.length - 1) {
                y += isHoriz ? -1 : 1;
            }
            yLinesPath += isHoriz ? `M${y},${x1}L${y},${x2}` : `M${x1},${y}L${x2},${y}`;
        }
    }
    if (y2MajorTick?.isRendered) {
        for (let i = 0; i < y2Ticks.length; i++) {
            if (yTicks[i] === 0) {
                // zero is skipped for majorTick. baseline is rendered at 0
                continue;
            }
            let y = y2Scale.transform(y2Ticks[i]);
            // last grid line get's clipped due to plot area clippath. Slightly adjust
            // coord so that it's not clipped.
            if (i === y2Ticks.length - 1) {
                y += isHoriz ? -1 : 1;
            }
            y2LinesPath += isHoriz ? `M${y},${x1}L${y},${x2}` : `M${x1},${y}L${x2},${y}`;
        }
    }
    if (isXMajorRendered) {
        if (xTicks) {
            for (let i = 0; i < xTicks.length; i++) {
                const x = xScale.transform(xTicks[i]);
                xLinesPath += isHoriz ? `M${y1},${x}L${y2},${x}` : `M${x},${y1}L${x},${y2}`;
            }
        }
    }
    if (isYMinorRendered || isY2MinorRendered) {
        for (let i = 0; i < yMinorTicks.length; i++) {
            const y = yScale.transform(yMinorTicks[i]);
            yMinorPath += isHoriz ? `M${y},${x1}L${y},${x2}` : `M${x1},${y}L${x2},${y}`;
        }
    }
    if (isY2MinorRendered) {
        for (let i = 0; i < y2MinorTicks.length; i++) {
            const y = y2Scale.transform(y2MinorTicks[i]);
            y2MinorPath += isHoriz ? `M${y},${x1}L${y},${x2}` : `M${x1},${y}L${x2},${y}`;
        }
    }
    if (xMinorTick.isRendered && xMinorTicks) {
        for (let i = 0; i < xMinorTicks.length; i++) {
            const x = xScale.transform(xMinorTicks[i]);
            xMinorPath += isHoriz ? `M${y1},${x}L${y2},${x}` : `M${x},${y1}L${x},${y2}`;
        }
    }
    const colorScheme = useColorScheme();
    let splitCoords = undefined;
    if (isSplitDualY) {
        const ySplitCoord = !isHoriz ? yTicks[0] : yTicks[yTicks.length - 1];
        const y2SplitCoord = !isHoriz ? y2Ticks[y2Ticks.length - 1] : y2Ticks[0];
        const splitCoord = (yScale.transform(ySplitCoord) + y2Scale.transform(y2SplitCoord)) / 2;
        splitCoords = getBaseLineCoords(isHoriz, splitCoord + (isHoriz ? -1 : 1) * 0.5, x1, x2, true);
    }
    /*
    Render order:
    1. Gridlines: y and y2 are same because of aligned ticks.
        a. majorTick: y -> x
        b. minorTick y -> x
    2. Axislines → Baselines, with each in the order: y2 → y → x
  */
    return (jsxs(Fragment, { children: [yMajorTick?.isRendered && (jsx("path", { d: yLinesPath, className: classNames([
                    styles.noPointerEvents,
                    styles.majorTickLineStyles,
                    yMajorTick?.lineStyle === 'dashed' ? styles.dashedLine : undefined,
                    yMajorTick?.lineStyle === 'dotted' ? styles.dottedLine : undefined
                ]), style: {
                    stroke: hasY2 ? y2MajorTick.lineColor : yMajorTick.lineColor,
                    strokeWidth: hasY2 ? y2MajorTick.lineWidth : yMajorTick.lineWidth
                } })), y2MajorTick?.isRendered && (jsx("path", { d: y2LinesPath, className: classNames([
                    styles.noPointerEvents,
                    styles.majorTickLineStyles,
                    y2MajorTick?.lineStyle === 'dashed' ? styles.dashedLine : undefined,
                    y2MajorTick?.lineStyle === 'dotted' ? styles.dottedLine : undefined
                ]), style: {
                    stroke: y2MajorTick.lineColor,
                    strokeWidth: y2MajorTick.lineWidth
                } })), isXMajorRendered && (jsx("path", { d: xLinesPath, className: classNames([
                    styles.noPointerEvents,
                    styles.majorTickLineStyles,
                    xMajorTick?.lineStyle === 'dashed' ? styles.dashedLine : undefined,
                    xMajorTick?.lineStyle === 'dotted' ? styles.dottedLine : undefined
                ]), style: {
                    stroke: xMajorTick.lineColor,
                    strokeWidth: xMajorTick.lineWidth
                } })), isYMinorRendered && (jsx("path", { d: yMinorPath, className: classNames([
                    styles.noPointerEvents,
                    styles.minorTickLineStyles,
                    colorScheme === 'light'
                        ? styles.lightMinorTickLineStroke
                        : styles.darkMinorTickLineStroke,
                    yMinorTick?.lineStyle === 'dashed' ? styles.dashedLine : undefined,
                    yMinorTick?.lineStyle === 'dotted' ? styles.dottedLine : undefined
                ]), style: {
                    stroke: hasY2 ? y2MinorTick.lineColor : yMinorTick?.lineColor,
                    strokeWidth: hasY2 ? y2MinorTick.lineWidth : yMinorTick?.lineWidth
                } })), isY2MinorRendered && (jsx("path", { d: y2MinorPath, className: classNames([
                    styles.noPointerEvents,
                    styles.minorTickLineStyles,
                    colorScheme === 'light'
                        ? styles.lightMinorTickLineStroke
                        : styles.darkMinorTickLineStroke,
                    y2MinorTick?.lineStyle === 'dashed' ? styles.dashedLine : undefined,
                    y2MinorTick?.lineStyle === 'dotted' ? styles.dottedLine : undefined
                ]), style: {
                    stroke: y2MinorTick?.lineColor,
                    strokeWidth: y2MinorTick?.lineWidth
                } })), xMinorTick.isRendered && (jsx("path", { d: xMinorPath, className: classNames([
                    styles.noPointerEvents,
                    styles.minorTickLineStyles,
                    colorScheme === 'light'
                        ? styles.lightMinorTickLineStroke
                        : styles.darkMinorTickLineStroke,
                    xMinorTick?.lineStyle === 'dashed' ? styles.dashedLine : undefined,
                    xMinorTick?.lineStyle === 'dotted' ? styles.dottedLine : undefined
                ]), style: {
                    stroke: xMinorTick?.lineColor,
                    strokeWidth: xMinorTick?.lineWidth
                } })), ((isDataXAxis && plotArea?.y2AxisLine?.isRendered !== false) ||
                plotArea?.y2AxisLine?.isRendered) && (jsx("line", { ...getY2AxisLineProps(availSpace, xAxisPosition, isRtl), class: styles.axisLineStyle, style: y2AxisLineStyle })), ((isDataXAxis && plotArea?.yAxisLine?.isRendered !== false) ||
                plotArea?.yAxisLine?.isRendered) && (jsx("line", { ...getYAxisLineProps(availSpace, xAxisPosition, isRtl), class: styles.axisLineStyle, style: yAxisLineStyle })), hasAxisLine && plotArea?.xAxisLine?.isRendered !== false && (jsx("line", { ...xAxisLineProps, class: styles.axisLineStyle, style: xAxisLineStyle })), y2MajorTick?.isRendered && (jsx("line", { ...y2BaseLineCoords, class: styles.axisLineStyle, style: y2AxisBaselineStyle })), yMajorTick?.isRendered && (jsx("line", { ...yBaseLineCoords, class: styles.axisLineStyle, style: yAxisBaselineStyle })), xMajorTick?.isRendered && (jsx("line", { ...xBaseLineCoords, class: styles.axisLineStyle, style: xAxisBaselineStyle })), isSplitDualY && splitCoords ? (jsx("line", { ...splitCoords, class: styles.axisLineStyle, style: yAxisBaselineStyle })) : null] }));
}

export { Gridlines as G, PlotArea as P };
//# sourceMappingURL=Gridlines-3cc69518.js.map
