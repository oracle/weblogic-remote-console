/* @oracle/oraclejet-preact: undefined */
/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Returns true if the key is contains in keys, false otherwise
 */
const containsKey = (keys, key) => {
    if (keys == null) {
        return false;
    }
    if (!keys.all) {
        return keys.keys.has(key);
    }
    return !keys.deletedKeys.has(key);
};
/**
 * Returns a new Keys that includes the specified key.
 * If the key is already in keys, then just return keys.
 */
const addKey = (keys, key) => {
    return addKeys(keys, [key]);
};
/**
 * Returns a new Keys that includes all the specified keys.
 * @param keys the base Keys<K>
 * @param addKeys an array of keys that we we want to include
 */
const addKeys = (keys, addKeys) => {
    if (keys.all) {
        const deletedKeys = keys.deletedKeys;
        if (deletedKeys.size === 0) {
            return keys;
        }
        const keySet = new Set(deletedKeys.values());
        addKeys.forEach((key) => {
            if (deletedKeys.has(key)) {
                keySet.delete(key);
            }
        });
        keys = { all: true, deletedKeys: keySet };
    }
    else {
        const currentKeys = keys.keys;
        const keySet = new Set(currentKeys.values());
        addKeys.forEach((key) => {
            if (!currentKeys.has(key)) {
                keySet.add(key);
            }
        });
        keys = { all: false, keys: keySet };
    }
    return keys;
};
/**
 * Returns a new Keys that excludes the specified key.
 * If the key is already in keys, then just return keys.
 * disallowEmpty if set to true, will ensure that the returning keys will not be empty.
 */
const removeKey = (keys, key, disallowEmpty) => {
    return removeKeys(keys, [key], disallowEmpty);
};
/**
 * Returns a new Keys that excludes all the specified keys.
 * @param keys the base Keys<K>
 * @param removeKeys an array of keys that we we want to exclude
 * @param disallowEmpty if set to true, will ensure that the returning keys will not be empty
 */
const removeKeys = (keys, removeKeys, disallowEmpty) => {
    if (keys.all) {
        const deletedKeys = keys.deletedKeys;
        const keySet = new Set(deletedKeys.values());
        removeKeys.forEach((key) => {
            if (!deletedKeys.has(key)) {
                keySet.add(key);
            }
        });
        keys = { all: true, deletedKeys: keySet };
    }
    else {
        const currentKeys = keys.keys;
        const keySet = new Set(currentKeys.values());
        removeKeys.forEach((key) => {
            if (currentKeys.has(key) && (!disallowEmpty || keySet.size > 1)) {
                keySet.delete(key);
            }
        });
        keys = { all: false, keys: keySet };
    }
    return keys;
};
/**
 * Helper function for checking for an undefined key
 * Keys can be null or undefined when not set, but falsey check is not appropriate for this as 0 is a legitimate key
 */
const isKeyDefined = (key) => key !== undefined && key !== null;
/**
 * Compares two Keys and return true if the keys inside each are the same including
 * having the same order.
 */
const isSameKey = (key1, key2) => {
    if (key1 == null || key2 == null) {
        return key1 == key2;
    }
    if (key1.all !== key2.all) {
        return false;
    }
    const arr1 = Array.from(key1.all ? key1.deletedKeys.values() : key1.keys.values());
    const arr2 = Array.from(key2.all ? key2.deletedKeys.values() : key2.keys.values());
    if (arr1.length !== arr2.length) {
        return false;
    }
    for (let i = 0; i < arr1.length; i++) {
        if (arr1[i] !== arr2[i]) {
            return false;
        }
    }
    return true;
};

export { addKey as a, addKeys as b, containsKey as c, removeKeys as d, isSameKey as e, isKeyDefined as i, removeKey as r };
//# sourceMappingURL=keys-49c92dbb.js.map
