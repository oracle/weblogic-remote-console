/* @oracle/oraclejet-preact: undefined */
import { jsx, jsxs, Fragment } from 'preact/jsx-runtime';
import { useRef, useState, useCallback, useMemo, useEffect, useLayoutEffect } from 'preact/hooks';
import { F as Floating } from './Floating-6023b41d.js';
import { g as getActiveElement, f as focusWithin, b as focusOn } from './tabbableUtils-ce19b388.js';
import { m as mergeRefs } from './refUtils-76275c69.js';
import { F as FocusTrap } from './FocusTrap-9f37aa41.js';
import { L as Layer } from './Layer-7d3dc8c7.js';
import { forwardRef } from 'preact/compat';
import './LayerHost-12489cef.js';
import { M as Modal } from './Modal-678575d5.js';
import { W as WindowOverlay } from './WindowOverlay-b380ce51.js';
import { u as usePopupAnimation } from './usePopupAnimation-66b186ad.js';
import { u as useTestId } from './useTestId-e5d44ab1.js';
import { u as useOutsideClick } from './useOutsideClick-73a51e1d.js';
import { g as getClientHints } from './clientHints-a42b510c.js';
import { L as LiveRegion } from './LiveRegion-79ffc814.js';
import { H as HiddenAccessible } from './HiddenAccessible-61197e7c.js';
import { u as useTranslationBundle } from './useTranslationBundle-25469f1c.js';
import { u as useComponentTheme } from './useComponentTheme-d2f9e47f.js';
import { popupVars } from './UNSAFE_Popup/themes/PopupContract.css.js';
import { g } from './stringUtils-0fe25200.js';
import { c as classNames } from './classNames-4e12b00d.js';
import { PopupRedwoodTheme } from './UNSAFE_Popup/themes/redwood/PopupTheme.js';
import { d as dimensionInterpolations } from './dimensions-ddde0eee.js';
import { c as colorInterpolations } from './colors-b6530fec.js';
import { m as mergeInterpolations } from './mergeInterpolations-30cd9a69.js';
import { U as UNSAFE_DOM_ACCESS } from './unsafeDomAccess-453eb74e.js';

function PopupSkipLink({ message, callback }) {
    const hiddenAccessibleRef = useRef(null);
    const handleKey = (event) => {
        // Prevent click generated from an "enter" key press by eating the event.
        // This could only happen in some kind of simulator as this skip link is only used on the iOS platform.
        if (event.code === 'Enter') {
            event.stopPropagation();
            event.preventDefault();
        }
    };
    return (jsx("div", { ref: hiddenAccessibleRef, children: jsx(HiddenAccessible, { children: jsx("a", { onClick: callback, tabIndex: -1, href: "#", role: "button", onKeyDown: handleKey, onKeyUp: handleKey, onKeyPress: handleKey, children: message }) }) }));
}

/**
 * A popup temporarily 'pops up' content in the foreground.
 */
const Popup = forwardRef(({ anchorRef, launcherRef, children, isOpen = false, modality = 'modeless', offset = { mainAxis: 0, crossAxis: 0 }, flipOptions = { mainAxis: true, crossAxis: true }, shiftOptions = { mainAxis: false, crossAxis: false }, onClickOutside, onClose, initialFocus = 'auto', placement = anchorRef ? 'top' : 'center', tail = 'none', onTransitionEnd, onFocusSet, variant = 'standard', role = 'dialog', 'aria-label': ariaLabel, 'aria-labelledby': ariaLabelledBy, 'aria-describedby': ariaDescribedBy, testId, ...props }, ref) => {
    const localLauncherRef = useRef(null);
    const [popupBgColor, setPopupBgColor] = useState();
    const contentWrapperRef = useRef(null);
    const prevStatusRef = useRef('unmounted');
    // testId support
    const testIdProps = useTestId(testId);
    const insideRefs = [contentWrapperRef];
    // launcher should be considered an "inside" element
    if (localLauncherRef.current && localLauncherRef.current !== document.body) {
        insideRefs.push(localLauncherRef);
    }
    const translations = useTranslationBundle('@oracle/oraclejet-preact');
    const isModal = useCallback(() => {
        return modality === 'modal';
    }, [modality]);
    // We can not merge outsideClick to onClose event with {reason: 'outsideClick'} payload
    // The reason is that we allow outsideClick/autodismiss in modeless mode and
    // we need to detect outsideClick which is
    useOutsideClick({
        isDisabled: !(isOpen && contentWrapperRef.current),
        ref: insideRefs,
        handler: (event) => {
            onClickOutside?.(event);
        }
    });
    const launcherKeyDownCallback = useCallback((event) => {
        if (localLauncherRef.current === getActiveElement() && event.code === 'F6' && !isModal()) {
            // Prevent default F6 handlers.
            // F6 is a standard Chrome address bar shortcut on Windows.
            event.preventDefault();
            event.stopPropagation();
            focusWithin(contentWrapperRef.current);
            onFocusSet?.();
        }
    }, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [isModal]);
    const _onTransitionEnd = (isOpen) => {
        if (isOpen) {
            setInitialFocus();
            onTransitionEnd?.(true);
        }
        else {
            onTransitionEnd?.(false);
        }
    };
    // Animation
    const { setAnimationElementRef, status, onPosition } = usePopupAnimation({
        isOpen,
        isAnimatedOnMount: true,
        onTransitionEnd: _onTransitionEnd,
        placement: placement
    });
    const stableRef = useMemo(() => mergeRefs(contentWrapperRef, ref), [contentWrapperRef, ref]);
    const returnFocus = useCallback(() => {
        // Try to return focus to 1.launcher or 2.anchor
        const launcherEl = localLauncherRef.current;
        const anchor = anchorRef?.current;
        if (launcherEl) {
            focusOn(launcherEl);
        }
        else if (anchor) {
            let anchorElement = null;
            // Checking instanceof to avoid Coords type that can not be focused
            if (anchor instanceof Element) {
                anchorElement = anchor;
            }
            else if (anchor[UNSAFE_DOM_ACCESS]) {
                anchorElement = anchor[UNSAFE_DOM_ACCESS];
            }
            if (anchorElement) {
                focusOn(anchorElement);
            }
        }
    }, [localLauncherRef, anchorRef]);
    useEffect(() => {
        // Init closing
        if (!isOpen && status === 'opening' && !isModal()) {
            // Only actively return focus to the launcher or anchor if the popup contained focus.
            // Otherwise, focus is already elsewhere on the page and should not be forced back
            // because that could reopen the popup again, which essentially prevents the user from
            // moving focus out of the launcher.
            if (contentWrapperRef.current?.contains(getActiveElement())) {
                returnFocus();
            }
        }
        // JET-71010 - for modal popups, the focus cannot be moved until the modal overlay is gone
        else if (!isOpen && status === 'unmounted' && isModal()) {
            // avoid returning focus on initial render
            if (status !== prevStatusRef.current) {
                returnFocus();
            }
        }
        return () => {
            prevStatusRef.current = status;
        };
    }, [isOpen, status, returnFocus, isModal]);
    // Initialize launcher
    useEffect(() => {
        if (isOpen) {
            if (!launcherRef?.current) {
                // 1. If launcher is not defined, most frequent scenario is,
                // that element, that has focus before opening a popup is considered launcher
                localLauncherRef.current = getActiveElement();
            }
            else if (launcherRef.current instanceof Element) {
                // 2. launcherRef element was provided.
                // Verify, if it exists in DOM, otherwise use the last active element
                localLauncherRef.current = document.body.contains(launcherRef.current)
                    ? launcherRef.current
                    : getActiveElement();
            }
            else {
                localLauncherRef.current = getActiveElement();
            }
            // Register F6 key handler to enter the Popup
            localLauncherRef.current?.addEventListener('keydown', launcherKeyDownCallback);
        }
        return () => {
            // Deregister F6 key handler
            localLauncherRef.current?.removeEventListener('keydown', launcherKeyDownCallback);
        };
    }, [isOpen, launcherRef, launcherKeyDownCallback]);
    // Note: unlike oj-c-popup we do not default anchorRef to launcherRef in Preact Popup
    // If anchorRef is undefined, we use WindowOverlay as anchor
    const setInitialFocus = () => {
        let derivedInitialFocus = initialFocus;
        if (initialFocus === 'auto') {
            if (isModal()) {
                // modal mode - set focus to first focusable
                derivedInitialFocus = 'firstFocusable';
            }
            else {
                // modeless mode - do not steal focus by default
                derivedInitialFocus = 'none';
            }
        }
        // Case: 'popup'
        // Focus on Popup container
        if (derivedInitialFocus === 'popup') {
            focusOn(contentWrapperRef.current);
            onFocusSet?.();
        }
        // Case: 'firstFocusable'
        // Focus on first tabbable in the Popup container or container itself if there is none
        if (derivedInitialFocus === 'firstFocusable') {
            focusWithin(contentWrapperRef.current);
            onFocusSet?.();
        }
    };
    const getMainAxisOffset = (offset) => {
        let calcOffset = 0;
        if (offset) {
            // @ts-ignore as OffsetFunction is going to be removed
            // Property 'mainAxis' does not exist on type 'OffsetFunction'.
            calcOffset = typeof offset === 'number' ? offset : offset.mainAxis || 0;
            if (tail === 'simple') {
                calcOffset += 5;
            }
        }
        return calcOffset;
    };
    const getCrossAxisOffset = (offset) => {
        if (!offset) {
            return 0;
        }
        else {
            // @ts-ignore as OffsetFunction is going to be removed
            // Property 'crossAxis' does not exist on type 'OffsetFunction'.
            return typeof offset === 'number' ? 0 : offset.crossAxis || 0;
        }
    };
    const finalOffset = {
        mainAxis: getMainAxisOffset(offset),
        crossAxis: getCrossAxisOffset(offset)
    };
    const handlePopupKeyDown = (event) => {
        const currentlyFocusedEl = getActiveElement();
        const wrapperEl = contentWrapperRef.current;
        const launcherEl = localLauncherRef.current;
        if (wrapperEl === currentlyFocusedEl || wrapperEl?.contains(currentlyFocusedEl)) {
            switch (event.code) {
                case 'Escape': {
                    // Trigger onClose event with outside click detail
                    onClose?.({ reason: 'escapeKey' });
                    break;
                }
                case 'F6':
                    // Prevent default F6 handlers.
                    // F6 is a standard Chrome address bar shortcut on Windows.
                    event.preventDefault();
                    event.stopPropagation();
                    // Focus launcher
                    if (launcherEl && !isModal()) {
                        focusOn(launcherEl);
                    }
                    break;
            }
        }
    };
    useLayoutEffect(() => {
        if (status === 'unmounted' ||
            contentWrapperRef.current == null ||
            popupBgColor != null ||
            tail === 'none')
            return;
        const backgroundColorVar = g(popupVars.backgroundColor);
        const computedStyle = getComputedStyle(contentWrapperRef.current);
        setPopupBgColor(props.backgroundColor || computedStyle.getPropertyValue(backgroundColorVar));
    }, [status, contentWrapperRef, popupBgColor, tail, props.backgroundColor]);
    const clientHints = getClientHints();
    const isVOSupported = ['ios', 'android'].indexOf(clientHints.platform) > -1;
    // Note: Popup does not have 'open' status. It is 'opening' even when open.
    const renderVOSupport = status === 'opening';
    // Styles
    const { baseTheme, classes } = useComponentTheme(PopupRedwoodTheme);
    const isMounted = status !== 'unmounted';
    const interpolations = [
        ...Object.values(dimensionInterpolations),
        ...Object.values(colorInterpolations)
    ];
    const styleInterpolations = mergeInterpolations(interpolations);
    const { ...styles } = styleInterpolations(props);
    const closeSkipLinkCallback = () => {
        // Trigger onClose event with outside click detail
        onClose?.({ reason: 'closeSkipLink' });
    };
    const renderPopup = () => {
        return (jsxs(Fragment, { children: [jsx(FocusTrap, { restoreFocusRef: false, children: jsxs("div", { ref: stableRef, tabIndex: -1, role: role, className: classNames([baseTheme, variant === 'unstyled' ? null : classes]), style: styles, onKeyDown: handlePopupKeyDown, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, ...testIdProps, children: [!isModal() && isVOSupported && renderVOSupport && (jsx(PopupSkipLink, { callback: closeSkipLinkCallback, message: `${translations.popup_close_skipLink}` })), children] }) }), !isModal() &&
                    // Render on non-mobile only.
                    !isVOSupported && (jsx(LiveRegion, { children: `${['auto', 'none'].indexOf(initialFocus) != -1
                        ? translations.popup_liveRegion_F6_initial_focus_none
                        : translations.popup_liveRegion_F6_initial_focus_firstFocusable}` }))] }));
    };
    const renderFloatingOrOverlayPopup = () => {
        if (!anchorRef || !anchorRef.current) {
            return (jsx(WindowOverlay, { placement: placement, offset: finalOffset, children: jsx("div", { ref: setAnimationElementRef, children: renderPopup() }) }));
        }
        else {
            return (jsx(Floating, { ref: setAnimationElementRef, backgroundColor: popupBgColor, anchorRef: anchorRef, placement: placement, offsetValue: finalOffset, flipOptions: flipOptions, shiftOptions: shiftOptions, tail: tail, onPosition: onPosition, children: renderPopup() }));
        }
    };
    if (isMounted) {
        if (isModal()) {
            return jsx(Modal, { isOpen: isMounted, children: renderFloatingOrOverlayPopup() });
        }
        else {
            return jsx(Layer, { children: renderFloatingOrOverlayPopup() });
        }
    }
    else
        return null;
});

export { Popup as P };
//# sourceMappingURL=Popup-0f026f03.js.map
