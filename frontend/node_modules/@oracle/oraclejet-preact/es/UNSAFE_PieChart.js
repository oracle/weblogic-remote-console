/* @oracle/oraclejet-preact: undefined */
import { jsxs, jsx, Fragment } from 'preact/jsx-runtime';
import { styles, dimensionStyle } from './UNSAFE_PieChart/themes/PieChartStyles.css.js';
import { T as TrackResizeContainer } from './TrackResizeContainer-4411f745.js';
import './datatipUtils-0a36125e.js';
import './accUtils-f6657e8e.js';
import { m as moveTo, a as arcTo, l as lineTo, b as closePath } from './lineUtils-586f3e8a.js';
import { d as getAvailSpace } from './utils-adfaaca0.js';
import { c as classNames } from './classNames-4e12b00d.js';
import { u as usePieChartNav } from './usePieChartNav-0cfc3456.js';
import { u as useDatatip } from './useDatatip-c7727336.js';
import { c as calculateOffset } from './layoutUtils-895c6de8.js';
import { m as mergeProps } from './mergeProps-88ea8306.js';
import { V as VisTabularDatatip } from './VisTabularDatatip-4d0f026a.js';
import { u as useUser } from './useUser-df8ae011.js';
import { u as useTestId } from './useTestId-e5d44ab1.js';
import { u as useVisTouchResponse } from './useVisTouchResponse-a59ab166.js';
import { useRef } from 'preact/hooks';
import { l } from './stringUtils-0fe25200.js';
import { u as useContextMenu } from './useContextMenu-6aa8193e.js';
import './SelectMenuGroupContext-0c1a7603.js';
import 'preact';
import './logger-c92f309c.js';
import './LayerHost-12489cef.js';
import 'preact/compat';
import './TooltipContentStyles.styles.css';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentBaseTheme.styles.css';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js';
import './tooltipUtils-466c63c4.js';
import './IconStyle.styles.css';
import './UNSAFE_Menu/themes/MenuItemStyles.css.js';
import './UNSAFE_Separator/themes/SeparatorStyles.css.js';
import './MenuSeparatorStyles.styles.css';
import './UNSAFE_Menu/themes/redwood/MenuSeparatorBaseTheme.styles.css';
import './UNSAFE_Menu/themes/redwood/MenuSeparatorVariants.css.js';
import './MenuStyles.styles.css';
import { g as getInfo } from './eventsUtils-e96290df.js';
import { g as getTextInfo } from './utils-49903d04.js';
import { u as useTextDimensions } from './useTextDimensions-45f79df4.js';
import { u as useCssVars } from './useCssVars-143870e2.js';
import { g as getChartVars } from './cssUtils-20795e7b.js';
import { g as getContrastingTextColor } from './colorUtils-b3804ee8.js';
import './PieChartStyles.styles.css';
import './useSize-3b5c56f5.js';
import './useResizeObserver-13641643.js';
import './useAddBusyState-7a6af61f.js';
import './BusyStateContext-9ee9751d.js';
import './useBusyStateContext-4d3c27c0.js';
import './unsafeDomAccess-453eb74e.js';
import './size-a3d3aeaf.js';
import './utils-cfef1929.js';
import './themeContract.css-2b5a42e2.js';
import './clientUtils-cccff45f.js';
import './clientHints-a42b510c.js';
import './getLocale-1c41e86a.js';
import './labelUtils-aee6ab65.js';
import './textUtils-3ed25dd1.js';
import './dimensionUtils-6d5dac30.js';
import './scale-9a834124.js';
import './useVisHover-d7a0b2f3.js';
import './useVisDrill-48b6609b.js';
import './useDoubleTap-4e290707.js';
import './clientUtils-71f2dbaf.js';
import './Layer-7d3dc8c7.js';
import './UNSAFE_Layer/themes/LayerStyles.css.js';
import './LayerStyles.styles.css';
import './useThemeInterpolations-4b48d878.js';
import './useColorScheme-96cce6a1.js';
import './useScale-0ebe15ed.js';
import './theme-63551f30.js';
import './Theme-e6dec6db.js';
import './mergeInterpolations-30cd9a69.js';
import './mergeDeepWithKey-33e3d1be.js';
import './_curry3-577eb45e.js';
import './_curry1-63949a9b.js';
import './_curry2-01c87f61.js';
import './_isObject-1fab0f5b.js';
import './useDensity-d06ae84a.js';
import './Floating-6023b41d.js';
import './useFloating-e1167cb9.js';
import './positionUtils-f26caad9.js';
import './refUtils-76275c69.js';
import './useOutsideClick-73a51e1d.js';
import './arrayUtils-35a58161.js';
import './useModal-953082f2.js';
import './useComponentTheme-d2f9e47f.js';
import './UNSAFE_Floating/themes/redwood/FloatingTheme.js';
import './UNSAFE_Floating/themes/FloatingStyles.css.js';
import './FloatingStyles.styles.css';
import './UNSAFE_Floating/themes/redwood/FloatingBaseTheme.css.js';
import './UNSAFE_Floating/themes/redwood/FloatingBaseTheme.styles.css';
import './UNSAFE_Floating/themes/redwood/FloatingVariants.css.js';
import './vanilla-extract-recipes-createRuntimeFn.esm-2aaf8c98.js';
import './vanilla-extract-dynamic.esm-c909758c.js';
import './UNSAFE_Floating/themes/FloatingContract.css.js';
import './useUnsafeDomElementRef-32290273.js';
import './hooks/PRIVATE_useDatatip/themes/useDatatip.css.js';
import './useDatatip.styles.css';
import './useId-03dbfdf0.js';
import './PRIVATE_VisTabularDatatip/themes/VisTabularDatatipStyles.css.js';
import './VisTabularDatatipStyles.styles.css';
import './useContextMenuGesture-906cf78d.js';
import './textSelectionUtils-a6554a42.js';
import './Sheet-24c3e407.js';
import './Modal-678575d5.js';
import './UNSAFE_Modal/themes/ModalStyles.css.js';
import './ModalStyles.styles.css';
import './tabbableUtils-ce19b388.js';
import './head-8f89fe66.js';
import './_arity-be492b9e.js';
import './_isArray-694cc52d.js';
import './_isString-675f1de9.js';
import './popupUtils-4edf62b5.js';
import './WindowOverlay-b380ce51.js';
import './UNSAFE_WindowOverlay/themes/WindowOverlayStyles.css.js';
import './WindowOverlayStyles.styles.css';
import './UNSAFE_WindowOverlay/themes/WindowOverlayContract.css.js';
import './UNSAFE_WindowOverlay/themes/redwood/WindowOverlayTheme.js';
import './UNSAFE_WindowOverlay/themes/redwood/WindowOverlayBaseTheme.css.js';
import './UNSAFE_WindowOverlay/themes/redwood/WindowOverlayBaseTheme.styles.css';
import './UNSAFE_WindowOverlay/themes/redwood/WindowOverlayVariants.css.js';
import './UNSAFE_Sheet/themes/SheetStyles.css.js';
import './SheetStyles.styles.css';
import './useAnimationStatus-072d6a98.js';
import './useAnimation-a5eb7604.js';
import './animationUtils-5f409a6c.js';
import './useTranslationBundle-25469f1c.js';
import './Dropdown-ead9e679.js';
import './keyboardUtils-986fe923.js';
import './usePopupAnimation-66b186ad.js';
import './popupAnimationUtils-175151d9.js';
import './CollectionInteractionContext-7cf19abc.js';
import './UNSAFE_Dropdown/themes/dropdownStyles.css.js';
import './dropdownStyles.styles.css';
import './useOutsideMousedown-39d7c9a6.js';
import './UNSAFE_Menu/themes/MenuStyles.css.js';
import './UNSAFE_Menu/themes/DropdownMenuStyles.css.js';
import './DropdownMenuStyles.styles.css';
import './Flex-5befe411.js';
import './boxalignment-51b42a0f.js';
import './boxalignment.styles.css';
import './vanilla-extract-sprinkles-createRuntimeSprinkles.esm-2d655d37.js';
import './dimensions-ddde0eee.js';
import './flexbox-529f25da.js';
import './flexbox.styles.css';
import './flexitem-7b7f7920.js';
import './flexitem.styles.css';
import './FlexStyles.styles.css';
import './Skeleton-a06f4f74.js';
import './borders-98a63040.js';
import './UNSAFE_Skeleton/themes/redwood/SkeletonTheme.js';
import './UNSAFE_Skeleton/themes/SkeletonStyles.css.js';
import './SkeletonStyles.styles.css';
import './UNSAFE_Skeleton/themes/redwood/SkeletonBaseTheme.css.js';
import './UNSAFE_Skeleton/themes/redwood/SkeletonBaseTheme.styles.css';
import './UNSAFE_Skeleton/themes/redwood/SkeletonVariants.css.js';
import './UNSAFE_Menu/themes/MenuSkeletonStyles.css.js';
import './MenuSkeletonStyles.styles.css';
import './LiveRegion-79ffc814.js';
import './LiveRegionStyles.styles.css';
import './UNSAFE_Menu/themes/redwood/MenuItemTheme.js';
import './UNSAFE_Menu/themes/redwood/MenuItemBaseTheme.css.js';
import './UNSAFE_Menu/themes/redwood/MenuItemBaseTheme.styles.css';
import './UNSAFE_Menu/themes/redwood/MenuItemVariants.css.js';
import './MenuItemStyles.styles.css';
import './MenuItemVariants.styles.css';
import './Text-983c749e.js';
import './UNSAFE_Text/themes/TextStyles.css.js';
import './TextStyles.styles.css';
import './usePress-051f5adb.js';
import './useInteractionStyle-99e32c23.js';
import './useHover-85077adb.js';
import './useToggle-8b7fcefe.js';
import './useActive-fb6d4d52.js';
import './index-3e2e69c4.js';
import './UNSAFE_Layer/themes/LayerHostStyles.css.js';
import './LayerHostStyles.styles.css';
import './TooltipContentVariants.styles.css';
import './EnvironmentProvider-546b7ebd.js';
import './LayerManager-a62e619b.js';
import './SeparatorStyles.styles.css';
import './useTheme-d30637db.js';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const RADIUS_RATIO = 0.45;
const RADIUS_RATIO_WITH_LABELS = 0.38;
const SLICE_GAP_RATIO = 3;
const MIN_ARC_LENGTH = 1.5;
const START_ANGLE = 90;
/**
 * Converts the angle from degrees to radians.
 * @param degree The angle in degrees
 * @returns
 */
function degreesToRads(degree) {
    return degree * (Math.PI / 180);
}
/**
 * Calculates the angle between two vectors.
 * @param vector1X The x component of first vector.
 * @param vector1Y The y component of first vector.
 * @param vector2X The x component of second vector.
 * @param vector2Y The y component of second vector.
 * @returns
 */
function calculateAngleBetweenTwoVectors(vector1X, vector1Y, vector2X, vector2Y) {
    const angle = Math.atan2(vector2Y, vector2X) - Math.atan2(vector1Y, vector1X);
    return angle < 0 ? angle + 2 * Math.PI : angle;
}
/**
 * Get the center coord of the pie chart.
 * @param availSpace The available space.
 * @returns
 */
function getPieCenter(availSpace) {
    return {
        cx: availSpace.x + Math.floor(availSpace.width / 2),
        cy: availSpace.y + Math.floor(availSpace.height / 2)
    };
}
/**
 * Returns the radius of the pie chart.
 * @param availSpace The available space.
 * @param labelPosition The position of labels.
 * @returns
 */
function getRadius(availSpace, isLabelOutside) {
    const radiusScale = isLabelOutside ? RADIUS_RATIO_WITH_LABELS : RADIUS_RATIO;
    return Math.floor(Math.min(availSpace.width, availSpace.height) * radiusScale);
}
/**
 * Returns the total value of the pie chart.
 * @param items
 */
function getPieChartInfo(items) {
    return items.reduce(({ totalValue, isLabelOutside }, item) => {
        return {
            totalValue: totalValue + item.value,
            isLabelOutside: isLabelOutside || (!!item.label && (item.labelPosition === 'outside' || item.labelPosition === 'auto'))
        };
    }, { totalValue: 0, isLabelOutside: false });
}
/**
 * Returns the startAngle and angleOffset for the rendered items.
 * @param items
 * @param totalValue
 */
function getSliceInfo(items, totalValue, colors, isRtl) {
    let anchorOffset = START_ANGLE;
    let percentage;
    const sliceInfo = [];
    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const value = item.value;
        if (value === totalValue) {
            percentage = 100;
        }
        else if (totalValue === 0) {
            percentage = 0;
        }
        else {
            // if value is not 100%, cap it at 99.99%
            percentage = Math.min((value / totalValue) * 100, 99.99);
        }
        const arc = percentage * 3.6;
        let angle = anchorOffset - arc;
        if (angle < 0)
            angle += 360;
        sliceInfo.push({
            color: colors[(isRtl ? items.length - 1 - i : i) % colors.length],
            index: i,
            startAngle: angle,
            angleExtent: arc,
            ...item
        });
        anchorOffset = angle;
    }
    return sliceInfo;
}
/**
 * Returns the pie slice gaps.
 * @param  pieSliceGap The ratio of maximum supported pie slice gap.
 * @returns
 */
function getPieSliceGap(pieSliceGap) {
    return SLICE_GAP_RATIO * pieSliceGap;
}
/**
 * Returns the array of layouts to render without skipping.
 * @param layouts
 * @param hasLargeItemCount
 * @param radius
 * @returns
 */
function getRenderedSlices(itemInfo, hasLargeItemCount, radius) {
    if (!hasLargeItemCount) {
        return itemInfo;
    }
    const perimeter = 2 * Math.PI * radius;
    let prevEndCoord = 0;
    return itemInfo.filter(({ startAngle, angleExtent }) => {
        const arcLength = (angleExtent / 360) * perimeter;
        const endCoord = ((angleExtent + startAngle) / 360) * perimeter;
        if (arcLength < MIN_ARC_LENGTH && Math.abs(prevEndCoord - endCoord) < MIN_ARC_LENGTH) {
            return false;
        }
        else {
            prevEndCoord = endCoord;
            return true;
        }
    });
}
/**
 * Returns the path of the pie slice wedge.
 * @param inset The inset.
 * @param cx The x coordinate of the center of the pie chart.
 * @param cy The y coordinate of the center of the pie chart.
 * @param radiusX The x radius of the slice.
 * @param radiusY The y radius of the slice.
 * @param innerRadius The inner radius.
 * @param angleExtent The angle extent.
 * @param wedgeGap The gap beteen the pie slices.
 * @param startAngle The start angle of the pie slice.
 * @returns
 */
function makeWedgePath(inset, cx, cy, radiusX, radiusY, innerRadius, angleExtent, wedgeGap, startAngle) {
    const rx = Math.max(radiusX - inset, 0);
    const ry = Math.max(radiusY - inset, 0);
    const gap = angleExtent == 360 || rx < inset ? 0 : wedgeGap + 2 * inset;
    const ir = innerRadius ? innerRadius + inset : 0;
    // if angle extent is not 360, cap it  at 359.99
    const angleExtentRads = angleExtent == 360 ? degreesToRads(359.99) : degreesToRads(angleExtent);
    const startAngleRads = degreesToRads(startAngle);
    const dataItemGaps = gap / 2;
    const gapAngle = dataItemGaps < rx ? Math.asin(dataItemGaps / rx) : 0;
    const centerLineAngle = -angleExtentRads / 2 - startAngleRads;
    // cap at 5* dataItemsGap. logic from legacy dvt toolkit
    const distanceToStartPointX = Math.min(dataItemGaps * 5, angleExtentRads > 0 ? Math.abs(dataItemGaps / Math.sin(angleExtentRads / 2)) : 0);
    const distanceToStartPointY = rx == 0 ? distanceToStartPointX : (distanceToStartPointX * ry) / rx;
    const startPointX = cx + Math.cos(centerLineAngle) * distanceToStartPointX;
    const startPointY = cy + Math.sin(centerLineAngle) * distanceToStartPointY;
    const arcPointX = cx + Math.cos(-gapAngle - startAngleRads) * rx;
    const arcPointY = cy + Math.sin(-gapAngle - startAngleRads) * ry;
    const arcPoint2X = cx + Math.cos(-startAngleRads - angleExtentRads + gapAngle) * rx;
    const arcPoint2Y = cy + Math.sin(-startAngleRads - angleExtentRads + gapAngle) * ry;
    let outerAngle = calculateAngleBetweenTwoVectors(arcPoint2X - cx, arcPoint2Y - cy, arcPointX - cx, arcPointY - cy);
    outerAngle = Math.min(outerAngle, angleExtentRads);
    let pathCommands;
    if (ir > 0) {
        const innerGapAngle = dataItemGaps < ir ? Math.asin(dataItemGaps / ir) : 0;
        const innerPointX = cx + Math.cos(-innerGapAngle - startAngleRads) * ir;
        const innerPointY = cy + Math.sin(-innerGapAngle - startAngleRads) * ir;
        const innerPoint2X = cx + Math.cos(-startAngleRads - angleExtentRads + innerGapAngle) * ir;
        const innerPoint2Y = cy + Math.sin(-startAngleRads - angleExtentRads + innerGapAngle) * ir;
        let innerAngle = calculateAngleBetweenTwoVectors(innerPoint2X - cx, innerPoint2Y - cy, innerPointX - cx, innerPointY - cy);
        innerAngle = Math.min(innerAngle, outerAngle, angleExtentRads);
        if (angleExtent == 360) {
            pathCommands = moveTo(arcPoint2X, arcPoint2Y);
            pathCommands += arcTo(rx, ry, angleExtentRads, 1, arcPointX, arcPointY);
            pathCommands += lineTo(arcPoint2X, arcPoint2Y);
            pathCommands += moveTo(innerPointX, innerPointY);
            pathCommands += arcTo(ir, ir, angleExtentRads, 0, innerPoint2X, innerPoint2Y);
        }
        else {
            pathCommands = moveTo(innerPoint2X, innerPoint2Y);
            pathCommands += lineTo(arcPoint2X, arcPoint2Y);
            pathCommands += arcTo(rx, ry, outerAngle, 1, arcPointX, arcPointY);
            pathCommands += lineTo(innerPointX, innerPointY);
            pathCommands += arcTo(ir, ir, innerAngle, 0, innerPoint2X, innerPoint2Y);
        }
    }
    else {
        if (angleExtent == 360) {
            pathCommands = moveTo(arcPoint2X, arcPoint2Y);
            pathCommands += arcTo(rx, ry, angleExtentRads, 1, arcPointX, arcPointY);
        }
        else {
            pathCommands = moveTo(startPointX, startPointY);
            pathCommands += lineTo(arcPoint2X, arcPoint2Y);
            pathCommands += arcTo(rx, ry, outerAngle, 1, arcPointX, arcPointY);
        }
    }
    pathCommands += closePath();
    return pathCommands;
}
/**
 * Returns the pie chart center context.
 * @param cx The x coordinate of the center of the pie chart.
 * @param cy The y coordinate of the center of the pie chart.
 * @param innerRadius The inner radius of the pie chart.
 * @returns
 */
function getCenterContext(cx, cy, innerRadius) {
    return {
        innerBounds: {
            width: Math.sqrt(2) * innerRadius,
            height: Math.sqrt(2) * innerRadius,
            x: cx - innerRadius / Math.sqrt(2),
            y: cy - innerRadius / Math.sqrt(2)
        },
        outerBounds: {
            width: 2 * innerRadius,
            height: 2 * innerRadius,
            x: cx - innerRadius,
            y: cy - innerRadius
        }
    };
}
/**
 * Returns the position of the datatip for a given slice.
 * @param startAngle The start angle of the pie slice.
 * @param angleExtent The angle extent of the pie slice.
 * @param cx The x coordinate of the center of the pie slice.
 * @param cy The y coordinate of the center of the pie slice.
 * @param innerRadius The inner radius.
 * @param radius The radius of the pie slice.
 * @returns
 */
function getPieItemCenterCoord(startAngle, angleExtent, cx, cy, innerRadius, radius) {
    const angle = startAngle + angleExtent / 2;
    const theta = (angle / 180) * Math.PI;
    const r = (innerRadius + radius) / 2;
    return {
        x: cx + r * Math.cos(theta),
        y: cy - r * Math.sin(theta),
        width: 0,
        height: 0
    };
}
/**
 * Returns the element bound for active item.
 * @param renderedSlices The array of info for rendered slices.
 * @param cx The x coordinate of pie chart center.
 * @param cy The y coordinate of pie chart center.
 * @param ir The inner radius of the pie chart.
 * @param radius The radius of the pie chart.
 * @param activeItem The active item.
 * @returns
 */
function getElementBounds(renderedSlices, cx, cy, ir, radius, activeItem) {
    return activeItem
        ? getPieItemCenterCoord(renderedSlices[activeItem.itemIndex].startAngle, renderedSlices[activeItem.itemIndex].angleExtent, cx, cy, ir, radius)
        : undefined;
}
/**
 * Returns default border color for datatip.
 * @param colors The color ramp.
 * @param activeItem The active item info.
 * @param activeData The active pie chart data item.
 * @returns
 */
function getDefaultBorderColor(colors, activeItem, activeData) {
    return activeData?.color || activeItem?.itemIndex != undefined
        ? colors[activeItem.itemIndex]
        : undefined;
}

/**
 * The Pie Slice component.
 */
function PieSlice({ cx, cy, r, startAngle, angleExtent, gap, innerRadius, color, id, itemIndex, isFocused = false, isInteractive, ...props }) {
    const { interactiveItemStyle, contrastBorder, innerShapes } = styles;
    const itemClasses = classNames([
        isInteractive && interactiveItemStyle,
        contrastBorder,
        innerShapes
    ]);
    const path = makeWedgePath(0, cx, cy, r, r, innerRadius, angleExtent, gap, startAngle);
    let innerPath;
    if (isFocused) {
        innerPath = makeWedgePath(2, cx, cy, r, r, innerRadius, angleExtent, gap, startAngle);
        return (jsxs("g", { id: id, role: props.accessibleLabel ? 'img' : undefined, "data-oj-private-item-index": itemIndex, "data-oj-private-object": "pieSlice", "aria-label": props.accessibleLabel, children: [jsx("path", { d: path, fill: color, stroke: color, className: styles.innerShapes }), jsx("path", { d: innerPath, fill: color, className: itemClasses })] }));
    }
    return (jsx("path", { role: props.accessibleLabel ? 'img' : undefined, "aria-label": props.accessibleLabel, d: path, "data-oj-private-object": "pieSlice", fill: color, id: id, "data-oj-private-item-index": itemIndex, className: isInteractive ? interactiveItemStyle : undefined }));
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Returns the item based on item info in a pie chart.
 * @param itemInfo
 * @param items
 * @returns
 */
function getItem(itemInfo, items) {
    const { itemIndex } = itemInfo;
    return items[itemIndex];
}
/**
 * Returns the nav util for pie chart.
 * @param data
 * @param isRtl
 * @returns
 */
function getPieChartNavUtils(data, isRtl) {
    return {
        getNextChartItem: ({ itemIndex }, arrow) => {
            let newItemIndex = itemIndex;
            if ((isRtl && (arrow === 'ArrowRight' || arrow === 'ArrowUp')) ||
                (!isRtl && (arrow === 'ArrowLeft' || arrow === 'ArrowDown'))) {
                newItemIndex = itemIndex - 1;
            }
            else {
                newItemIndex = itemIndex + 1;
            }
            return {
                itemIndex: ((newItemIndex % data.length) + data.length) % data.length
            };
        },
        getDetailFromInfo: (itemInfo) => {
            if (!itemInfo) {
                return { id: undefined, data: undefined };
            }
            const item = getItem(itemInfo, data);
            return { id: item ? item.id : undefined, data: item };
        }
    };
}

const usePieChartContextMenu = ({ offset, rootRef, contextMenuConfig, focusedItemInfo, items, onContextMenuDismissed, width, isRtl }) => {
    const { contextMenuProps, contextMenuContent } = useContextMenu({
        onContextMenuHandler: ({ gesture, target }) => {
            if (gesture === 'keyboard') {
                const itemIndex = focusedItemInfo.itemIndex;
                const data = items[itemIndex];
                const context = {
                    type: 'item',
                    data
                };
                return {
                    type: 'offset',
                    context,
                    offsetValue: offset,
                    isRtl,
                    width
                };
            }
            const itemIndex = getInfo(rootRef, target)?.itemIndex;
            const data = itemIndex !== undefined ? items[itemIndex] : null;
            let context;
            if (data) {
                context = {
                    type: 'item',
                    data: data
                };
            }
            else if (rootRef.current?.children[1].contains(target)) {
                context = { type: 'centerLabel' };
            }
            else {
                context = { type: 'background' };
            }
            return {
                type: 'pointer',
                context
            };
        },
        contextMenuOptions: {
            isDisabled: !contextMenuConfig //If there is no context menu renderer, we disable the hook
        },
        rootRef,
        contextMenuConfig,
        onContextMenuDismissed
    });
    return { contextMenuContent, contextMenuProps };
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const OUTSIDE_LABEL_DISTANCE = 1.04;
const _COLLISION_MARGIN = 1;
const _FEELER_RAD_MINSIZE = 0.1;
const _FEELER_HORIZ_MINSIZE = 0.1;
const _LABEL_TO_FEELER_OFFSET = 0.5;
const _ALL_COLLISION = 2;
const _HALF_COLLISION = 1;
const _NO_COLLISION = 0;
const _LABEL_TO_FEELER_DISTANCE = 3;
function degreesToRadians(degrees) {
    return degrees * (Math.PI / 180);
}
function reflectAngleOverYAxis(angle, cx, cy, rx, ry) {
    const radian = degreesToRadians(360 - angle);
    const cosine = Math.cos(radian);
    const sine = Math.sin(radian);
    return { x: cx + cosine * rx, y: cy + sine * ry };
}
function skipSliceLabel(slice, seriesCount) {
    const { angleExtent } = slice;
    return angleExtent < 3 && seriesCount > 120;
}
/**
 * Returns true if this slice contains the given coordinates.
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */
function sliceContainsPoint(slice, x, y, cx, cy, innerRadius, radius) {
    const { angleExtent, startAngle } = slice;
    const ir = innerRadius;
    const c = { x: cx, y: cy };
    const cos = (x - c.x) / radius;
    const sin = (y - c.y) / radius;
    // Compute the angle
    let angle = -Math.atan2(sin, cos) * (180 / Math.PI); // in degrees
    // First adjust angle to be greater than the start angle.
    while (angle < startAngle)
        angle += 360;
    // Then adjust to be within 360 degrees of it
    while (angle - startAngle >= 360)
        angle -= 360;
    const distance = Math.pow(cos, 2) + Math.pow(sin, 2);
    const containsRadius = Math.sqrt(distance) > ir / radius && distance <= 1;
    const containsAngle = angle <= startAngle + angleExtent;
    return containsRadius && containsAngle;
}
function getInsideLabelsInfo(slices, innerRadius, radius, pieCenter, defaultFontSize, getTextDimensions) {
    const insideLabels = [];
    const outsideLabelsIndex = new Set();
    const { cx, cy } = pieCenter;
    for (const slice of slices) {
        const { labelPosition: l, startAngle, angleExtent, label, labelStyle } = slice;
        const labelPosition = l || 'auto';
        if (labelPosition === 'none') {
            continue;
        }
        if (labelPosition === 'outside' || skipSliceLabel(slice, slices.length) || label == null) {
            outsideLabelsIndex.add(slice.index);
            continue;
        }
        const midAngle = startAngle + angleExtent / 2;
        const ir = innerRadius;
        const center = pieCenter;
        let posX, posY;
        if (slices.length === 1) {
            posX = center.cx;
            posY = center.cy;
        }
        else {
            const offset = Math.max(0.45, 0.65 - (0.45 * ir) / Math.max(radius, 0.001));
            const midPt = reflectAngleOverYAxis(midAngle, center.cx, center.cy, ir + (radius - ir) * offset, ir + (radius - ir) * offset);
            posX = midPt.x;
            posY = midPt.y;
        }
        const sliceLabelPosition = {
            x: posX,
            y: posY
        };
        const sliceLabelDims = getTextDimensions(label, { fontSize: defaultFontSize, ...labelStyle });
        let x1 = posX;
        let x2 = posX;
        const y1 = posY - sliceLabelDims.height / 2;
        const y2 = posY + sliceLabelDims.height / 2;
        while (sliceContainsPoint(slice, x1, y1, cx, cy, innerRadius, radius) &&
            sliceContainsPoint(slice, x1, y2, cx, cy, innerRadius, radius)) {
            x1--;
        }
        while (sliceContainsPoint(slice, x2, y1, cx, cy, innerRadius, radius) &&
            sliceContainsPoint(slice, x2, y2, cx, cy, innerRadius, radius)) {
            x2++;
        }
        x1 = Math.ceil(x1 + 3);
        x2 = Math.floor(x2 - 3);
        let usableSpace = 2 * Math.min(posX - x1, x2 - posX);
        if (usableSpace < sliceLabelDims.width) {
            sliceLabelPosition.x = (x1 + x2) / 2;
            usableSpace = x2 - x1;
        }
        if (labelPosition === 'inside') {
            const textWidth = sliceLabelDims.width;
            if (textWidth < usableSpace) {
                insideLabels.push({
                    position: midAngle,
                    angle: midAngle,
                    slice,
                    textInfo: getTextInfo(label, { fontSize: defaultFontSize, ...labelStyle }, usableSpace, sliceLabelDims.height, false, label.length, getTextDimensions),
                    ...sliceLabelDims,
                    ...sliceLabelPosition
                });
            }
        }
        else {
            const minChars = label.length;
            const textInfo = getTextInfo(label, { fontSize: defaultFontSize, ...labelStyle }, usableSpace, sliceLabelDims.height, false, minChars, getTextDimensions);
            if (!textInfo.didNotFit) {
                insideLabels.push({
                    position: midAngle,
                    angle: midAngle,
                    slice,
                    textInfo,
                    ...sliceLabelDims,
                    ...sliceLabelPosition
                });
            }
            else {
                outsideLabelsIndex.add(slice.index); // Indicates outside label is needed
            }
        }
    }
    return [insideLabels, outsideLabelsIndex];
}
const layoutPieChartLabels = (slices, pieCenter, innerRadius, radius, availSpace, getTextDimensions, defaultFontSize) => {
    const [insideLabels, outsideLabels] = getInsideLabelsInfo(slices, innerRadius, radius, pieCenter, defaultFontSize, getTextDimensions);
    const { leftLabels, rightLabels } = generateInitialLayout(slices, outsideLabels, availSpace, pieCenter, radius, defaultFontSize, getTextDimensions);
    const leftColl = _refineInitialLayout(slices, radius, pieCenter, availSpace, leftLabels, 'left');
    const rightColl = _refineInitialLayout(slices, radius, pieCenter, availSpace, rightLabels, 'right');
    if (leftColl === _HALF_COLLISION && rightColl !== _NO_COLLISION) {
        _columnLabels(slices, availSpace, pieCenter, radius, leftLabels, true, true, true);
    }
    if (leftColl !== _NO_COLLISION && rightColl === _HALF_COLLISION) {
        _columnLabels(slices, availSpace, pieCenter, radius, rightLabels, false, true, true);
    }
    setLabelsAndFeelers(leftLabels, availSpace, pieCenter, radius, 'left', { fontSize: defaultFontSize }, getTextDimensions);
    setLabelsAndFeelers(rightLabels, availSpace, pieCenter, radius, 'right', { fontSize: defaultFontSize }, getTextDimensions);
    return { insideLabels, rightLabels, leftLabels };
};
function generateInitialLayout(slices, outsideLabels, availSpace, center, radius, defaultFontSize, getTextDimensions) {
    const leftLabels = [];
    const rightLabels = [];
    const { cx, cy } = center;
    for (let i = 0; i < slices.length; i++) {
        const slice = slices[i];
        const { labelPosition, startAngle, angleExtent, label, labelStyle } = slice;
        if (label == null ||
            labelPosition == 'none' ||
            labelPosition == 'inside' ||
            skipSliceLabel(slices[i], slices.length) ||
            !outsideLabels.has(slice.index)) {
            continue;
        }
        let middleAngle = startAngle + angleExtent / 2;
        if (middleAngle > 360)
            middleAngle -= 360;
        if (middleAngle < 0)
            middleAngle += 360;
        const labelPt = reflectAngleOverYAxis(middleAngle, cx, cy, radius * OUTSIDE_LABEL_DISTANCE, radius * OUTSIDE_LABEL_DISTANCE);
        const isLeftSide = middleAngle >= 90 && middleAngle < 270;
        const maxLabelWidth = getMaxLabelWidth(availSpace, labelPt.x, isLeftSide);
        const textInfo = getTextInfo(label, { fontSize: defaultFontSize, ...labelStyle }, maxLabelWidth, Infinity, true, 1, getTextDimensions);
        const tmDimPt = { x: textInfo.width, y: textInfo.height };
        const midArea = 15;
        if (middleAngle < 180 - midArea && middleAngle > midArea) {
            //upper half
            labelPt.y -= tmDimPt.y * 1;
        }
        else if (middleAngle < midArea || middleAngle > 360 - midArea) {
            //right side, near horizontal
            labelPt.y -= tmDimPt.y * 0.5;
            labelPt.x += tmDimPt.y * 0.2;
        }
        else if (middleAngle > 180 - midArea && middleAngle < 180 + midArea) {
            //left side, near horizontal
            labelPt.y -= tmDimPt.y * 0.5;
            labelPt.x -= tmDimPt.y * 0.2;
        }
        if (slices.length == 1)
            // only 1 label
            labelPt.x -= tmDimPt.x / 2; //position the label at the center
        if (labelPt.y < availSpace.y || labelPt.y + tmDimPt.y > availSpace.y + availSpace.height)
            // label will not fit with appropriate spacing
            continue;
        let pa;
        if (middleAngle >= 90.0 && middleAngle < 270.0) {
            pa = middleAngle - 90.0;
            createLabelInfo(slice, middleAngle, pa, tmDimPt, labelPt, textInfo, leftLabels);
        }
        else {
            // right side
            // normalize from 0 to 180
            pa = middleAngle <= 90.0 ? Math.abs(90 - middleAngle) : 180 - (middleAngle - 270);
            createLabelInfo(slice, middleAngle, pa, tmDimPt, labelPt, textInfo, rightLabels);
        }
    }
    return { leftLabels, rightLabels };
}
function getMaxLabelWidth(availSpace, labelX, isLeftSide) {
    return isLeftSide ? labelX - availSpace.x : availSpace.x + availSpace.width - labelX;
}
function createLabelInfo(slice, midAngle, position, tmDimPt, labelPt, textInfo, labelInfoArray) {
    let insertPos = -1;
    // insertion "sort"
    for (let j = 0; j < labelInfoArray.length; j++) {
        const labelInfo = labelInfoArray[j];
        if (labelInfo['position'] && labelInfo['position'] > position) {
            insertPos = j;
            break;
        }
    }
    if (insertPos == -1)
        insertPos = labelInfoArray.length;
    const labelInfo = {
        position,
        angle: midAngle,
        width: tmDimPt.x,
        height: tmDimPt.y,
        x: labelPt.x,
        y: labelPt.y,
        slice,
        textInfo
    };
    labelInfoArray.splice(insertPos, 0, labelInfo);
}
function _refineInitialLayout(slices, radius, center, availableSpace, labelInfoArray, side) {
    if (labelInfoArray.length < 1) {
        return;
    }
    let lastY = availableSpace.y; //think again!!
    let collisionTop = false;
    let collisionCentral = false;
    let collisionBottom = false;
    let labelBottom = 0;
    let labelInfo;
    let bottomQuarter = false;
    let prevBottomQuarter;
    let collide = false;
    const isLeftSideLabels = side == 'left';
    for (let i = 0; i < labelInfoArray.length; i++) {
        labelInfo = labelInfoArray[i];
        prevBottomQuarter = bottomQuarter;
        if (labelInfo.position > 90)
            bottomQuarter = true;
        labelBottom = labelInfo.y + labelInfo.height;
        collide = lastY - labelInfo.y > _COLLISION_MARGIN;
        if (collide) {
            if (!bottomQuarter) {
                collisionTop = true;
            }
            else if (!prevBottomQuarter) {
                collisionCentral = true;
            }
            else {
                collisionBottom = true;
            }
        }
        if (labelBottom > lastY) {
            lastY = labelBottom;
        }
    }
    if ((collisionTop && collisionBottom) || collisionCentral) {
        _columnLabels(slices, availableSpace, center, radius, labelInfoArray, isLeftSideLabels, true, true);
        return _ALL_COLLISION;
    }
    else if (collisionTop) {
        _columnLabels(slices, availableSpace, center, radius, labelInfoArray, isLeftSideLabels, true, false);
        return _HALF_COLLISION;
    }
    else if (collisionBottom) {
        _columnLabels(slices, availableSpace, center, radius, labelInfoArray, isLeftSideLabels, false, true);
        return _HALF_COLLISION;
    }
    return _NO_COLLISION;
}
function _getRadFeelerAngle(labelInfo, x, y, radius, center) {
    const ma = labelInfo.angle;
    const startPt = reflectAngleOverYAxis(ma, center.cx, center.cy, radius, radius);
    return Math.atan2(Math.abs(x - startPt.x), startPt.y - y);
}
function getMiddleLabel(alabels) {
    let bestAngle = 91;
    let bestIndex = -1;
    for (let i = 0; i < alabels.length; i++) {
        const pa = alabels[i]['position'];
        if (Math.abs(pa - 90) < bestAngle) {
            bestAngle = Math.abs(pa - 90);
            bestIndex = i;
        }
    }
    return bestIndex;
}
function setOptimalLabelPos(radius, labelInfo, vertX, center) {
    //set optimal X
    labelInfo['x'] = vertX;
    const b = radius * (1 + _FEELER_RAD_MINSIZE);
    const angleInRad = degreesToRads(labelInfo['position']);
    const heightFromCenter = b * Math.cos(angleInRad);
    const tilt = 0;
    let optimalY = center.cy - heightFromCenter - labelInfo.height * _LABEL_TO_FEELER_OFFSET + tilt;
    const _minY = labelInfo['minY'];
    const _maxY = labelInfo['maxY'];
    if (_minY <= _maxY) {
        optimalY = Math.max(optimalY, _minY);
        optimalY = Math.min(optimalY, _maxY);
    }
    labelInfo['y'] = optimalY;
}
function _columnLabels(slices, availableSpace, center, radius, alabels, isLeft, isTop, isBottom) {
    const frame = availableSpace;
    let minY = frame.y;
    let maxY = frame.y + frame.height;
    let i;
    let labelInfo;
    let pa = 0;
    let radFeelerAngle;
    //determine the position where the column will be aligned
    let vertX = center.cx;
    let feelerX;
    const minFeelerDist = radius * (1 + _FEELER_RAD_MINSIZE + _FEELER_HORIZ_MINSIZE);
    if (isLeft) {
        vertX -= minFeelerDist;
        feelerX = vertX + radius * _FEELER_HORIZ_MINSIZE;
    }
    else {
        vertX += minFeelerDist;
        feelerX = vertX - radius * _FEELER_HORIZ_MINSIZE;
    }
    //set the minimum heights that ensures as many labels as possible are displayed
    for (i = 0; i < alabels.length; i++) {
        labelInfo = alabels[i];
        pa = degreesToRads(labelInfo.position);
        radFeelerAngle = _getRadFeelerAngle(labelInfo, feelerX, minY, radius, center);
        // Remove labels that are more than a certain angle away from the slice.
        if (radFeelerAngle - pa > 0.45 * Math.PI || skipSliceLabel(alabels[i].slice, slices.length)) {
            alabels.splice(i, 1);
            i--;
        }
        else {
            alabels[i].minY = minY;
            minY += alabels[i].height;
        }
    }
    //set the maximum heights that ensures as many labels as possible are displayed
    for (i = alabels.length - 1; i >= 0; i--) {
        labelInfo = alabels[i];
        const position = labelInfo['position'];
        pa = degreesToRads(position);
        radFeelerAngle = _getRadFeelerAngle(labelInfo, feelerX, maxY, radius, center);
        // Remove labels that are more than a certain angle away from the slice.
        if (pa - radFeelerAngle > 0.45 * Math.PI || skipSliceLabel(alabels[i].slice, slices.length)) {
            alabels.splice(i, 1);
        }
        else {
            maxY -= alabels[i].height;
            alabels[i].maxY = maxY;
        }
    }
    if (alabels.length == 0)
        return;
    const startIndex = getMiddleLabel(alabels);
    const startLabel = alabels[startIndex];
    //if the column is only partial but there are too many labels, then set the whole side as column
    if (isTop && !isBottom) {
        if (startLabel.minY + startLabel.height > center.cy) {
            isBottom = true;
        }
    }
    if (isBottom && !isTop) {
        if (startLabel.maxY < center.cy) {
            isTop = true;
        }
    }
    const labelPostion = startLabel['position'];
    if ((isBottom && isTop) || (labelPostion > 90 && isBottom) || (labelPostion <= 90 && isTop)) {
        setOptimalLabelPos(radius, startLabel, vertX, center);
        startLabel.slice.hasFeelers = true;
    }
    let highestY = startLabel.y;
    let lowestY = startLabel.y + startLabel.height;
    let optimalY;
    let labelHeight;
    if (isTop) {
        //labels above the start label
        for (i = startIndex - 1; i >= 0; i--) {
            labelInfo = alabels[i];
            labelHeight = labelInfo.height;
            setOptimalLabelPos(radius, labelInfo, vertX, center);
            labelInfo.slice.hasFeelers = true;
            //avoid collision with the label below
            optimalY = labelInfo.y;
            if (optimalY + labelHeight < highestY) {
                highestY = optimalY;
            }
            else {
                highestY -= labelHeight;
            }
            labelInfo.y = highestY;
        }
    }
    if (isBottom) {
        //labels below the start label
        for (i = startIndex + 1; i < alabels.length; i++) {
            labelInfo = alabels[i];
            labelHeight = labelInfo.height;
            setOptimalLabelPos(radius, labelInfo, vertX, center);
            labelInfo.slice.hasFeelers = true;
            //avoid collision with the label above
            optimalY = labelInfo.y;
            if (optimalY > lowestY) {
                lowestY = optimalY + labelHeight;
            }
            else {
                lowestY += labelHeight;
            }
            labelInfo.y = lowestY - labelHeight;
        }
    }
}
function setLabelsAndFeelers(alabels, availSpace, center, radius, side, labelStyle, getTextDimension) {
    if (alabels == null || alabels.length <= 0)
        return;
    let i;
    let slice;
    let sliceLabel;
    const isLeftSide = side === 'left';
    const frame = availSpace;
    let excessWidth = Infinity;
    let excessLength;
    // Determine how much the horizontal feelers can be shortened
    for (i = 0; i < alabels.length; i++) {
        const labelInfo = alabels[i];
        const style = { ...labelStyle, ...labelInfo.slice.labelStyle };
        if (labelInfo.slice['hasFeelers']) {
            excessLength = _calculateFeeler(labelInfo, center, radius, isLeftSide);
            const fontHeight = getTextDimension('MW', style).height;
            const labelWidth = labelInfo['width'];
            const minLabelWidth = Math.min(2 * fontHeight, labelWidth);
            const maxLabelWidth = getMaxLabelWidth(availSpace, labelInfo['x'], isLeftSide);
            // Remove feelers for labels that will not be rendered and ignore for excess width calculation
            if (maxLabelWidth + excessLength < minLabelWidth || labelInfo['width'] == 0) {
                labelInfo.textInfo = undefined;
                labelInfo.slice.hasFeelers = false;
                continue;
            }
            excessWidth = Math.min(excessWidth, excessLength);
        }
        else {
            labelInfo.slice.hasFeelers = false;
        }
    }
    for (i = 0; i < alabels.length; i++) {
        const labelInfo = alabels[i];
        slice = labelInfo.slice;
        sliceLabel = labelInfo.slice.label;
        if (!sliceLabel)
            continue;
        if (labelInfo.slice.hasFeelers) {
            // shorten the horizontal feelers
            if (isLeftSide) {
                labelInfo.x = labelInfo.x + excessWidth;
            }
            else {
                labelInfo.x = labelInfo.x - excessWidth;
            }
            // setup the feeler line (let it clip if needed)
            _calculateFeeler(labelInfo, center, radius, isLeftSide);
        }
        // perform 'logical' clipping ourselves
        if (labelInfo.y < frame.y || labelInfo.y + labelInfo.height > frame.y + frame.height) {
            slice.label = '';
            slice.hasFeelers = false;
        }
        else {
            const maxLabelWidth = getMaxLabelWidth(availSpace, labelInfo.x, isLeftSide);
            const textInfo = labelInfo.textInfo &&
                getTextInfo(labelInfo.slice.label, { ...labelStyle, ...labelInfo.slice.labelStyle }, maxLabelWidth, labelInfo.textInfo.height, true, 1, getTextDimension);
            labelInfo.textInfo = textInfo;
            if (labelInfo.height === 0 || labelInfo.width === 0) {
                slice.label = '';
                slice.hasFeelers = false;
            }
        }
    }
}
function _calculateFeeler(labelInfo, center, radius, isLeft) {
    const { x, y, height } = labelInfo;
    let targetX = x;
    const targetY = y + height * _LABEL_TO_FEELER_OFFSET;
    const minHorizLength = _FEELER_HORIZ_MINSIZE * radius;
    let midX;
    if (isLeft) {
        targetX += _LABEL_TO_FEELER_DISTANCE;
        midX = targetX + minHorizLength;
    }
    else {
        targetX -= _LABEL_TO_FEELER_DISTANCE;
        midX = targetX - minHorizLength;
    }
    const midPt = {
        x: midX,
        y: targetY
    };
    const endPt = {
        x: targetX,
        y: targetY
    };
    const ma = labelInfo.angle;
    const startPt = reflectAngleOverYAxis(ma, center.cx, center.cy, radius, radius);
    // make set the first section of the feeler radial if possible
    const pa = degreesToRads(labelInfo['position']);
    const radFeelerAngle = Math.abs(Math.atan2(midPt.x - startPt.x, startPt.y - midPt.y));
    const horizOffset = (startPt.y - midPt.y) * Math.tan(pa); // * pieChart.getRadiusX() / pieChart.getRadiusY();
    if ((pa > Math.PI / 2 && radFeelerAngle > Math.PI / 2 && radFeelerAngle < pa) ||
        (pa < Math.PI / 2 && radFeelerAngle < Math.PI / 2 && radFeelerAngle > pa)) {
        if (isLeft) {
            midPt.x = startPt.x - horizOffset;
        }
        else {
            midPt.x = startPt.x + horizOffset;
        }
    }
    //store outside feeler points on slice
    //and let slice draw the feeler so that we can
    //easily redraw it when selecting
    labelInfo['startPt'] = startPt;
    labelInfo['midPt'] = midPt;
    labelInfo['endPt'] = endPt;
    return Math.abs(endPt.x - midPt.x) - minHorizLength;
}

function PieChartLabel({ pieLabelInfo, labelPos, fontSize, isRtl }) {
    const { x, y, textInfo, slice, startPt, midPt, endPt } = pieLabelInfo;
    const color = slice.color;
    const fill = labelPos === 'inside' ? getContrastingTextColor(color) : undefined;
    return (jsx(Fragment, { children: textInfo?.lines.map((line, i) => {
            const lineX = x;
            const lineY = y + (i + 0.5) * textInfo.dims[i].height;
            const textAnchor = (isRtl && labelPos === 'left') || (!isRtl && labelPos === 'right')
                ? 'start'
                : labelPos === 'inside'
                    ? 'middle'
                    : 'end';
            return (jsxs(Fragment, { children: [slice.label && (jsx("text", { className: styles.labelStyle, x: lineX, y: lineY, textAnchor: textAnchor, dominantBaseline: labelPos === 'inside' ? 'center' : 'middle', style: {
                            fill,
                            fontSize
                        }, children: line })), slice.hasFeelers && startPt && midPt && endPt && (jsxs(Fragment, { children: [jsx("line", { x1: startPt.x, x2: midPt.x, y1: startPt.y, y2: midPt.y, className: styles.fillerLineStyle }), jsx("line", { x1: endPt.x, x2: midPt.x, y1: endPt.y, y2: midPt.y, className: styles.fillerLineStyle })] }))] }));
        }) }));
}

const NUM_PIE_SLICE_THRESHOLD = 100;
const chartVars = getChartVars();
function PieChartWithDimensions({ width, height, testId, innerRadius = 0, contextMenuConfig, drilling = 'off', selectionMode = 'none', onItemDrill, onItemHover, onItemFocus, ...props }) {
    const rootRef = useRef(null);
    const { direction } = useUser();
    const isRtl = direction === 'rtl';
    const { resolvedVars, cssContent } = useCssVars(chartVars);
    const colors = Array.from(Array(12)).map((_, index) => {
        return resolvedVars[`color${index + 1}`];
    });
    const data = isRtl ? props.data.slice().reverse() : props.data;
    const { totalValue, isLabelOutside } = getPieChartInfo(data);
    const sliceInfos = getSliceInfo(data, totalValue, colors, isRtl);
    const hasData = data.length > 0;
    // default data item gaps is 0.5. TODO: replace 0.5 with pie dataItemGaps/pieSliceGaps
    const pieSliceGap = getPieSliceGap(0.5);
    const hasLargeSeriesCount = data.length > NUM_PIE_SLICE_THRESHOLD;
    const testIdProps = useTestId(testId);
    const availSpace = getAvailSpace(width, height, false);
    const { cx, cy } = getPieCenter(availSpace);
    const radius = getRadius(availSpace, isLabelOutside);
    const ir = innerRadius * radius;
    const renderedSlices = getRenderedSlices(sliceInfos, hasLargeSeriesCount, radius);
    const { getDetailFromInfo, getNextChartItem } = getPieChartNavUtils(data, direction === 'rtl');
    const { textMeasureContent, getTextDimensions } = useTextDimensions();
    const supportsSelection = !!(selectionMode && selectionMode !== 'none');
    const supportsDrill = drilling === 'on';
    // const isReadOnly = !supportsSelection && !supportsDrill && onItemHover === null && onItemFocus === null;
    const { touchResponse, touchResponseStyle } = useVisTouchResponse({
        type: 'auto',
        supportsTouchDragGestures: false,
        rootRef
    });
    const { activeId, focusedItemInfo, hoveredItemInfo, eventsProps, onContextMenuDismissed } = usePieChartNav(touchResponse, getDetailFromInfo, getNextChartItem, drilling, onItemDrill);
    const activeItem = focusedItemInfo.isFocusVisible ? focusedItemInfo : hoveredItemInfo;
    const activeData = activeItem ? data[renderedSlices[activeItem.itemIndex].index] : undefined;
    const defaultDatatip = (activeData, activeItem) => {
        if (!activeData) {
            return {
                content: undefined,
                borderColor: undefined
            };
        }
        if (activeData.accessibleLabel) {
            return {
                content: activeData.accessibleLabel,
                borderColor: getDefaultBorderColor(colors, activeItem, activeData)
            };
        }
        return {
            content: (jsx(VisTabularDatatip, { tableData: [
                    {
                        key: 'Value',
                        value: activeData.value
                    }
                ] })),
            borderColor: getDefaultBorderColor(colors, activeItem, activeData)
        };
    };
    const { content: datatipString, borderColor } = activeData && props.datatip
        ? props.datatip({ data: activeData })
        : defaultDatatip(activeData, activeItem);
    const anchor = focusedItemInfo.isFocusVisible ? 'element' : 'pointer';
    const elementBounds = activeItem?.isFocusVisible
        ? getElementBounds(renderedSlices, cx, cy, ir, radius, activeItem)
        : undefined;
    const offset = calculateOffset(isRtl, width, elementBounds);
    const { datatipContent, datatipProps } = useDatatip({
        content: datatipString,
        offset,
        anchor,
        placement: 'top-start',
        borderColor,
        touchResponse
    });
    datatipProps['aria-describedby'] = l([
        props['aria-describedby'],
        datatipProps['aria-describedby']
    ]);
    const { contextMenuContent, contextMenuProps } = usePieChartContextMenu({
        offset,
        rootRef,
        contextMenuConfig: hasData ? contextMenuConfig : undefined,
        onContextMenuDismissed,
        focusedItemInfo,
        items: sliceInfos,
        width,
        isRtl
    });
    const mergedProps = mergeProps(eventsProps, datatipProps, contextMenuProps);
    let insideLabels = [];
    let rightLabels = [];
    let leftLabels = [];
    const defaultFontSize = resolvedVars['labelFontSize'];
    if (getTextDimensions) {
        const labels = layoutPieChartLabels(renderedSlices, { cx, cy }, ir, radius, availSpace, getTextDimensions, defaultFontSize);
        insideLabels = labels.insideLabels;
        rightLabels = labels.rightLabels;
        leftLabels = labels.leftLabels;
    }
    return (jsxs("div", { ref: rootRef, tabIndex: 0, "aria-label": props['aria-label'], "aria-labelledby": props['aria-labelledby'], "aria-activedescendant": activeId, role: "application", ...mergedProps, ...testIdProps, className: styles.chart, style: {
            width,
            height,
            ...touchResponseStyle
        }, children: [renderedSlices.length > 0 && (jsxs("svg", { className: styles.svg, children: [renderedSlices.map((item, index) => {
                        return (jsx(PieSlice, { isInteractive: supportsSelection || supportsDrill, cx: cx, cy: cy, itemIndex: index, id: activeItem?.itemIndex === index ? activeId : undefined, isFocused: focusedItemInfo?.itemIndex === index && focusedItemInfo?.isFocusVisible, isHovered: hoveredItemInfo?.itemIndex === index, r: radius, startAngle: item.startAngle, gap: pieSliceGap, innerRadius: ir, angleExtent: item.angleExtent, color: item.color, accessibleLabel: item.accessibleLabel }, item.id));
                    }), insideLabels?.map((v) => {
                        return (jsx(PieChartLabel, { isRtl: isRtl, pieLabelInfo: v, labelPos: "inside", fontSize: defaultFontSize }));
                    }), leftLabels?.map((v) => {
                        return (jsx(PieChartLabel, { isRtl: isRtl, pieLabelInfo: v, labelPos: "left", fontSize: defaultFontSize }));
                    }), rightLabels?.map((v) => {
                        return (jsx(PieChartLabel, { isRtl: isRtl, pieLabelInfo: v, labelPos: "right", fontSize: defaultFontSize }));
                    })] })), props.children?.(getCenterContext(cx, cy, ir)), datatipContent, cssContent, contextMenuContent, textMeasureContent] }));
}

/**
 * Pie charts are useful for visualizing parts of a whole, but do not display zero or negative values so they are not recommended for data sets that may have negative or null data
 */
function PieChart({ width, height, ...props }) {
    return (jsx(TrackResizeContainer, { width: width, height: height, class: dimensionStyle, children: (width, height) => jsx(PieChartWithDimensions, { width: width, height: height, ...props }) }));
}

export { PieChart };
//# sourceMappingURL=UNSAFE_PieChart.js.map
