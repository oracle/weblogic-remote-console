/* @oracle/oraclejet-preact: undefined */
import { jsx, jsxs, Fragment } from 'preact/jsx-runtime';
import { createElement } from 'preact';
import { styles } from './PRIVATE_Chart/themes/ChartStyles.css.js';
import { c as classNames } from './classNames-4e12b00d.js';
import { k as getBarGapsInfo, l as getMixedFreqGroupCenter } from './utils-adfaaca0.js';
import { s as supportsMobileScreenReader } from './accUtils-f6657e8e.js';
import { g as getContrastingTextColor } from './colorUtils-b3804ee8.js';

const HOVERED_INNER_INSET = 1.5;
const SELECTED_INNER_INSET = 2.5;
/**
 * The rect representing the bar item.
 * @param props
 * @returns
 */
function Bar(props) {
    const isInteractive = props.isSelected || props.isFocused;
    if (isInteractive) {
        return jsx(InteractiveBar, { ...props });
    }
    return (jsx("rect", { x: props.x, y: props.y, "data-oj-private-series-index": props.seriesIndex, "data-oj-private-group-index": props.groupIndex, "data-oj-private-object": "bar", "aria-label": props['aria-label'], role: props['aria-label'] ? 'img' : undefined, id: props.activeId, style: {
            width: props.width,
            height: props.height,
            fill: props.fill,
            stroke: props.stroke,
            strokeWidth: props.strokeWidth
        }, class: classNames([
            props.isPointerEnabled ? styles.cursorEnable : undefined,
            props.isDimmed ? styles.dimmed : undefined
        ]) }));
}
/**
 * The selected or hovered selected bar.
 */
function InteractiveBar(props) {
    const { x, y, width, height, fill, isSelected, isFocused } = props;
    const inset = isSelected ? SELECTED_INNER_INSET : HOVERED_INNER_INSET;
    return (jsxs("g", { id: props.activeId, "data-oj-private-object": "bar", "data-oj-private-series-index": props.seriesIndex, "data-oj-private-group-index": props.groupIndex, className: props.isDimmed ? styles.dimmed : '', role: props['aria-label'] ? 'img' : undefined, "aria-label": props['aria-label'], children: [jsx("rect", { x: x, y: y, class: classNames([isSelected ? styles.selectedBorder : '']), style: {
                    width: width,
                    height: height,
                    fill: !isSelected && isFocused ? fill : undefined
                } }), jsx("rect", { x: x + inset, y: y + inset, class: classNames([
                    styles.contrastBorder,
                    props.isPointerEnabled ? styles.cursorEnable : undefined
                ]), style: {
                    width: width - 2 * inset,
                    height: height - 2 * inset,
                    fill: fill
                } })] }));
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
function getBarProps(item, series, seriesColor) {
    const fill = item.color || series.color || seriesColor;
    const stroke = item.borderColor || series.borderColor;
    return { fill, stroke };
}
/**
 * Returns the coordinate of bar rect.
 * @param x1 The bar start coordinate in x axis.
 * @param x2 The bar end coordinate in x axis.
 * @param endCoord The coordinate of bar top in y axis.
 * @param baselineCoord The coordinate of bar base in y axis.
 * @param isHoriz Whether the chart is horizontal chart.
 * @returns
 */
function getRectCoord(x1, x2, endCoord, baselineCoord, isHoriz) {
    let x;
    let y;
    let width;
    let height;
    let x_1 = x1;
    let x_2 = x2;
    // Bar width has to be at least 1px to prevent disappearing bars
    let barWidth = x2 - x1;
    if (barWidth < 1) {
        x_1 = Math.floor(x_1);
        x_2 = x_1 + 1;
        barWidth = 1;
    }
    if (!isHoriz) {
        x = x_1;
        y = endCoord > baselineCoord ? baselineCoord : endCoord;
        width = Math.abs(x_2 - x_1);
        height = Math.abs(baselineCoord - endCoord);
    }
    else {
        y = x_1;
        x = endCoord > baselineCoord ? baselineCoord : endCoord;
        width = Math.abs(baselineCoord - endCoord);
        height = Math.abs(x_2 - x_1);
    }
    return { x, y, width, height };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Returns the base and end coordinate of the bar.
 * @param value The value of the bar item.
 * @param yScale The yscale.
 * @param isStacked Whether the bar chart is stacked or not.
 * @param isLog Whether the y axis is in log scale.
 * @param itemsGaps The gap between data item.
 * @param negCummulativeValue The negative cummulative value of the group.
 * @param posCummulativeValue The positive cummulative value of the group.
 * @returns
 */
function getBaseAndEndCoord(value, yScale, isStacked, isLog, itemsGaps, negCummulativeValue, posCummulativeValue) {
    let baselineCoord;
    let endCoord;
    if (isStacked) {
        baselineCoord = yScale.transform(value < 0 ? negCummulativeValue : posCummulativeValue);
        negCummulativeValue += value < 0 ? value : 0;
        posCummulativeValue += value > 0 ? value : 0;
        endCoord = yScale.transform(value < 0 ? negCummulativeValue : posCummulativeValue);
        baselineCoord += endCoord > baselineCoord ? itemsGaps : -itemsGaps;
    }
    else {
        baselineCoord = isLog ? yScale.range()[0] : yScale.transform(0);
        endCoord = yScale.transform(value);
    }
    return { baselineCoord, endCoord };
}
function getBarPosition(series, groups, getDataItem, xScale, yScale, y2Scale, hiddenIds, dataItemGaps, axisStepWidth, averageGroupZ, barGapRatio, isLog, isStacked, isRtl, isHoriz, isSplitDualY, timeAxisType) {
    const seriesY = series.filter((series) => series.associatedYAxis !== 'y2');
    const seriesY2 = series.filter((s) => s.associatedYAxis === 'y2');
    const numSeriesY = seriesY.length;
    const numSeriesY2 = seriesY2.length;
    return (seriesIndex, groupIndex) => {
        const seriesItem = series[seriesIndex];
        const isAssociatedToY2 = seriesItem.associatedYAxis === 'y2';
        const numOfSeries = series.length;
        let yPosCumulativeValue = 0;
        let yNegCumulativeValue = 0;
        let y2PosCumulativeValue = 0;
        let y2NegCumulativeValue = 0;
        for (let index = 0; index < numOfSeries; index += 1) {
            const item = getDataItem(index, groupIndex);
            let xVal = groupIndex;
            if (timeAxisType) {
                const val = timeAxisType === 'mixedFrequency'
                    ? getDataItem(seriesIndex, groupIndex)?.x
                    : groups[groupIndex].id;
                xVal = new Date(val).getTime();
            }
            if (!item || hiddenIds?.has(item.id) || (isLog && item.value <= 0)) {
                continue;
            }
            const groupCenter = xScale.transform(xVal);
            const splitIndex = (isAssociatedToY2 ? seriesY2 : seriesY).findIndex((value) => value.id === seriesItem.id);
            const { barWidth, offset, itemsGaps } = getBarGapsInfo(isSplitDualY ? splitIndex : index, groupIndex, series[index], axisStepWidth, averageGroupZ, getDataItem, barGapRatio, isSplitDualY ? numSeriesY : series.length, isSplitDualY ? numSeriesY2 : series.length, dataItemGaps, isStacked, isRtl, isHoriz);
            const x1 = groupCenter + offset;
            const x2 = x1 + barWidth;
            const { baselineCoord, endCoord } = getBaseAndEndCoord(item.value, isAssociatedToY2 ? y2Scale : yScale, isStacked, isLog, itemsGaps, isAssociatedToY2 ? y2NegCumulativeValue : yNegCumulativeValue, isAssociatedToY2 ? y2PosCumulativeValue : yPosCumulativeValue);
            if (isAssociatedToY2) {
                y2NegCumulativeValue += item.value < 0 ? item.value : 0;
                y2PosCumulativeValue += item.value > 0 ? item.value : 0;
            }
            else {
                yNegCumulativeValue += item.value < 0 ? item.value : 0;
                yPosCumulativeValue += item.value > 0 ? item.value : 0;
            }
            if (seriesIndex === index) {
                return getRectCoord(x1, x2, endCoord, baselineCoord, isHoriz);
            }
        }
        return;
    };
}
/**
 * Returns the center coordinate of the bar item.
 * @param value
 * @param yScale
 * @param isStacked
 * @param isLog
 * @param dataItemGaps
 * @param negCummValue
 * @param posCummValue
 * @returns
 */
function getBarCenterCoordinate(value, yScale, isStacked, isLog, dataItemGaps, negCummValue, posCummValue) {
    const { baselineCoord, endCoord } = getBaseAndEndCoord(value, yScale, isStacked, isLog, dataItemGaps, negCummValue, posCummValue);
    return (baselineCoord + endCoord) / 2;
}
function getSeriesOffsetAndWidth(axisStepWidth, averageGroupZ, series, getDataItem, barGapRatio, dataItemGaps, isStacked, isRtl, isHoriz) {
    const seriesY = series.filter((series) => series.associatedYAxis !== 'y2');
    const numSeriesY = seriesY.length;
    const numSeriesY2 = series.length - numSeriesY;
    return (seriesIndex, groupIndex) => {
        const { offset, barWidth } = getBarGapsInfo(seriesIndex, groupIndex, series[seriesIndex], axisStepWidth, averageGroupZ, getDataItem, barGapRatio, numSeriesY, numSeriesY2, dataItemGaps, isStacked, isRtl, isHoriz);
        return { offset, dataWidth: barWidth };
    };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const LABEL_OFFSET = 2;
function getValueCoord(isHoriz, isRtl, isNegative, barDims) {
    if (isHoriz) {
        return (isNegative && !isRtl) || (!isNegative && isRtl) ? barDims.x : barDims.x + barDims.width;
    }
    return isNegative ? barDims.height + barDims.y : barDims.y;
}
function getLabelProps(isHoriz, isRtl, isNegative, barDims, dataLabelPosition, labelDims) {
    if (!labelDims) {
        return {};
    }
    const valueCoord = getValueCoord(isHoriz, isRtl, isNegative, barDims);
    if (dataLabelPosition === 'insideBarEdge') {
        return {
            y: isHoriz
                ? barDims.y + barDims.height / 2
                : valueCoord + (isNegative ? -1 : 1) * (labelDims.height / 2 + LABEL_OFFSET + 2),
            x: isHoriz
                ? valueCoord -
                    ((isNegative && !isRtl) || (!isNegative && isRtl) ? -1 : 1) *
                        (labelDims.width / 2 + LABEL_OFFSET)
                : barDims.x + barDims.width / 2
        };
    }
    if (dataLabelPosition === 'outsideBarEdge') {
        return {
            y: isHoriz
                ? barDims.y + barDims.height / 2
                : valueCoord - (isNegative ? -1 : 1) * (labelDims.height / 2 + LABEL_OFFSET),
            x: isHoriz
                ? valueCoord +
                    ((isNegative && !isRtl) || (!isNegative && isRtl) ? -1 : 1) *
                        (labelDims.width / 2 + LABEL_OFFSET)
                : barDims.x + barDims.width / 2
        };
    }
    return {
        x: barDims.x + barDims.width / 2,
        y: barDims.y + barDims.height / 2
    };
}
function canFitLabel(isHoriz, labelDims, barDims, labelPos) {
    if (isHoriz) {
        if (labelDims.height > barDims.height) {
            return false;
        }
        if (labelPos != 'outsideBarEdge') {
            return labelDims.width < barDims.width;
        }
        return true;
    }
    if (labelDims.width > barDims.width) {
        return false;
    }
    if (labelPos != 'outsideBarEdge') {
        return labelDims.height < barDims.height;
    }
    return true;
}
const getStackLabelProps = (groupCenterCoord, valueCoord, isNegative, isHoriz, isRtl, labelDims) => {
    return {
        y: isHoriz
            ? groupCenterCoord
            : valueCoord - (isNegative ? -1 : 1) * (labelDims.height / 2 + LABEL_OFFSET),
        x: isHoriz
            ? valueCoord +
                ((isNegative && !isRtl) || (!isNegative && isRtl) ? -1 : 1) *
                    (labelDims.width / 2 + LABEL_OFFSET)
            : groupCenterCoord
    };
};

function StackLabels({ groupCenter, getStackLabel, group, posValue, negValue, posItemsData, yScale, isHoriz, isRtl, negItemsData, defaultFontSize, labelStyle, getTextDimensions }) {
    const positiveStackLabel = getStackLabel({
        group,
        value: posValue,
        data: posItemsData
    });
    // default style used for text dims calc. should match with styles.stackLabelStyle
    const stackLabelStyle = { fontSize: defaultFontSize, fontWeight: 'bold', ...labelStyle };
    const negativeStackLabel = negValue < 0
        ? getStackLabel?.({
            group,
            value: negValue,
            data: negItemsData
        })
        : '';
    const posProps = getStackLabelProps(groupCenter, yScale.transform(posValue), false, isHoriz, isRtl, getTextDimensions(positiveStackLabel, stackLabelStyle));
    const negProps = getStackLabelProps(groupCenter, yScale.transform(negValue), true, isHoriz, isRtl, getTextDimensions(negativeStackLabel, stackLabelStyle));
    return (jsxs(Fragment, { children: [jsx("text", { class: styles.stackLabelStyle, style: stackLabelStyle, ...posProps, children: positiveStackLabel }), jsx("text", { class: styles.stackLabelStyle, style: stackLabelStyle, ...negProps, children: negativeStackLabel })] }));
}

function BarLabel({ item, seriesColor, isStacked, defaultFontSize, barDim, isRtl, isHoriz, getTextDimensions }) {
    let label = null;
    const position = !item.labelPosition || (item.labelPosition === 'outsideBarEdge' && isStacked)
        ? 'center'
        : item.labelPosition;
    const labelString = item.label;
    const color = item.color || seriesColor;
    const needsContrastColor = isStacked || !(position === 'outsideBarEdge');
    if (position != 'none' &&
        labelString &&
        getTextDimensions &&
        !(isStacked && position === 'outsideBarEdge')) {
        const labelStyle = {
            fontSize: defaultFontSize,
            fill: needsContrastColor ? getContrastingTextColor(color) : undefined,
            ...item.labelStyle
        };
        const labelDims = getTextDimensions(labelString, labelStyle);
        const canFit = canFitLabel(isHoriz, labelDims, barDim, position || 'center');
        label = canFit ? (jsx("text", { class: styles.dataLabelStyle, style: labelStyle, ...getLabelProps(isHoriz, isRtl, item.value < 0, barDim, position || 'center', getTextDimensions?.(labelString, labelStyle)), children: labelString })) : null;
    }
    return label;
}

function BarGroup({ yScale, y2Scale, xScale, colors, series, groupIndex, hiddenIds, barGapRatio, dataItemGaps, axisStepWidth, averageGroupZ, highlightedIds, selectedIds, isPointInsideMarquee, orientation, isLog, activeId, getDataItem, isRtl, isStacked, isSelectionEnabled, focusedItemInfo, hoveredItemInfo, isDrillEnabled, group, timeAxisType, getTextDimensions, defaultFontSize, stacklabelStyle, getStackLabel, getItemAriaLabel, splitDualY, seriesIndex, plotAreaClipPathId }) {
    const isHoriz = orientation === 'horizontal';
    const items = [];
    const seriesY = series.filter((s) => s.associatedYAxis !== 'y2');
    const seriesY2 = series.filter((s) => s.associatedYAxis === 'y2');
    const labels = [];
    const numSeriesY = seriesY.length;
    const numSeriesY2 = series.length - numSeriesY;
    let yPosCumulativeValue = isLog ? yScale.domain()[0] : 0;
    let yNegCumulativeValue = 0;
    const yPositiveValueItems = [];
    const yNegativeValueItems = [];
    let y2PosCumulativeValue = isLog ? y2Scale.domain()[0] : 0;
    let y2NegCumulativeValue = 0;
    const y2PositiveValueItems = [];
    const y2NegativeValueItems = [];
    const isStackLabelRendered = isStacked && !!getStackLabel && timeAxisType != 'mixedFrequency';
    let groupCenter = timeAxisType != 'mixedFrequency'
        ? xScale.transform(timeAxisType != undefined ? new Date(group.id).getTime() : groupIndex)
        : undefined;
    let isAssociatedToY2;
    const processSeries = (_seriesIndex) => {
        isAssociatedToY2 = series[_seriesIndex].associatedYAxis === 'y2';
        const item = getDataItem(_seriesIndex, groupIndex);
        if (!item || hiddenIds?.has(item.id) || (isLog && item.value <= 0)) {
            return;
        }
        if (timeAxisType === 'mixedFrequency') {
            groupCenter = getMixedFreqGroupCenter(xScale, item);
        }
        const isFocused = focusedItemInfo?.groupIndex === groupIndex &&
            focusedItemInfo?.seriesIndex === _seriesIndex &&
            focusedItemInfo?.isFocusVisible;
        const isHovered = hoveredItemInfo?.groupIndex === groupIndex &&
            hoveredItemInfo?.seriesIndex === _seriesIndex &&
            hoveredItemInfo?.isCurrent;
        const isFocusVisible = !!isFocused || (!!isHovered && isSelectionEnabled);
        const isActive = (isFocused && focusedItemInfo.isCurrent) || isHovered;
        const isHighlighted = highlightedIds === undefined || highlightedIds.size === 0 || highlightedIds.has(item.id);
        const isDrillable = item.drilling === 'on' || (item.drilling != 'off' && isDrillEnabled);
        const { barWidth, offset, itemsGaps } = getBarGapsInfo(splitDualY
            ? (isAssociatedToY2 ? seriesY2 : seriesY).findIndex((value) => value.id === series[_seriesIndex].id)
            : _seriesIndex, groupIndex, series[_seriesIndex], axisStepWidth, averageGroupZ, getDataItem, barGapRatio, splitDualY ? numSeriesY : series.length, splitDualY ? numSeriesY2 : series.length, dataItemGaps, isStacked, isRtl, isHoriz);
        const x1 = groupCenter + offset;
        const x2 = x1 + barWidth;
        const { baselineCoord, endCoord } = getBaseAndEndCoord(item.value, isAssociatedToY2 ? y2Scale : yScale, isStacked, isLog, itemsGaps, isAssociatedToY2 ? y2NegCumulativeValue : yNegCumulativeValue, isAssociatedToY2 ? y2PosCumulativeValue : yPosCumulativeValue);
        if (isAssociatedToY2) {
            y2NegCumulativeValue += item.value < 0 ? item.value : 0;
            y2PosCumulativeValue += item.value > 0 ? item.value : 0;
        }
        else {
            yNegCumulativeValue += item.value < 0 ? item.value : 0;
            yPosCumulativeValue += item.value > 0 ? item.value : 0;
        }
        if (isStackLabelRendered) {
            if (item.value >= 0) {
                if (isAssociatedToY2) {
                    y2PositiveValueItems.push(item);
                }
                else {
                    yPositiveValueItems.push(item);
                }
            }
            else {
                if (isAssociatedToY2) {
                    y2NegativeValueItems.push(item);
                }
                else {
                    yNegativeValueItems.push(item);
                }
            }
        }
        const barprops = getBarProps(item, series[_seriesIndex], colors?.[_seriesIndex]);
        const rectParam = getRectCoord(x1, x2, endCoord, baselineCoord, isHoriz);
        const isSelected = isPointInsideMarquee
            ? isPointInsideMarquee?.(item.id, {
                x: rectParam.x + rectParam.width / 2,
                y: rectParam.y
            })
            : selectedIds?.has(item.id);
        const ariaLabel = supportsMobileScreenReader || isActive
            ? getItemAriaLabel(item, _seriesIndex, groupIndex, isSelectionEnabled, !!isSelected, isDrillable)
            : '';
        items.push(createElement(Bar, { ...rectParam, ...barprops, seriesIndex: _seriesIndex, groupIndex: groupIndex, isFocused: isFocusVisible, activeId: isActive ? activeId : '', "aria-label": ariaLabel, isDimmed: !isHighlighted, isSelected: !!isSelected, isPointerEnabled: isDrillable || isSelectionEnabled, key: `${groupIndex};${_seriesIndex}` }));
        labels.push(jsx(BarLabel, { item: item, isRtl: isRtl, seriesColor: colors[_seriesIndex % 12], isStacked: isStacked, defaultFontSize: defaultFontSize, barDim: rectParam, isHoriz: isHoriz, getTextDimensions: getTextDimensions }));
    };
    if (seriesIndex !== undefined) {
        processSeries(seriesIndex);
    }
    else {
        series.forEach((_, index) => processSeries(index));
    }
    return (jsxs(Fragment, { children: [jsx("g", { "clip-path": plotAreaClipPathId, children: items }), labels, isStackLabelRendered && getTextDimensions && (jsx(StackLabels, { group: group, isRtl: isRtl, yScale: isAssociatedToY2 ? y2Scale : yScale, getStackLabel: getStackLabel, defaultFontSize: defaultFontSize, getTextDimensions: getTextDimensions, posItemsData: isAssociatedToY2 ? y2PositiveValueItems : yPositiveValueItems, negItemsData: isAssociatedToY2 ? y2NegativeValueItems : yNegativeValueItems, isHoriz: isHoriz, groupCenter: groupCenter, labelStyle: stacklabelStyle, posValue: isAssociatedToY2 ? y2PosCumulativeValue : yPosCumulativeValue, negValue: isAssociatedToY2 ? y2NegCumulativeValue : yNegCumulativeValue }))] }));
}

export { BarGroup as B, getSeriesOffsetAndWidth as a, getBarCenterCoordinate as b, getBarPosition as g };
//# sourceMappingURL=BarGroup-2c5ca597.js.map
