/* @oracle/oraclejet-preact: undefined */
import { jsx, jsxs, Fragment } from 'preact/jsx-runtime';
import { useContext, useMemo, useRef as useRef$1, useState as useState$1, useCallback as useCallback$1 } from 'preact/hooks';
import { u as useId } from './useId-03dbfdf0.js';
import { S as SvgCheck } from './Check-67a66daf.js';
import { S as SelectMenuGroupContext, B as BaseMenuItem, u as useMenuContainerContext, D as DropdownMenu, b as useMenuContext, c as MenuContainer } from './SelectMenuGroupContext-0c1a7603.js';
import { styles } from './UNSAFE_Menu/themes/MenuItemStyles.css.js';
import { useMemo as useMemo$1, useRef, useState, useEffect, useCallback, createPortal } from 'preact/compat';
import { D as DirectionalExpandArrowIcon } from './DirectionalExpandArrowIcon-4591d832.js';
import { s as scaleVars } from './themeContract.css-2b5a42e2.js';
import { u as useScale } from './useScale-0ebe15ed.js';
import { D as DirectionalCollapseArrowIcon } from './DirectionalCollapseArrowIcon-d9c9f9ac.js';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Utility hook for consuming the MenuContext
 *
 * @returns The value of MenuContext provider
 */
function useSelectMenuGroupContext() {
    return useContext(SelectMenuGroupContext);
}

function SelectMenuItem({ value, label, isDisabled, endIcon }) {
    const { isMultiple, value: selectedValue, onCommit, groupKey } = useSelectMenuGroupContext();
    const uniqueID = useId();
    const id = useMemo(() => `oj-menu-item-${uniqueID}`, [uniqueID]);
    const { isSelected, memoizedOnCommit } = useMemo(() => {
        if (!isMultiple) {
            return {
                isSelected: selectedValue === value,
                memoizedOnCommit: () => {
                    onCommit?.({ value, previousValue: selectedValue });
                }
            };
        }
        return {
            isSelected: !!selectedValue?.includes(value),
            memoizedOnCommit: () => {
                const proposedValue = isSelected
                    ? selectedValue?.filter((val) => val !== value) || []
                    : [...(selectedValue || []), value];
                onCommit?.({ value: proposedValue, previousValue: selectedValue });
            }
        };
    }, [selectedValue, value, onCommit, isMultiple]);
    return (jsx(BaseMenuItem, { id: id, type: "select", role: isMultiple ? 'menuitemcheckbox' : 'menuitemradio', isChecked: isSelected, isDisabled: isDisabled, startIcon: isSelected ? jsx(SvgCheck, {}) : jsx("span", { class: styles.noSelectedIcon }), label: label, onAction: memoizedOnCommit, endIcon: endIcon, itemKey: `${groupKey}-${value}` }));
}

function SelectSingleMenuGroup({ value, onCommit, children, groupKey }) {
    return (jsx(SelectMenuGroupContext.Provider, { value: { isMultiple: false, value, onCommit, groupKey }, children: children }));
}

const DropdownSubmenu = ({ label, children, startIcon, itemKey }) => {
    //Id of the submenu that will be used to connect via aria-owns, menuItem with its submenu
    const submenuId = useId();
    const preProcessedMenuItemID = useId();
    //MenuItem id
    const menuItemId = useMemo$1(() => `oj-menu-item-${preProcessedMenuItemID}`, [preProcessedMenuItemID]);
    const { changeKey, currentKey } = useMenuContainerContext();
    const submenuMenuItemRef = useRef(null);
    const dropdownSubmenuRef = useRef(null);
    const [isOpen, setIsOpen] = useState(false);
    const [currentFocus, setCurrentFocus] = useState('none');
    const [pxPerUnit, setPxPerUnit] = useState(DEFAULT_PX_PER_UNIT);
    const scale = useScale();
    useEffect(() => {
        // Important to have scale as a posible reason for running this effect since changing scale would produce a need of updating px per unit
        if (!scale || !scaleVars?.size?.units) {
            setPxPerUnit(0.25 * remInPx());
        }
        else {
            // We asume scale vars has the form of var(x), due to that we obtain string inside parenthesis, if not found empty string is passed
            const cssVar = /\(([^)]+)\)/.exec(scaleVars.size.units)?.[1] || '';
            // We try to get css var value, if this could not be obtained we use 0.25rem as fallback value
            const valueofCSSVar = window
                .getComputedStyle(submenuMenuItemRef.current)
                .getPropertyValue(cssVar);
            if (valueofCSSVar.endsWith('px')) {
                setPxPerUnit(parseFloat(valueofCSSVar));
            }
            else if (valueofCSSVar.endsWith('rem')) {
                setPxPerUnit(parseFloat(valueofCSSVar) * remInPx());
            }
            else {
                setPxPerUnit(0.25 * remInPx());
            }
        }
    }, [scale]);
    useEffect(() => {
        if (menuItemId !== currentKey) {
            setIsOpen(false);
        }
    }, [currentKey, menuItemId]);
    //This function is used when pressing submenuitem and hovering over it
    const openSubmenuAction = useCallback((e) => {
        submenuMenuItemRef.current?.focus();
        //If not click/touch we set the focus on the first item
        setIsOpen(true);
        if (e.type === 'keyup') {
            setCurrentFocus('firstItem');
        }
        else {
            setCurrentFocus('none');
        }
    }, []);
    //TODO: There is a bug in a Icon, once that bug is solved we have to check this again. JET-56980
    const hoverStatus = useRef({
        recentClose: false,
        pendingUnhover: false
    });
    return (jsxs(Fragment, { children: [jsx(BaseMenuItem, { itemKey: itemKey, startIcon: startIcon, id: menuItemId, submenuId: submenuId, ref: submenuMenuItemRef, label: label, endIcon: jsx(DirectionalExpandArrowIcon, {}), type: "submenu", role: "menuitem", onAction: openSubmenuAction, hoverInfo: {
                    //Specific hover events of submenuItem
                    hoverProps: {
                        onMouseEnter: (e) => {
                            openSubmenuAction(e);
                        }
                    },
                    hoverStatus
                }, 
                //Open submenu using right/left key
                openSubmenu: () => {
                    setIsOpen(true);
                    setCurrentFocus('firstItem');
                }, submenuRef: dropdownSubmenuRef, isSubmenuOpen: isOpen }), jsx(DropdownMenu, { isOpen: isOpen, menuLevel: "sub", menuId: submenuId, 
                //Close submenu with left/right key
                closeSubmenu: () => {
                    hoverStatus.current.recentClose = true;
                    changeKey({ key: currentKey, reason: 'keyboard' });
                    setTimeout(() => {
                        hoverStatus.current.recentClose = false;
                    }, HOVER_SHIFT_TIMEOUT);
                    setIsOpen(false);
                    //CurrentKey can be the same as submenuItem, because of that we explicitly focus it
                    submenuMenuItemRef.current?.focus();
                }, 
                /*For now we are exposing ref if this is exposed at some point we would look for other
                    mechanisms to use this ref */
                ref: dropdownSubmenuRef, anchorRef: submenuMenuItemRef, defaultPlacement: "end-top", currentFocus: currentFocus, offsetValue: {
                    mainAxis: -(2 * pxPerUnit), //TODO: need to figure out how to make this themable.
                    crossAxis: -(2 * pxPerUnit + 1)
                }, flipOptions: {
                    crossAxis: true,
                    mainAxis: true,
                    fallbackPlacements: ['start-top', 'end-bottom', 'start-bottom']
                }, children: children })] }));
};
const HOVER_SHIFT_TIMEOUT = 100;
const DEFAULT_PX_PER_UNIT = 4;
const remInPx = () => {
    return parseInt(window.getComputedStyle(document.documentElement).fontSize || '16px', 10);
};

const SheetSubmenu = ({ label, children, startIcon, itemKey }) => {
    const { isMobile } = useMenuContext();
    const submenuId = useId();
    const submenuItemId = useId();
    const submenuTitleId = useId();
    const submenuMenuItemRef = useRef$1(null);
    const [isOpen, setIsOpen] = useState$1(false);
    const [initialFocus, setInitialFocus] = useState$1('menu');
    const { menuContainerRef, changeKey } = useMenuContainerContext();
    const openSubmenuDirectional = useCallback$1(() => {
        openSubmenu();
        setInitialFocus('secondItem');
    }, []);
    const openSubmenuAction = useCallback$1((e) => {
        openSubmenu();
        //If the submenu is open using keyboard focus has to go to second item(first is the title), if not to the menu Container
        if (e.type === 'keyup') {
            setInitialFocus('secondItem');
        }
        else {
            if (isMobile) {
                setInitialFocus('secondItemDueToTouch');
            }
            else {
                setInitialFocus('menu');
            }
        }
    }, []);
    const returnFocusToSubmenuItem = useCallback$1(() => {
        changeKey({ key: submenuItemId, reason: 'keyboard' });
        submenuMenuItemRef.current?.focus();
    }, [changeKey, submenuItemId, submenuMenuItemRef]);
    /* No need to "save" these functions with useCallback */
    const openSubmenu = () => {
        /* Menu hidden instead of unmounted for two main reasons:
          1. Children need to be updated even if menu is not present.
          2. We can't unmount parent since all the submenus are children of main menu */
        menuContainerRef.current.style.display = 'none';
        setIsOpen(true);
    };
    const closeSubmenu = () => {
        setIsOpen(false);
        if (menuContainerRef.current) {
            //Submenu is unmounted and prev menu is visible again.
            /*Dom manipulation is kind of dirty. Have to check for new approaches. JET-57239 */
            menuContainerRef.current.style.display = 'block';
        }
    };
    const closeSubmenuPressingTitleItem = (e) => {
        closeSubmenu();
        //If the submenu is closed using keyboard focus has to go to submenuItem that opened submenu, if not to the menu Container
        if (e.type === 'keyup') {
            returnFocusToSubmenuItem();
        }
        else {
            if (isMobile) {
                changeKey({ key: submenuItemId, reason: 'touch' });
                // We need to add a little delay due to VO double tap producing focusing wrong item. Will be removed once animation is added for sheet submenus
                setTimeout(() => {
                    submenuMenuItemRef.current?.focus();
                }, 0);
            }
            else {
                changeKey({ key: undefined, reason: 'click' });
                menuContainerRef.current?.focus();
            }
        }
    };
    const closeDirectional = () => {
        closeSubmenu();
        returnFocusToSubmenuItem();
    };
    return (jsxs(Fragment, { children: [jsx(BaseMenuItem, { itemKey: itemKey, startIcon: startIcon, id: submenuItemId, submenuId: submenuId, ref: submenuMenuItemRef, label: label, endIcon: jsx(DirectionalExpandArrowIcon, {}), type: "submenu", role: "menuitem", onAction: openSubmenuAction, openSubmenu: openSubmenuDirectional, isSubmenuOpen: isOpen }), !isOpen
                ? null
                : // We need to use portal to ensure all submenus are siblings so if one dissapear not every submenu dissapear
                    createPortal(jsxs(MenuContainer, { display: "sheet", "aria-label": label, menuId: submenuId, closeSubmenu: closeDirectional, menuLevel: "sub", anchorRef: submenuMenuItemRef, 
                        //TODO: We need to check if this initial focus is desired based on some W3C specs
                        currentFocus: initialFocus, children: [jsx(BaseMenuItem, { id: submenuTitleId, menuItemLabelWeight: "bold", role: "menuitem", type: "submenu", startIcon: jsx(DirectionalCollapseArrowIcon, {}), onAction: closeSubmenuPressingTitleItem, label: label }), children] }), menuContainerRef.current?.parentElement)] }));
};

/*Submenu behaves differently depending the device */
const Submenu = (props) => {
    const { isMobile } = useMenuContext();
    return (jsx(Fragment, { children: isMobile ? (jsx(SheetSubmenu, { ...props })) : (jsx(DropdownSubmenu, { ...props })) }));
};

export { Submenu as S, SelectSingleMenuGroup as a, SelectMenuItem as b };
//# sourceMappingURL=Submenu-712f5f55.js.map
