/* @oracle/oraclejet-preact: undefined */
import { jsx, jsxs, Fragment } from 'preact/jsx-runtime';
import { a as MARKER_PADDING, M as Marker } from './Marker-81aae9f0.js';
import './SvgShapesStyles.styles.css';
import { r as getLabelPosition, s as getGroupCenterCoord, t as getMarkerFillAndStroke, q as isNonCurvedLine } from './utils-adfaaca0.js';
import { s as supportsMobileScreenReader } from './accUtils-f6657e8e.js';
import { styles } from './PRIVATE_Chart/themes/ChartStyles.css.js';
import { c as classNames } from './classNames-4e12b00d.js';
import { u as updateVisTextStyleProperties } from './textUtils-3ed25dd1.js';
import { g as getCmdsForLine } from './lineUtils-586f3e8a.js';

const DEFAULT_POSITION = 'center';
function MarkerLabel({ labelPosition, label, labelStyle, tx, ty, defaultFontSize, dataLabelEffect, isHighContrast, getTextDimensions }) {
    let markerLabel = null;
    const position = labelPosition ? labelPosition : DEFAULT_POSITION;
    const { dataLabelStyle, dataLabelContrast, highContrastLabelStyle } = styles;
    const labelString = label;
    if (position && labelString) {
        const markerLabelStyle = {
            fontSize: defaultFontSize,
            ...updateVisTextStyleProperties(labelStyle)
        };
        const labelDims = getTextDimensions?.(labelString, markerLabelStyle);
        const { x, y } = getLabelPosition(position, tx, ty, labelDims);
        markerLabel = (jsx("text", { x: x, y: y, class: classNames([
                dataLabelStyle,
                dataLabelEffect === 'outline' ? dataLabelContrast : '',
                isHighContrast ? highContrastLabelStyle : ''
            ]), style: markerLabelStyle, children: labelString }));
    }
    return markerLabel;
}

const MARKER_DEFAULT_SIZE = 10;
function MarkersWithLabel({ yScale, xScale, color, seriesIndex, startIndex, endIndex, hiddenIds, selectedIds, highlightedIds, orientation, isLog, markerType, getDataItem, focusedItemIndex, hoveredItemIndex, isDrillEnabled, activeId, isSelectionEnabled, timeAxisType, isPointInsideMarquee, groups, defaultFontSize, dataLabelEffect, isHighContrast, isTestEnv, isDataXAxis, getTextDimensions, getItemAriaLabel }) {
    const isHoriz = orientation === 'horizontal';
    const items = [];
    for (let groupIndex = startIndex; groupIndex < endIndex + 1; groupIndex++) {
        const item = getDataItem(seriesIndex, groupIndex);
        if (!item || hiddenIds?.has(item.id)) {
            continue;
        }
        let x, y;
        const itemHasValue = 'value' in item;
        if (isDataXAxis && 'y' in item) {
            x = xScale.transform(item.x);
            y = yScale.transform(item.y);
        }
        else {
            const value = itemHasValue ? item?.value : undefined;
            if (value == null || (isLog && value <= 0)) {
                continue;
            }
            x = isHoriz
                ? yScale.transform(value)
                : getGroupCenterCoord(groups[groupIndex], groupIndex, xScale, item, timeAxisType);
            y = isHoriz
                ? getGroupCenterCoord(groups[groupIndex], groupIndex, xScale, item, timeAxisType)
                : yScale.transform(value);
        }
        const isFocused = focusedItemIndex === groupIndex;
        const isHovered = hoveredItemIndex === groupIndex;
        const isSelected = !!(selectedIds?.has(item.id) || isPointInsideMarquee?.(item.id, { x, y })); // TODO: tagcloud has isItemSelected we should look to leverage here
        const isDrillable = item.drilling === 'on' || (item.drilling != 'off' && isDrillEnabled);
        const isHighlighted = !highlightedIds || highlightedIds?.size === 0 || highlightedIds?.has(item.id); // TODO: tagcloud has isItemHighlighted we should look to leverage here
        const { fill, stroke, outerStroke } = getMarkerFillAndStroke(!!item.isMarkerDisplayed, isSelectionEnabled, isHovered, isFocused, isSelected, color, item.markerColor);
        const itemMarkerType = item.isMarkerDisplayed ? item.markerType || markerType : markerType;
        const isActive = isFocused || isHovered;
        const ariaLabel = supportsMobileScreenReader || isActive
            ? getItemAriaLabel(item, seriesIndex, groupIndex, isSelectionEnabled, !!isSelected, isDrillable)
            : undefined;
        const dataInfo = {
            'data-oj-private-series-index': seriesIndex,
            'data-oj-private-group-index': groupIndex,
            'data-oj-private-object': 'item',
            id: isActive ? activeId : undefined,
            role: ariaLabel ? 'img' : undefined,
            'aria-label': ariaLabel,
            'data-oj-private-item-id': isTestEnv ? item.id : undefined
        };
        const markerSize = (item.markerSize || MARKER_DEFAULT_SIZE) + 2 * MARKER_PADDING;
        items.push(jsxs(Fragment, { children: [jsx(Marker, { type: itemMarkerType, tx: x, ty: y, isInteractive: isDrillable || isSelectionEnabled, scale: 1, fill: fill, stroke: stroke, outerStroke: outerStroke, width: markerSize, height: markerSize, dataInfo: dataInfo, preserveRectAspectRatio: true, styleClass: isHighlighted ? undefined : styles.dimmed }), jsx(MarkerLabel, { labelPosition: item.labelPosition, label: item.label, labelStyle: item.labelStyle, tx: x, ty: y, defaultFontSize: defaultFontSize, dataLabelEffect: dataLabelEffect, isHighContrast: isHighContrast, getTextDimensions: getTextDimensions })] }));
    }
    return jsx(Fragment, { children: items });
}

function LineSeries({ color, isHorizontal, lineType = 'straight', lineColor, lineStyle, lineWidth = 3, isHighlighted, lineSegmentCoords, seriesIndex, groupWidth, isRtl, timeAxisType, plotAreaClipPathId }) {
    const style = {
        stroke: lineColor || color,
        strokeDasharray: lineStyle === 'dotted' ? 3 : lineStyle === 'dashed' ? 6 : undefined,
        strokeWidth: lineWidth,
        fill: 'none'
    };
    return (jsx(Fragment, { children: lineSegmentCoords.map((value) => {
            if (value.length < 2) {
                return;
            }
            const cmds = getCmdsForLine(value, lineType, isHorizontal, groupWidth, isRtl, timeAxisType);
            return isNonCurvedLine(lineType) ? (jsx("g", { "clip-path": `url(#${plotAreaClipPathId})`, children: cmds.split(' ').map((cmd) => (jsx("polyline", { points: cmd, style: style, className: isHighlighted ? undefined : styles.dimmed, "data-oj-private-series-index": seriesIndex, "data-oj-private-object": 'line' }))) })) : lineType === 'curved' ? (jsx("path", { d: cmds, "clip-path": `url(#${plotAreaClipPathId})`, style: style, className: isHighlighted ? undefined : styles.dimmed, "data-oj-private-series-index": seriesIndex, "data-oj-private-object": 'line' })) : undefined;
        }) }));
}

export { LineSeries as L, MarkersWithLabel as M };
//# sourceMappingURL=LineSeries-5ee0f790.js.map
