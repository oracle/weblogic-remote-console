/* @oracle/oraclejet-preact: undefined */
import { jsx, Fragment } from 'preact/jsx-runtime';
import { useRef, useCallback } from 'preact/hooks';
import { F as Floating } from './Floating-6023b41d.js';
import { L as Layer } from './Layer-7d3dc8c7.js';
import 'preact/compat';
import './LayerHost-12489cef.js';
import { K as KEYS } from './keyboardUtils-986fe923.js';
import { f as focusWithin } from './tabbableUtils-ce19b388.js';
import { u as usePopupAnimation } from './usePopupAnimation-66b186ad.js';
import { g as getTransformOrigin } from './popupAnimationUtils-175151d9.js';
import { C as CollectionInteractionContext } from './CollectionInteractionContext-7cf19abc.js';
import { dropdownStyles } from './UNSAFE_Dropdown/themes/dropdownStyles.css.js';
import { u as useOutsideMousedown } from './useOutsideMousedown-39d7c9a6.js';
import { m as mergeAnimationStateObjects, D as DURATION_LARGE, b as SCALE_UP_FULL } from './animationUtils-5f409a6c.js';
import { U as UNSAFE_DOM_ACCESS } from './unsafeDomAccess-453eb74e.js';

const DEFAULT_PLACEMENT = 'bottom-start';
const DEFAULT_OFFSET = { mainAxis: 4, crossAxis: 0 };
const DEFAULT_SIZE_OPTIONS = { isMaxWidthAdjusted: true, isMaxHeightAdjusted: true };
const DEFAULT_FLIP_OPTIONS = { mainAxis: true, crossAxis: true };
const animationStates = {
    opening: (node) => {
        return mergeAnimationStateObjects([
            SCALE_UP_FULL,
            {
                from: { transformOrigin: getTransformOrigin(node.placement, node.direction) },
                to: { transformOrigin: getTransformOrigin(node.placement, node.direction) }
            }
        ], {
            duration: DURATION_LARGE
        });
    }
};
//TODO: Add animation to dropdown. JET-62628
//TODO: Investigate best approach to have different virtual padding depending on the position and implement it.JET-57950
function Dropdown({ isOpen = false, anchorRef, children, id, onClose, minWidth, placement = DEFAULT_PLACEMENT, offset = DEFAULT_OFFSET, onPosition, flipOptions = DEFAULT_FLIP_OPTIONS, sizeOptions = DEFAULT_SIZE_OPTIONS, shiftOptions, initialFocus = 'none' }) {
    const dropdownRef = useRef(null);
    const onTransitionEnd = useCallback((isOpen) => {
        if (isOpen && initialFocus === 'firstFocusable') {
            const dropdownElement = dropdownRef.current;
            if (dropdownElement) {
                focusWithin(dropdownElement);
            }
        }
    }, [initialFocus]);
    const { status, setAnimationElementRef, onPosition: onPositionAnimated } = usePopupAnimation({
        isOpen,
        placement,
        isAnimatedOnMount: true,
        animationStates,
        onPosition,
        onTransitionEnd
    });
    const handleMousedownClose = useCallback((event) => {
        onClose?.({ reason: 'outsideMousedown', target: event.target });
    }, [onClose]);
    const handleKeyDown = useCallback((event) => {
        if (event.defaultPrevented) {
            return;
        }
        switch (event.code) {
            case KEYS.ESC:
                onClose?.({ reason: 'dismissed' });
                break;
            case KEYS.TAB:
                onClose?.({ reason: 'dismissed' });
                break;
        }
    }, [onClose]);
    // use the mousedown event to be consistent with legacy JET
    useOutsideMousedown({
        isDisabled: false,
        ref: [dropdownRef],
        handler: handleMousedownClose
    });
    return (jsx(Fragment, { children: status !== 'unmounted' ? (jsx(Layer, { logicalParentRef: toLogicalParentRef(anchorRef), children: jsx(Floating, { anchorRef: anchorRef, ref: setAnimationElementRef, placement: placement, flipOptions: flipOptions, shiftOptions: shiftOptions, sizeOptions: sizeOptions, offsetValue: offset, onPosition: onPositionAnimated, boundaryOptions: { padding: { top: 8, bottom: 8, left: 0, right: 0 } }, children: jsx("div", { ref: dropdownRef, id: id, class: dropdownStyles.base, style: { minWidth: `${minWidth || 0}px` }, onKeyDown: handleKeyDown, children: jsx(CollectionInteractionContext.Provider, { value: 'embedded', children: children }) }) }) })) : null }));
}
function toLogicalParentRef(anchorRef) {
    const current = anchorRef.current;
    if (current) {
        if (current instanceof Element) {
            return anchorRef;
        }
        else if (current[UNSAFE_DOM_ACCESS]) {
            return anchorRef;
        }
    }
    return null;
}

export { Dropdown as D };
//# sourceMappingURL=Dropdown-ead9e679.js.map
