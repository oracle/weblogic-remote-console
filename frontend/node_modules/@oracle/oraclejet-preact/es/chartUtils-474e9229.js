/* @oracle/oraclejet-preact: undefined */
import { jsx } from 'preact/jsx-runtime';
import { p as getCmdPoints, q as isNonCurvedLine } from './utils-adfaaca0.js';
import { a as dvtVars } from './themeContract.css-2b5a42e2.js';
import { f as fixCoord, c as curveThroughPoints } from './lineUtils-586f3e8a.js';

/**
 * @license
 * Copyright (c) 2008 %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Returns a straight area path command.
 * @param {array} lineSegmentCoords Polyline top points array.
 * @param {array} bottomCoords Polyline bottom points array.
 * @return {string} Straight area path commands.
 */
function getNonCurveAreaPath(lineSegmentCoords, bottomCoords, areaType, isHoriz, isRtl, groupWidth, timeAxisType) {
    // Create the path data string
    const highCoords = getCmdPoints(lineSegmentCoords, areaType, isHoriz, isRtl, groupWidth, timeAxisType, true).split(',');
    const lowCoords = getCmdPoints(bottomCoords, areaType, isHoriz, isRtl, groupWidth, timeAxisType, true).split(',');
    // Reverse the lowArray
    const revLowArray = [];
    for (let i = 0; i < lowCoords.length; i += 2) {
        revLowArray.unshift(lowCoords[i], lowCoords[i + 1]);
    }
    return revLowArray.concat(highCoords);
}
/**
 * Returns a curved area path command, based on cubic hermite splines, that goes through the points in the points array.
 * @param {array} lineSegmentCoords Polyline top points array.
 * @param {array} bottomCoords Polyline bottom points array.
 * @param {boolean} connectWithLine Whether the first point is reached using lineTo. Otherwise, moveTo is used.
 * @param {string} splineType The spline type.
 * @return {string} Curved area path commands.
 */
function getCurveAreaPath(lineSegmentCoords, bottomCoords, connectWithLine, splineType, isBottomSegmentCurved) {
    let pathData;
    if (lineSegmentCoords.length > 0) {
        if (!isBottomSegmentCurved) {
            pathData =
                curveThroughPoints(lineSegmentCoords, connectWithLine, splineType) +
                    [...bottomCoords]
                        .reverse()
                        .map((bottomCoord) => {
                        return `L ${bottomCoord[0]} ${bottomCoord[1]}`;
                    })
                        .join(' ') +
                    'Z';
        }
        else {
            pathData =
                curveThroughPoints(lineSegmentCoords, false, splineType) +
                    ' ' +
                    curveThroughPoints([...bottomCoords].reverse(), true, splineType) +
                    ' Z';
        }
    }
    return pathData;
}
function getCmdsForArea(lineSegmentCoords, bottomCoords, areaType, isHoriz, isBottomSegmentCurved, isRtl, groupWidth, timeAxisType) {
    const l = lineSegmentCoords.map((coord) => fixCoord(coord, isHoriz));
    const b = bottomCoords.map((coord) => fixCoord(coord, isHoriz));
    if (areaType === 'curved') {
        return getCurveAreaPath(l, b, false, isHoriz ? 'mh' : 'mv', isBottomSegmentCurved);
    }
    else {
        return getNonCurveAreaPath(lineSegmentCoords, bottomCoords, areaType, isHoriz, isRtl, groupWidth, timeAxisType).join(' ');
    }
}

function AreaSeries({ yScale, lineType = 'straight', color, isHorizontal, isLog, areaColorOpacity, lineSegments, bottomCoords, isHighlighted, isBottomSegmentCurved, seriesIndex, groupWidth, isRtl, timeAxisType, plotAreaClipPathId }) {
    const style = {
        fill: color,
        opacity: isHighlighted
            ? areaColorOpacity
            : `calc(${dvtVars.dimmedOpacity} * ${areaColorOpacity})`
    };
    return (jsx("g", { "clip-path": `url(#${plotAreaClipPathId})`, children: lineSegments.map((lineSegment) => {
            if (lineSegment.length < 2) {
                return;
            }
            let baseCoords;
            if (bottomCoords) {
                // custom bottom coords. eg: top of last series in stacked area
                baseCoords = bottomCoords;
            }
            else {
                // TODO: make this more generic when we support apps setting baseline
                // for log assume domain min is the baseline, otherwise use 0 baseline
                const baselineCoord = yScale.transform(isLog ? yScale.domain()[0] : 0);
                baseCoords = [
                    [lineSegment[0][0], baselineCoord],
                    [lineSegment[lineSegment.length - 1][0], baselineCoord]
                ];
            }
            const cmds = getCmdsForArea(lineSegment, baseCoords, lineType, isHorizontal, isBottomSegmentCurved, isRtl, groupWidth, timeAxisType);
            return isNonCurvedLine(lineType) ? (jsx("polygon", { points: cmds, style: style, "data-oj-private-series-index": seriesIndex, "data-oj-private-object": 'area' })) : lineType === 'curved' ? (jsx("path", { d: cmds, style: style, "data-oj-private-series-index": seriesIndex, "data-oj-private-object": 'area' })) : undefined;
        }) }));
}

const getLineAreaChartItemPosition = (seriesIndex, groupIndex, 
// TODO: JET-71332 ; should only be (number | undefined)[][]
// scatter chart does not call this function
renderedSeries, getDataItem, groups, isHoriz, xScale, yScale, timeAxisType) => {
    // TODO: JET-71332; remove as number after JET-71332 is fixed
    const value = renderedSeries[seriesIndex][groupIndex];
    if (value == null) {
        return undefined;
    }
    let xVal = groupIndex;
    if (timeAxisType) {
        const val = timeAxisType === 'mixedFrequency'
            ? getDataItem(seriesIndex, groupIndex)?.x
            : groups[groupIndex].id;
        xVal = new Date(val).getTime();
    }
    const x = isHoriz ? yScale.transform(value) : xScale.transform(xVal);
    const y = isHoriz ? xScale.transform(xVal) : yScale.transform(value);
    return { x, y, height: 0, width: 0 };
};

export { AreaSeries as A, getLineAreaChartItemPosition as g };
//# sourceMappingURL=chartUtils-474e9229.js.map
