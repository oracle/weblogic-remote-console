/* @oracle/oraclejet-preact: undefined */
import './TabbableModeContext-7d8ad946.js';
import { u as useTabbableMode } from './useTabbableMode-a2fdbb06.js';
import { useRef, useLayoutEffect, useCallback } from 'preact/compat';
import { u as useUser } from './useUser-df8ae011.js';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * A custom hook that handles focus for a month or year cell.
 */
const useFocusableCell = ({ isFocusable, isFocused }) => {
    const cellRef = useRef(null);
    const { isTabbable } = useTabbableMode();
    // Using layout effect here to set the focus as we want to focus the element
    // before the browser has a chance to paint. This way the browser don't have to
    // repaint the focused state.
    useLayoutEffect(() => {
        if (isFocusable && isFocused) {
            cellRef.current?.focus();
        }
    }, [isFocusable, isFocused]);
    return { ref: cellRef, tabIndex: isFocusable && isTabbable ? 0 : -1 };
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
// Utility for killing handled events.
const killEvent = (event) => {
    event.preventDefault();
    event.stopPropagation();
};
/**
 * A custom hook that handles navigation for a DatePicker cell.
 */
const useCellNavigation = ({ navigationMap, payload, onAction, onNavigation }) => {
    const { direction } = useUser();
    const handleSelection = useCallback(() => {
        onAction(payload);
    }, [payload, onAction]);
    // JET-67580: Prevent InputDatePicker dropdown from re-opening by performing
    // selection onKeyUp. After a selection is made, IDP transfers focus to the
    // calendar icon. If we use key down, then IconButton gets the key up which
    // causes it to fire its action handler and reopen the picker.
    const handleKeyUp = useCallback((event) => {
        if (['Enter', 'Space'].includes(event.code)) {
            // since we are handling the event, we need to kill the event here
            // so that no other action is performed
            killEvent(event);
            handleSelection();
            return;
        }
    }, [handleSelection]);
    // Although we handle the Space/Enter keys in onKeyUp, the rest of the events
    // (like arrow keys, home, end, etc.) are still handled on key down which feels
    // more natural. It also lets you hold keys down - like arrow keys - to keep
    // navigating through day cells.
    const handleKeyDown = useCallback((event) => {
        if (event.code === 'Space') {
            // Even though we handle Space on key up, we need to call preventDefault on
            // key down to prevent browser scrolling on some browsers.
            event.preventDefault();
            return;
        }
        // Handle Ctrl + Alt + T
        if (event.code === 'KeyT' && event.ctrlKey && event.altKey) {
            const navigationDirection = navigationMap['CtrlAltT'];
            if (navigationDirection !== undefined) {
                // since we are handling the event, we need to kill the event here
                // so that no other action is performed
                killEvent(event);
                onNavigation({
                    direction: getLogicalValue(navigationDirection, direction),
                    ...payload
                });
            }
        }
        const { key, shiftKey } = event;
        switch (key) {
            // since we are handling the event, we need to kill the event here
            // so that no other action is performed
            case 'ArrowLeft':
            case 'ArrowRight':
            case 'ArrowUp':
            case 'ArrowDown':
            case 'End':
            case 'Home':
            case 'PageUp':
            case 'PageDown': {
                const mapKey = shiftKey && (key === 'PageUp' || key === 'PageDown') ? `Shift${key}` : key;
                if (navigationMap[mapKey] !== undefined) {
                    killEvent(event);
                    const navigationDirection = navigationMap[mapKey];
                    onNavigation({
                        direction: getLogicalValue(navigationDirection, direction),
                        ...payload
                    });
                }
            }
        }
    }, [direction, navigationMap, onNavigation, payload]);
    return {
        onClick: handleSelection,
        onKeyDown: handleKeyDown,
        onKeyUp: handleKeyUp
    };
};
/**
 * Determines the logical value for the navigation direction.
 * @param value The value representing the navigation direction
 * @param dir The reading direction from the user preferences
 * @returns The logical navigation direction
 */
const getLogicalValue = (value, dir) => typeof value === 'string' ? value : value[dir];

export { useCellNavigation as a, useFocusableCell as u };
//# sourceMappingURL=useCellNavigation-aabee5c0.js.map
