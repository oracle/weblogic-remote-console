/* @oracle/oraclejet-preact: undefined */
import { u as useDnd } from './useDnd-c5ae190c.js';
import { a as dvtVars } from './themeContract.css-2b5a42e2.js';
import { x as xUnits } from './utils-cfef1929.js';
import { styles } from './PRIVATE_BaseLegend/themes/LegendStyles.css.js';
import { c as cancelEvent } from './eventsUtils-e96290df.js';

function getDragImage({ event, target }) {
    const container = document.createElement('div');
    const { width, height, x, y } = target.getBoundingClientRect();
    const clone = target.cloneNode(true);
    container.appendChild(clone);
    const styles = window.getComputedStyle(target.parentElement);
    container.style.fontSize = styles.getPropertyValue('font-size');
    container.style.fontFamily = styles.getPropertyValue('font-family');
    container.style.textAnchor = styles.getPropertyValue('text-anchor');
    container.style.dominantBaseline = styles.getPropertyValue('dominant-baseline');
    return {
        image: container,
        offSetX: event.clientX - x,
        offSetY: event.clientY - y,
        width,
        height
    };
}

/**
 * Returns the value of the data-oj-private-item-index attribute for a given element.
 * @param element The HTML element.
 * @returns
 */
const getItemInfo = (element) => {
    const item = element.dataset['ojPrivateItem'];
    const section = element.dataset['ojPrivateSection'];
    if (item == null || section == null) {
        return;
    }
    return {
        itemIdx: Number(item),
        sectionIdx: Number(section)
    };
};
/**
 * Checks if the item is highlighted.
 * @param id Id of the item
 * @param highlighted The set of highlighted item
 */
function isItemHighlighted(id, highlighted) {
    if (!highlighted) {
        return;
    }
    if (highlighted.length === 0) {
        return true;
    }
    return new Set(highlighted).has(id);
}
/**
 * Checks if the item is hidden.
 * @param id Id of the item.
 * @param hiddenIds The set of hidden items.
 * @returns
 */
function isItemHidden(id, hiddenIds) {
    if (!hiddenIds) {
        return;
    }
    return new Set(hiddenIds).has(id);
}
/**
 * Checks if the item is the currentItem and if the focus ring
 * is visible.
 * @param itemInfo ItemInfo
 * @param itemIdx Item index
 * @param sectionIdx Section index
 */
const hasFocusRing = (itemInfo, itemIdx, sectionIdx) => {
    if (!itemInfo.isFocusVisible)
        return false;
    const { itemIdx: item, sectionIdx: section } = itemInfo;
    if (sectionIdx == null) {
        return item === itemIdx;
    }
    return item === itemIdx && section === sectionIdx;
};
/**
 * Returns the text for the legend datatip.
 * @param items The legend items data.
 * @param itemInfoRef The item currently hovered.
 * @param currentItem The item that is currently keyboard focused.
 */
function getDatatipText(items, getItem, focusedItem, hoveredItem) {
    const isPointerActive = hoveredItem?.isCurrent;
    if (isPointerActive && hoveredItem.itemIdx != null) {
        return getItem(hoveredItem, items)?.datatip;
    }
    if (focusedItem && focusedItem.isCurrent) {
        return getItem(focusedItem, items)?.datatip;
    }
    return;
}
/**
 * Returns the aria properties for the legend.
 * @param isReadOnly { boolean } If the legend is readonly.
 * @param ariaLabel { string } The aria-label set by the app.
 * @returns The aria props.
 */
function getAriaProps(isReadOnly, ariaLabel, hiddenIds, ariaDescribedBy, ariaLabelledBy) {
    const hideAndShow = hiddenIds && !isReadOnly;
    return {
        'aria-label': ariaLabel,
        'aria-disabled': isReadOnly,
        role: hideAndShow ? 'menu' : 'application',
        'aria-describedby': ariaDescribedBy,
        'aria-labelledby': ariaLabelledBy
    };
}
/**
 * Returns the item props for BaseLegendItem.
 * @param item The legend item.
 * @param itemIdx The item index of the item.
 * @param sectionIdx The section index of section of the item.
 * @param focusedItem The info of currently focused item.
 * @param isReadOnly Whether the legend is readonly.
 * @param hoveredItem The info of the currently hovered item.
 * @param hiddenIds The hidden ids.
 * @param highlightedIds The highlighted ids.
 */
function getItemProps(item, itemIdx, sectionIdx, focusedItem, isReadOnly, hoveredItem, hiddenIds, highlightedIds) {
    let isCurrent = false;
    if (!isReadOnly) {
        const isFocusedItem = itemIdx === focusedItem.itemIdx && sectionIdx === focusedItem.sectionIdx;
        const isHoveredItem = itemIdx === hoveredItem?.itemIdx && sectionIdx === hoveredItem?.sectionIdx;
        isCurrent = !!((isFocusedItem && focusedItem.isCurrent) ||
            (isHoveredItem && hoveredItem?.isCurrent));
    }
    return {
        isCurrent,
        isHighlighted: isItemHighlighted(item.id, highlightedIds),
        isHidden: isItemHidden(item.id, hiddenIds),
        isFocused: hasFocusRing(focusedItem, itemIdx, sectionIdx),
        key: item.id,
        ...item
    };
}
/**
 * Compares if two ItemInfo are equal
 * @param item1
 * @param item2
 * @returns
 */
const isEqualItem = (item1, item2) => {
    return item1?.itemIdx === item2?.itemIdx && item1?.sectionIdx === item2?.sectionIdx;
};
/**
 * Returns the num of cols and rows for the legend.
 */
const getGridNums = (numItems, layoutInfo, orientation) => {
    let itemsPerRow;
    let itemsPerCol;
    if (orientation === 'vertical') {
        itemsPerRow = 1;
        itemsPerCol = numItems;
    }
    if (layoutInfo?.isWrapped) {
        itemsPerRow = layoutInfo.itemsPerRow;
        itemsPerCol = Math.ceil(numItems / itemsPerRow);
        itemsPerRow = Math.ceil(numItems / itemsPerCol);
    }
    return { itemsPerRow, itemsPerCol };
};
/**
 * Returns the num of cols and rows for the sectional legend.
 */
const getSectionGridNums = (numItems, legendItemsPerRow) => {
    let itemsPerRow;
    let itemsPerCol;
    if (legendItemsPerRow) {
        itemsPerRow = legendItemsPerRow;
        itemsPerCol = Math.ceil(numItems / itemsPerRow);
        itemsPerRow = Math.ceil(numItems / itemsPerCol);
    }
    return { itemsPerRow, itemsPerCol };
};
/**
 * Returns the grid row and column for given item.
 * @param noOfItems The number of items in the section.
 * @param index The index of the item.
 * @param itemsPerRow The num of items per row in the grid.
 * @param itemsPerCol The num of items per col in the grid.
 * @returns
 */
function getGridCellIndices(noOfItems, index, itemsPerRow, itemsPerCol) {
    let gridRow;
    let gridCol;
    if (itemsPerRow && itemsPerCol && noOfItems > itemsPerRow) {
        gridRow = (index % itemsPerCol) + 1;
        gridCol = Math.floor(index / itemsPerCol) + 1;
    }
    return { gridRow, gridCol };
}
/**
 * Returns the resolved values for the legend vars.
 */
const legendVars = [
    {
        tokenVar: xUnits(1),
        key: 'unit',
        cssProp: 'padding'
    },
    {
        tokenVar: dvtVars.label.sm.fontSize,
        key: 'fontSize',
        cssProp: 'font-size'
    }
];
/**
 * Returns the resolved values for the legend vars.
 */
function getLegendTextStyle(props, resolvedVars) {
    return {
        fontStyle: props.fontStyle,
        fontSize: (resolvedVars['fontSize'] ?? props.fontSize),
        fontWeight: props.fontWeight,
        fontFamily: props.fontFamily
    };
}
/**
 * Returns the style for current legend item.
 */
function getLegendCurrentItemStyle(isCurrent, isHighlighted, hideAndShowBehavior, hoverBehavior, isHidden, actionable) {
    if (isCurrent) {
        if (isHighlighted == null && isHidden == null && actionable !== 'off')
            return styles.legendItemIsCurrentWithCursor;
        else if (isHighlighted == null && hideAndShowBehavior === 'on' && actionable !== 'off')
            return styles.legendItemIsCurrentWithCursor;
        else if (isHidden == null && hoverBehavior === 'dim' && actionable !== 'off')
            return styles.legendItemIsCurrentWithoutCursor;
    }
    return '';
}
function getIsLegendItemActionable(legendData, isReadOnly, isSectional) {
    return (itemInfo) => {
        let item;
        if (isSectional && itemInfo.sectionIdx != null) {
            item = legendData[itemInfo.sectionIdx].items[itemInfo.itemIdx];
        }
        else {
            item = legendData[itemInfo.itemIdx];
        }
        return !isReadOnly && item?.actionable !== 'off';
    };
}
/*
 * Returns KeyUp handler for legend.
 * @param triggerOnAction
 * @param updatefocusedItemInfo
 * @param focusedItemInfo
 * @returns
 */
function getKeyUpHandler(triggerOnAction, updatefocusedItemInfo, focusedItemInfo, isHideShow) {
    return (event) => {
        const key = event.code;
        switch (key) {
            case 'Space': {
                if (isHideShow) {
                    triggerOnAction();
                    cancelEvent(event);
                }
                break;
            }
            case 'Enter': {
                triggerOnAction();
                cancelEvent(event);
                break;
            }
            case 'Home': {
                updatefocusedItemInfo({
                    itemIdx: 0,
                    sectionIdx: 0,
                    isFocusVisible: true,
                    isCurrent: true
                });
                cancelEvent(event);
                break;
            }
            case 'End': {
                updatefocusedItemInfo({
                    itemIdx: -1,
                    sectionIdx: -1,
                    isCurrent: true,
                    isFocusVisible: true
                });
                cancelEvent(event);
                break;
            }
            case 'Tab': {
                updatefocusedItemInfo({
                    ...focusedItemInfo,
                    isCurrent: true,
                    isFocusVisible: true
                });
                cancelEvent(event);
                break;
            }
        }
    };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const useLegendDnd = ({ onDragStart, onDrag, onDragEnd, onDragEnter, onDragLeave, onDragOver, onDrop, items, sections, itemDraggable, setDragOver, setDatatipDisabled }) => {
    const draggable = itemDraggable !== undefined;
    const getDragContext = function (target, event) {
        //We search for the key using the target of the event
        const itemIdx = getItemInfo(target)?.itemIdx;
        let sectionIdx;
        if (sections) {
            sectionIdx = getItemInfo(target)?.sectionIdx;
        }
        let data;
        if (items) {
            data = itemIdx !== undefined ? items[itemIdx] : null;
            if (itemDraggable && data && itemDraggable(data)) {
                return {
                    type: 'item',
                    data: data,
                    event
                };
            }
        }
        else {
            data =
                sectionIdx !== undefined && itemIdx !== undefined
                    ? sections[sectionIdx]?.items[itemIdx]
                    : null;
            if (itemDraggable && data && itemDraggable(data)) {
                return {
                    type: 'item',
                    data: data,
                    event,
                    itemIndexPath: [sectionIdx, itemIdx]
                };
            }
        }
        return undefined;
    };
    const getDropContext = function (event) {
        return { type: 'background', event };
    };
    const showDropEffect = function () {
        setDragOver(true);
    };
    const showRejectedDropEffect = function () {
        setDragOver(false);
    };
    const clearDropEffect = function () {
        setDragOver(undefined);
    };
    const { dragProps, dropProps, content } = useDnd({
        onDragStart,
        onDrag,
        onDragEnd,
        onDragEnter,
        onDragLeave,
        onDragOver,
        onDrop,
        getDragContext,
        getDropContext,
        getDragImage,
        setDatatipDisabled,
        showDropEffect,
        showRejectedDropEffect,
        clearDropEffect
    });
    return {
        draggable: draggable,
        dndProps: draggable ? { ...dragProps, ...dropProps } : dropProps,
        dndContent: content
    };
};

export { getLegendTextStyle as a, getItemInfo as b, getDatatipText as c, getAriaProps as d, getIsLegendItemActionable as e, getKeyUpHandler as f, getGridNums as g, getLegendCurrentItemStyle as h, isEqualItem as i, getItemProps as j, getGridCellIndices as k, legendVars as l, getSectionGridNums as m, useLegendDnd as u };
//# sourceMappingURL=useLegendDnd-19e0e582.js.map
