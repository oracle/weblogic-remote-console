/* @oracle/oraclejet-preact: undefined */
/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
class ScaleLinear {
    constructor(domain, range) {
        this._domain = domain;
        this._range = range;
        this.m = (this._range[1] - this._range[0]) / (this._domain[1] - this._domain[0]);
        this.c = this._range[0] - this.m * this._domain[0];
    }
    transform(value) {
        return this.m * value + this.c;
    }
    invert(value) {
        return (value - this.c) / this.m;
    }
    domain() {
        return this._domain;
    }
    range() {
        return this._range;
    }
}
class ScaleLog {
    constructor(domain, range) {
        this._linearDomain = [Math.log(domain[0]), Math.log(domain[1])];
        this._domain = domain;
        this._range = range;
        this.linearScale = new ScaleLinear(this._linearDomain, this._range);
    }
    transform(value) {
        const v = Math.log(value);
        return this.linearScale.transform(v);
    }
    invert(value) {
        const v = this.linearScale.invert(value);
        return Math.pow(10, v);
    }
    domain() {
        return this._domain;
    }
    range() {
        return this._range;
    }
}
class VariableWidthScale {
    constructor(domain, range, groupWidthRatios, groupCount) {
        this._domain = domain;
        this._range = range;
        this._groupWidthRatios = groupWidthRatios;
        this.MinValue = this._domain[0];
        this.MaxValue = this._domain[1];
        this.StartCoord = this._range[0];
        this.EndCoord = this._range[1];
        this._groupCount = groupCount;
        this._processGroupWidthRatios();
    }
    _processGroupWidthRatios() {
        // Edge case: less than two groups
        if (!this._groupWidthRatios || this._groupWidthRatios.length < 2) {
            this._groupWidthRatios = [];
            return;
        }
        // Compute the sums of the group widths that are contained within the viewport
        let sum = 0;
        let groupMin, groupMax;
        for (let g = 0; g < this._groupCount; g++) {
            groupMin = g == 0 ? this.MinValue : Math.max(g - 0.5, this.MinValue);
            groupMax = g == this._groupCount - 1 ? this.MaxValue : Math.min(g + 0.5, this.MaxValue);
            if (groupMax > groupMin) {
                sum += (groupMax - groupMin) * this._groupWidthRatios[g];
            }
        }
        // Divide the total viewport length (in pixels) proportionally based on the group width ratios.
        const totalWidth = this.EndCoord - this.StartCoord;
        this._groupWidths = this._groupWidthRatios.map((ratio) => {
            return (ratio * totalWidth) / sum;
        });
        // Construct borderValues array which stores the the value location of the group boundaries.
        this._borderValues = [];
        for (let g = 0; g < this._groupWidthRatios.length - 1; g++) {
            this._borderValues.push(g + 0.5);
        }
        // Construct borderCoords array which stores the coord location of the group boundaries.
        this._borderCoords = [];
        const anchor = Math.min(Math.max(Math.round(this.MinValue), 0), this._borderValues.length - 1);
        this._borderCoords[anchor] =
            this.StartCoord + (this._borderValues[anchor] - this.MinValue) * this._groupWidths[anchor];
        for (let g = anchor + 1; g < this._borderValues.length; g++ // compute borderCoords after the anchor
        ) {
            this._borderCoords[g] = this._borderCoords[g - 1] + this._groupWidths[g];
        }
        for (let g = anchor - 1; g >= 0; g-- // compute borderCoords before the anchor
        ) {
            this._borderCoords[g] = this._borderCoords[g + 1] - this._groupWidths[g + 1];
        }
    }
    transform(value) {
        if (this._groupWidthRatios) {
            // Find the anchor, i.e. the group boundary closest to the value.
            let anchor = this._borderValues.length;
            for (let g = 0; g < this._borderValues.length; g++) {
                if (value <= this._borderValues[g]) {
                    anchor = g;
                    break;
                }
            }
            // Compute the coord based on the group width at the anchor.
            if (anchor == 0) {
                return this._borderCoords[0] - this._groupWidths[0] * (this._borderValues[0] - value);
            }
            else {
                return (this._borderCoords[anchor - 1] +
                    this._groupWidths[anchor] * (value - this._borderValues[anchor - 1]));
            }
        }
        return 0;
    }
    invert(coord) {
        if (this._groupWidthRatios) {
            // Find the anchor, i.e. the group boundary closest to the coord.
            let anchor = this._borderCoords.length;
            for (let g = 0; g < this._borderCoords.length; g++) {
                if (coord <= this._borderCoords[g]) {
                    anchor = g;
                    break;
                }
            }
            // Compute the value based on the group width at the anchor.
            if (anchor == 0) {
                return this._borderValues[0] - (this._borderCoords[0] - coord) / this._groupWidths[0];
            }
            else {
                return (this._borderValues[anchor - 1] +
                    (coord - this._borderCoords[anchor - 1]) / this._groupWidths[anchor]);
            }
        }
        return 0;
    }
    domain() {
        return this._domain;
    }
    range() {
        return this._range;
    }
}

export { ScaleLog as S, VariableWidthScale as V, ScaleLinear as a };
//# sourceMappingURL=scale-9a834124.js.map
