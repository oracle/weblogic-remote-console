/* @oracle/oraclejet-preact: undefined */
import { jsx, Fragment } from 'preact/jsx-runtime';
import './LayerHost-12489cef.js';
import { E as EnvironmentProvider } from './EnvironmentProvider-546b7ebd.js';
import { F as Floating } from './Floating-6023b41d.js';
import { L as Layer } from './Layer-7d3dc8c7.js';
import 'preact/compat';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const FocusTriggerKeys = ['Tab', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'];
/**
 * A global tooltip manager that
 * - ensures that only one tooltip is shown at a time
 * - detects a Tab key press and allows tooltips to check if their target was focused via keyboard
 */
class TooltipManager {
    constructor() {
        this.keyDownHandler = (event) => {
            if (FocusTriggerKeys.includes(event.key)) {
                this.triggerKeyActive = true;
                setTimeout(() => {
                    this.triggerKeyActive = false;
                }, 100);
            }
            if (this.activeCallback && event.key === 'Escape') {
                // hide active tooltip on Escape
                this.activeCallback();
            }
        };
        /**
         * notifies the previously registered active tooltip callback and registers a new one
         */
        this.register = (callback) => {
            if (this.activeCallback && this.activeCallback !== callback) {
                this.activeCallback();
            }
            this.activeCallback = callback;
        };
        /**
         * resets the registered active callback
         */
        this.unregister = (callback) => {
            if (this.activeCallback === callback) {
                this.activeCallback = null;
            }
        };
        /**
         * returns the active Tab key status ('active' means a Tab key press within the last 100ms)
         */
        this.isTabKeyActive = () => {
            return this.triggerKeyActive;
        };
        this.activeCallback = null;
        this.triggerKeyActive = false;
        window.addEventListener('keydown', this.keyDownHandler, true);
    }
}

// Global TooltipManager singleton instance
const globalTooltipManager = new TooltipManager();
/**
 * The delays (in ms) for Redwood tooltips.
 */
const SHOW_TOOLTIP_DELAY = 1000;
const HIDE_TOOLTIP_DELAY = 150;
/**
 * Returns a global TooltipManager singleton instance
 */
const getGlobalTooltipManager = () => {
    return globalTooltipManager;
};
/**
 * Wraps the tooltip content provided in the appropriate layering and returns the result for display.
 */
const getWrappedTooltipContent = (tooltipContent, variant, colorScheme, anchorRef, placement, offset) => {
    const defaultOffset = 8; // Redwood tooltip has a default offset of 8 pixels
    const newOffset = offset ? offset : { mainAxis: defaultOffset, crossAxis: 0 };
    const newColorScheme = !colorScheme || colorScheme === 'light' ? 'dark' : 'light';
    const renderTooltipOrDatatip = () => {
        if (variant === 'tooltip') {
            return (jsx(EnvironmentProvider, { environment: { colorScheme: newColorScheme }, children: tooltipContent }));
        }
        else {
            return jsx(Fragment, { children: tooltipContent });
        }
    };
    return (jsx(Layer, { priority: "tooltip", children: jsx(Floating, { anchorRef: anchorRef, placement: placement, offsetValue: newOffset, children: renderTooltipOrDatatip() }) }));
};

export { HIDE_TOOLTIP_DELAY as H, SHOW_TOOLTIP_DELAY as S, getGlobalTooltipManager as a, getWrappedTooltipContent as g };
//# sourceMappingURL=tooltipUtils-466c63c4.js.map
