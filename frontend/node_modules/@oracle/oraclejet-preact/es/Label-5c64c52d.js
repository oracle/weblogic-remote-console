/* @oracle/oraclejet-preact: undefined */
import { jsx, jsxs, Fragment } from 'preact/jsx-runtime';
import { useState, useRef, useCallback } from 'preact/hooks';
import './FormFieldContext-47ca0c20.js';
import { u as useFormFieldContext } from './useFormFieldContext-daf7a676.js';
import { c as classNames } from './classNames-4e12b00d.js';
import './FormContext-55fb8000.js';
import { u as useFormContext } from './useFormContext-bb9dc478.js';
import { u as useComponentTheme } from './useComponentTheme-d2f9e47f.js';
import './TabbableModeContext-7d8ad946.js';
import './LayerHost-12489cef.js';
import 'preact/compat';
import './UserAssistanceStyles.styles.css';
import './UNSAFE_UserAssistance/themes/redwood/UserAssistanceBaseTheme.styles.css';
import './UNSAFE_UserAssistance/themes/redwood/UserAssistanceVariants.css.js';
import './Flex-5befe411.js';
import './MessageBannerStyles.styles.css';
import './UNSAFE_MessageBanner/themes/redwood/MessageBannerBaseTheme.styles.css';
import './UNSAFE_MessageBanner/themes/redwood/MessageBannerVariants.css.js';
import 'preact';
import { u as useTooltip } from './useTooltip-f442fedb.js';
import { u as useScale } from './useScale-0ebe15ed.js';
import { u as useDensity } from './useDensity-d06ae84a.js';
import './TooltipContentStyles.styles.css';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentBaseTheme.styles.css';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js';
import './tooltipUtils-466c63c4.js';
import './IconStyle.styles.css';
import { g as getClientHints } from './clientHints-a42b510c.js';
import './IconButton-c91faa06.js';
import './MessageStyles.styles.css';
import './MessageFormattingUtils-cdb25115.js';
import './logger-c92f309c.js';
import './TransitionGroup-5fd80dc9.js';
import './MessagesContext-76544845.js';
import './HiddenAccessibleStyles.styles.css';
import './ComponentMessageStyles.styles.css';
import './UNSAFE_ComponentMessage/themes/redwood/ComponentMessageBaseTheme.styles.css';
import './UNSAFE_ComponentMessage/themes/redwood/ComponentMessageVariants.css.js';
import './InputGroupContext-20bdbd6e.js';
import './Popup-0f026f03.js';
import './UNSAFE_Separator/themes/SeparatorStyles.css.js';
import { C as CompactLabelAssistance } from './CompactLabelAssistance-1082f67f.js';
import './UNSAFE_Popup/themes/redwood/PopupBaseTheme.styles.css';
import './UNSAFE_Popup/themes/redwood/PopupVariants.css.js';
import { d as detectTruncation } from './truncationUtils-e37f95ee.js';
import { TextFieldRedwoodTheme } from './UNSAFE_TextField/themes/redwood/TextFieldTheme.js';
import { LabelRedwoodTheme } from './UNSAFE_Label/themes/redwood/LabelTheme.js';

/**
 * Hook that detects truncated text when you hover the mouse over a label.
 */
const useDetectLabelTruncation = ({ isDisabled = false, rootRef }) => {
    const [isTextTruncated, setIsTextTruncated] = useState(false);
    const mouseOverTimerRef = useRef();
    const handleMouseOver = useCallback(() => {
        clearTimeout(mouseOverTimerRef.current);
        // Determine if the label is truncated after the user hovers over it.
        mouseOverTimerRef.current = setTimeout(() => {
            const isTruncated = detectTruncation(rootRef);
            setIsTextTruncated(isTruncated);
        }, 1000);
    }, [rootRef]);
    const handleMouseOut = useCallback(() => {
        clearTimeout(mouseOverTimerRef.current);
        mouseOverTimerRef.current = undefined;
        setIsTextTruncated(false);
    }, []);
    const detectTruncationProps = !isDisabled
        ? {
            onMouseOver: handleMouseOver,
            onMouseOut: handleMouseOut
        }
        : {};
    return { detectTruncationProps, isTextTruncated };
};

// When you mouse over the label, useDetectLabelTruncation determines if the text is truncated
// and shows a tooltip. When you move the mouse outside of the label, the tooltip goes away.
const TruncatingLabel = ({ children: text, labelRef, hasValue, isFocused, ...labelProps }) => {
    const labelElementRef = useRef(null);
    const ref = labelRef ?? labelElementRef;
    const { detectTruncationProps, isTextTruncated } = useDetectLabelTruncation({ rootRef: ref });
    // Calculate the tooltip offset so it looks like it's relative to the field instead of the label.
    const scale = useScale() || 'lg';
    const density = useDensity() || 'standard';
    const scaleMap = { sm: 3, md: 3.5, lg: 4 };
    const xUnits = scaleMap[scale];
    const densityUnits = density === 'standard' ? 0 : -xUnits;
    const mainAxisMap = {
        sm: Math.max(xUnits + densityUnits, 3),
        md: Math.max(1.14 * xUnits + densityUnits, 3.5),
        lg: 2 * xUnits + densityUnits
    };
    const mainAxis = hasValue || isFocused ? mainAxisMap[scale] + 5 : Math.max(5.75 * xUnits + densityUnits, 16);
    const { tooltipContent, tooltipProps } = useTooltip({
        offset: {
            mainAxis,
            crossAxis: -4 * xUnits - 1
        },
        position: 'top-start',
        text,
        isDisabled: !isTextTruncated
    });
    const { 'aria-describedby': notNeeded, ...tooltipEventHandlerProps } = tooltipProps;
    return (jsxs(Fragment, { children: [jsx("label", { ref: ref, ...detectTruncationProps, ...labelProps, ...tooltipEventHandlerProps, children: text }), tooltipContent] }));
};
const StyledLabel = ({ hasValue, readonly, disabled, isFocused, isRequiredShown, labelRef, helpIconId, helpSourceLink, helpSourceText, userAssistanceDensity = 'reflow', variant = 'inside', parentComponentVariant = 'textField', ...props }) => {
    const { isFormLayout, isReadonly: isReadonlyForm, labelWrapping } = useFormContext();
    const isInside = variant === 'inside';
    const isTextField = parentComponentVariant === 'textField';
    const clientHints = getClientHints();
    // JET-73197: Truncated tooltips for core pack.
    // Determine whether to render a TruncatingLabel, which is measured to determine if
    // the label's content exceeds the size of the label itself, i.e. it's truncated.
    // We only want to do this for inside label edge, not disabled, and the textField variant.
    const useTruncatingLabel = isInside && !disabled && parentComponentVariant === 'textField';
    // because variants have to match strings, we have to take any boolean props and convert
    // them to a string value, (ie prefixed with "is" or "non")
    const { classes, styles: { safariAfter, uaDensityCompactLabel, uaDensityCompactLabelStart, uaDensityCompactLabelTopInside } } = useComponentTheme(LabelRedwoodTheme, {
        labelWrapping,
        position: variant,
        inside: isInside ? 'isInside' : 'notInside',
        inEnabledForm: isFormLayout && !isReadonlyForm ? 'isInEnabledForm' : 'notInEnabledForm',
        readonly: readonly ? 'isReadonly' : 'notReadonly',
        focused: isFocused ? 'isFocused' : 'nonFocused',
        formLayout: isFormLayout ? 'isFormLayout' : 'nonFormLayout',
        readonlyForm: isReadonlyForm ? 'isReadonlyForm' : 'notReadonlyForm',
        textField: isTextField ? 'isTextField' : 'notTextField',
        value: hasValue ? 'hasValue' : 'noValue',
        valueOrFocus: hasValue || isFocused ? 'hasValueOrFocus' : 'noValueOrFocus',
        animatedWhenInside: isTextField ? 'isAnimated' : 'notAnimated',
        disabled: isTextField && disabled ? 'isDisabled' : 'nonDisabled',
        userAssistanceDensity
    });
    const { baseTheme: textFieldTheme } = useComponentTheme(TextFieldRedwoodTheme);
    // JET-74754: Fix dual tooltips on Safari. This prevents safari from putting
    // up its own tooltip for truncated labels.
    const afterClass = clientHints.browser === 'safari' ? safariAfter : undefined;
    // TODO: We need to decide whether to standardize on 'class' or 'className'.  Otherwise, we'll
    // run into issues destructuring style interpolations, for example having to concatenate both.
    const compactLabelStyles = classNames([
        afterClass,
        uaDensityCompactLabel,
        variant === 'start' ? uaDensityCompactLabelStart : uaDensityCompactLabelTopInside
    ]);
    const compactUADLabel = useTruncatingLabel ? (jsx(TruncatingLabel, { ...props, class: compactLabelStyles, hasValue: hasValue, isFocused: isFocused, labelRef: labelRef })) : (jsx("label", { ...props, class: compactLabelStyles }));
    return userAssistanceDensity === 'compact' ? (jsxs("div", { class: classNames([classes, textFieldTheme]), children: [variant !== 'start' && compactUADLabel, jsx(CompactLabelAssistance, { isRequiredShown: isRequiredShown, helpIconId: helpIconId, helpSourceLink: helpSourceLink, helpSourceText: helpSourceText, labelEdge: variant === 'top' || variant === 'start' ? variant : 'inside' }), variant === 'start' && compactUADLabel] })) : useTruncatingLabel ? (jsx(TruncatingLabel, { ...props, class: classNames([afterClass, classes, textFieldTheme]), hasValue: hasValue, isFocused: isFocused, labelRef: labelRef })) : (jsx("label", { "aria-disabled": disabled ? 'true' : undefined, ...props, class: classNames([afterClass, classes, textFieldTheme]) }));
};
const Label = ({ forId, ...props }) => {
    const { hasValue, isDisabled, isFocused, isReadonly } = useFormFieldContext();
    return (jsx(StyledLabel, { for: forId, hasValue: hasValue, disabled: isDisabled, isFocused: isFocused, readonly: isReadonly, ...props }));
};

export { Label as L };
//# sourceMappingURL=Label-5c64c52d.js.map
