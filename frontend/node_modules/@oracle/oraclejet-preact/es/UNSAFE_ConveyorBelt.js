/* @oracle/oraclejet-preact: undefined */
import { jsx, jsxs } from 'preact/jsx-runtime';
import { useState, useRef, useMemo, useEffect, useCallback } from 'preact/hooks';
import { B as BaseButton } from './BaseButton-c2fbaa6d.js';
import { B as ButtonLabelLayout } from './ButtonLabelLayout-d449261a.js';
import { S as SvgChevronLeft } from './ChevronLeft-9485ef57.js';
import { S as SvgChevronRight } from './ChevronRight-e0152ded.js';
import { S as SvgChevronUp } from './ChevronUp-6d141334.js';
import { S as SvgChevronDown } from './ChevronDown-42f09951.js';
import { c as classNames } from './classNames-4e12b00d.js';
import { styles } from './UNSAFE_ConveyorBelt/themes/ConveyorBeltStyles.css.js';
import { u as useUser } from './useUser-df8ae011.js';
import { g as getClientHints } from './clientHints-a42b510c.js';
import { C as ConveyorBeltContext } from './ConveyorBeltContext-76a29c59.js';
export { C as ConveyorBeltContext } from './ConveyorBeltContext-76a29c59.js';
import { u as useTestId } from './useTestId-e5d44ab1.js';
import { forwardRef, useImperativeHandle } from 'preact/compat';
import { u as useComponentTheme } from './useComponentTheme-d2f9e47f.js';
import { ConveyorBeltRedwoodTheme } from './UNSAFE_ConveyorBelt/themes/redwood/ConveyorBeltTheme.js';
import { u as useConveyorBeltItem } from './useConveyorBeltItem-ce7d69d6.js';
import './useHover-85077adb.js';
import './useToggle-8b7fcefe.js';
import './useActive-fb6d4d52.js';
import './useColorScheme-96cce6a1.js';
import './LayerHost-12489cef.js';
import './index-3e2e69c4.js';
import 'preact';
import './UNSAFE_Layer/themes/LayerHostStyles.css.js';
import './LayerHostStyles.styles.css';
import './dimensions-ddde0eee.js';
import './size-a3d3aeaf.js';
import './utils-cfef1929.js';
import './themeContract.css-2b5a42e2.js';
import './colorUtils-b3804ee8.js';
import './_curry1-63949a9b.js';
import './mergeInterpolations-30cd9a69.js';
import './mergeDeepWithKey-33e3d1be.js';
import './_curry3-577eb45e.js';
import './_curry2-01c87f61.js';
import './_isObject-1fab0f5b.js';
import './mergeProps-88ea8306.js';
import './UNSAFE_BaseButton/themes/redwood/BaseButtonTheme.js';
import './UNSAFE_BaseButton/themes/BaseButtonStyles.css.js';
import './BaseButtonStyles.styles.css';
import './UNSAFE_BaseButton/themes/redwood/BaseButtonVariants.css.js';
import './vanilla-extract-recipes-createRuntimeFn.esm-2aaf8c98.js';
import './UNSAFE_BaseButton/themes/redwood/BaseButtonBaseTheme.styles.css';
import './BareButton-0954f33d.js';
import './useBareButton-07a3eef9.js';
import './usePress-051f5adb.js';
import './usePressClick-2ec8e098.js';
import './TabbableModeContext-7d8ad946.js';
import './useTabbableMode-a2fdbb06.js';
import './useId-03dbfdf0.js';
import './buttonUtils-55fb1df7.js';
import './id-83adac50.js';
import './unsafeDomAccess-453eb74e.js';
import './Text-983c749e.js';
import './UNSAFE_Text/themes/TextStyles.css.js';
import './TextStyles.styles.css';
import './useButtonLabelLayoutTheme-a1b95a52.js';
import './UNSAFE_ButtonLabelLayout/themes/redwood/ButtonLabelLayoutTheme.js';
import './UNSAFE_ButtonLabelLayout/themes/ButtonLabelLayoutStyles.css.js';
import './ButtonLabelLayoutStyles.styles.css';
import './UNSAFE_ButtonLabelLayout/themes/redwood/ButtonLabelLayoutBaseTheme.css.js';
import './UNSAFE_ButtonLabelLayout/themes/redwood/ButtonLabelLayoutBaseTheme.styles.css';
import './UNSAFE_ButtonLabelLayout/themes/redwood/ButtonLabelLayoutVariants.css.js';
import './ButtonLabelLayoutVariants.styles.css';
import './Icon-ef2ac069.js';
import './useTooltip-f442fedb.js';
import './useTooltipControlled-d7724623.js';
import './useFocus-38c95977.js';
import './useTouch-4828df25.js';
import './useAnimation-a5eb7604.js';
import './useThemeInterpolations-4b48d878.js';
import './useScale-0ebe15ed.js';
import './theme-63551f30.js';
import './Theme-e6dec6db.js';
import './useDensity-d06ae84a.js';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentTheme.js';
import './hooks/UNSAFE_useTooltip/themes/TooltipContentStyles.css.js';
import './TooltipContentStyles.styles.css';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentBaseTheme.css.js';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentBaseTheme.styles.css';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js';
import './TooltipContentVariants.styles.css';
import './tooltipUtils-466c63c4.js';
import './EnvironmentProvider-546b7ebd.js';
import './LayerManager-a62e619b.js';
import './Floating-6023b41d.js';
import './useFloating-e1167cb9.js';
import './positionUtils-f26caad9.js';
import './refUtils-76275c69.js';
import './useOutsideClick-73a51e1d.js';
import './arrayUtils-35a58161.js';
import './Layer-7d3dc8c7.js';
import './UNSAFE_Layer/themes/LayerStyles.css.js';
import './LayerStyles.styles.css';
import './useModal-953082f2.js';
import './UNSAFE_Floating/themes/redwood/FloatingTheme.js';
import './UNSAFE_Floating/themes/FloatingStyles.css.js';
import './FloatingStyles.styles.css';
import './UNSAFE_Floating/themes/redwood/FloatingBaseTheme.css.js';
import './UNSAFE_Floating/themes/redwood/FloatingBaseTheme.styles.css';
import './UNSAFE_Floating/themes/redwood/FloatingVariants.css.js';
import './vanilla-extract-dynamic.esm-c909758c.js';
import './UNSAFE_Floating/themes/FloatingContract.css.js';
import './useUnsafeDomElementRef-32290273.js';
import './logger-c92f309c.js';
import './UNSAFE_Icon/themes/IconStyle.css.js';
import './IconStyle.styles.css';
import './ConveyorBeltStyles.styles.css';
import './UNSAFE_ConveyorBelt/themes/redwood/ConveyorBeltVariants.css.js';
import './ConveyorBeltVariants.styles.css';
import './UNSAFE_ConveyorBelt/themes/redwood/ConveyorBeltBaseTheme.css.js';
import './UNSAFE_ConveyorBelt/themes/redwood/ConveyorBeltBaseTheme.styles.css';

/**
 * Helper function to determine whether the current device is a mobile device
 * @returns true if runnning on a mobile device, false otherwise
 */
function isMobile() {
    const deviceType = getClientHints().deviceRenderMode;
    return deviceType === 'phone';
}
function getOffsetParent(element) {
    if (getComputedStyle(element).position === 'fixed') {
        return null;
    }
    return element.offsetParent;
}
function getOffsetLeft(element, contentContainer) {
    let offsetParent = getOffsetParent(element);
    let offsetLeft = element.offsetLeft;
    while (offsetParent && offsetParent !== contentContainer && offsetParent !== document.body) {
        offsetLeft = offsetLeft + offsetParent.offsetLeft;
        offsetParent = getOffsetParent(offsetParent);
    }
    return offsetLeft;
}
function getOffsetTop(element, contentContainer) {
    let offsetParent = getOffsetParent(element);
    let offsetTop = element.offsetTop;
    while (offsetParent !== contentContainer) {
        if (offsetParent != null) {
            offsetTop = offsetTop + offsetParent.offsetTop;
            offsetParent = getOffsetParent(offsetParent);
        }
    }
    return offsetTop;
}
// utility hook that calculates which conveyorbelt items are visible inside conveyorbelt viewport
// and which are hidden
const useConveyorElementsVisible = (root, orientation, prevBtn, nextBtn, direction) => {
    const observerRef = useRef();
    const targetsRef = useRef([]);
    const [targets] = useState([]);
    const addTarget = useCallback((target) => {
        if (targetsRef.current !== null) {
            targetsRef.current.push(target);
            targets.push(target);
        }
    }, [targets]);
    useEffect(() => {
        if (targets && targets.length > 0 && root) {
            // IntersectionObserver calls visibility change only when item is
            // fully visible inside (threshold: 1)
            // conveyorbelt viewport (root),
            // taking arrow buttons into the account
            // and viewport should be smaller by the buttons width (rootMargin)
            const rootMargin = orientation === 'horizontal'
                ? direction === 'ltr'
                    ? `0px ${nextBtn ? -nextBtn.offsetWidth : 0}px 0px ${prevBtn ? -prevBtn.offsetWidth : 0}px`
                    : `0px ${prevBtn ? -prevBtn.offsetWidth : 0}px 0px ${nextBtn ? -nextBtn.offsetWidth : 0}px`
                : `${nextBtn ? -nextBtn.offsetHeight : 0}px 0px ${prevBtn ? -prevBtn.offsetHeight : 0}px 0px`;
            observerRef.current = new IntersectionObserver(onVisibilityChange, {
                root,
                rootMargin: rootMargin,
                threshold: 1
            });
            for (const target of targets) {
                if (target != null)
                    observerRef.current.observe(target.element);
            }
        }
        return () => {
            for (const target of targets) {
                if (observerRef.current && target != null)
                    observerRef.current.unobserve(target.element);
            }
        };
    }, [targets, targets.length, root, nextBtn, prevBtn, direction, orientation]);
    // handle visibility changes
    const onVisibilityChange = (entries) => {
        const newItems = targetsRef.current.map((conveyorItem, index) => {
            const foundEntry = entries.find((entry) => entry.target === conveyorItem.element);
            // if visibility changed for the item, change isVisible property,
            // otherwise just return the original
            if (foundEntry) {
                return {
                    element: foundEntry.target,
                    isVisible: foundEntry.isIntersecting,
                    isCurrent: conveyorItem.isCurrent,
                    index: index
                };
            }
            else {
                return conveyorItem;
            }
        });
        targetsRef.current = newItems;
    };
    return useMemo(() => ({
        itemElementsRef: targetsRef,
        addItem: addTarget
    }), [targetsRef, addTarget]);
};
/**
 * The Conveyor belt component is a container element that manages
 * overflow for its child elements and allows scrolling among them
 */
const ConveyorBelt = forwardRef(({ children, scrollPosition, onScrollPositionChanged, arrowVisibility = 'auto', orientation = 'horizontal', testId }, ref = null) => {
    const [canPaginateNext, setCanPaginateNext] = useState(false);
    const [canPaginatePrevious, setCanPaginatePrevious] = useState(false);
    const overflowContainerRef = useRef(null);
    const contentContainerRef = useRef(null);
    const nextButtonContainerRef = useRef(null);
    const prevButtonContainerRef = useRef(null);
    const baseRef = useRef(null);
    const leftRef = useRef(null);
    const rightRef = useRef(null);
    const observerRef = useRef(null);
    const currentItemRef = useRef(null);
    const [buttonsHidden, setButtonsHidden] = useState((isMobile() && arrowVisibility === 'auto') || arrowVisibility === 'hidden');
    const { direction } = useUser();
    const { itemElementsRef, addItem } = useConveyorElementsVisible(overflowContainerRef.current, orientation, prevButtonContainerRef.current, nextButtonContainerRef.current, direction);
    useImperativeHandle(ref, () => ({
        scrollElementIntoView: (element) => {
            scrollIntoView(element);
        },
        scrollPrevious: () => {
            scrollToPreviousPage();
        },
        scrollNext: () => {
            scrollToNextPage();
        }
    }));
    const testIdProps = useTestId(testId);
    const leftArrowTestIdProps = 'leftArrow' + testId;
    const rightArrowTestIdProps = 'rightArrow' + testId;
    const { variantClasses } = useComponentTheme(ConveyorBeltRedwoodTheme, {
        orientation
    });
    const { variantClasses: contentClasses } = useComponentTheme(ConveyorBeltRedwoodTheme, {
        content: orientation
    });
    const { variantClasses: overflowClasses } = useComponentTheme(ConveyorBeltRedwoodTheme, {
        pagination: canPaginateNext && canPaginatePrevious
            ? 'both'
            : canPaginateNext
                ? 'next'
                : canPaginatePrevious
                    ? 'previous'
                    : 'none',
        direction,
        orientation,
        overflow: orientation,
        arrowVisibility: buttonsHidden === true ? 'hidden' : 'visible'
    });
    const { classes: nextButtonClasses } = useComponentTheme(ConveyorBeltRedwoodTheme, {
        nextButton: orientation,
        direction
    });
    const { classes: previousButtonClasses } = useComponentTheme(ConveyorBeltRedwoodTheme, {
        previousButton: orientation,
        direction
    });
    // utility method to get all conveyorbelt items
    const _getConveyorItems = () => {
        const conveyorContentChildren = contentContainerRef.current
            ? Array.from(contentContainerRef.current.querySelectorAll('[data-oj-conveyorbelt-item]'))
            : [];
        if (conveyorContentChildren) {
            let index = -1;
            itemElementsRef.current = [];
            for (const child of conveyorContentChildren) {
                index++;
                const element = child;
                if (element) {
                    addItem({
                        element: element,
                        isVisible: false,
                        index: index,
                        isCurrent: false
                    });
                }
            }
        }
    };
    useEffect(() => {
        _getConveyorItems();
    });
    const scrollEndHandler = useCallback(() => {
        if (onScrollPositionChanged)
            onScrollPositionChanged(overflowContainerRef.current?.scrollLeft);
    }, [onScrollPositionChanged]);
    useEffect(() => {
        setButtonsHidden((isMobile() && arrowVisibility === 'auto') || arrowVisibility === 'hidden');
    }, [arrowVisibility]);
    useEffect(() => {
        if (!overflowContainerRef.current)
            return;
        overflowContainerRef.current.scrollTo({
            left: scrollPosition
        });
    }, [scrollPosition]);
    // useEffect hook that calculates when arrow buttons should become visible or hidden
    // using IntersectionObserver
    useEffect(() => {
        const overflowContainer = overflowContainerRef.current;
        const leftGuard = leftRef.current;
        const rightGuard = rightRef.current;
        if (overflowContainer && leftGuard && rightGuard) {
            if (!buttonsHidden) {
                observerRef.current = new IntersectionObserver((entries) => {
                    entries.forEach((entry) => {
                        if (entry.target.getAttribute('data-intersection-id') === 'left') {
                            setCanPaginatePrevious(!entry.isIntersecting);
                        }
                        else {
                            setCanPaginateNext(!entry.isIntersecting);
                        }
                    });
                }, {
                    root: overflowContainer
                });
                observerRef.current.observe(leftGuard);
                observerRef.current.observe(rightGuard);
            }
            overflowContainer.addEventListener('scrollend', scrollEndHandler);
        }
        // Clean-up
        return () => {
            if (!overflowContainer)
                return;
            overflowContainer.removeEventListener('scrollend', scrollEndHandler);
            observerRef.current?.unobserve(leftGuard);
            observerRef.current?.unobserve(rightGuard);
        };
    }, [buttonsHidden, scrollEndHandler]);
    const scrollIntoView = useCallback((element) => {
        const prevOffsetWidth = prevButtonContainerRef.current ? prevButtonContainerRef.current.offsetWidth : 0;
        const prevOffsetHeight = nextButtonContainerRef.current ? nextButtonContainerRef.current.offsetHeight : 0;
        const nextOffsetWidth = prevButtonContainerRef.current ? prevButtonContainerRef.current.offsetWidth : 0;
        const nextOffsetHeight = nextButtonContainerRef.current ? nextButtonContainerRef.current.offsetWidth : 0;
        // utility method to check if the element is closer to the end edge of the conveyorbelt
        const _shouldSnapToTheEndEdge = (ltr, orientation, elem, scroller) => {
            if (!elem || !scroller)
                return false;
            let right;
            let left;
            let bottom;
            if (scroller === document.documentElement) {
                left = 0;
                right = document.documentElement.clientWidth;
                bottom = document.documentElement.clientHeight;
            }
            else {
                const scrollerBounds = scroller.getBoundingClientRect();
                right = canPaginateNext
                    ? scrollerBounds.right - nextOffsetWidth
                    : scrollerBounds.right;
                left = canPaginateNext
                    ? scrollerBounds.left - nextOffsetWidth
                    : scrollerBounds.left;
                bottom = canPaginateNext
                    ? scrollerBounds.bottom - nextOffsetHeight
                    : scrollerBounds.bottom;
            }
            const bounds = elem.getBoundingClientRect();
            return orientation === 'horizontal'
                ? ltr
                    ? bounds.right > right
                    : bounds.left < left
                : bounds.bottom > bottom;
        };
        // utility method to check that an element is fully visible inside conveyorbelt
        const _isElementInsideScrollerBounds = (orientation, elem, scroller) => {
            if (!elem || !scroller)
                return false;
            let left;
            let right;
            let top;
            let bottom;
            if (scroller === document.documentElement) {
                left = 0;
                right = document.documentElement.clientWidth;
                top = 0;
                bottom = document.documentElement.clientHeight;
            }
            else {
                const scrollerBounds = scroller.getBoundingClientRect();
                left = canPaginatePrevious
                    ? scrollerBounds.left + prevOffsetWidth
                    : scrollerBounds.left;
                right = canPaginateNext
                    ? scrollerBounds.right - nextOffsetWidth
                    : scrollerBounds.right;
                top = canPaginatePrevious
                    ? scrollerBounds.top + prevOffsetHeight
                    : scrollerBounds.top;
                bottom = canPaginateNext
                    ? scrollerBounds.bottom - nextOffsetHeight
                    : scrollerBounds.bottom;
            }
            const bounds = elem.getBoundingClientRect();
            return orientation === 'horizontal'
                ? bounds.left <= right &&
                    bounds.right <= right &&
                    bounds.left >= left &&
                    bounds.right >= left
                : bounds.top <= bottom &&
                    bounds.bottom <= bottom &&
                    bounds.top >= top &&
                    bounds.bottom >= top;
        };
        const _isElementOverflowingScrollerBounds = (orientation, elem, scroller) => {
            if (!elem || !scroller)
                return false;
            const bounds = elem.getBoundingClientRect();
            const scrollerBounds = scroller.getBoundingClientRect();
            let width = scrollerBounds.width;
            let height = scrollerBounds.height;
            if (orientation === 'horizontal') {
                width =
                    canPaginatePrevious && prevButtonContainerRef.current
                        ? width - prevButtonContainerRef.current.offsetWidth
                        : width;
                width =
                    canPaginateNext && nextButtonContainerRef.current
                        ? width - nextButtonContainerRef.current.offsetWidth
                        : width;
            }
            else {
                height =
                    canPaginatePrevious && prevButtonContainerRef.current
                        ? height - prevButtonContainerRef.current.offsetHeight
                        : height;
                height =
                    canPaginateNext && nextButtonContainerRef.current
                        ? height - nextButtonContainerRef.current.offsetHeight
                        : height;
            }
            return orientation === 'horizontal' ? bounds.width > width : bounds.height > height;
        };
        const isElementVisible = _isElementInsideScrollerBounds(orientation, element, overflowContainerRef.current);
        if (isElementVisible) {
            return;
        }
        const isElementOverflowing = _isElementOverflowingScrollerBounds(orientation, element, overflowContainerRef.current);
        if (!overflowContainerRef.current || !contentContainerRef.current)
            return;
        const shouldSnapEnd = _shouldSnapToTheEndEdge(direction === 'ltr', orientation, element, overflowContainerRef.current);
        if (orientation === 'vertical') {
            if (shouldSnapEnd && !isElementOverflowing) {
                overflowContainerRef.current.scrollTo({
                    top: getOffsetTop(element, contentContainerRef.current) +
                        element.offsetHeight -
                        overflowContainerRef.current.offsetHeight +
                        (nextButtonContainerRef.current?.offsetHeight
                            ? nextButtonContainerRef.current?.offsetHeight + 1
                            : 0),
                    behavior: 'smooth'
                });
            }
            else {
                overflowContainerRef.current.scrollTo({
                    top: getOffsetTop(element, contentContainerRef.current) -
                        (prevButtonContainerRef.current?.offsetHeight
                            ? prevButtonContainerRef.current?.offsetHeight + 1
                            : 0),
                    behavior: 'smooth'
                });
            }
            return;
        }
        if (direction === 'ltr') {
            if (shouldSnapEnd && !isElementOverflowing) {
                overflowContainerRef.current.scrollTo({
                    left: getOffsetLeft(element, contentContainerRef.current) +
                        element.offsetWidth -
                        overflowContainerRef.current.offsetWidth +
                        (nextButtonContainerRef.current?.offsetWidth
                            ? nextButtonContainerRef.current?.offsetWidth + 1
                            : 0),
                    behavior: 'smooth'
                });
            }
            else {
                overflowContainerRef.current.scrollTo({
                    left: getOffsetLeft(element, contentContainerRef.current) -
                        (prevButtonContainerRef.current?.offsetWidth
                            ? prevButtonContainerRef.current?.offsetWidth + 1
                            : 0),
                    behavior: 'smooth'
                });
            }
        }
        else {
            if (shouldSnapEnd && !isElementOverflowing) {
                overflowContainerRef.current.scrollTo({
                    left: getOffsetLeft(element, contentContainerRef.current) -
                        contentContainerRef.current.offsetWidth +
                        overflowContainerRef.current.offsetWidth -
                        (nextButtonContainerRef.current?.offsetWidth
                            ? nextButtonContainerRef.current?.offsetWidth + 1
                            : 0),
                    behavior: 'smooth'
                });
            }
            else {
                overflowContainerRef.current.scrollTo({
                    left: getOffsetLeft(element, contentContainerRef.current) +
                        element.offsetWidth -
                        contentContainerRef.current.offsetWidth +
                        (prevButtonContainerRef.current?.offsetWidth
                            ? prevButtonContainerRef.current?.offsetWidth + 1
                            : 0),
                    behavior: 'smooth'
                });
            }
        }
    }, [canPaginateNext, canPaginatePrevious, direction, orientation]);
    const getNextInvisible = useCallback(() => {
        const nextInvisible = itemElementsRef.current.find((item) => {
            if (item.isVisible == false &&
                item.index >= 1 &&
                itemElementsRef.current[item.index - 1].isVisible == true) {
                return true;
            }
            return false;
        });
        return nextInvisible?.element;
    }, [itemElementsRef]);
    const getPreviousInvisible = useCallback(() => {
        const previousInvisible = itemElementsRef.current.find((item) => {
            if (item.isVisible == false &&
                item.index < itemElementsRef.current.length - 1 &&
                itemElementsRef.current[item.index + 1].isVisible == true) {
                return true;
            }
            return false;
        });
        return previousInvisible?.element;
    }, [itemElementsRef]);
    // paginates to the previous partially visible or hidden item in the conveyorbelt,
    // so that it is the last visible of the conveyorbelt view port
    const scrollToPreviousPage = useCallback(() => {
        const overflowContainer = overflowContainerRef.current;
        const scrollAmount = orientation === 'horizontal'
            ? overflowContainerRef.current?.clientWidth
            : overflowContainerRef.current?.clientHeight;
        if (overflowContainer && scrollAmount) {
            const previousInvisible = getPreviousInvisible();
            if (orientation === 'vertical') {
                if (!previousInvisible) {
                    overflowContainer.scrollTo({
                        top: overflowContainer.scrollTop - scrollAmount,
                        behavior: 'smooth'
                    });
                }
                else {
                    overflowContainer.scrollTo({
                        top: getOffsetTop(previousInvisible, contentContainerRef.current) +
                            previousInvisible.offsetHeight -
                            overflowContainer.offsetHeight +
                            (prevButtonContainerRef.current?.offsetHeight
                                ? prevButtonContainerRef.current?.offsetHeight + 1
                                : 0),
                        behavior: 'smooth'
                    });
                }
                return;
            }
            if (direction === 'ltr') {
                if (!previousInvisible) {
                    overflowContainer.scrollTo({
                        left: overflowContainer.scrollLeft - scrollAmount,
                        behavior: 'smooth'
                    });
                }
                else {
                    overflowContainer.scrollTo({
                        left: getOffsetLeft(previousInvisible, contentContainerRef.current) +
                            previousInvisible.offsetWidth -
                            overflowContainer.offsetWidth +
                            (prevButtonContainerRef.current?.offsetWidth
                                ? prevButtonContainerRef.current?.offsetWidth + 1
                                : 0),
                        behavior: 'smooth'
                    });
                }
            }
            else {
                if (!previousInvisible) {
                    overflowContainer.scrollTo({
                        left: overflowContainer.scrollLeft + scrollAmount,
                        behavior: 'smooth'
                    });
                }
                else {
                    overflowContainer.scrollTo({
                        left: getOffsetLeft(previousInvisible, contentContainerRef.current) -
                            (contentContainerRef.current ? contentContainerRef.current.offsetWidth : 0) +
                            overflowContainer.offsetWidth -
                            (prevButtonContainerRef.current?.offsetWidth
                                ? prevButtonContainerRef.current?.offsetWidth + 1
                                : 0),
                        behavior: 'smooth'
                    });
                }
            }
        }
    }, [direction, orientation, getPreviousInvisible]);
    // paginates to the next partially visible or hidden item in the conveyorbelt,
    // so that it is the first at the start of the conveyorbelt view port
    const scrollToNextPage = useCallback(() => {
        const overflowContainer = overflowContainerRef.current;
        const scrollAmount = orientation === 'horizontal'
            ? overflowContainerRef.current?.clientWidth
            : overflowContainerRef.current?.clientHeight;
        if (overflowContainer && scrollAmount) {
            const nextInvisible = getNextInvisible();
            if (orientation === 'vertical') {
                if (!nextInvisible) {
                    overflowContainer.scrollTo({
                        top: overflowContainer.scrollTop + scrollAmount,
                        behavior: 'smooth'
                    });
                }
                else {
                    overflowContainer.scrollTo({
                        top: getOffsetTop(nextInvisible, contentContainerRef.current) -
                            (nextButtonContainerRef.current?.offsetHeight
                                ? nextButtonContainerRef.current?.offsetHeight + 1
                                : 0),
                        behavior: 'smooth'
                    });
                }
                return;
            }
            if (direction === 'ltr') {
                if (!nextInvisible) {
                    overflowContainer.scrollTo({
                        left: overflowContainer.scrollLeft + scrollAmount,
                        behavior: 'smooth'
                    });
                }
                else {
                    overflowContainer.scrollTo({
                        left: (getOffsetLeft(nextInvisible, contentContainerRef.current) ?? 0) -
                            (nextButtonContainerRef.current?.offsetWidth
                                ? nextButtonContainerRef.current?.offsetWidth + 1
                                : 0),
                        behavior: 'smooth'
                    });
                }
            }
            else {
                if (!nextInvisible) {
                    overflowContainer.scrollTo({
                        left: overflowContainer.scrollLeft - scrollAmount,
                        behavior: 'smooth'
                    });
                }
                else {
                    overflowContainer.scrollTo({
                        left: -((contentContainerRef.current ? contentContainerRef.current.offsetWidth : 0) -
                            (getOffsetLeft(nextInvisible, contentContainerRef.current) ?? 0)) +
                            (nextInvisible?.offsetWidth ?? 0) +
                            (nextButtonContainerRef.current?.offsetWidth
                                ? nextButtonContainerRef.current?.offsetWidth + 1
                                : 0),
                        behavior: 'smooth'
                    });
                }
            }
        }
    }, [direction, orientation, getNextInvisible]);
    const setCurrentItem = useCallback((node) => {
        if (currentItemRef.current !== node) {
            // this logic below is needed to make sure only one item is current
            const item = itemElementsRef.current.find((item) => item.element === node);
            const currentItem = itemElementsRef.current.find((item) => item.isCurrent === true);
            if (item === currentItem || !item)
                return;
            if (currentItem)
                currentItem.isCurrent = false;
            item.isCurrent = true;
            currentItemRef.current = node;
            if (node)
                scrollIntoView(node);
        }
    }, [itemElementsRef, scrollIntoView]);
    const onFocus = useCallback((event) => {
        if (baseRef.current?.isEqualNode(event.target)) {
            return;
        }
        if (itemElementsRef.current.length > 0) {
            const item = itemElementsRef.current.find((item) => item.element.contains(event.target));
            if (item) {
                scrollIntoView(item.element);
            }
        }
        else {
            scrollIntoView(event.target);
        }
    }, [scrollIntoView, itemElementsRef]);
    const previousButtonStyle = classNames([styles.buttonContainer, previousButtonClasses]);
    const nextButtonStyle = classNames([styles.buttonContainer, nextButtonClasses]);
    return (jsx(ConveyorBeltContext.Provider, { value: { setCurrentItem }, children: jsxs("div", { onFocus: onFocus, ref: baseRef, className: classNames([styles.conveyorStyle, variantClasses]), ...testIdProps, children: [canPaginatePrevious && !buttonsHidden && (jsx("div", { ref: prevButtonContainerRef, class: previousButtonStyle, children: jsx(BaseButton, { elementDetails: { type: 'span', isFocusable: false }, styling: ['min'], size: 'sm', variant: 'ghost', onAction: () => scrollToPreviousPage(), "aria-hidden": true, testId: leftArrowTestIdProps, children: jsx(ButtonLabelLayout, { size: 'sm', display: 'icons', startIcon: orientation === 'horizontal' ? (direction === 'ltr' ? (jsx(SvgChevronLeft, {})) : (jsx(SvgChevronRight, {}))) : (jsx(SvgChevronUp, {})) }) }) })), jsx("div", { className: classNames([styles.overflowContainer, overflowClasses]), ref: overflowContainerRef, tabIndex: -1, children: jsxs("div", { className: classNames([styles.contentContainer, variantClasses, contentClasses]), ref: contentContainerRef, children: [jsx("div", { "data-intersection-id": "left", ref: leftRef, style: { minWidth: 1, minHeight: 1 } }), children, jsx("div", { "data-intersection-id": "right", ref: rightRef, style: { minWidth: 1, minHeight: 1 } })] }) }), canPaginateNext && !buttonsHidden && (jsx("div", { ref: nextButtonContainerRef, class: nextButtonStyle, children: jsx(BaseButton, { elementDetails: { type: 'span', isFocusable: false }, styling: ['min'], size: 'sm', variant: 'ghost', onAction: () => scrollToNextPage(), "aria-hidden": true, testId: rightArrowTestIdProps, children: jsx(ButtonLabelLayout, { size: 'sm', display: 'icons', startIcon: orientation === 'horizontal' ? (direction === 'ltr' ? (jsx(SvgChevronRight, {})) : (jsx(SvgChevronLeft, {}))) : (jsx(SvgChevronDown, {})) }) }) }))] }) }));
});

/**
 * A wrapper component for one conveyor belt item/child element.
 * It takes care of correctly mark the child components as conveyor belt items.
 * @param param0 ConveyorBeltItemProps
 * @returns
 */
const ConveyorBeltItem = ({ children, isCurrent }) => {
    const props = useConveyorBeltItem({
        isCurrent: isCurrent
    });
    return (jsx("div", { className: classNames([styles.conveyorBeltItemStyle]), ...props, children: children }));
};

export { ConveyorBelt, ConveyorBeltItem };
//# sourceMappingURL=UNSAFE_ConveyorBelt.js.map
