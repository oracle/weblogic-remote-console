/* @oracle/oraclejet-preact: undefined */
/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Returns the normalized Position depending on the reading direction
 * @param side The side that should be normalized
 * @param direction The reading direction
 * @returns The normalized 'right' or 'left' position if the side was 'start' or 'end', otherwise returns unchanged position
 */
const normalizePosition = (side, direction) => {
    const sideHashLtr = {
        start: 'left',
        end: 'right'
    };
    const sideHashRtl = {
        start: 'right',
        end: 'left'
    };
    if (direction === 'rtl') {
        return side.replace(/start|end/g, (matched) => sideHashRtl[matched]);
    }
    else {
        return side.replace(/start|end/g, (matched) => sideHashLtr[matched]);
    }
};
/**
 * Returns the reversed normalized Position depending on the reading direction
 * @param side The side that should be reversed
 * @param direction The reading direction
 * @returns The 'start' or 'end' position if the side was 'right' or 'left', otherwise returns unchanged position
 */
const reverseNormalizePosition = (side, direction) => {
    const sideHashLtr = {
        left: 'start',
        right: 'end'
    };
    const sideHashRtl = {
        right: 'start',
        left: 'end'
    };
    if (direction === 'rtl') {
        return side.replace(/left|right/g, (matched) => sideHashRtl[matched]);
    }
    else {
        return side.replace(/left|right/g, (matched) => sideHashLtr[matched]);
    }
};
/**
 * Check is 'window' is available
 */
const hasWindow = () => {
    return typeof window !== 'undefined';
};
/**
 * Returns the window object for the node
 */
const getWindow = (node) => {
    return node?.ownerDocument?.defaultView || window;
};
/**
 * Checks if the value is a valid node
 */
const isNode = (value) => {
    if (!hasWindow()) {
        return false;
    }
    return value instanceof Node || value instanceof getWindow(value).Node;
};
/**
 * Checks if the node is the last traversable ancestor
 */
const isLastTraversableNode = (node) => {
    return ['html', 'body', '#document'].includes(getNodeName(node));
};
/**
 * Returns document element for the node
 */
const getDocumentElement = (node) => {
    return ((isNode(node) ? node.ownerDocument : node.document) || window.document)?.documentElement;
};
/**
 * Returns normalized node name
 */
const getNodeName = (node) => {
    if (isNode(node)) {
        return (node.nodeName || '').toLowerCase();
    }
    return '#document';
};
/**
 * Returns node's parent
 */
const getParentNode = (node) => {
    if (getNodeName(node) === 'html') {
        return node;
    }
    return node.parentNode || getDocumentElement(node);
};
/**
 * Checks if the value is an HTMLElement
 */
const isHTMLElement = (value) => {
    if (!hasWindow()) {
        return false;
    }
    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
};
/**
 * Checks if the element is a containing block
 */
const isContainingBlock = (element) => {
    const css = getComputedStyle(element);
    return (css.transform !== 'none' ||
        css.perspective !== 'none' ||
        (css.containerType ? css.containerType !== 'normal' : false) ||
        ['transform', 'perspective', 'filter'].some((value) => (css.willChange || '').includes(value)) ||
        ['paint', 'layout', 'strict', 'content'].some((value) => (css.contain || '').includes(value)));
};
/**
 * Returns element's containg block or null (if no containing block exists)
 */
const getContainingBlockElem = (element) => {
    let currentNode = getParentNode(element);
    while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
        if (isContainingBlock(currentNode)) {
            return currentNode;
        }
        currentNode = getParentNode(currentNode);
    }
    return null;
};

export { getContainingBlockElem as g, normalizePosition as n, reverseNormalizePosition as r };
//# sourceMappingURL=positionUtils-f26caad9.js.map
