/* @oracle/oraclejet-preact: undefined */
import { jsx } from 'preact/jsx-runtime';
import { useRef } from 'preact/hooks';

const useDnd = ({ onDragStart, onDrag, onDragEnd, onDragEnter, onDragLeave, onDragOver, onDrop, getDragContext, getDropContext, getDragImage, onPreDndStart, setDatatipDisabled, showDropEffect = () => undefined, showRejectedDropEffect = () => undefined, clearDropEffect = () => undefined }) => {
    const dragCandidate = useRef(null);
    const dragImageRef = useRef(null);
    const dndContent = jsx("div", { ref: dragImageRef });
    const onPointerDown = (event) => {
        dragCandidate.current = event.target;
    };
    const onDndStart = (event) => {
        const target = dragCandidate.current ? dragCandidate.current : event.target;
        const context = getDragContext(target, event);
        if (context) {
            onPreDndStart && onPreDndStart(context);
            setDatatipDisabled(true);
            const dragImg = getDragImage({ event, target, context });
            if (!dragImg)
                return;
            const dragImage = dragImg.image;
            dragImage.style.width = dragImg.width + 'px';
            dragImage.style.height = dragImg.height + 'px';
            // JET-69400 Drag and drop multiple nodes far apart shows wrong drag image
            dragImage.style.left = -1 * dragImg.width + 'px';
            dragImage.style.top = -1 * dragImg.height + 'px';
            dragImage.style.position = 'absolute';
            document.body.append(dragImage); // @HTMLUpdateOK will remove in next animation frame
            event.dataTransfer?.setDragImage(dragImage, dragImg.offSetX, dragImg.offSetY);
            window.requestAnimationFrame(() => {
                document.body.removeChild(dragImage);
            });
            onDragStart && onDragStart(context);
        }
        else {
            event.preventDefault();
        }
    };
    const onDndDrag = (event) => {
        onDrag && onDrag({ event: event });
    };
    const onDndEnd = (event) => {
        setDatatipDisabled(false);
        onDragEnd && onDragEnd({ event: event });
    };
    const onDndEnter = (event) => {
        const context = getDropContext(event);
        if (onDragEnter && context) {
            onDragEnter(context);
            if (event.defaultPrevented) {
                showDropEffect(context);
            }
            else {
                showRejectedDropEffect(context);
            }
        }
    };
    const onDndLeave = (event) => {
        const context = getDropContext(event);
        onDragLeave && context && onDragLeave(context);
        clearDropEffect();
    };
    const onDndOver = (event) => {
        const context = getDropContext(event);
        if (onDragOver && context) {
            onDragOver(context);
            if (event.defaultPrevented) {
                showDropEffect(context);
            }
            else {
                showRejectedDropEffect(context);
            }
        }
    };
    const onDndDrop = (event) => {
        const context = getDropContext(event);
        onDrop && context && onDrop(context);
        clearDropEffect();
    };
    return {
        dragProps: {
            onDragStart: onDndStart,
            onDrag: onDndDrag,
            onDragEnd: onDndEnd,
            onPointerDown
        },
        dropProps: {
            onDragEnter: onDndEnter,
            onDragLeave: onDndLeave,
            onDragOver: onDndOver,
            onDrop: onDndDrop
        },
        content: dndContent
    };
};

export { useDnd as u };
//# sourceMappingURL=useDnd-c5ae190c.js.map
