/* @oracle/oraclejet-preact: undefined */
import { byCss } from '@oracle/oraclejet-testing/UNSAFE_Locators';
import { TestAdapter } from '@oracle/oraclejet-testing/UNSAFE_TestAdapter';

class MessageToastAdapter extends TestAdapter {
    /**
     * Closes the message identified by the provided key.
     * @param messageLocator.key {string | number} The key within the MessageToast's dataset associated with the individual message.
     * @throws {Error} when the specified is not closable (closeAffordance set to "off")
     */
    async doClose(messageLocator) {
        const driver = this.getTestDriver();
        const toastSelector = `div[role="alert"]${this.getMessageSelector(messageLocator.key)}`;
        const closeButtonSelector = '[data-oj-message-close-button] button';
        let closeButton;
        try {
            closeButton = await (await this.getElement()).waitForElement(byCss(`${toastSelector} ${closeButtonSelector}`));
        }
        catch {
            throw new Error('The close operation is not applicable for the messageLocator.');
        }
        await driver.click(closeButton);
    }
    /**
     * Retrieve a TestElement which represents the custom detail content of a single message.
     * @param messageLocator.key {string | number} The key within the MessageToast's dataset associated with the individual message.
     * @throws {Error} when the detail content rendered is not provided by the application
     * @returns The detail content of the message rendered by the application
     */
    async findDetail(messageLocator) {
        const toastSelector = `div[role="alert"]${this.getMessageSelector(messageLocator.key)}`;
        const customDetailContentSelector = '[data-oj-message-custom-detail]';
        try {
            const customDetail = await (await this.getElement()).waitForElement(byCss(`${toastSelector} ${customDetailContentSelector}`));
            return customDetail;
        }
        catch {
            throw new Error('No corresponding detail template or renderer found for the messageLocator.');
        }
    }
    /**
     * Retrieve a TestElement which represents the custom icon content of a single message.
     * @param messageLocator.key {string | number} The key within the MessageToast's dataset associated with the individual message.
     * @throws {Error} when the icon content rendered is not provided by the application
     * @returns The icon content of the message rendered by the application
     */
    async findIcon(messageLocator) {
        const toastSelector = `div[role="alert"]${this.getMessageSelector(messageLocator.key)}`;
        const customIconContentSelector = '[data-oj-message-custom-icon]';
        try {
            const customIcon = await (await this.getElement()).waitForElement(byCss(`${toastSelector} ${customIconContentSelector}`));
            return customIcon;
        }
        catch {
            throw new Error('No corresponding icon template or renderer found for the messageLocator.');
        }
    }
    /**
     * Creates the CSS selector for the message with the provided key.
     *
     * @param key The key of the message
     * @returns the css selector that can used to fetch the message
     */
    getMessageSelector(key) {
        return typeof key === 'number'
            ? `[data-oj-key="number-${key}"]`
            : `[data-oj-key="string-${key}"]`;
    }
}

export { MessageToastAdapter };
//# sourceMappingURL=MessageToastAdapter.js.map
