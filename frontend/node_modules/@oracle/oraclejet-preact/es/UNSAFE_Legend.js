/* @oracle/oraclejet-preact: undefined */
import { jsxs, Fragment, jsx } from 'preact/jsx-runtime';
import { useContext, useRef, useState, useMemo } from 'preact/hooks';
import { u as useLegendDatatip, a as useLegendContextMenu, B as BaseLegend } from './useLegendContextMenu-44f0fe17.js';
import { u as useVisEvent } from './useVisEvents-51a15315.js';
import { g as getGridNums, a as getLegendTextStyle, b as getItemInfo, i as isEqualItem, c as getDatatipText, d as getAriaProps, u as useLegendDnd, l as legendVars, e as getIsLegendItemActionable, f as getKeyUpHandler } from './useLegendDnd-19e0e582.js';
import { m as mergeProps } from './mergeProps-88ea8306.js';
import { u as useItemFocus } from './useItemFocus-c12e2756.js';
import { styles } from './PRIVATE_BaseLegend/themes/LegendStyles.css.js';
import { u as useCssVars } from './useCssVars-143870e2.js';
import { c as classNames } from './classNames-4e12b00d.js';
import { u as useTestId } from './useTestId-e5d44ab1.js';
import { u as useVisTouchResponse } from './useVisTouchResponse-a59ab166.js';
import { l } from './stringUtils-0fe25200.js';
import { forwardRef, useImperativeHandle } from 'preact/compat';
import { T as TrackResizeContainer } from './TrackResizeContainer-4411f745.js';
import { u as useTextDimensions } from './useTextDimensions-45f79df4.js';
import { styles as styles$1 } from './hooks/PRIVATE_useVisDnd/themes/VisDndStyles.css.js';
import { L as LegendRenderedContext } from './LegendRendered-65a3684e.js';
import './SvgSymbol-a3802183.js';
import './Marker-81aae9f0.js';
import './PRIVATE_SvgShapes/themes/SvgShapesStyles.css.js';
import './SvgShapesStyles.styles.css';
import './Text-983c749e.js';
import './mergeInterpolations-30cd9a69.js';
import './mergeDeepWithKey-33e3d1be.js';
import './_curry3-577eb45e.js';
import './_curry1-63949a9b.js';
import './_curry2-01c87f61.js';
import './_isObject-1fab0f5b.js';
import './UNSAFE_Text/themes/TextStyles.css.js';
import './TextStyles.styles.css';
import './vanilla-extract-recipes-createRuntimeFn.esm-2aaf8c98.js';
import './clientHints-a42b510c.js';
import './useUser-df8ae011.js';
import './LayerHost-12489cef.js';
import './index-3e2e69c4.js';
import 'preact';
import './UNSAFE_Layer/themes/LayerHostStyles.css.js';
import './LayerHostStyles.styles.css';
import './datatipUtils-0a36125e.js';
import './clientUtils-cccff45f.js';
import './useDatatip-c7727336.js';
import './Layer-7d3dc8c7.js';
import './UNSAFE_Layer/themes/LayerStyles.css.js';
import './LayerStyles.styles.css';
import './useThemeInterpolations-4b48d878.js';
import './useColorScheme-96cce6a1.js';
import './useScale-0ebe15ed.js';
import './theme-63551f30.js';
import './Theme-e6dec6db.js';
import './useDensity-d06ae84a.js';
import './unsafeDomAccess-453eb74e.js';
import './Floating-6023b41d.js';
import './useFloating-e1167cb9.js';
import './positionUtils-f26caad9.js';
import './refUtils-76275c69.js';
import './useOutsideClick-73a51e1d.js';
import './arrayUtils-35a58161.js';
import './useModal-953082f2.js';
import './useComponentTheme-d2f9e47f.js';
import './logger-c92f309c.js';
import './utils-cfef1929.js';
import './themeContract.css-2b5a42e2.js';
import './colorUtils-b3804ee8.js';
import './UNSAFE_Floating/themes/redwood/FloatingTheme.js';
import './UNSAFE_Floating/themes/FloatingStyles.css.js';
import './FloatingStyles.styles.css';
import './UNSAFE_Floating/themes/redwood/FloatingBaseTheme.css.js';
import './UNSAFE_Floating/themes/redwood/FloatingBaseTheme.styles.css';
import './UNSAFE_Floating/themes/redwood/FloatingVariants.css.js';
import './vanilla-extract-dynamic.esm-c909758c.js';
import './UNSAFE_Floating/themes/FloatingContract.css.js';
import './useUnsafeDomElementRef-32290273.js';
import './hooks/PRIVATE_useDatatip/themes/useDatatip.css.js';
import './useDatatip.styles.css';
import './useId-03dbfdf0.js';
import './useVisHover-d7a0b2f3.js';
import './useContextMenu-6aa8193e.js';
import './SelectMenuGroupContext-0c1a7603.js';
import './Sheet-24c3e407.js';
import './Modal-678575d5.js';
import './UNSAFE_Modal/themes/ModalStyles.css.js';
import './ModalStyles.styles.css';
import './tabbableUtils-ce19b388.js';
import './head-8f89fe66.js';
import './_arity-be492b9e.js';
import './_isArray-694cc52d.js';
import './_isString-675f1de9.js';
import './popupUtils-4edf62b5.js';
import './WindowOverlay-b380ce51.js';
import './UNSAFE_WindowOverlay/themes/WindowOverlayStyles.css.js';
import './WindowOverlayStyles.styles.css';
import './UNSAFE_WindowOverlay/themes/WindowOverlayContract.css.js';
import './UNSAFE_WindowOverlay/themes/redwood/WindowOverlayTheme.js';
import './UNSAFE_WindowOverlay/themes/redwood/WindowOverlayBaseTheme.css.js';
import './UNSAFE_WindowOverlay/themes/redwood/WindowOverlayBaseTheme.styles.css';
import './UNSAFE_WindowOverlay/themes/redwood/WindowOverlayVariants.css.js';
import './UNSAFE_Sheet/themes/SheetStyles.css.js';
import './SheetStyles.styles.css';
import './useAnimationStatus-072d6a98.js';
import './useAnimation-a5eb7604.js';
import './animationUtils-5f409a6c.js';
import './useTranslationBundle-25469f1c.js';
import './Dropdown-ead9e679.js';
import './keyboardUtils-986fe923.js';
import './usePopupAnimation-66b186ad.js';
import './popupAnimationUtils-175151d9.js';
import './CollectionInteractionContext-7cf19abc.js';
import './UNSAFE_Dropdown/themes/dropdownStyles.css.js';
import './dropdownStyles.styles.css';
import './useOutsideMousedown-39d7c9a6.js';
import './UNSAFE_Menu/themes/MenuStyles.css.js';
import './MenuStyles.styles.css';
import './UNSAFE_Menu/themes/DropdownMenuStyles.css.js';
import './DropdownMenuStyles.styles.css';
import './Flex-5befe411.js';
import './boxalignment-51b42a0f.js';
import './size-a3d3aeaf.js';
import './boxalignment.styles.css';
import './vanilla-extract-sprinkles-createRuntimeSprinkles.esm-2d655d37.js';
import './dimensions-ddde0eee.js';
import './flexbox-529f25da.js';
import './flexbox.styles.css';
import './flexitem-7b7f7920.js';
import './flexitem.styles.css';
import './FlexStyles.styles.css';
import './Skeleton-a06f4f74.js';
import './borders-98a63040.js';
import './UNSAFE_Skeleton/themes/redwood/SkeletonTheme.js';
import './UNSAFE_Skeleton/themes/SkeletonStyles.css.js';
import './SkeletonStyles.styles.css';
import './UNSAFE_Skeleton/themes/redwood/SkeletonBaseTheme.css.js';
import './UNSAFE_Skeleton/themes/redwood/SkeletonBaseTheme.styles.css';
import './UNSAFE_Skeleton/themes/redwood/SkeletonVariants.css.js';
import './UNSAFE_Menu/themes/MenuSkeletonStyles.css.js';
import './MenuSkeletonStyles.styles.css';
import './LiveRegion-79ffc814.js';
import './LiveRegionStyles.styles.css';
import './UNSAFE_Menu/themes/redwood/MenuItemTheme.js';
import './UNSAFE_Menu/themes/MenuItemStyles.css.js';
import './MenuItemStyles.styles.css';
import './UNSAFE_Menu/themes/redwood/MenuItemBaseTheme.css.js';
import './UNSAFE_Menu/themes/redwood/MenuItemBaseTheme.styles.css';
import './UNSAFE_Menu/themes/redwood/MenuItemVariants.css.js';
import './MenuItemVariants.styles.css';
import './usePress-051f5adb.js';
import './useInteractionStyle-99e32c23.js';
import './useHover-85077adb.js';
import './useToggle-8b7fcefe.js';
import './useActive-fb6d4d52.js';
import './TooltipContentStyles.styles.css';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentBaseTheme.styles.css';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js';
import './TooltipContentVariants.styles.css';
import './tooltipUtils-466c63c4.js';
import './EnvironmentProvider-546b7ebd.js';
import './LayerManager-a62e619b.js';
import './IconStyle.styles.css';
import './UNSAFE_Separator/themes/SeparatorStyles.css.js';
import './SeparatorStyles.styles.css';
import './MenuSeparatorStyles.styles.css';
import './UNSAFE_Menu/themes/redwood/MenuSeparatorBaseTheme.styles.css';
import './UNSAFE_Menu/themes/redwood/MenuSeparatorVariants.css.js';
import './useContextMenuGesture-906cf78d.js';
import './textSelectionUtils-a6554a42.js';
import './layoutUtils-895c6de8.js';
import './eventsUtils-e96290df.js';
import './useDnd-c5ae190c.js';
import './LegendStyles.styles.css';
import './useTheme-d30637db.js';
import './useSize-3b5c56f5.js';
import './useResizeObserver-13641643.js';
import './useAddBusyState-7a6af61f.js';
import './BusyStateContext-9ee9751d.js';
import './useBusyStateContext-4d3c27c0.js';
import './VisDndStyles.styles.css';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
function getItem(itemInfo, items) {
    const { itemIdx } = itemInfo;
    if (itemIdx == -1) {
        return items[items.length - 1];
    }
    return items[itemIdx];
}
function getNextItemInfo(itemInfo, items) {
    let itemIdx = itemInfo.itemIdx;
    if (itemIdx == -1) {
        itemIdx = items.length - 1;
    }
    itemIdx = Math.min(items.length - 1, itemIdx + 1);
    if (items[itemIdx].actionable !== 'off') {
        return { sectionIdx: 0, itemIdx };
    }
    else if (itemIdx === items.length - 1) {
        itemIdx = itemIdx - 1;
        return { sectionIdx: 0, itemIdx };
    }
    return getNextItemInfo({ sectionIdx: 0, itemIdx }, items);
}
function getPrevItemInfo(itemInfo, items) {
    let itemIdx = itemInfo.itemIdx;
    if (itemIdx == -1) {
        itemIdx = items.length - 1;
    }
    itemIdx = Math.max(0, itemIdx - 1);
    if (items[itemIdx].actionable !== 'off') {
        return { sectionIdx: 0, itemIdx };
    }
    return getPrevItemInfo({ sectionIdx: 0, itemIdx }, items);
}
/**
 * Returns utils functions for navigation in simple legend.
 * @param items
 * @returns
 */
function getLegendNavUtils(items) {
    return {
        getItem: (itemInfo) => {
            return getItem(itemInfo, items);
        },
        getDetailFromInfo: (itemInfo) => {
            if (!itemInfo || items.length === 0) {
                return { itemId: undefined, data: undefined };
            }
            const item = getItem(itemInfo, items);
            return { itemId: item.id, data: item };
        },
        getPrevItemInfo: (itemInfo) => {
            return getPrevItemInfo(itemInfo, items);
        },
        getNextItemInfo: (itemInfo) => {
            return getNextItemInfo(itemInfo, items);
        }
    };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const getLinearLegendLayoutInfo = ({ width, getTextDimensions, resolvedVars, orientation, legendFontStylesObj = {}, symbolWidth, items }) => {
    let maxWidth = 0;
    let maxHeight = 0;
    let totalWidth = 0;
    let isWrapped = false;
    const containerWidth = width;
    if (!Object.keys(resolvedVars).length || !getTextDimensions) {
        return;
    }
    const unitLength = parseFloat(resolvedVars['unit']);
    const { maxItemWidth, maxItemHeight, horizontalSectionWidth } = getMaxWidth(items, unitLength, getTextDimensions, legendFontStylesObj, symbolWidth);
    totalWidth = horizontalSectionWidth;
    maxWidth = maxItemWidth;
    maxHeight = maxItemHeight;
    isWrapped = horizontalSectionWidth > containerWidth;
    const legendLayoutInfo = {
        totalWidth,
        maxItemWidth: Math.min(maxWidth, containerWidth),
        maxItemHeight: maxHeight,
        itemsPerRow: orientation === 'vertical' ? 1 : Math.max(1, Math.floor(containerWidth / maxWidth)),
        isWrapped
    };
    return legendLayoutInfo;
};
/**
 * Returns maximum of the width among the items in a section of legend also return the width of the entire section.
 * @param items Legend items array
 * @param unitLength Base  element
 * @param getTextDimensions Text width measurement function
 * @param legendFontStylesObj Legend text font style properties object
 * @param symbolWidth Width of legend symbol
 *
 * @returns
 */
const getMaxWidth = (items, unitLength, getTextDimensions, legendFontStylesObj, symbolWidth, symbolHeight) => {
    let maxItemWidth = 0;
    let maxItemHeight = 0;
    let horizontalSectionWidth = 0;
    let itemSymbolWidth = 0;
    let itemSymbolHeight = 0;
    if (symbolWidth) {
        itemSymbolWidth = unitLength * 1.5 + symbolWidth;
    }
    else {
        //itemSymbolWidth = marginLeft + marginRight + width below expression is simplified
        itemSymbolWidth = 4 * unitLength;
    }
    if (symbolHeight) {
        // symbolHeight/defaultSymbolHeight + symbolPaddingTopBottom
        itemSymbolHeight = symbolHeight + unitLength * 1.7;
    }
    else {
        // symbolHeight/defaultSymbolHeight + symbolPaddingTopBottom
        itemSymbolHeight = 2.5 * unitLength + unitLength * 1.7;
    }
    items?.forEach((item) => {
        const legendItem = item;
        const { width, height } = getTextDimensions(legendItem.text, legendFontStylesObj);
        //itemTextWidth = paddingLeft + paddingRight + width
        const itemTextWidth = unitLength * 2.5 + width;
        //horizontalSectionWidth = total width of the section
        horizontalSectionWidth += itemSymbolWidth + itemTextWidth;
        maxItemWidth = Math.max(maxItemWidth, itemSymbolWidth + itemTextWidth);
        maxItemHeight = Math.max(maxItemHeight, height, itemSymbolHeight);
    });
    return { maxItemWidth, maxItemHeight, horizontalSectionWidth };
};
function _getPreferredSize(_width, _height, items, resolvedVars, orientation, legendFontStylesObj, symbolWidth, symbolHeight, getTextDimensions) {
    if (!getTextDimensions) {
        return undefined;
    }
    const layoutInfo = getLinearLegendLayoutInfo({
        width: _width,
        getTextDimensions,
        resolvedVars,
        orientation,
        legendFontStylesObj,
        symbolWidth: symbolWidth,
        symbolHeight: symbolHeight,
        items
    });
    const { itemsPerCol, itemsPerRow } = getGridNums(items.length, layoutInfo, orientation);
    const unitLength = parseFloat(resolvedVars['unit']);
    const preferredWidth = Math.min(_width, itemsPerCol === 1
        ? layoutInfo.totalWidth
        : itemsPerRow
            ? layoutInfo.maxItemWidth * itemsPerRow
            : layoutInfo.totalWidth);
    const paddingLegendItems = 0.8 * unitLength;
    const paddingLegendTopBottom = 1.5 * unitLength;
    const legendHeight = itemsPerCol
        ? layoutInfo.maxItemHeight * itemsPerCol +
            (itemsPerCol - 1) * paddingLegendItems +
            paddingLegendTopBottom
        : layoutInfo.maxItemHeight + paddingLegendTopBottom;
    const preferredHeight = Math.min(_height, legendHeight);
    return { width: Math.ceil(preferredWidth), height: Math.ceil(preferredHeight) };
}

/**
 * A legend displays an interactive description of symbols, colors, etc., used in graphical information representations.
 */
const Legend = forwardRef(({ orientation = 'horizontal', items, isReadOnly = true, onItemAction, onItemHover, onItemFocus, testId, contextMenuConfig, hideAndShowBehavior = 'off', hoverBehavior = 'none', halign = 'start', valign = 'top', ...props }, ref = null) => {
    // Use the context
    const { isGetPreferredSizeReady, width, height } = useContext(LegendRenderedContext);
    const { textMeasureContent, getTextDimensions } = useTextDimensions();
    const { resolvedVars, cssContent } = useCssVars(legendVars);
    const legendFontStylesObj = getLegendTextStyle({
        fontStyle: props.textFontStyle,
        fontSize: props.textFontSize?.toString(),
        fontWeight: props.textFontWeight?.toString(),
        fontFamily: props.textFontFamily
    }, resolvedVars);
    const rootRef = useRef(null);
    useImperativeHandle(ref, () => ({
        _getPreferredSize: (_width, _height) => {
            return _getPreferredSize(_width, _height, items, resolvedVars, orientation, legendFontStylesObj, props.symbolWidth, props.symbolHeight, getTextDimensions);
        }
    }), [
        getTextDimensions,
        resolvedVars,
        orientation,
        legendFontStylesObj,
        props.symbolWidth,
        props.symbolHeight,
        items
    ]);
    if (getTextDimensions &&
        resolvedVars['unit'] != undefined &&
        resolvedVars['fontSize'] != undefined) {
        isGetPreferredSizeReady?.(true);
    }
    const testIdProps = useTestId(testId);
    const isTestEnv = testIdProps['data-testid'] !== undefined;
    const rootDimsRef = useRef();
    const { getItem, getDetailFromInfo, getPrevItemInfo, getNextItemInfo } = getLegendNavUtils(items);
    const isLegendItemActionable = getIsLegendItemActionable(items, isReadOnly);
    const hasData = items.length > 0;
    const legendKeyUpHandler = (triggerOnAction, updatefocusedItemInfo, focusedItemInfo) => getKeyUpHandler(triggerOnAction, updatefocusedItemInfo, focusedItemInfo, props.hiddenIds != null);
    const { touchResponse, touchResponseStyle } = useVisTouchResponse({
        type: 'touchStart'
    });
    const { focusedItemInfo, hoveredItemInfo, onContextMenuDismissed, activeId, eventsProps } = useVisEvent(touchResponse, !isReadOnly, isLegendItemActionable, legendKeyUpHandler, getDetailFromInfo, getPrevItemInfo, getNextItemInfo, onItemAction, onItemHover, onItemFocus, isEqualItem, getItemInfo, { itemIdx: 0, sectionIdx: 0 }, props.hiddenIds != null);
    const { focusedItemRef } = useItemFocus(focusedItemInfo);
    const datatipText = getDatatipText(items, getItem, focusedItemInfo, hoveredItemInfo);
    const [datatipDisabled, setDatatipDisabled] = useState(false);
    const { datatipContent, datatipProps: { 'aria-describedby': datatipAriaDescribedby, ...datatipProps } } = useLegendDatatip({
        text: datatipText,
        rootDimsRef,
        focusedItemInfo,
        focusedItemRef,
        touchResponse,
        isDisabled: datatipDisabled
    });
    const ariaProps = getAriaProps(isReadOnly, props['aria-label'], props.hiddenIds, l([props['aria-describedby'], datatipAriaDescribedby]), props['aria-labelledby']);
    const { contextMenuContent, contextMenuProps } = useLegendContextMenu({
        rootRef,
        contextMenuConfig: hasData ? contextMenuConfig : undefined,
        focusedItemInfo,
        items,
        isReadOnly,
        onContextMenuDismissed
    });
    const [dragOver, setDragOver] = useState();
    const { draggable, dndProps, dndContent } = useLegendDnd({
        onDrag: props.onDrag,
        onDragStart: props.onDragStart,
        onDragEnd: props.onDragEnd,
        onDragEnter: props.onDragEnter,
        onDragLeave: props.onDragLeave,
        onDragOver: props.onDragOver,
        onDrop: props.onDrop,
        items,
        setDragOver,
        setDatatipDisabled,
        itemDraggable: props.itemDraggable
    });
    const mergedProps = mergeProps(eventsProps, datatipProps, contextMenuProps, dndProps);
    const { legendStyle, renderedLegendStyle } = styles;
    return (jsxs(Fragment, { children: [!isGetPreferredSizeReady && (jsx(TrackResizeContainer, { width: width ? `${width}px` : '100%', height: height ? `${height}px` : '100%', class: classNames([
                    styles.flexStyle,
                    styles[`${halign}HAlign`],
                    styles[`${valign}VAlign`]
                ]), children: function _(width) {
                    const layoutInfo = useMemo(() => getLinearLegendLayoutInfo({
                        width,
                        getTextDimensions,
                        resolvedVars,
                        orientation,
                        legendFontStylesObj,
                        symbolWidth: props.symbolWidth,
                        symbolHeight: props.symbolHeight,
                        items
                    }), [width]);
                    const { itemsPerCol, itemsPerRow } = getGridNums(items.length, layoutInfo);
                    return (jsxs(Fragment, { children: [jsx("div", { ref: rootRef, tabIndex: isReadOnly ? undefined : 0, role: "application", draggable: draggable, class: classNames([
                                    legendStyle,
                                    renderedLegendStyle,
                                    dragOver
                                        ? styles$1.dndDragOverHTMLStyle
                                        : dragOver === false
                                            ? styles$1.dndRejectedStyle
                                            : undefined
                                ]), style: touchResponseStyle, ...testIdProps, ...ariaProps, ...mergedProps, "aria-activedescendant": activeId, children: jsx(BaseLegend, { ...props, focusedItemRef: focusedItemRef, items: items, isReadOnly: isReadOnly, orientation: orientation, sectionIdx: 0, itemsPerRow: itemsPerRow, itemsPerCol: itemsPerCol, itemWidth: layoutInfo?.isWrapped ? layoutInfo?.maxItemWidth : undefined, focusedItemInfo: focusedItemInfo, hoveredItemInfo: hoveredItemInfo, activeId: activeId, hideAndShowBehavior: hideAndShowBehavior, hoverBehavior: hoverBehavior, isTestEnv: isTestEnv }) }), datatipContent, contextMenuContent, dndContent] }));
                } })), textMeasureContent, cssContent] }));
});

export { Legend };
//# sourceMappingURL=UNSAFE_Legend.js.map
