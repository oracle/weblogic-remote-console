/* @oracle/oraclejet-preact: undefined */
import { useRef, useCallback } from 'preact/hooks';
import { g as getContainingBlockElem } from './positionUtils-f26caad9.js';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * A hook with draggable implementation.
 * Returns event handlers that can enhance the target element with drag capability.
 *
 * @param isDisabled determines if the hook is disabled
 * @returns an object with the 'draggableProps' properties.
 */
function useDraggable({ isDisabled = false, containerRef, onDragMove, onDragStart, onDragEnd }) {
    const isDragging = useRef(false);
    const startPosition = useRef();
    const offset = useRef({ x: 0, y: 0 });
    const initialMousePosition = useRef({ x: 0, y: 0 });
    const initialClientRect = useRef({ x: 0, y: 0, width: 0, height: 0 });
    const constrainPos = useCallback((x, y) => {
        const elem = containerRef?.current;
        const pos = { x, y };
        if (!elem)
            return pos;
        const containingBlock = getContainingBlockElem(elem);
        const boundingRect = containingBlock?.getBoundingClientRect();
        const dialogRect = elem.getBoundingClientRect();
        const limitLeft = boundingRect ? boundingRect.left : 0;
        const limitTop = boundingRect ? boundingRect.top : 0;
        const limitRight = boundingRect ? boundingRect.right : window.innerWidth;
        const limitBottom = boundingRect ? boundingRect.bottom : window.innerHeight;
        if (pos.x < limitLeft) {
            pos.x = limitLeft;
        }
        if (pos.x + dialogRect.width > limitRight) {
            pos.x = limitRight - dialogRect.width;
        }
        if (pos.y < limitTop) {
            pos.y = limitTop;
        }
        if (pos.y + dialogRect.height > limitBottom) {
            pos.y = limitBottom - dialogRect.height;
        }
        return pos;
    }, [containerRef]);
    /**
     * Handles the mousemove events while the dragging is activated
     */
    const handleDrag = useCallback((event) => {
        if (!isDragging.current || !startPosition.current)
            return;
        const left = event.pageX - initialMousePosition.current.x;
        const top = event.pageY - initialMousePosition.current.y;
        const newPos = constrainPos(initialClientRect.current.x + left, initialClientRect.current.y + top);
        event.stopPropagation();
        event.preventDefault();
        onDragMove?.({
            x: newPos.x,
            y: newPos.y
        });
    }, [onDragMove, constrainPos]);
    /**
     * handles the drag end
     */
    const endDrag = useCallback((event) => {
        if (!isDragging.current || !startPosition.current)
            return;
        isDragging.current = false;
        const left = event.pageX - initialMousePosition.current.x;
        const top = event.pageY - initialMousePosition.current.y;
        const newPos = constrainPos(initialClientRect.current.x + left, initialClientRect.current.y + top);
        document.removeEventListener('mousemove', handleDrag, true);
        document.removeEventListener('mouseup', endDrag, true);
        event.preventDefault();
        event.stopPropagation();
        onDragEnd?.({
            x: newPos.x,
            y: newPos.y
        });
    }, [onDragEnd, handleDrag, constrainPos]);
    /**
     * handles the start of dragging
     */
    const startDrag = useCallback((event) => {
        const findPos = (element) => {
            let elem = element;
            let curLeft = 0;
            let curTop = 0;
            if (elem.offsetParent) {
                do {
                    curLeft += elem.offsetLeft;
                    curTop += elem.offsetTop;
                } while ((elem = elem.offsetParent));
            }
            return { left: curLeft, top: curTop };
        };
        const elem = event.currentTarget;
        if (!elem)
            return;
        const pos = findPos(elem);
        isDragging.current = true;
        elem.style.cursor = 'move';
        document.addEventListener('mousemove', handleDrag, true);
        document.addEventListener('mouseup', endDrag, true);
        startPosition.current = { x: pos.left, y: pos.top };
        offset.current.x = event.offsetX;
        offset.current.y = event.offsetY;
        initialMousePosition.current = { x: event.pageX, y: event.pageY };
        initialClientRect.current = elem.getBoundingClientRect();
        onDragStart?.({
            x: initialClientRect.current.x,
            y: initialClientRect.current.y
        });
    }, [onDragStart, endDrag, handleDrag]);
    /**
     * mouseenter event handler to change the mouse cursor when the drag sensitive area is hovered
     */
    const mouseEnter = useCallback((event) => {
        if (isDisabled)
            return;
        const elem = event.currentTarget;
        if (elem) {
            elem.style.cursor = 'move';
        }
    }, [isDisabled]);
    /**
     * mouseleave event handler to restore the mouse cursor when the drag sensitive area is left
     */
    const mouseLeave = useCallback((event) => {
        if (isDisabled)
            return;
        const elem = event.currentTarget;
        if (elem) {
            elem.style.cursor = 'auto';
        }
    }, [isDisabled]);
    // return object
    const draggableProps = isDisabled
        ? {}
        : {
            onMouseDown: startDrag,
            onMouseEnter: mouseEnter,
            onMouseLeave: mouseLeave
        };
    return {
        draggableProps: draggableProps
    };
}

export { useDraggable as u };
//# sourceMappingURL=useDraggable-e1aaa8f3.js.map
