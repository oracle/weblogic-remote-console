/* @oracle/oraclejet-preact: undefined */
import { createRef } from 'preact';
import { useRef, useState, useCallback } from 'preact/hooks';
import { u as useResizeObserver } from '../useResizeObserver-13641643.js';
import '../useAddBusyState-7a6af61f.js';
import '../BusyStateContext-9ee9751d.js';
import '../useBusyStateContext-4d3c27c0.js';
import '../unsafeDomAccess-453eb74e.js';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const _defaultMinWidth = 16;
/**
 * Utility hook for controlling a TableView's sizing.
 */
function useTableViewColumnResizing({ columnOrder, columnWidths, onColumnWidthsChanging, onColumnWidthsChange, applyWidths = 'onResizing', minColumnWidth = _defaultMinWidth, resizeBehavior = 'redistribute' }) {
    const columnWidthsRef = useRef(columnWidths);
    columnWidthsRef.current = columnWidths;
    const [columnResizingIndicator, setColumnResizingIndicator] = useState();
    const columnResizingStartingColumnWidthsRef = useRef();
    const frozenAddColumnWidthsRef = useRef({});
    const [frozenAddColumnWidths, setFrozenAddColumnWidths] = useState({});
    // ensure all 'real' column widths are applied to the local realizedColumnWidths
    const realizedColumnWidths = {};
    const updatedKeys = [];
    if (columnWidths != null) {
        const keys = Object.keys(columnWidths);
        for (const key of keys) {
            realizedColumnWidths[key] = columnWidths[key];
            updatedKeys.push(key);
        }
    }
    // ensure all 'frozenAdd' column widths are applied to the local realizedColumnWidths
    const frozenAddKeys = Object.keys(frozenAddColumnWidths);
    for (const frozenAddKey of frozenAddKeys) {
        if (!updatedKeys.includes(frozenAddKey)) {
            realizedColumnWidths[frozenAddKey] = frozenAddColumnWidths[frozenAddKey];
        }
    }
    const addResizePaddingWidthRef = useRef(0);
    const _cloneColumnWidths = useCallback((widths) => {
        const keys = Object.keys(widths);
        const newColumnWidths = {};
        for (const key of keys) {
            newColumnWidths[key] = widths[key];
        }
        return newColumnWidths;
    }, []);
    /**
     * Helper method to update the Table's column widths while a column resize operation is ongoing.
     */
    const onColumnResizing = useCallback((detail) => {
        // save the initial state when column resize begins
        if (columnResizingStartingColumnWidthsRef.current == null) {
            columnResizingStartingColumnWidthsRef.current = detail.allColumnWidths;
        }
        const newStaticColumnWidths = _cloneColumnWidths(columnWidthsRef.current != null ? columnWidthsRef.current : {});
        const startKey = detail.key;
        const endKey = columnOrder[columnOrder.indexOf(startKey) + 1];
        const initialStartWidth = columnResizingStartingColumnWidthsRef.current[startKey];
        const initialEndWidth = columnResizingStartingColumnWidthsRef.current[endKey];
        const newStartWidth = Math.min(Math.max(initialStartWidth + detail.delta, minColumnWidth), initialStartWidth + initialEndWidth - minColumnWidth);
        newStaticColumnWidths[startKey] = newStartWidth;
        const newEndWidth = initialEndWidth + initialStartWidth - newStartWidth;
        newStaticColumnWidths[endKey] = newEndWidth;
        if (onColumnWidthsChanging != null) {
            onColumnWidthsChanging(newStaticColumnWidths);
        }
        columnWidthsRef.current = newStaticColumnWidths;
        setColumnResizingIndicator({ key: startKey, delta: 0 });
    }, [onColumnWidthsChanging, minColumnWidth, columnOrder, _cloneColumnWidths]);
    /**
     * Helper method to update the Table's column resize indicator line only.
     */
    const onColumnIndicatorResizing = useCallback((detail) => {
        const startKey = detail.key;
        const endKey = columnOrder[columnOrder.indexOf(startKey) + 1];
        const initialStartWidth = detail.allColumnWidths[startKey];
        const initialEndWidth = detail.allColumnWidths[endKey];
        const newStartWidth = Math.min(Math.max(initialStartWidth + detail.delta, minColumnWidth), initialStartWidth + initialEndWidth - minColumnWidth);
        setColumnResizingIndicator({ key: startKey, delta: newStartWidth - initialStartWidth });
    }, [columnOrder, minColumnWidth]);
    /**
     * Helper method to update the Table's column widths at the end of column resize operation. This is
     * the same as during an ongoing resize operation, but additionally pushes back the resized column widths
     * to the consumer if a 'setInitialColumnWidths' callback is provided, and removes the indicator line.
     */
    const onColumnResize = useCallback((detail) => {
        const initialWidths = columnResizingStartingColumnWidthsRef.current != null
            ? columnResizingStartingColumnWidthsRef.current
            : detail.allColumnWidths;
        const newStaticColumnWidths = _cloneColumnWidths(columnWidthsRef.current != null ? columnWidthsRef.current : {});
        const startKey = detail.key;
        const initialStartWidth = initialWidths[startKey];
        let newStartWidth;
        if (detail.type === 'absolute') {
            newStartWidth = Math.max(detail.newWidth, minColumnWidth);
            newStaticColumnWidths[startKey] = newStartWidth;
        }
        else {
            const endKey = columnOrder[columnOrder.indexOf(startKey) + 1];
            const initialEndWidth = initialWidths[endKey];
            newStartWidth = Math.min(Math.max(initialStartWidth + detail.delta, minColumnWidth), initialStartWidth + initialEndWidth - minColumnWidth);
            const newEndWidth = initialEndWidth + initialStartWidth - newStartWidth;
            newStaticColumnWidths[endKey] = newEndWidth;
        }
        newStaticColumnWidths[startKey] = newStartWidth;
        if (onColumnWidthsChange != null) {
            onColumnWidthsChange(newStaticColumnWidths);
        }
        columnWidthsRef.current = newStaticColumnWidths;
        columnResizingStartingColumnWidthsRef.current = undefined;
        setColumnResizingIndicator(undefined);
    }, [onColumnWidthsChange, minColumnWidth, columnOrder, _cloneColumnWidths]);
    /**
     * Helper method to update the Table's column widths while a column resize operation is ongoing.
     */
    const onAddBehaviorResizing = useCallback((detail) => {
        addResizePaddingWidthRef.current = detail.paddingWidth;
        // save the initial state when column resize begins
        if (columnResizingStartingColumnWidthsRef.current == null) {
            columnResizingStartingColumnWidthsRef.current = detail.allColumnWidths;
        }
        const newFrozenColumnWidths = _cloneColumnWidths(columnResizingStartingColumnWidthsRef.current != null
            ? columnResizingStartingColumnWidthsRef.current
            : detail.allColumnWidths);
        const newStaticColumnWidths = _cloneColumnWidths(columnWidthsRef.current != null ? columnWidthsRef.current : {});
        const startKey = detail.key;
        const initialStartWidth = columnResizingStartingColumnWidthsRef.current[startKey];
        const newStartWidth = Math.max(initialStartWidth + detail.delta, minColumnWidth);
        newStaticColumnWidths[startKey] = newStartWidth;
        newFrozenColumnWidths[startKey] = newStartWidth;
        if (onColumnWidthsChanging != null) {
            onColumnWidthsChanging(newStaticColumnWidths);
        }
        setFrozenAddColumnWidths(newFrozenColumnWidths);
        frozenAddColumnWidthsRef.current = newFrozenColumnWidths;
        setColumnResizingIndicator({ key: startKey, delta: 0 });
    }, [onColumnWidthsChanging, minColumnWidth, _cloneColumnWidths]);
    /**
     * Helper method to update the Table's column resize indicator line only.
     */
    const onAddBehaviorIndicatorResizing = useCallback((detail) => {
        addResizePaddingWidthRef.current = detail.paddingWidth;
        const startKey = detail.key;
        const initialStartWidth = detail.allColumnWidths[startKey];
        const newStartWidth = Math.max(initialStartWidth + detail.delta, minColumnWidth);
        setColumnResizingIndicator({ key: startKey, delta: newStartWidth - initialStartWidth });
    }, [minColumnWidth]);
    /**
     * Helper method to update the Table's column widths at the end of column resize operation. This is
     * the same as during an ongoing resize operation, but additionally pushes back the resized column widths
     * to the consumer if a 'setInitialColumnWidths' callback is provided, and removes the indicator line.
     */
    const onAddBehaviorResize = useCallback((detail) => {
        addResizePaddingWidthRef.current = detail.paddingWidth;
        const initialWidths = columnResizingStartingColumnWidthsRef.current != null
            ? columnResizingStartingColumnWidthsRef.current
            : detail.allColumnWidths;
        const newFrozenColumnWidths = _cloneColumnWidths(columnResizingStartingColumnWidthsRef.current != null
            ? columnResizingStartingColumnWidthsRef.current
            : detail.type === 'absolute'
                ? columnWidthsRef.current != null
                    ? columnWidthsRef.current
                    : {}
                : detail.allColumnWidths);
        const newStaticColumnWidths = _cloneColumnWidths(columnWidthsRef.current != null ? columnWidthsRef.current : {});
        const startKey = detail.key;
        const initialStartWidth = initialWidths[startKey];
        const newStartWidth = detail.type === 'delta'
            ? Math.max(initialStartWidth + detail.delta, minColumnWidth)
            : Math.max(detail.newWidth, minColumnWidth);
        newStaticColumnWidths[startKey] = newStartWidth;
        newFrozenColumnWidths[startKey] = newStartWidth;
        if (onColumnWidthsChange != null) {
            onColumnWidthsChange(newStaticColumnWidths);
        }
        setFrozenAddColumnWidths(newFrozenColumnWidths);
        frozenAddColumnWidthsRef.current = newFrozenColumnWidths;
        columnResizingStartingColumnWidthsRef.current = undefined;
        setColumnResizingIndicator(undefined);
    }, [onColumnWidthsChange, minColumnWidth, _cloneColumnWidths]);
    const onColumnResizingHandler = applyWidths === 'onResize'
        ? resizeBehavior === 'add'
            ? onAddBehaviorIndicatorResizing
            : onColumnIndicatorResizing
        : resizeBehavior === 'add'
            ? onAddBehaviorResizing
            : onColumnResizing;
    const tableWidthRef = useRef();
    // scrollerRef is callback-based to meet useResizeObserver hook's state management requirements
    const [scrollerRef, setScrollerRef] = useState(createRef());
    const scrollerRefCallback = useCallback((unsafeDomAccess) => {
        setScrollerRef({ current: unsafeDomAccess });
    }, []);
    // setup a resize observer to unfreeze and previously 'frozen' column widths when required
    useResizeObserver(scrollerRef, useCallback((entry) => {
        const boxSize = entry.contentBoxSize;
        const newWidth = boxSize[0].inlineSize;
        if (tableWidthRef.current == null || tableWidthRef.current !== newWidth) {
            tableWidthRef.current = newWidth;
            let totalWidth = 0;
            const keys = Object.keys(frozenAddColumnWidthsRef.current);
            for (const key of keys) {
                totalWidth += frozenAddColumnWidthsRef.current[key];
            }
            if (newWidth >= totalWidth + addResizePaddingWidthRef.current) {
                setFrozenAddColumnWidths({});
                frozenAddColumnWidthsRef.current = {};
            }
        }
    }, []), { isDisabled: resizeBehavior === 'redistribute' });
    const onColumnResizeHandler = resizeBehavior === 'add' ? onAddBehaviorResize : onColumnResize;
    return {
        columnResizingProps: {
            onColumnResizing: onColumnResizingHandler,
            onColumnResize: onColumnResizeHandler,
            columnResizingIndicator: columnResizingIndicator,
            columnWidths: realizedColumnWidths,
            scrollerRef: scrollerRefCallback
        }
    };
}

export { useTableViewColumnResizing };
//# sourceMappingURL=UNSAFE_useTableViewColumnResizing.js.map
