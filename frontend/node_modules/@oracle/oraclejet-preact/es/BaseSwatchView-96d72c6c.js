/* @oracle/oraclejet-preact: undefined */
import { jsx } from 'preact/jsx-runtime';
import { Fragment } from 'preact';
import { memo, forwardRef } from 'preact/compat';
import { useRef, useCallback, useLayoutEffect, useImperativeHandle, useState, useEffect } from 'preact/hooks';
import { m as mergeProps } from './mergeProps-88ea8306.js';
import { T as TabbableModeContext } from './TabbableModeContext-7d8ad946.js';
import { u as useTabbableMode } from './useTabbableMode-a2fdbb06.js';
import { i as isKeyDefined } from './keys-49c92dbb.js';
import { e as compareListItemContext, f as findElementByKey, j as getViewportConfig, k as keyExtractor, I as ITEM_SELECTOR, l as getPrevNextKeyByCount, b as getFirstVisibleKey } from './collectionUtils-893f2808.js';
import { u as useCurrentKey } from './useCurrentKey-7c652655.js';
import { u as useCollectionFocusRing } from './useCollectionFocusRing-71cdd52c.js';
import { u as useTabbableModeSet } from './useTabbableModeSet-274065a0.js';
import { u as useSwatchSelection } from './useSwatchSelection-9395722d.js';
import { a as LoadMoreCollection } from './LoadMoreCollection-02671d0d.js';
import { multiVariantStyles, styles } from './PRIVATE_BaseSwatchView/themes/BaseSwatchViewStyles.css.js';
import { c as classNames } from './classNames-4e12b00d.js';
import { w as warn } from './logger-c92f309c.js';
import { a as allTabbableElements } from './tabbableUtils-ce19b388.js';
import { u as useId } from './useId-03dbfdf0.js';
import { u as useResizeObserver } from './useResizeObserver-13641643.js';
import { F as FocusTrap } from './FocusTrap-9f37aa41.js';
import { F as Flex } from './Flex-5befe411.js';

/**
 * The internal component used to render a single item in SwatchView.
 */
function BaseSwatchViewItem({ children, context, isTabbable, isFocused, isFocusRingVisible, focusBehavior, setIsFocusBehaviorValid, updateSwatchSize }) {
    const rootRef = useRef(null);
    const itemKey = context.metadata.key;
    const isItemFocused = isFocused && isFocusRingVisible;
    const variantClasses = multiVariantStyles({
        itemFocused: focusBehavior === 'swatch' && isItemFocused ? 'isItemFocused' : 'isNotItemFocused',
        itemInGridLayout: 'isNotInGridLayout'
    });
    const classes = classNames([styles.itemStyle, variantClasses]);
    /*********************************** Tabbable Mode ***********************************/
    // don't bubble Arrow Up/Down/Left/Right events to parent when in isTabbable mode
    // this bubbling causes the outer CollectionFocus ring to change index while in the isTabbable mode.
    const handleKeyDown = (event) => {
        if (focusBehavior === 'swatch' &&
            isTabbable &&
            (event.key === 'ArrowDown' ||
                event.key === 'ArrowUp' ||
                event.key === 'ArrowLeft' ||
                event.key === 'ArrowRight')) {
            event.stopPropagation();
        }
    };
    /************************************ Swatch Size ************************************/
    const handleResize = useCallback((entry) => {
        updateSwatchSize?.(entry.contentRect.width, entry.contentRect.height);
    }, [updateSwatchSize]);
    const nullRef = useRef(null);
    useResizeObserver(updateSwatchSize ? rootRef : nullRef, handleResize);
    /********************************* Focus Behavior *********************************/
    useLayoutEffect(() => {
        if (focusBehavior === 'content' && isItemFocused) {
            // rootRef is swatchview item, its first child is the focus trap div, so its first grand child
            // is the actual content
            const content = rootRef.current?.firstElementChild?.firstElementChild;
            const focusable = allTabbableElements(content, true, true);
            if (focusable.length === 0 || focusable.length > 1) {
                warn(`${focusable.length} focusable elements are detected in the swatch. 'content' focusBehavior is intended only for use when the swatch has single focusable element. Please specify one focusable element in the swatch or switch the focusBehavior to 'swatch'.`);
                setIsFocusBehaviorValid?.(false);
            }
            else {
                focusable[0].focus();
            }
        }
    }, [focusBehavior, isItemFocused, setIsFocusBehaviorValid]);
    const childrenComponent = children(context);
    return (jsx("div", { id: useId(), ref: rootRef, class: classes, role: "gridcell", "data-oj-key": itemKey, onKeyDown: handleKeyDown, ...(typeof itemKey === 'number' && { 'data-oj-key-type': 'number' }), children: jsx(TabbableModeContext.Provider, { value: { isTabbable }, children: jsx(FocusTrap, { isDisabled: !isTabbable, restoreFocusRef: false, children: childrenComponent }) }) }));
}
const MemoizeBaseSwatchViewItem = memo(BaseSwatchViewItem, (prev, next) => {
    if (prev && next) {
        return (prev.children === next.children &&
            prev.isTabbable === next.isTabbable &&
            prev.isFocused === next.isFocused &&
            prev.isFocusRingVisible === next.isFocusRingVisible &&
            prev.focusBehavior === next.focusBehavior &&
            compareListItemContext(prev.context, next.context));
    }
    return false;
});

function BaseSwatchViewLayout({ children }) {
    const gap = ['2x', '2x'];
    return (jsx(Flex, { wrap: "wrap", gap: gap, children: children }));
}

const emptyKeys = { all: false, keys: new Set() };
const getColCount = (gapWidth, swatchWidth, rootWidth) => {
    if (!swatchWidth || !rootWidth)
        return 0;
    // if we have n swatchs, we have n-1 gaps
    const colCount = Math.floor((rootWidth + gapWidth) / (gapWidth + swatchWidth));
    return Math.max(1, colCount);
};

const BaseSwatchViewImpl = forwardRef(({ children, data, onLoadMore = () => { }, hasMore = false, getRowKey, currentKey, onCurrentKeyChange, selectedKeys = emptyKeys, onSelectionChange, viewportConfig, focusBehavior = 'swatch', 'aria-label': ariaLabel, 'aria-labelledby': ariaLabelledBy, columns, swatchSize, updateSwatchSize }, ref) => {
    const rootRef = useRef(null);
    useImperativeHandle(ref, () => rootRef.current, [rootRef]);
    // tracking the anchor key which is used for shift+click selection
    const anchorKey = useRef();
    // tracking pending current key in pointer down event
    const pendingCurrentKey = useRef();
    const ariaMultiSelectable = 'false';
    const ariaRowcount = hasMore || !data || columns < 1 ? -1 : Math.ceil(data?.length / columns);
    const ariaColcount = columns < 1 ? -1 : columns;
    const [isFocusBehaviorValid, setIsFocusBehaviorValid] = useState(true);
    const validFocusBehavior = isFocusBehaviorValid ? focusBehavior : 'swatch';
    // ensure current item is scrolled into view when current item is updated
    // during reordering, enable that during keyboard reordering, disable that during mouse reordering
    const scrollCurrItemIntoView = useRef(false);
    const isFetching = useRef(false);
    /*****************************************************************************************/
    /************************************* Tabbable Mode *************************************/
    /*****************************************************************************************/
    const [isCurrentTabbableKey, tabbableModeProps] = useTabbableModeSet(rootRef, (element) => {
        return keyExtractor(element, ITEM_SELECTOR);
    }, currentKey, onCurrentKeyChange);
    /*****************************************************************************************/
    /********************************* Current Key and Focus *********************************/
    /*****************************************************************************************/
    const { currentKeyProps } = useCurrentKey((element) => keyExtractor(element, ITEM_SELECTOR), true, 
    // init a function every time to make sure we pass in the latest columns,
    // otherwise the new key might be wrong after resize
    getPrevNextKeyByCount(data, getRowKey, currentKey, -columns), getPrevNextKeyByCount(data, getRowKey, currentKey, columns), getPrevNextKeyByCount(data, getRowKey, currentKey, -1), getPrevNextKeyByCount(data, getRowKey, currentKey, 1), currentKey, onCurrentKeyChange);
    const [showFocusRing, focusRingProps] = useCollectionFocusRing(rootRef, [
        'ArrowUp',
        'ArrowDown',
        'ArrowLeft',
        'ArrowRight'
    ]);
    const handleFocus = () => {
        // handle initial focus
        if (!isKeyDefined(currentKey) &&
            onCurrentKeyChange &&
            isCurrentTabbableKey(undefined) &&
            rootRef.current) {
            const firstKey = pendingCurrentKey.current || getFirstVisibleKey(rootRef.current, ITEM_SELECTOR);
            if (isKeyDefined(firstKey)) {
                onCurrentKeyChange({ value: firstKey });
            }
        }
    };
    // need to track pointer down element to set currentItem when initial focus happens
    const handlePointerDown = (event) => {
        const key = keyExtractor(event.target, ITEM_SELECTOR);
        if (isKeyDefined(key)) {
            pendingCurrentKey.current = key;
        }
    };
    const handleKeyDown = (event) => {
        // for content focusBehavior, when users tab out, we need to focus back to swatch grid, to ensure
        // the tabbing order works properly, otherwise the focus might get stuck at the current item
        if (validFocusBehavior === 'content' && event.key === 'Tab') {
            rootRef.current?.focus({ preventScroll: true });
        }
        // during keyboard reordering, the current item should be scrolled into view
        const keyHandlers = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'];
        if ((event.metaKey || event.ctrlKey) && event.shiftKey && keyHandlers.includes(event.key)) {
            scrollCurrItemIntoView.current = true;
        }
    };
    useEffect(() => {
        if (currentKey != null && rootRef.current) {
            const elem = findElementByKey(rootRef.current, currentKey, ITEM_SELECTOR);
            if (elem) {
                // only update aria-activedescendant for screen reader in default focusBehavior
                if (validFocusBehavior === 'swatch') {
                    const cell = elem.closest(`[role=gridcell]`);
                    const activeDescendant = rootRef.current.getAttribute('aria-activedescendant');
                    if (cell && activeDescendant !== cell.id) {
                        rootRef.current.setAttribute('aria-activedescendant', cell.id);
                        scrollCurrItemIntoView.current = true;
                    }
                }
                // make sure current item is visible
                if (scrollCurrItemIntoView.current) {
                    elem.scrollIntoView({ block: 'nearest' });
                    scrollCurrItemIntoView.current = false;
                }
            }
        }
        // listen to data because the current item would re-render when data is updated, i.e. the id
        // of current item would be updated, so the currentKey itself couldn't guarantee the root has
        // the latest aria-activedescendant
    }, [currentKey, data, validFocusBehavior]);
    /*****************************************************************************************/
    /*************************************** Selection ***************************************/
    /*****************************************************************************************/
    const handleSelectionChange = useCallback((detail) => {
        if (onSelectionChange) {
            if (detail.value.all === false && detail.value.keys.size > 0) {
                // during regular selection, the last key selected by a user gesture is the anchor key
                anchorKey.current = Array.from(detail.value.keys.values()).pop();
            }
            onSelectionChange(detail);
        }
    }, [anchorKey, onSelectionChange]);
    const { selectionProps } = useSwatchSelection((element) => {
        if (element === rootRef.current) {
            return currentKey === undefined ? null : currentKey;
        }
        return keyExtractor(element, ITEM_SELECTOR);
    }, selectedKeys, false, 'toggle', handleSelectionChange);
    /*****************************************************************************************/
    /************************************* Load More *****************************************/
    /*****************************************************************************************/
    const handleLoadMore = useCallback(() => {
        // check isFetching to avoid multiple load more at the same time (details in JET-61117)
        if (!isFetching.current) {
            isFetching.current = true;
            onLoadMore();
        }
    }, [isFetching, onLoadMore]);
    useEffect(() => {
        isFetching.current = false;
        // listen to data and hasMore because when one of them gets updated, the fetching is done
    }, [data, hasMore]);
    /*****************************************************************************************/
    /************************************ Child Component ************************************/
    /*****************************************************************************************/
    const getItemContext = useCallback((context) => {
        const key = getRowKey(context.data);
        return {
            index: context.index,
            data: context.data,
            metadata: { key: key },
            selector: undefined
        };
    }, [getRowKey]);
    const childrenComponent = (context) => {
        const swatchItemContext = getItemContext(context);
        const isTabbable = isCurrentTabbableKey(swatchItemContext.metadata.key);
        const isFocused = currentKey === swatchItemContext.metadata.key && !isTabbable;
        const isFocusRingVisible = isFocused && showFocusRing;
        const itemRenderFunc = (context) => (jsx(MemoizeBaseSwatchViewItem, { context: context, isTabbable: isTabbable, isFocused: isFocused, isFocusRingVisible: isFocusRingVisible, focusBehavior: validFocusBehavior, ...(focusBehavior === 'content' && { setIsFocusBehaviorValid }), ...(swatchItemContext.index === 0 && !swatchSize.width && { updateSwatchSize }), children: children }, swatchItemContext.metadata.key));
        return itemRenderFunc(swatchItemContext);
    };
    const { tabbableModeProps: viewTabbleModeProps } = useTabbableMode();
    viewportConfig = getViewportConfig(rootRef, viewportConfig);
    const collectionComponent = (jsx("div", { role: "row", children: jsx(BaseSwatchViewLayout, { children: jsx(LoadMoreCollection, { data: data, hasMore: hasMore, onLoadMore: handleLoadMore, loadMoreThreshold: 12, viewportConfig: viewportConfig, children: childrenComponent }) }) }));
    return (jsx("div", { ...mergeProps(currentKeyProps, focusRingProps, viewTabbleModeProps, selectionProps, {
            onFocus: handleFocus,
            onPointerDown: handlePointerDown,
            onKeyDown: handleKeyDown
        }, 
        // only enable tabbable mode in default focusBehavior
        { ...(validFocusBehavior === 'swatch' && tabbableModeProps) }), ref: rootRef, role: "grid", className: styles.baseStyle, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-multiselectable": ariaMultiSelectable, "aria-rowcount": ariaRowcount, "aria-colcount": ariaColcount, children: data?.length || hasMore ? collectionComponent : jsx(Fragment, {}) }));
});
/**
 * Cast BaseSwatchViewImpl to generic type, because BaseSwatchViewImpl would infer the generic type to specific type,
 * i.e infer <K extends string | number, D> to <string | number, unknown>, which will cause type issues in the parent component
 */
const BaseSwatchView = BaseSwatchViewImpl;

export { BaseSwatchView as B, getColCount as g };
//# sourceMappingURL=BaseSwatchView-96d72c6c.js.map
