/* @oracle/oraclejet-preact: undefined */
import { TestAdapter } from '@oracle/oraclejet-testing/UNSAFE_TestAdapter';
import { Keys } from '@oracle/oraclejet-testing/UNSAFE_Driver';
import { byCss } from '@oracle/oraclejet-testing/UNSAFE_Locators';

class InputTimeMaskAdapter extends TestAdapter {
    /**
     * Clear and commit the value of the InputTimeMask
     * @returns Promise<void>
     */
    async clear() {
        await this.changeValue(undefined);
    }
    /**
     * Change the InputTimeMask segments within the root element, and commit the value.
     * This function will figure out if it is a 12-hour clock by looking for a dayPeriod segment. If it is a 12-hour clock
     * the value.hour passed in (which is 0-23) will be converted to a 1-12 hour + the dayPeriod,
     * and both the hour and dayPeriod segments will be changed.
     * @param value {Time | undefined} The new Time value.
     * @returns Promise<void>
     */
    async changeValue(value) {
        const driver = this.getTestDriver();
        const el = await this.getElement();
        // Find the hour element underneath the root.
        // InputTimeMask always renders the hour and minute segments, regardless of granularity or hourClock.
        const hourSegment = await el.waitForElement(byCss(`div[data-segment="hour"]`));
        // Select all, then delete to clear the entire time.
        await driver.sendKeys(hourSegment, Keys['CONTROL_COMMAND'], 'a');
        await driver.sendKeys(hourSegment, Keys['DELETE']);
        if (value && value.hour !== undefined) {
            let dayPeriodSegment;
            // dayPeriod segment is only rendered when hourClock is '12' either explicitly on the InputTimeMask component or from the locale's default.
            try {
                dayPeriodSegment = await el.waitForElement(byCss(`div[data-segment="dayPeriod"]`));
            }
            catch (_) {
                dayPeriodSegment = undefined;
            }
            if (dayPeriodSegment) {
                if (value.hour < 12) {
                    // if hour is 0, we send 12 am.
                    // if hour is x=1,2,3,4,5,6,7,8,9,10,11, we sent xam.
                    const hourToType = value.hour === 0 ? '12' : '' + value.hour;
                    await driver.sendKeys(hourSegment, hourToType);
                    // HOME goes to AM
                    await driver.sendKeys(dayPeriodSegment, Keys['HOME']);
                }
                else {
                    // if hour is 12, we send 12pm.
                    // if hour is 13, 14, 15,16,17,18,19,20,21,22,23, we send x-12 pm.
                    const hour12PMToType = value.hour === 12 ? '12' : '' + (value.hour - 12);
                    await driver.sendKeys(hourSegment, hour12PMToType);
                    // END goes to PM
                    await driver.sendKeys(dayPeriodSegment, Keys['END']);
                }
            }
            else {
                // Type the value into the segments.
                // All InputTimeMasks have hour and minute segments.
                await driver.sendKeys(hourSegment, '' + value.hour);
            }
        }
        if (value && value.minute !== undefined) {
            // InputTimeMask always render hour and minute, regardless of the granularity
            const minuteSegment = await el.waitForElement(byCss(`div[data-segment="minute"]`));
            await driver.sendKeys(minuteSegment, '' + value.minute);
        }
        if (value && value.second !== undefined) {
            // if granularity is minute, InputTimeMask does not render the second segment.
            try {
                const secondSegment = await el.waitForElement(byCss(`div[data-segment="second"]`));
                await driver.sendKeys(secondSegment, '' + value.second);
            }
            catch (_) {
                // Ignoring the error if the element is not found
            }
        }
        if (value && value.millisecond !== undefined) {
            // if granularity is minute or second, InputTimeMask does not render the millisecond segment.
            try {
                const millisecondSegment = await el.waitForElement(byCss(`div[data-segment="millisecond"]`));
                await driver.sendKeys(millisecondSegment, '' + value.millisecond);
            }
            catch (_) {
                // Ignoring the error if the element is not found
            }
        }
        await driver.sendKeys(hourSegment, Keys['ENTER']);
    }
}

export { InputTimeMaskAdapter };
//# sourceMappingURL=InputTimeMaskAdapter.js.map
