{"version":3,"file":"InputTimeMaskAdapter.js","sources":["../../../../src/UNSAFE_InputTimeMask/__testing__/InputTimeMaskAdapter.ts"],"sourcesContent":["import { TestAdapter } from '@oracle/oraclejet-testing/UNSAFE_TestAdapter';\nimport { Time } from '#utils/UNSAFE_timeUtils';\nimport { Keys } from '@oracle/oraclejet-testing/UNSAFE_Driver';\nimport { byCss } from '@oracle/oraclejet-testing/UNSAFE_Locators';\n\nexport class InputTimeMaskAdapter extends TestAdapter {\n  /**\n   * Clear and commit the value of the InputTimeMask\n   * @returns Promise<void>\n   */\n  async clear() {\n    await this.changeValue(undefined);\n  }\n\n  /**\n   * Change the InputTimeMask segments within the root element, and commit the value.\n   * This function will figure out if it is a 12-hour clock by looking for a dayPeriod segment. If it is a 12-hour clock\n   * the value.hour passed in (which is 0-23) will be converted to a 1-12 hour + the dayPeriod,\n   * and both the hour and dayPeriod segments will be changed.\n   * @param value {Time | undefined} The new Time value.\n   * @returns Promise<void>\n   */\n  async changeValue(value: Time | undefined) {\n    const driver = this.getTestDriver();\n    const el = await this.getElement();\n\n    // Find the hour element underneath the root.\n    // InputTimeMask always renders the hour and minute segments, regardless of granularity or hourClock.\n    const hourSegment = await el.waitForElement(byCss(`div[data-segment=\"hour\"]`));\n\n    // Select all, then delete to clear the entire time.\n    await driver.sendKeys(hourSegment, Keys['CONTROL_COMMAND'], 'a');\n    await driver.sendKeys(hourSegment, Keys['DELETE']);\n\n    if (value && value.hour !== undefined) {\n      let dayPeriodSegment;\n      // dayPeriod segment is only rendered when hourClock is '12' either explicitly on the InputTimeMask component or from the locale's default.\n      try {\n        dayPeriodSegment = await el.waitForElement(byCss(`div[data-segment=\"dayPeriod\"]`));\n      } catch (_) {\n        dayPeriodSegment = undefined;\n      }\n\n      if (dayPeriodSegment) {\n        if (value.hour < 12) {\n          // if hour is 0, we send 12 am.\n          // if hour is x=1,2,3,4,5,6,7,8,9,10,11, we sent xam.\n          const hourToType = value.hour === 0 ? '12' : '' + value.hour;\n          await driver.sendKeys(hourSegment, hourToType);\n          // HOME goes to AM\n          await driver.sendKeys(dayPeriodSegment, Keys['HOME']);\n        } else {\n          // if hour is 12, we send 12pm.\n          // if hour is 13, 14, 15,16,17,18,19,20,21,22,23, we send x-12 pm.\n          const hour12PMToType = value.hour === 12 ? '12' : '' + (value.hour - 12);\n          await driver.sendKeys(hourSegment, hour12PMToType);\n          // END goes to PM\n          await driver.sendKeys(dayPeriodSegment, Keys['END']);\n        }\n      } else {\n        // Type the value into the segments.\n        // All InputTimeMasks have hour and minute segments.\n        await driver.sendKeys(hourSegment, '' + value.hour);\n      }\n    }\n\n    if (value && value.minute !== undefined) {\n      // InputTimeMask always render hour and minute, regardless of the granularity\n      const minuteSegment = await el.waitForElement(byCss(`div[data-segment=\"minute\"]`));\n      await driver.sendKeys(minuteSegment, '' + value.minute);\n    }\n\n    if (value && value.second !== undefined) {\n      // if granularity is minute, InputTimeMask does not render the second segment.\n      try {\n        const secondSegment = await el.waitForElement(byCss(`div[data-segment=\"second\"]`));\n        await driver.sendKeys(secondSegment, '' + value.second);\n      } catch (_) {\n        // Ignoring the error if the element is not found\n      }\n    }\n\n    if (value && value.millisecond !== undefined) {\n      // if granularity is minute or second, InputTimeMask does not render the millisecond segment.\n      try {\n        const millisecondSegment = await el.waitForElement(\n          byCss(`div[data-segment=\"millisecond\"]`)\n        );\n        await driver.sendKeys(millisecondSegment, '' + value.millisecond);\n      } catch (_) {\n        // Ignoring the error if the element is not found\n      }\n    }\n\n    await driver.sendKeys(hourSegment, Keys['ENTER']);\n  }\n}\n"],"names":[],"mappings":"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"}