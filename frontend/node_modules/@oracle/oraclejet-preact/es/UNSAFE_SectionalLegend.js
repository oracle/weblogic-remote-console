/* @oracle/oraclejet-preact: undefined */
import { jsx, jsxs } from 'preact/jsx-runtime';
import { forwardRef } from 'preact/compat';
import { useRef, useState, useImperativeHandle } from 'preact/hooks';
import { u as useVisEvent } from './useVisEvents-51a15315.js';
import { m as mergeProps } from './mergeProps-88ea8306.js';
import { g as getRandomId } from './layoutUtils-895c6de8.js';
import { m as getSectionGridNums, a as getLegendTextStyle, c as getDatatipText, d as getAriaProps, u as useLegendDnd, l as legendVars, b as getItemInfo, i as isEqualItem, f as getKeyUpHandler, e as getIsLegendItemActionable } from './useLegendDnd-19e0e582.js';
import { u as useLegendDatatip, b as useSectionalLegendContextMenu, L as LegendText, B as BaseLegend } from './useLegendContextMenu-44f0fe17.js';
import { u as useItemFocus } from './useItemFocus-c12e2756.js';
import { F as Flex } from './Flex-5befe411.js';
import { styles } from './PRIVATE_BaseLegend/themes/LegendStyles.css.js';
import { u as useCssVars } from './useCssVars-143870e2.js';
import { c as classNames } from './classNames-4e12b00d.js';
import { u as useTestId } from './useTestId-e5d44ab1.js';
import { u as useVisTouchResponse } from './useVisTouchResponse-a59ab166.js';
import { l } from './stringUtils-0fe25200.js';
import { u as useTextDimensions } from './useTextDimensions-45f79df4.js';
import { T as TrackResizeContainer } from './TrackResizeContainer-4411f745.js';
import { styles as styles$1 } from './hooks/PRIVATE_useVisDnd/themes/VisDndStyles.css.js';
import './useUser-df8ae011.js';
import './LayerHost-12489cef.js';
import './index-3e2e69c4.js';
import 'preact';
import './UNSAFE_Layer/themes/LayerHostStyles.css.js';
import './LayerHostStyles.styles.css';
import './eventsUtils-e96290df.js';
import './useVisHover-d7a0b2f3.js';
import './datatipUtils-0a36125e.js';
import './clientUtils-cccff45f.js';
import './clientHints-a42b510c.js';
import './useDnd-c5ae190c.js';
import './themeContract.css-2b5a42e2.js';
import './utils-cfef1929.js';
import './colorUtils-b3804ee8.js';
import './_curry1-63949a9b.js';
import './SvgSymbol-a3802183.js';
import './Marker-81aae9f0.js';
import './PRIVATE_SvgShapes/themes/SvgShapesStyles.css.js';
import './SvgShapesStyles.styles.css';
import './Text-983c749e.js';
import './mergeInterpolations-30cd9a69.js';
import './mergeDeepWithKey-33e3d1be.js';
import './_curry3-577eb45e.js';
import './_curry2-01c87f61.js';
import './_isObject-1fab0f5b.js';
import './UNSAFE_Text/themes/TextStyles.css.js';
import './TextStyles.styles.css';
import './vanilla-extract-recipes-createRuntimeFn.esm-2aaf8c98.js';
import './useDatatip-c7727336.js';
import './Layer-7d3dc8c7.js';
import './UNSAFE_Layer/themes/LayerStyles.css.js';
import './LayerStyles.styles.css';
import './useThemeInterpolations-4b48d878.js';
import './useColorScheme-96cce6a1.js';
import './useScale-0ebe15ed.js';
import './theme-63551f30.js';
import './Theme-e6dec6db.js';
import './useDensity-d06ae84a.js';
import './unsafeDomAccess-453eb74e.js';
import './Floating-6023b41d.js';
import './useFloating-e1167cb9.js';
import './positionUtils-f26caad9.js';
import './refUtils-76275c69.js';
import './useOutsideClick-73a51e1d.js';
import './arrayUtils-35a58161.js';
import './useModal-953082f2.js';
import './useComponentTheme-d2f9e47f.js';
import './logger-c92f309c.js';
import './UNSAFE_Floating/themes/redwood/FloatingTheme.js';
import './UNSAFE_Floating/themes/FloatingStyles.css.js';
import './FloatingStyles.styles.css';
import './UNSAFE_Floating/themes/redwood/FloatingBaseTheme.css.js';
import './UNSAFE_Floating/themes/redwood/FloatingBaseTheme.styles.css';
import './UNSAFE_Floating/themes/redwood/FloatingVariants.css.js';
import './vanilla-extract-dynamic.esm-c909758c.js';
import './UNSAFE_Floating/themes/FloatingContract.css.js';
import './useUnsafeDomElementRef-32290273.js';
import './hooks/PRIVATE_useDatatip/themes/useDatatip.css.js';
import './useDatatip.styles.css';
import './useId-03dbfdf0.js';
import './useContextMenu-6aa8193e.js';
import './SelectMenuGroupContext-0c1a7603.js';
import './Sheet-24c3e407.js';
import './Modal-678575d5.js';
import './UNSAFE_Modal/themes/ModalStyles.css.js';
import './ModalStyles.styles.css';
import './tabbableUtils-ce19b388.js';
import './head-8f89fe66.js';
import './_arity-be492b9e.js';
import './_isArray-694cc52d.js';
import './_isString-675f1de9.js';
import './popupUtils-4edf62b5.js';
import './WindowOverlay-b380ce51.js';
import './UNSAFE_WindowOverlay/themes/WindowOverlayStyles.css.js';
import './WindowOverlayStyles.styles.css';
import './UNSAFE_WindowOverlay/themes/WindowOverlayContract.css.js';
import './UNSAFE_WindowOverlay/themes/redwood/WindowOverlayTheme.js';
import './UNSAFE_WindowOverlay/themes/redwood/WindowOverlayBaseTheme.css.js';
import './UNSAFE_WindowOverlay/themes/redwood/WindowOverlayBaseTheme.styles.css';
import './UNSAFE_WindowOverlay/themes/redwood/WindowOverlayVariants.css.js';
import './UNSAFE_Sheet/themes/SheetStyles.css.js';
import './SheetStyles.styles.css';
import './useAnimationStatus-072d6a98.js';
import './useAnimation-a5eb7604.js';
import './animationUtils-5f409a6c.js';
import './useTranslationBundle-25469f1c.js';
import './Dropdown-ead9e679.js';
import './keyboardUtils-986fe923.js';
import './usePopupAnimation-66b186ad.js';
import './popupAnimationUtils-175151d9.js';
import './CollectionInteractionContext-7cf19abc.js';
import './UNSAFE_Dropdown/themes/dropdownStyles.css.js';
import './dropdownStyles.styles.css';
import './useOutsideMousedown-39d7c9a6.js';
import './UNSAFE_Menu/themes/MenuStyles.css.js';
import './MenuStyles.styles.css';
import './UNSAFE_Menu/themes/DropdownMenuStyles.css.js';
import './DropdownMenuStyles.styles.css';
import './Skeleton-a06f4f74.js';
import './dimensions-ddde0eee.js';
import './size-a3d3aeaf.js';
import './borders-98a63040.js';
import './UNSAFE_Skeleton/themes/redwood/SkeletonTheme.js';
import './UNSAFE_Skeleton/themes/SkeletonStyles.css.js';
import './SkeletonStyles.styles.css';
import './UNSAFE_Skeleton/themes/redwood/SkeletonBaseTheme.css.js';
import './UNSAFE_Skeleton/themes/redwood/SkeletonBaseTheme.styles.css';
import './UNSAFE_Skeleton/themes/redwood/SkeletonVariants.css.js';
import './UNSAFE_Menu/themes/MenuSkeletonStyles.css.js';
import './MenuSkeletonStyles.styles.css';
import './LiveRegion-79ffc814.js';
import './LiveRegionStyles.styles.css';
import './UNSAFE_Menu/themes/redwood/MenuItemTheme.js';
import './UNSAFE_Menu/themes/MenuItemStyles.css.js';
import './MenuItemStyles.styles.css';
import './UNSAFE_Menu/themes/redwood/MenuItemBaseTheme.css.js';
import './UNSAFE_Menu/themes/redwood/MenuItemBaseTheme.styles.css';
import './UNSAFE_Menu/themes/redwood/MenuItemVariants.css.js';
import './MenuItemVariants.styles.css';
import './usePress-051f5adb.js';
import './flexitem-7b7f7920.js';
import './flexitem.styles.css';
import './vanilla-extract-sprinkles-createRuntimeSprinkles.esm-2d655d37.js';
import './useInteractionStyle-99e32c23.js';
import './useHover-85077adb.js';
import './useToggle-8b7fcefe.js';
import './useActive-fb6d4d52.js';
import './TooltipContentStyles.styles.css';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentBaseTheme.styles.css';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js';
import './TooltipContentVariants.styles.css';
import './tooltipUtils-466c63c4.js';
import './EnvironmentProvider-546b7ebd.js';
import './LayerManager-a62e619b.js';
import './IconStyle.styles.css';
import './UNSAFE_Separator/themes/SeparatorStyles.css.js';
import './SeparatorStyles.styles.css';
import './MenuSeparatorStyles.styles.css';
import './UNSAFE_Menu/themes/redwood/MenuSeparatorBaseTheme.styles.css';
import './UNSAFE_Menu/themes/redwood/MenuSeparatorVariants.css.js';
import './useContextMenuGesture-906cf78d.js';
import './textSelectionUtils-a6554a42.js';
import './boxalignment-51b42a0f.js';
import './boxalignment.styles.css';
import './flexbox-529f25da.js';
import './flexbox.styles.css';
import './FlexStyles.styles.css';
import './LegendStyles.styles.css';
import './useTheme-d30637db.js';
import './useAddBusyState-7a6af61f.js';
import './BusyStateContext-9ee9751d.js';
import './useBusyStateContext-4d3c27c0.js';
import './useSize-3b5c56f5.js';
import './useResizeObserver-13641643.js';
import './VisDndStyles.styles.css';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
function getItem(itemInfo, sections) {
    const { sectionIdx, itemIdx } = itemInfo;
    if (sectionIdx == -1 && itemIdx == -1) {
        const itemsLength = sections[sections.length - 1].items.length;
        return sections[sections.length - 1].items[itemsLength - 1];
    }
    return sections[sectionIdx].items[itemIdx];
}
function getNextItemInfo(itemInfo, sections) {
    let { itemIdx, sectionIdx } = itemInfo;
    if (sectionIdx == -1 && itemIdx == -1) {
        return {
            itemIdx: sections[sections.length - 1].items.length - 1,
            sectionIdx: sections.length - 1
        };
    }
    itemIdx += 1;
    const itemsLength = sections[sectionIdx].items.length;
    if (itemIdx >= itemsLength) {
        if (sectionIdx === sections.length - 1) {
            itemIdx = itemInfo.itemIdx;
        }
        else {
            sectionIdx += 1;
            itemIdx = 0;
        }
    }
    const item = sections[sectionIdx].items[itemIdx]; //TODO : Work for better fix instead of adding 'as LegendItem<D>'
    if (item?.actionable !== 'off') {
        return { itemIdx, sectionIdx };
    }
    return getNextItemInfo({ itemIdx, sectionIdx }, sections);
}
function getPrevItemInfo(itemInfo, sections) {
    let { itemIdx, sectionIdx } = itemInfo;
    if (sectionIdx == -1 && itemIdx == -1) {
        (itemIdx = sections[sections.length - 1].items.length - 1), (sectionIdx = sections.length - 1);
    }
    itemIdx -= 1;
    if (itemIdx < 0) {
        if (sectionIdx === 0) {
            itemIdx = 0;
        }
        else {
            itemIdx = sections[sectionIdx - 1].items.length - 1;
            sectionIdx -= 1;
        }
    }
    const item = sections[sectionIdx].items[itemIdx]; //TODO : Work for better fix instead of adding 'as LegendItem<D>'
    if (item?.actionable !== 'off') {
        return { itemIdx, sectionIdx };
    }
    return getPrevItemInfo({ itemIdx, sectionIdx }, sections);
}
/**
 * Returns utils functions for navigation in simple sectional legend.
 * @param items
 * @returns
 */
function getSectionalNavUtils(sections) {
    return {
        getItem: (itemInfo) => {
            return getItem(itemInfo, sections);
        },
        getDetailFromInfo: (itemInfo) => {
            if (!itemInfo || sections.length === 0) {
                return { itemId: undefined, sectionId: undefined, data: undefined };
            }
            const item = getItem(itemInfo, sections);
            const sectionId = sections[itemInfo.sectionIdx].id;
            return {
                itemId: item.id,
                sectionId: sectionId,
                data: sections[itemInfo.sectionIdx].items[itemInfo.itemIdx]
            };
        },
        getPrevItemInfo: (itemInfo) => {
            return getPrevItemInfo(itemInfo, sections);
        },
        getNextItemInfo: (itemInfo) => {
            return getNextItemInfo(itemInfo, sections);
        }
    };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const getSectionalLegendLayoutInfo = ({ width, getTextDimensions, resolvedVars, rootRef, orientation, legendFontStylesObj = {}, symbolWidth, symbolHeight, sections }) => {
    let maxWidth = 0;
    let maxHeight = 0;
    let totalWidth = 0;
    const containerWidth = width;
    if (!rootRef.current || !Object.keys(resolvedVars).length || !getTextDimensions) {
        return;
    }
    const unitLength = parseFloat(resolvedVars['unit']);
    let currentRowWidth = 0;
    let maxRowWidth = 0;
    const isSectionWrappedArray = [];
    const isLegendWrappedArray = [];
    const itemsPerRowArray = [];
    let legendHeight = 0;
    const paddingTop = 0.75 * unitLength;
    // const paddingBottom = 1.5 * unitLength;
    sections.forEach((section, index) => {
        let isSectionWrapped = false;
        let isLegendWrapped = false;
        let totalSectionalWidth;
        let rowsAndCol;
        // getTextDimensions calculating text height as +6 from orignal size
        const titleDims = getTextDimensions(section.title, { fontWeight: '600' });
        //0.5 is adjustment made as getTextdimensions is not calculating correct height
        const titleHeight = titleDims.height + paddingTop + 0.5;
        const titlePaddingStart = 3;
        const titleWidth = titleDims.width + titlePaddingStart;
        const { maxItemWidth, maxItemHeight, horizontalSectionWidth } = getMaxWidth(section.items, unitLength, getTextDimensions, legendFontStylesObj, symbolWidth, symbolHeight);
        let initialNumberOfItemsPerRow = section.items.length;
        const rowGap = 4 * unitLength;
        if (titleWidth + horizontalSectionWidth < containerWidth) {
            totalSectionalWidth = horizontalSectionWidth + titleWidth;
            if (currentRowWidth !== 0 &&
                currentRowWidth + rowGap + totalSectionalWidth < containerWidth &&
                !isLegendWrappedArray[index - 1]) {
                currentRowWidth = currentRowWidth + totalSectionalWidth + rowGap;
            }
            else {
                currentRowWidth = totalSectionalWidth;
                legendHeight += Math.max(titleHeight, maxItemHeight);
                if (index !== 0) {
                    legendHeight += rowGap;
                }
            }
        }
        else {
            isSectionWrapped = true;
            totalSectionalWidth = horizontalSectionWidth;
            const rowPadding = 0.4 * unitLength;
            if (horizontalSectionWidth > containerWidth) {
                isLegendWrapped = true;
                currentRowWidth = 0;
                initialNumberOfItemsPerRow = Math.floor(containerWidth / maxItemWidth);
                rowsAndCol = getSectionGridNums(section.items.length, initialNumberOfItemsPerRow);
                if (rowsAndCol.itemsPerCol && rowsAndCol.itemsPerRow) {
                    legendHeight += titleHeight + 2 * (maxItemHeight + rowPadding) + 2 * paddingTop;
                    currentRowWidth = rowsAndCol.itemsPerRow * maxItemWidth;
                    if (rowsAndCol.itemsPerCol > 2) {
                        //here padding gets added to top and bottom
                        legendHeight += (rowsAndCol.itemsPerCol - 2) * (maxItemHeight + 2 * rowPadding);
                    }
                }
            }
            else {
                currentRowWidth = totalSectionalWidth;
                legendHeight += maxItemHeight + titleHeight + 2 * paddingTop;
                if (index !== 0) {
                    legendHeight += rowGap;
                }
            }
        }
        maxRowWidth = Math.max(currentRowWidth, maxRowWidth);
        totalWidth += horizontalSectionWidth;
        maxWidth = Math.max(maxWidth, maxItemWidth);
        maxHeight = maxItemHeight;
        isSectionWrappedArray.push(isSectionWrapped);
        isLegendWrappedArray.push(isLegendWrapped);
        itemsPerRowArray.push(orientation === 'vertical' ? 1 : Math.max(1, initialNumberOfItemsPerRow));
    });
    const legendLayoutInfo = {
        maxRowWidth: Math.ceil(maxRowWidth),
        legendHeight,
        totalWidth,
        maxItemWidth: Math.min(maxWidth, containerWidth),
        maxItemHeight: Math.ceil(maxHeight),
        itemsPerRowArray,
        isSectionWrappedArray,
        isLegendWrappedArray
    };
    return legendLayoutInfo;
};
/**
 * Returns maximum of the width among the items in a section of legend also return the width of the entire section.
 * @param items Legend items array
 * @param unitLength Base  element
 * @param getTextDimensions Text width measurement function
 * @param legendFontStylesObj Legend text font style properties object
 * @param symbolWidth Width of legend symbol
 *
 * @returns
 */
const getMaxWidth = (items, unitLength, getTextDimensions, legendFontStylesObj, symbolWidth, symbolHeight) => {
    let maxItemWidth = 0;
    let maxItemHeight = 0;
    let horizontalSectionWidth = 0;
    let itemSymbolWidth = 0;
    let itemSymbolHeight = 0;
    const symbolPadding = unitLength * 1.5;
    if (symbolWidth) {
        itemSymbolWidth = symbolPadding + symbolWidth;
    }
    else {
        //below expression is simplified as, itemSymbolWidth = marginLeft + marginRight + width
        itemSymbolWidth = 4 * unitLength;
    }
    const paddingTop = 1.7 * unitLength;
    const defaultSymbolHeight = 2.5 * unitLength;
    if (symbolHeight) {
        // symbolHeight/defaultSymbolHeight + paddingTopBottom
        itemSymbolHeight = symbolHeight + paddingTop;
    }
    else {
        itemSymbolHeight = defaultSymbolHeight + paddingTop;
    }
    const paddingLeftRight = 2.5 * unitLength;
    items?.forEach((item) => {
        const legendItem = item;
        const { width, height } = getTextDimensions(legendItem.text, legendFontStylesObj);
        //itemTextWidth = paddingLeft + paddingRight + width
        const itemTextWidth = paddingLeftRight + width;
        //horizontalSectionWidth = total width of the section
        horizontalSectionWidth += itemSymbolWidth + itemTextWidth;
        maxItemWidth = Math.max(maxItemWidth, itemSymbolWidth + itemTextWidth);
        maxItemHeight = Math.max(maxItemHeight, height, itemSymbolHeight);
    });
    return { maxItemWidth, maxItemHeight, horizontalSectionWidth };
};

/**
 * A Sectional Legend allows grouping of legend items in sections with a specific title.
 */
const SectionalLegend = forwardRef(({ orientation = 'horizontal', sectionTitleHAlign = 'start', sections, isReadOnly = true, onItemAction, onItemHover, onItemFocus, testId, contextMenuConfig, hideAndShowBehavior = 'off', hoverBehavior = 'none', valign = 'top', halign = 'start', ...props }, ref = null) => {
    return (jsx(TrackResizeContainer, { width: '100%', height: '100%', class: classNames([
            styles.flexStyle,
            styles[`${halign}HAlign`],
            styles[`${valign}VAlign`]
        ]), children: function _(width, _height) {
            const testIdProps = useTestId(testId);
            const rootRef = useRef(null);
            const isTestEnv = testIdProps['data-testid'] !== undefined;
            const rootDimsRef = useRef();
            const { resolvedVars, cssContent } = useCssVars(legendVars);
            const { getItem, getDetailFromInfo, getPrevItemInfo, getNextItemInfo } = getSectionalNavUtils(sections);
            const legendFontStylesObj = getLegendTextStyle({
                fontStyle: props.textFontStyle,
                fontSize: props.textFontSize?.toString(),
                fontWeight: props.textFontWeight?.toString(),
                fontFamily: props.textFontFamily
            }, resolvedVars);
            const { textMeasureContent, getTextDimensions } = useTextDimensions();
            const isLegendItemActionable = getIsLegendItemActionable(sections, isReadOnly, true);
            const hasData = sections.length > 0;
            const layoutInfo = getSectionalLegendLayoutInfo({
                width,
                rootRef,
                getTextDimensions,
                resolvedVars,
                orientation,
                legendFontStylesObj,
                symbolWidth: props.symbolWidth,
                symbolHeight: props.symbolHeight,
                sections
            });
            const { touchResponse, touchResponseStyle } = useVisTouchResponse({ type: 'touchStart' });
            const { focusedItemInfo, hoveredItemInfo, onContextMenuDismissed, activeId, eventsProps } = useVisEvent(touchResponse, !isReadOnly, isLegendItemActionable, getKeyUpHandler, getDetailFromInfo, getPrevItemInfo, getNextItemInfo, onItemAction, onItemHover, onItemFocus, isEqualItem, getItemInfo, { itemIdx: 0, sectionIdx: 0 });
            const { focusedItemRef } = useItemFocus(focusedItemInfo);
            const text = getDatatipText(sections, getItem, focusedItemInfo, hoveredItemInfo);
            const [datatipDisabled, setDatatipDisabled] = useState(false);
            const { datatipContent, datatipProps: { 'aria-describedby': datatipAriaDescribedby, ...datatipProps } } = useLegendDatatip({
                text,
                rootDimsRef,
                focusedItemInfo,
                focusedItemRef,
                touchResponse,
                isDisabled: datatipDisabled
            });
            const ariaProps = getAriaProps(isReadOnly, props['aria-label'], props.hiddenIds, l([props['aria-describedby'], datatipAriaDescribedby]), props['aria-labelledby']);
            const { contextMenuContent, contextMenuProps } = useSectionalLegendContextMenu({
                rootRef,
                contextMenuConfig: hasData ? contextMenuConfig : undefined,
                focusedItemInfo,
                sections,
                isReadOnly,
                onContextMenuDismissed
            });
            const [dragOver, setDragOver] = useState();
            const { draggable, dndProps, dndContent } = useLegendDnd({
                onDrag: props.onDrag,
                onDragStart: props.onDragStart,
                onDragEnd: props.onDragEnd,
                onDragEnter: props.onDragEnter,
                onDragLeave: props.onDragLeave,
                onDragOver: props.onDragOver,
                onDrop: props.onDrop,
                sections,
                setDragOver,
                setDatatipDisabled,
                itemDraggable: props.itemDraggable
            });
            const mergedProps = mergeProps(eventsProps, datatipProps, contextMenuProps, dndProps);
            const titleStyle = {
                fontFamily: props.sectionTitleFontFamily,
                fontSize: props.sectionTitleFontSize,
                color: props.sectionTitleColor,
                fontStyle: props.sectionTitleFontStyle,
                fontWeight: props.sectionTitleFontWeight,
                textDecoration: props.sectionTitleTextDecoration
            };
            const { sectionalLegendBaseStyles, renderedLegendStyle } = styles;
            const isHoriz = orientation === 'horizontal';
            useImperativeHandle(ref, () => ({
                _getPreferredSize: (_width, _height) => {
                    const legendLayoutInfo = getSectionalLegendLayoutInfo({
                        width: _width,
                        getTextDimensions,
                        resolvedVars,
                        rootRef,
                        orientation,
                        legendFontStylesObj,
                        symbolWidth: props.symbolWidth,
                        symbolHeight: props.symbolHeight,
                        sections
                    });
                    if (legendLayoutInfo) {
                        return {
                            width: legendLayoutInfo?.maxRowWidth,
                            height: legendLayoutInfo?.legendHeight
                        };
                    }
                    else {
                        return;
                    }
                }
            }), [getTextDimensions, legendFontStylesObj, resolvedVars]);
            return (jsxs("div", { ref: rootRef, tabIndex: isReadOnly ? undefined : 0, role: "application", class: classNames([
                    sectionalLegendBaseStyles,
                    renderedLegendStyle,
                    dragOver
                        ? styles$1.dndDragOverHTMLStyle
                        : dragOver === false
                            ? styles$1.dndRejectedStyle
                            : undefined
                ]), draggable: draggable, style: touchResponseStyle, ...testIdProps, ...ariaProps, ...mergedProps, "aria-activedescendant": activeId, children: [jsx(Flex, { direction: isHoriz ? 'row' : 'column', wrap: 'wrap', gap: '4x', children: sections.map((section, index) => {
                            const labelledById = !isReadOnly ? getRandomId() : '';
                            const isWrappedSection = layoutInfo
                                ? layoutInfo.isSectionWrappedArray[index]
                                : false;
                            const flexDirection = !isHoriz || isWrappedSection ? 'column' : 'row';
                            const alignItems = !isHoriz || isWrappedSection ? 'start' : 'center';
                            const { itemsPerCol, itemsPerRow } = getSectionGridNums(section.items.length, layoutInfo?.itemsPerRowArray[index]);
                            return (jsxs(Flex, { align: alignItems, direction: flexDirection, maxWidth: '100%', justify: 'start', wrap: "wrap", children: [jsx(LegendText, { text: section.title, ...titleStyle, type: "title", id: labelledById, align: sectionTitleHAlign }), jsx(BaseLegend, { ...props, focusedItemRef: focusedItemRef, labelledBy: labelledById, sectionIdx: index, items: section.items, orientation: orientation, itemsPerRow: itemsPerRow, itemsPerCol: itemsPerCol, itemWidth: layoutInfo?.isLegendWrappedArray[index]
                                            ? layoutInfo?.maxItemWidth
                                            : undefined, isReadOnly: isReadOnly, focusedItemInfo: focusedItemInfo, hoveredItemInfo: hoveredItemInfo, activeId: activeId, hideAndShowBehavior: hideAndShowBehavior, hoverBehavior: hoverBehavior, isTestEnv: isTestEnv })] }));
                        }) }), datatipContent, textMeasureContent, cssContent, contextMenuContent, dndContent] }));
        } }));
});

export { SectionalLegend };
//# sourceMappingURL=UNSAFE_SectionalLegend.js.map
