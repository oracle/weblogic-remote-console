/* @oracle/oraclejet-preact: undefined */
import { useRef, useCallback } from 'preact/hooks';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
function useSwipe(onSwipe, { threshold = 10, maximumTime = 300, tolerance = 50, isDisabled = false } = {
    threshold: 10,
    maximumTime: 300,
    tolerance: 50,
    isDisabled: false
}) {
    const ref = useRef({
        pointerDownId: 0,
        startTime: null,
        prevClientX: 0,
        prevClientY: 0
    });
    const clearSwipe = useCallback(() => {
        ref.current = {
            pointerDownId: null,
            startTime: 0,
            prevClientX: 0,
            prevClientY: 0
        };
    }, []);
    const onPointerDown = useCallback((e) => {
        if (!ref.current.pointerDownId) {
            ref.current = {
                pointerDownId: e.pointerId,
                startTime: e.timeStamp,
                prevClientX: e.clientX,
                prevClientY: e.clientY
            };
        }
        else {
            clearSwipe();
        }
    }, [clearSwipe]);
    const onPointerUp = useCallback((ev) => {
        if (ev.pointerId === ref.current.pointerDownId) {
            if (ref.current.startTime && ev.timeStamp - ref.current.startTime < maximumTime) {
                if (ref.current.prevClientX - ev.clientX > threshold &&
                    Math.abs(ev.clientY - ref.current.prevClientY) <= tolerance) {
                    onSwipe?.({ direction: 'left' });
                }
                else if (ev.clientX - ref.current.prevClientX > threshold &&
                    Math.abs(ev.clientY - ref.current.prevClientY) <= tolerance) {
                    onSwipe?.({ direction: 'right' });
                }
                else if (ref.current.prevClientY - ev.clientY > threshold &&
                    Math.abs(ev.clientX - ref.current.prevClientX) <= tolerance) {
                    onSwipe?.({ direction: 'up' });
                }
                else if (ev.clientY - ref.current.prevClientY > threshold &&
                    Math.abs(ev.clientX - ref.current.prevClientX) <= tolerance) {
                    onSwipe?.({ direction: 'down' });
                }
            }
        }
        // state would be reset to its original state whether swipe is completed or cancelled
        clearSwipe();
    }, [threshold, onSwipe, clearSwipe, maximumTime, tolerance]);
    const swipeProps = isDisabled
        ? {}
        : {
            /** event handlers to spread on the target element. */
            onPointerDown,
            onPointerUp,
            onPointerCancel: clearSwipe
        };
    return {
        swipeProps
    };
}

export { useSwipe as u };
//# sourceMappingURL=useSwipe-b5c1b9ad.js.map
