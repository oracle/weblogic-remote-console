/* @oracle/oraclejet-preact: undefined */
import { g as getColorRamp } from './colorUtils-45d1cac0.js';
import './accUtils-f6657e8e.js';
import { m as getMarkers } from './utils-adfaaca0.js';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Returns the next navigable item in the same series.
 * @param seriesIndex
 * @param groupIndex
 * @param numOfGroups
 * @returns
 */
function getNextItemInSeries(info, viewportEndIndex, isNavigable) {
    const { seriesIndex, groupIndex } = info;
    const nextGroupIndex = groupIndex + 1;
    if (nextGroupIndex > viewportEndIndex) {
        return;
    }
    if (isNavigable(seriesIndex, nextGroupIndex)) {
        return { seriesIndex, groupIndex: nextGroupIndex };
    }
    return getNextItemInSeries({
        seriesIndex,
        groupIndex: nextGroupIndex
    }, viewportEndIndex, isNavigable);
}
/**
 * Returns the previous navigable item in the same series.
 * @param seriesIndex
 * @param itemIndex
 * @returns
 */
function getPrevItemInSeries(info, viewportStartIndex, isNavigable) {
    const { seriesIndex, groupIndex } = info;
    const prevGroupIndex = groupIndex - 1;
    if (prevGroupIndex < viewportStartIndex) {
        return;
    }
    if (isNavigable(seriesIndex, prevGroupIndex)) {
        return { seriesIndex, groupIndex: prevGroupIndex };
    }
    if (prevGroupIndex === 0) {
        return undefined;
    }
    return getPrevItemInSeries({ seriesIndex, groupIndex: prevGroupIndex }, viewportStartIndex, isNavigable);
}
/**
 * Returns the previous navigable item in the same group.
 * @param seriesIndex
 * @param groupIndex
 * @param isNavigable
 */
function getPrevItemInGroup(info, isNavigable) {
    const { seriesIndex, groupIndex } = info;
    const prevSeriesIndex = seriesIndex - 1;
    if (prevSeriesIndex < 0) {
        return;
    }
    if (isNavigable(prevSeriesIndex, groupIndex)) {
        return { seriesIndex: prevSeriesIndex, groupIndex };
    }
    return getPrevItemInGroup({
        seriesIndex: prevSeriesIndex,
        groupIndex
    }, isNavigable);
}
/**
 * Returns the next navigable item in the same group.
 * @param seriesIndex
 * @param groupIndex
 * @param numOfSeries
 * @param numOfGroups
 */
function getNextItemInGroup(info, numOfSeries, isNavigable) {
    const { seriesIndex, groupIndex } = info;
    const nextSeriesIndex = seriesIndex + 1;
    if (nextSeriesIndex >= numOfSeries) {
        return;
    }
    if (isNavigable(nextSeriesIndex, groupIndex)) {
        return { seriesIndex: nextSeriesIndex, groupIndex };
    }
    return getNextItemInGroup({
        seriesIndex: nextSeriesIndex,
        groupIndex
    }, numOfSeries, isNavigable);
}
/**
 * Returns the next item in the group with higher value than the current item.
 * @param info The ItemInfo of current item.
 * @param numSeries The number of series in the group.
 * @param getDataItem The function that returns the chart data item.
 * @returns
 */
function getNextHigherItemInGroup(info, numSeries, getDataItem, isItemNavigable) {
    const getValue = (_item) => {
        return 'value' in _item && _item.value !== undefined
            ? _item.value
            : 'y' in _item && _item.y !== undefined
                ? _item.y
                : undefined;
    };
    const { groupIndex, seriesIndex } = info;
    const item = getDataItem(seriesIndex, groupIndex);
    const itemValue = getValue(item);
    if (!item || itemValue === undefined) {
        return info;
    }
    let minValue = Number.MAX_VALUE;
    let minIndex = seriesIndex;
    for (let i = 0; i < numSeries; i++) {
        const currentItem = getDataItem(i, groupIndex);
        const currentItemValue = currentItem !== undefined ? getValue(currentItem) : undefined;
        if (currentItemValue === undefined ||
            currentItemValue < itemValue ||
            !isItemNavigable(i, groupIndex) ||
            seriesIndex === i) {
            continue;
        }
        if (currentItemValue < minValue) {
            minValue = currentItemValue;
            minIndex = i;
        }
    }
    return { seriesIndex: minIndex, groupIndex };
}
/**
 * Returns the item info of the item in the group with lower value than the current item.
 * @param info The ItemInfo of the current item.
 * @param numSeries The number of series in the group.
 * @param getDataItem The function that returns the chart data item.
 * @returns
 */
function getNextLowerItemInGroup(info, numSeries, getDataItem, isItemNavigable) {
    const getValue = (_item) => {
        return 'value' in _item && _item.value !== undefined
            ? _item.value
            : 'y' in _item && _item.y !== undefined
                ? _item.y
                : undefined;
    };
    const { groupIndex, seriesIndex } = info;
    const item = getDataItem(seriesIndex, groupIndex);
    const itemValue = getValue(item);
    if (!item || itemValue === undefined) {
        return info;
    }
    let maxValue = Number.MIN_VALUE;
    let maxIndex = seriesIndex;
    for (let i = 0; i < numSeries; i++) {
        const currentItem = getDataItem(i, groupIndex);
        const currentItemValue = currentItem !== undefined ? getValue(currentItem) : undefined;
        if (currentItemValue === undefined ||
            currentItemValue > itemValue ||
            !isItemNavigable(i, groupIndex) ||
            seriesIndex === i) {
            continue;
        }
        if (currentItemValue > maxValue) {
            maxValue = currentItemValue;
            maxIndex = i;
        }
    }
    return { seriesIndex: maxIndex, groupIndex };
}
function getLineAreaChartNavUtil(getDataItem, numSeries, viewportStartIndex, viewportEndIndex, isStacked, isRtl, isHoriz) {
    const isItemNavigable = (seriesIndex, groupIndex) => {
        const barItem = getDataItem(seriesIndex, groupIndex);
        return Boolean(barItem);
    };
    const getNextChartItem = (itemInfo, arrow) => {
        let newInfo;
        const info = {
            groupIndex: itemInfo.groupIndex,
            seriesIndex: itemInfo.seriesIndex
        };
        if (info.groupIndex < viewportStartIndex) {
            info.groupIndex = viewportStartIndex;
            return info;
        }
        else if (info.groupIndex > viewportEndIndex) {
            info.groupIndex = viewportEndIndex;
            return info;
        }
        if (arrow === 'ArrowLeft') {
            if (!isHoriz) {
                newInfo = isRtl
                    ? getNextItemInSeries(info, viewportEndIndex, isItemNavigable)
                    : getPrevItemInSeries(info, viewportStartIndex, isItemNavigable);
            }
            else {
                newInfo = isRtl
                    ? getNextHigherItemInGroup(info, numSeries, getDataItem, isItemNavigable)
                    : getNextLowerItemInGroup(info, numSeries, getDataItem, isItemNavigable);
            }
        }
        else if (arrow === 'ArrowRight') {
            if (!isHoriz) {
                newInfo = isRtl
                    ? getPrevItemInSeries(info, viewportStartIndex, isItemNavigable)
                    : getNextItemInSeries(info, viewportEndIndex, isItemNavigable);
            }
            else {
                newInfo = !isRtl
                    ? getNextHigherItemInGroup(info, numSeries, getDataItem, isItemNavigable)
                    : getNextLowerItemInGroup(info, numSeries, getDataItem, isItemNavigable);
            }
        }
        else if (arrow === 'ArrowDown') {
            if (isHoriz) {
                newInfo = getNextItemInSeries(info, viewportEndIndex, isItemNavigable);
            }
            else {
                if (isStacked) {
                    newInfo = getPrevItemInGroup(info, isItemNavigable);
                }
                else {
                    newInfo = getNextLowerItemInGroup(info, numSeries, getDataItem, isItemNavigable);
                }
            }
        }
        else {
            if (isHoriz) {
                newInfo = getPrevItemInSeries(info, viewportStartIndex, isItemNavigable);
            }
            else {
                if (isStacked) {
                    newInfo = getNextItemInGroup(info, numSeries, isItemNavigable);
                }
                else {
                    newInfo = getNextHigherItemInGroup(info, numSeries, getDataItem, isItemNavigable);
                }
            }
        }
        return newInfo || info;
    };
    return getNextChartItem;
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
function getItemColor(seriesIndex, groupIndex, series, getDataItem) {
    const item = getDataItem(seriesIndex, groupIndex);
    if (item?.color) {
        return item.color;
    }
    if (item?.markerColor) {
        return item.markerColor;
    }
    const itemSeries = series[seriesIndex];
    const colors = getColorRamp();
    return (itemSeries.color ||
        itemSeries.lineColor ||
        itemSeries.areaColor ||
        colors[seriesIndex % colors.length]);
}
function getMarkerType(seriesIndex, groupIndex, getDataItem) {
    const item = getDataItem(seriesIndex, groupIndex);
    if (item?.markerType) {
        return item.markerType;
    }
    const shapes = getMarkers();
    return shapes[seriesIndex % shapes.length];
}

export { getPrevItemInSeries as a, getNextItemInGroup as b, getPrevItemInGroup as c, getItemColor as d, getLineAreaChartNavUtil as e, getMarkerType as f, getNextItemInSeries as g };
//# sourceMappingURL=dataStyleUtils-a529150d.js.map
