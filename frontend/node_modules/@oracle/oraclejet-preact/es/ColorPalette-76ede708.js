/* @oracle/oraclejet-preact: undefined */
import { jsx } from 'preact/jsx-runtime';
import { forwardRef, useState, useEffect, useImperativeHandle } from 'preact/compat';
import { useRef } from 'preact/hooks';
import { C as ColorSwatch } from './ColorSwatch-52f47316.js';
import { p as parseColorValue, c as convertPalette, s as sortPalette } from './swatchData-64959ad2.js';
import { F as Flex } from './Flex-5befe411.js';
import { u as useTestId } from './useTestId-e5d44ab1.js';
import { d as dimensionInterpolations } from './dimensions-ddde0eee.js';
import { p as paddingInterpolations } from './padding-9b3afaa2.js';
import { c as colorInterpolations } from './colors-b6530fec.js';
import { a as ariaInterpolations } from './aria-efa0582c.js';
import { m as mergeInterpolations } from './mergeInterpolations-30cd9a69.js';
import bundle from './resources/nls/en/bundle.js';
import { S as SwatchFlexView } from './SwatchFlexView-6c94f2bd.js';

const interpolations = [
    ...Object.values(dimensionInterpolations),
    ...Object.values(colorInterpolations),
    ...Object.values(ariaInterpolations),
    ...Object.values(paddingInterpolations)
];
const mergedInterpolations = mergeInterpolations(interpolations);
/**
 * A Color Palette is an interface that displays a variety of color swatches allowing
 * users to select a color value.
 *
 * @param {ColorPaletteProps} props ColorPalette component props.
 * @returns {JSX.Element} ColorPalette component element.
 */
const ColorPalette = forwardRef(({ value, swatchSize = 'sm', palette, onCommit, testId, ...props }, focusHandleRef) => {
    const { class: mergedClasses, ariaLabel, ariaLabelledBy, ...mergedStyles } = mergedInterpolations(props);
    const rootRef = useRef(null);
    const testIdProps = useTestId(testId);
    const colorPaletteTranslated = bundle.accColorPalette();
    const [current, setCurrent] = useState(undefined);
    const [selected, setSelected] = useState({
        all: false,
        keys: new Set([value ?? undefined])
    });
    useEffect(() => {
        setSelected({
            all: false,
            keys: new Set([parseColorValue(value ?? undefined)])
        });
    }, [value]);
    useEffect(() => { }, [selected]); // redraw when selection occurs
    const getRowKey = (data) => {
        return data;
    };
    //Allows to call focus on rootRef without having to expose it
    useImperativeHandle(focusHandleRef, () => ({
        focus: () => {
            if (rootRef.current) {
                rootRef.current.focus();
            }
        },
        blur: () => {
            if (rootRef.current) {
                rootRef.current.blur();
            }
        }
    }));
    const dropdownStyle = {
        width: '100%',
        height: '100%'
    };
    return (jsx("div", { "aria-labelledby": ariaLabelledBy, className: mergedClasses, style: dropdownStyle, ...testIdProps, ...mergedStyles, children: jsx(Flex, { align: "center", children: jsx(SwatchFlexView, { ref: rootRef, "aria-label": ariaLabel ? ariaLabel : colorPaletteTranslated, focusBehavior: "content", data: palette ? convertPalette(sortPalette(palette)) : null, getRowKey: getRowKey, currentKey: current, onCurrentKeyChange: (detail) => {
                    setCurrent(detail.value);
                }, selectedKeys: selected, children: (context) => (jsx(ColorSwatch, { size: swatchSize, testId: testId + '_palette' + '_colorSwatch_' + context.data, "aria-hidden": true, value: context.data, onToggle: () => {
                        onCommit?.({
                            value: context.data,
                            previousValue: selected.keys?.values().next().value
                        });
                        setSelected({ all: false, keys: new Set([context.data]) });
                    }, isSelected: selected.keys?.has(context.data) })) }) }) }));
});
ColorPalette.displayName = 'ColorPalette';

export { ColorPalette as C };
//# sourceMappingURL=ColorPalette-76ede708.js.map
