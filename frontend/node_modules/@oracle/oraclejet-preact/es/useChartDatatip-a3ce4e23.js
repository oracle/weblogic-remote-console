/* @oracle/oraclejet-preact: undefined */
import { u as useDatatip } from './useDatatip-c7727336.js';
import { c as calculateOffset } from './layoutUtils-895c6de8.js';
import { jsx } from 'preact/jsx-runtime';
import { V as VisTabularDatatip } from './VisTabularDatatip-4d0f026a.js';
import { g as generateAriaLabel } from './accUtils-f6657e8e.js';
import { g as getColorRamp } from './colorUtils-45d1cac0.js';
import { u as useUser } from './useUser-df8ae011.js';

/**
 * Returns the data required for the VisTabularDatatip to render.
 * @param activeInfo active item info.
 * @param series The array of chart series.
 * @param groups The array of chart groups.
 * @param valueFormats The array of chart series.
 * @param getDataItem function which returns chartItem
 */
function getChartTabularData(data, seriesValue, groupValue, translations, valueFormats, isTimeAxis, defaultXFormatter, defaultYFormatter, hasXYValues) {
    let itemValue, itemX, itemY, itemWidthWeight;
    const seriesLabel = translations.chart_labelSeries();
    const groupLabel = translations.chart_labelGroup();
    const valueLabel = translations.chart_labelValue();
    const xLabel = translations.chart_labelX();
    const yLabel = translations.chart_labelY();
    const widthWeightLabel = translations.chart_labelWidthWeight();
    if (hasXYValues && 'y' in data) {
        const x = data.x;
        itemX = valueFormats?.x?.format ? valueFormats?.x?.format(x) : defaultXFormatter?.(x);
        const y = data.y;
        itemY = valueFormats?.y?.format ? valueFormats?.y?.format(y) : defaultYFormatter?.(y);
    }
    else if ('value' in data && data.value !== undefined) {
        const value = data.value;
        itemValue = valueFormats?.value?.format
            ? valueFormats?.value?.format?.(value)
            : defaultYFormatter?.(value);
    }
    if ('widthWeight' in data && data.widthWeight !== undefined) {
        const widthWeight = data.widthWeight;
        itemWidthWeight = valueFormats?.widthWeight?.format
            ? valueFormats?.widthWeight?.format?.(widthWeight)
            : defaultYFormatter?.(widthWeight);
    }
    const tableData = [];
    if (valueFormats?.series?.isDisplayed != false) {
        tableData.push({
            key: valueFormats?.series?.label || seriesLabel,
            value: seriesValue
        });
    }
    if (valueFormats?.group?.isDisplayed != false) {
        const isArray = Array.isArray(valueFormats?.group?.label);
        if (isTimeAxis) {
            const group = Array.isArray(groupValue) ? groupValue[0] : groupValue;
            tableData.push({
                key: (isArray ? valueFormats?.group?.label?.[0] : valueFormats?.group?.label) ||
                    'Date',
                value: defaultXFormatter ? defaultXFormatter?.(new Date(group).getTime()) : group
            });
        }
        else {
            const groupsLabel = (isArray ? valueFormats?.group?.label : [valueFormats?.group?.label || groupLabel]);
            const groups = Array.isArray(groupValue) ? groupValue : [groupValue];
            groups.forEach((value, index) => {
                tableData.push({
                    key: groupsLabel[index],
                    value: value
                });
            });
        }
    }
    if (valueFormats?.value?.isDisplayed != false) {
        if (hasXYValues) {
            tableData.push({
                key: valueFormats?.value?.label || xLabel,
                value: itemX
            });
            tableData.push({
                key: valueFormats?.value?.label || yLabel,
                value: itemY
            });
        }
        else {
            tableData.push({
                key: valueFormats?.value?.label || valueLabel,
                value: itemValue
            });
        }
    }
    if (valueFormats?.widthWeight?.isDisplayed != false && itemWidthWeight) {
        tableData.push({
            key: valueFormats?.widthWeight?.label || widthWeightLabel,
            value: itemWidthWeight
        });
    }
    return tableData;
}
function getDefaultDatatipRenderer(options) {
    const isSeriesAssociatedToY2 = options.series.associatedYAxis === 'y2';
    const isMixedFrequency = options.timeAxisType === 'mixedFrequency';
    const isRegularTimeAxis = options.timeAxisType === 'enabled' || options.timeAxisType === 'skipGaps';
    return (context) => {
        const groupValue = options.groups;
        const timeValue = (isMixedFrequency ? context.data.x : isRegularTimeAxis ? groupValue : undefined);
        return {
            content: (jsx(VisTabularDatatip, { tableData: getChartTabularData(context.data, options.series.name || options.series.id.toString(), timeValue || options.groups, options.translations, options.valueFormats, options.timeAxisType != null, options.defaultXFormatter, isSeriesAssociatedToY2 ? options.defaultY2Formatter : options.defaultYFormatter, options.hasXYValues) })),
            borderColor: context.data.color || options.series.color
        };
    };
}
function getAriaLabelGenerator(series, translations, valueFormats, leafGroupsInfo, xAxis, isDataXAxis, getGroupFromPath, xDefaultLabelFormatter, yDefaultLabelFormatter, y2DefaultLabelFormatter) {
    const getItemAriaLabel = (data, seriesIndex, groupIndex, isSelectionEnabled, isSelected, isDrillable) => {
        let accLabel = data.accessibleLabel;
        if (!accLabel) {
            const _series = series[seriesIndex];
            const isAssociatedToY2 = _series.associatedYAxis === 'y2';
            const groupValue = getGroupFromPath(leafGroupsInfo[groupIndex].path);
            const timeValue = (xAxis?.timeAxisType === 'mixedFrequency'
                ? data.x
                : xAxis?.timeAxisType === 'enabled'
                    ? groupValue
                    : undefined);
            const tababularData = getChartTabularData(data, _series.name || _series.id.toString(), timeValue || groupValue, translations, valueFormats, xAxis?.timeAxisType != null, xDefaultLabelFormatter, isAssociatedToY2 ? y2DefaultLabelFormatter : yDefaultLabelFormatter, isDataXAxis);
            accLabel = tababularData
                .map(({ key, value }) => `${key ? key + ':' : ''} ${value}`)
                .join(', ');
        }
        return generateAriaLabel(translations, accLabel, {
            isSelected: !isSelectionEnabled ? undefined : isSelected,
            isDrillable
        });
    };
    return getItemAriaLabel;
}

const DATA_CURSOR_OFFSET = 10;
const useChartDatatip = ({ isDataCursorEnabled, dataCursorPosition, isHoriz, datatip, xScale, getDataItem, getDataItemPos, hoveredItemInfo, focusedItemInfo, series, valueFormats, leafGroupsInfo, width, height, findNearest, timeAxisType, touchResponse, isDisabled, defaultXFormatter, defaultYFormatter, defaultY2Formatter, hasXYValues, translations, getGroupFromPath }) => {
    const hasData = leafGroupsInfo.length > 0 && series.length > 0;
    let activeInfo = !hasData
        ? undefined
        : !isDisabled
            ? focusedItemInfo?.isCurrent
                ? focusedItemInfo
                : hoveredItemInfo?.isCurrent &&
                    hoveredItemInfo.seriesIndex !== undefined &&
                    hoveredItemInfo.groupIndex !== undefined
                    ? hoveredItemInfo
                    : undefined
            : undefined;
    const anchor = focusedItemInfo?.isCurrent || isDataCursorEnabled ? 'element' : 'pointer';
    const elementBounds = focusedItemInfo?.isCurrent
        ? getDataItemPos(focusedItemInfo.seriesIndex, focusedItemInfo.groupIndex)
        : undefined;
    const { direction } = useUser();
    const isRtl = direction === 'rtl';
    let placement = 'top-start';
    let offset = calculateOffset(isRtl, width, elementBounds);
    if (isDataCursorEnabled &&
        dataCursorPosition?.x != null &&
        (dataCursorPosition?.y != null || dataCursorPosition?.y2 != null)) {
        const neareast = findNearest(dataCursorPosition.x, dataCursorPosition.y, dataCursorPosition.y2);
        activeInfo = activeInfo || neareast;
        // TOD0: The offset for data cursor should be calculated according to
        // datatip content dimensions as well.
        const xPos = xScale.transform(dataCursorPosition.x);
        offset = { mainAxis: -1, crossAxis: -1 };
        if (isHoriz) {
            placement = 'end';
            offset.mainAxis = -1 * DATA_CURSOR_OFFSET;
            offset.crossAxis = xPos - height / 2;
        }
        else {
            placement = 'top';
            offset.crossAxis = isRtl ? width / 2 - xPos : xPos - width / 2;
            offset.mainAxis = -1 * DATA_CURSOR_OFFSET;
        }
    }
    let dtContent;
    let item;
    if (activeInfo?.seriesIndex != null && activeInfo?.groupIndex != null) {
        item = getDataItem(activeInfo.seriesIndex, activeInfo.groupIndex, leafGroupsInfo[activeInfo.groupIndex].path);
        const datatipContext = item
            ? {
                data: item,
                seriesIndex: activeInfo.seriesIndex,
                groupIndex: activeInfo.groupIndex,
                id: item.id,
                groupPath: leafGroupsInfo[activeInfo.groupIndex].path
            }
            : undefined;
        if (datatipContext) {
            const datatipRenderer = datatip ||
                getDefaultDatatipRenderer({
                    series: series[activeInfo.seriesIndex],
                    groups: getGroupFromPath(leafGroupsInfo[activeInfo.groupIndex].path),
                    translations,
                    valueFormats,
                    timeAxisType,
                    defaultXFormatter,
                    defaultYFormatter,
                    defaultY2Formatter,
                    hasXYValues
                });
            dtContent = datatipRenderer(datatipContext);
        }
    }
    const colors = getColorRamp();
    const borderColor = dtContent?.borderColor ||
        (activeInfo &&
            (series[activeInfo.seriesIndex]?.color ||
                series[activeInfo.seriesIndex]?.lineColor ||
                series[activeInfo.seriesIndex]?.areaColor)) ||
        (activeInfo && colors[activeInfo.seriesIndex % colors.length]);
    const { datatipContent, datatipProps } = useDatatip({
        content: dtContent?.content,
        anchor,
        placement,
        offset,
        borderColor,
        touchResponse,
        isDisabled
    });
    return { datatipContent, datatipProps };
};

export { getAriaLabelGenerator as g, useChartDatatip as u };
//# sourceMappingURL=useChartDatatip-a3ce4e23.js.map
