/* @oracle/oraclejet-preact: undefined */
import { u as useContextMenu } from './useContextMenu-6aa8193e.js';
import 'preact/jsx-runtime';
import './SelectMenuGroupContext-0c1a7603.js';
import 'preact/hooks';
import 'preact';
import './logger-c92f309c.js';
import './LayerHost-12489cef.js';
import 'preact/compat';
import './TooltipContentStyles.styles.css';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentBaseTheme.styles.css';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js';
import './tooltipUtils-466c63c4.js';
import './IconStyle.styles.css';
import './UNSAFE_Menu/themes/MenuItemStyles.css.js';
import './UNSAFE_Separator/themes/SeparatorStyles.css.js';
import './MenuSeparatorStyles.styles.css';
import './UNSAFE_Menu/themes/redwood/MenuSeparatorBaseTheme.styles.css';
import './UNSAFE_Menu/themes/redwood/MenuSeparatorVariants.css.js';
import './MenuStyles.styles.css';
import { g as getInfo } from './eventsUtils-e96290df.js';
import './accUtils-f6657e8e.js';
import { c as calculateOffset } from './layoutUtils-895c6de8.js';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
function getChartContextMenuContext(focusedItemInfo, focusedGroupInfo, gesture, target, series, levelsArray, rootRef, xAxisTitle, yAxisTitle, getDataItem) {
    let seriesIndex;
    let groupIndex;
    let levelIndex;
    if (gesture === 'keyboard') {
        //We find the element where the position of the menu is going to be based of
        groupIndex = focusedItemInfo.groupIndex;
        seriesIndex = focusedItemInfo.seriesIndex;
        levelIndex = focusedGroupInfo.levelIndex;
    }
    else {
        //We search for the key using the target of the event
        const info = getInfo(rootRef, target);
        seriesIndex = info ? info.seriesIndex : undefined;
        groupIndex = info ? info.groupIndex : undefined;
        levelIndex = info ? info.levelIndex : undefined;
    }
    let context;
    if (seriesIndex !== undefined && groupIndex !== undefined && getDataItem) {
        const groupPath = levelsArray[levelsArray.length - 1]?.[groupIndex]?.path;
        const data = getDataItem(seriesIndex, groupIndex, groupPath);
        context = {
            data,
            groupIndex,
            seriesIndex,
            type: 'item'
        };
    }
    else if (seriesIndex !== undefined) {
        context = {
            data: series[seriesIndex],
            type: 'series'
        };
    }
    else if (groupIndex !== undefined && levelIndex != undefined) {
        context = {
            data: levelsArray[levelIndex]?.[groupIndex],
            type: 'xAxisTickLabel'
        };
    }
    else {
        const target = event?.target;
        const text = target?.textContent;
        if ((text && gesture !== 'keyboard' && text === xAxisTitle) || text === yAxisTitle) {
            context = {
                type: 'axisTitle',
                axis: text === xAxisTitle ? 'x' : 'y'
            };
        }
        else {
            context = {
                type: 'background'
            };
        }
    }
    return {
        context: context
    };
}

const useChartContextMenu = ({ isRtl, width, getDataItemPosition, getDataItem, focusedItemInfo, focusedGroupInfo, series, levelsArray, rootRef, xAxisTitle, yAxisTitle, contextMenuConfig, onContextMenuDismissed }) => {
    const { contextMenuProps, contextMenuContent } = useContextMenu({
        onContextMenuHandler: ({ gesture, target }) => {
            const { context } = getChartContextMenuContext(focusedItemInfo, focusedGroupInfo, gesture, target, series, levelsArray, rootRef, xAxisTitle, yAxisTitle, getDataItem);
            if (gesture === 'keyboard' && context.type === 'item') {
                const elementBounds = focusedItemInfo?.isCurrent
                    ? getDataItemPosition(focusedItemInfo.seriesIndex, focusedItemInfo.groupIndex)
                    : undefined;
                const offsetValue = calculateOffset(isRtl, width, elementBounds);
                return {
                    type: 'offset',
                    context,
                    offsetValue,
                    isRtl,
                    width
                };
            }
            return { type: 'pointer', context };
        },
        contextMenuOptions: {
            isDisabled: !contextMenuConfig //If there is not a context menu renderer we disable the hook
        },
        rootRef,
        contextMenuConfig,
        onContextMenuDismissed
    });
    return { contextMenuContent, contextMenuProps };
};

export { useChartContextMenu as u };
//# sourceMappingURL=useChartContextMenu-92d9028b.js.map
