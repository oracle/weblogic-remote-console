{"version":3,"file":"DataGrid-6b0305ec.js","sources":["../../src/PRIVATE_DataGrid/DataGridCell.tsx","../../src/PRIVATE_DataGrid/utils/DataGridRenderUtils.ts","../../src/PRIVATE_DataGrid/DataGrid.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Skeleton } from '#UNSAFE_Skeleton';\nimport { classNames } from '#utils/UNSAFE_classNames/classNames';\nimport { dataGridCellStyles } from './themes/DataGridCell.css';\n\nexport type DataGridCellProps<D> = {\n  cell: {\n    cellType: string;\n    rowStart: number;\n    rowExtent: number;\n    columnStart: number;\n    columnExtent: number;\n    data: D;\n    lastColIndex: boolean;\n    lastRowIndex: boolean;\n    borderLeft: boolean;\n    borderRight: boolean;\n    level?: number;\n  };\n  height: number;\n  width: number;\n};\n\nconst getCellStyle = (cell: any, width: number, height: number) => {\n  let styleString = `\n    grid-row-start: ${cell.rowStart + 1};\n    grid-row-end: ${cell.rowStart + cell.rowExtent + 1};\n    grid-column-start: ${cell.columnStart + 1};\n    grid-column-end: ${cell.columnStart + cell.columnExtent + 1};\n  `;\n\n  switch (cell.cellType) {\n    case 'rowHeader':\n    case 'rowHeaderSkeleton':\n      styleString += `left: ${width * cell.level}px;`;\n      break;\n    case 'rowEndHeader':\n    case 'rowEndHeaderSkeleton':\n      styleString += `right: ${width * cell.level}px;`;\n      break;\n    case 'columnEndHeader':\n    case 'columnEndHeaderSkeleton':\n      styleString += `bottom: ${height * cell.level}px;`;\n      break;\n    case 'columnHeader':\n    case 'columnHeaderSkeleton':\n      styleString += `top: ${height * cell.level}px;`;\n      break;\n    case 'rowHeaderLabel':\n    case 'columnHeaderLabel':\n      styleString += `\n        top: ${height * cell.rowStart}px;\n        left: ${width * cell.columnStart}px;\n      `;\n      break;\n    case 'rowEndHeaderLabel':\n      styleString += `right: ${width * cell.level}px;`;\n      break;\n    case 'columnEndHeaderLabel':\n      styleString += `bottom: ${height * cell.level}px;`;\n      break;\n  }\n\n  return styleString.trim();\n};\n\nconst getCellClasses = (cell: any) => {\n  const baseClass = dataGridCellStyles.base;\n  const headerTypes = [\n    'rowHeader',\n    'rowEndHeader',\n    'columnEndHeader',\n    'columnHeader',\n    'rowHeaderSkeleton',\n    'rowEndHeaderSkeleton',\n    'columnEndHeaderSkeleton',\n    'columnHeaderSkeleton'\n  ];\n  const topLeftTypes = ['rowHeaderLabel', 'columnHeaderLabel', 'topLeftSpacer'];\n  const topRightTypes = ['rowEndHeaderLabel', 'topRightSpacer'];\n  const bottomLeftTypes = ['columnEndHeaderLabel', 'bottomLeftSpacer'];\n  const bottomRightTypes = ['bottomRightSpacer'];\n\n  const classes = [baseClass];\n\n  if (headerTypes.includes(cell.cellType)) {\n    classes.push(dataGridCellStyles.header);\n  } else if (topLeftTypes.includes(cell.cellType)) {\n    classes.push(dataGridCellStyles.topLeft);\n  } else if (topRightTypes.includes(cell.cellType)) {\n    classes.push(dataGridCellStyles.topRight);\n  } else if (bottomLeftTypes.includes(cell.cellType)) {\n    classes.push(dataGridCellStyles.bottomLeft);\n  } else if (bottomRightTypes.includes(cell.cellType)) {\n    classes.push(dataGridCellStyles.bottomRight);\n  } else if (cell.cellType === 'rowHeaderSpacer') {\n    classes.push(dataGridCellStyles.rhSpacer);\n  } else if (cell.cellType === 'columnHeaderSpacer') {\n    classes.push(dataGridCellStyles.chSpacer);\n  }\n\n  if (cell.lastRow) {\n    classes.push(dataGridCellStyles.lastRow);\n  }\n  if (cell.lastColumn) {\n    classes.push(dataGridCellStyles.lastColumn);\n  }\n  if (cell.borderLeft) {\n    classes.push(dataGridCellStyles.borderLeft);\n  }\n  if (cell.borderTop) {\n    classes.push(dataGridCellStyles.borderTop);\n  }\n\n  return classNames(classes);\n};\n\nexport function DataGridCell<D>({ cell, height, width }: DataGridCellProps<D>) {\n  if (cell.cellType.includes('Skeleton')) {\n    return (\n      <div style={getCellStyle(cell, width, height)} class={getCellClasses(cell)}>\n        <Skeleton height=\"6x\" width=\"16x\" />\n      </div>\n    );\n  }\n  return (\n    <div style={getCellStyle(cell, width, height)} class={getCellClasses(cell)}>\n      {(cell as any).data}\n    </div>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { DataGridRange, Props } from '../../PRIVATE_GridView';\nimport { dataGridStyles } from '../themes/DataGrid.css';\nimport { classNames } from '../../utils/UNSAFE_classNames';\nimport {\n  DataGridColumnRange,\n  DataGridRowRange,\n  GridProps\n} from '#PRIVATE_GridView/DataGrid.types.js';\n\nconst _CELL_HEIGHT = 50;\nconst _CELL_WIDTH = 85;\n\nconst _ROW_CONST = 'row';\nconst _ROW_END_CONST = 'rowEnd';\nconst _COLUMN_CONST = 'column';\nconst _COLUMN_END_CONST = 'columnEnd';\n\ntype D = any;\ntype _ROW_TYPE = typeof _ROW_CONST;\ntype _ROW_END_TYPE = typeof _ROW_END_CONST;\ntype _COLUMN_TYPE = typeof _COLUMN_CONST;\ntype _COLUMN_END_TYPE = typeof _COLUMN_END_CONST;\ntype _ROW_TYPES = _ROW_TYPE | _ROW_END_TYPE;\ntype _COLUMN_TYPES = _COLUMN_TYPE | _COLUMN_END_TYPE;\ntype _HEADER_TYPES = _ROW_TYPES | _COLUMN_TYPES;\n\nexport const renderGrid = (\n  { ranges, totalColumnCount, totalRowCount, onLoadRange, height, width, cell, header }: Props<D>,\n  skeletonList: (\n    | { type: string; rowIndex: number }\n    | { type: string; columnIndex: number }\n    | { type: string; columnIndex: number; rowIndex: number }\n  )[]\n) => {\n  // TODO: handle custom heights widths\n  const getHeaderLevels = (header: GridProps<D>['header'], type: _HEADER_TYPES) => {\n    const headerLevels = header?.[type]?.levels;\n    let range;\n    if (type === 'row') {\n      range = ranges.rowHeaders;\n    } else if (type === 'rowEnd') {\n      range = ranges.rowEndHeaders;\n    } else if (type === 'column') {\n      range = ranges.columnHeaders;\n    } else if (type === 'columnEnd') {\n      range = ranges.columnEndHeaders;\n    }\n    return range && headerLevels && headerLevels > 0 ? headerLevels : 0;\n  };\n\n  const getHeaderLabels = (header: GridProps<D>['header'], type: _HEADER_TYPES) => {\n    const headerLabels = header?.[type]?.label;\n    return headerLabels && getHeaderLevels(header, type) > 0;\n  };\n\n  // Helper to check if both headers exist for a given pair\n  const getHasBothHeaders = (\n    header: GridProps<D>['header'],\n    _ROW_TYPES: _ROW_TYPES,\n    colType: _COLUMN_TYPES\n  ) => getHeaderLevels(header, _ROW_TYPES) > 0 && getHeaderLevels(header, colType) > 0;\n\n  // Helper to check if both labels exist for a given pair\n  const getHasBothLabels = (\n    header: GridProps<D>['header'],\n    _ROW_TYPES: _ROW_TYPES,\n    colType: _COLUMN_TYPES\n  ) => getHeaderLabels(header, _ROW_TYPES) && getHeaderLabels(header, colType);\n\n  // Determine if a top-left spacer is needed\n  const hasBothHeaders = getHasBothHeaders(header, _ROW_CONST, _COLUMN_CONST);\n  const hasBothLabels = getHasBothLabels(header, _ROW_CONST, _COLUMN_CONST);\n  const isEmptyRowLabels = !getHeaderLabels(header, _ROW_CONST);\n  const isEmptyColumnLabels = !getHeaderLabels(header, _COLUMN_CONST);\n  const rowLevels = getHeaderLevels(header, _ROW_CONST);\n  const columnLevels = getHeaderLevels(header, _COLUMN_CONST);\n\n  const hasTopLeftSpacer =\n    hasBothHeaders &&\n    ((!hasBothLabels && isEmptyRowLabels && isEmptyColumnLabels) ||\n      (hasBothLabels && rowLevels > columnLevels) ||\n      (hasBothLabels && rowLevels > 1 && columnLevels > 1));\n\n  // Determine if spacers are needed for other corners\n  const hasTopRightSpacer =\n    getHasBothHeaders(header, _ROW_END_CONST, _COLUMN_CONST) &&\n    !getHeaderLabels(header, _ROW_END_CONST);\n  const hasBottomLeftSpacer =\n    getHasBothHeaders(header, _ROW_CONST, _COLUMN_END_CONST) &&\n    !getHeaderLabels(header, _COLUMN_END_CONST);\n\n  const hasBottomRightSpacer = getHasBothHeaders(header, _ROW_END_CONST, _COLUMN_END_CONST);\n\n  // Check for header collision in the top-left corner\n  const collision =\n    getHasBothHeaders(header, _ROW_CONST, _COLUMN_CONST) &&\n    getHasBothLabels(header, _ROW_CONST, _COLUMN_CONST) &&\n    Math.min(getHeaderLevels(header, _ROW_CONST), getHeaderLevels(header, _COLUMN_CONST)) >= 1;\n\n  // Check if row or column header spacers are needed\n  const hasRowHeaderSpacer =\n    (getHeaderLabels(header, _COLUMN_CONST) || getHeaderLabels(header, _COLUMN_END_CONST)) &&\n    getHeaderLevels(header, _ROW_CONST) <= 0;\n\n  const hasColumnHeaderSpacer =\n    (getHeaderLabels(header, _ROW_CONST) || getHeaderLabels(header, _ROW_END_CONST)) &&\n    getHeaderLevels(header, _COLUMN_CONST) <= 0;\n\n  // TODO: handle unknown\n  // Helper function to add header levels if they exist\n  const addHeaderLevels = (header: GridProps<D>['header'], type: _HEADER_TYPES) =>\n    getHeaderLevels(header, type) > 0 ? getHeaderLevels(header, type) : 0;\n\n  // Calculate total columns in the grid\n  let gridTotalColumns = totalColumnCount === 'unknown' ? 0 : totalColumnCount;\n  const dataRegionColumnCount = gridTotalColumns;\n\n  // Adjust for row headers and row header spacer\n  gridTotalColumns += addHeaderLevels(header, _ROW_CONST) + addHeaderLevels(header, _ROW_END_CONST);\n  gridTotalColumns += hasRowHeaderSpacer ? 1 : 0;\n\n  // Calculate total rows in the grid\n  let gridTotalRows = totalRowCount === 'unknown' ? 0 : totalRowCount;\n  const dataRegionRowCount = gridTotalRows;\n\n  // Adjust for column headers, collisions, and column header spacer\n  gridTotalRows +=\n    addHeaderLevels(header, _COLUMN_CONST) + addHeaderLevels(header, _COLUMN_END_CONST);\n  gridTotalRows += collision ? 1 : 0;\n  gridTotalRows += hasColumnHeaderSpacer ? 1 : 0;\n\n  // Calculate row starts\n  const rowHeaderRowStart =\n    getHeaderLevels(header, _COLUMN_CONST) + (collision || hasColumnHeaderSpacer ? 1 : 0);\n  const rowEndHeaderRowStart = rowHeaderRowStart;\n\n  const columnHeaderRowStart = 0;\n  const columnEndHeaderRowStart = gridTotalRows - getHeaderLevels(header, _COLUMN_END_CONST);\n\n  // Calculate column starts\n  const columnHeaderColumnStart =\n    getHeaderLevels(header, _ROW_CONST) + (hasRowHeaderSpacer ? 1 : 0);\n  const columnEndHeaderColumnStart = columnHeaderColumnStart;\n\n  const rowHeaderColumnStart = 0;\n  const rowEndHeaderColumnStart = gridTotalColumns - getHeaderLevels(header, _ROW_END_CONST);\n\n  // Merges overlapping or adjacent cell ranges in a grid in 2 dimensions.\n  const mergeCellRanges = (ranges: DataGridRange[] | undefined): DataGridRange[] | false => {\n    if (!ranges || ranges.length === 0) return false;\n\n    const mergedRanges: DataGridRange[] = [];\n\n    // Sort ranges by rowStart and then by columnStart\n    ranges.sort((a, b) =>\n      a.rowStart === b.rowStart ? a.columnStart - b.columnStart : a.rowStart - b.rowStart\n    );\n\n    // Merge ranges\n    for (const range of ranges) {\n      const lastMerged = mergedRanges[mergedRanges.length - 1];\n      if (\n        !lastMerged ||\n        lastMerged.rowStart + lastMerged.rowCount < range.rowStart ||\n        lastMerged.columnStart + lastMerged.columnCount < range.columnStart\n      ) {\n        mergedRanges.push(range);\n      } else {\n        // Extend the current merged range\n        lastMerged.rowCount =\n          Math.max(lastMerged.rowStart + lastMerged.rowCount, range.rowStart + range.rowCount) -\n          lastMerged.rowStart;\n\n        lastMerged.columnCount =\n          Math.max(\n            lastMerged.columnStart + lastMerged.columnCount,\n            range.columnStart + range.columnCount\n          ) - lastMerged.columnStart;\n      }\n    }\n\n    return mergedRanges;\n  };\n\n  const mergedDataBody = mergeCellRanges(ranges.dataBody);\n  let actualDataRows = 0;\n  let actualDataCols = 0;\n  if (mergedDataBody) {\n    mergedDataBody.forEach((range) => {\n      actualDataCols += range.columnCount;\n      actualDataRows += range.rowCount;\n    });\n  }\n\n  // 1D array of actual cells we need to render\n  const grid = [];\n\n  // Map of indices that we getHas seen\n  const seenIndexMap = new Map();\n\n  // Handle skipping cells for row extent\n  const handleRowSkip = (rowIndex: number, columnIndex: number, rowExtent: number) => {\n    for (let r = rowIndex; r < rowIndex + rowExtent; r++) {\n      seenIndexMap.set(`${r},${columnIndex}`, { cellType: 'skip' });\n    }\n  };\n\n  // Handle skipping cells for column extent\n  const handleColumnSkip = (rowIndex: number, columnIndex: number, columnExtent: number) => {\n    for (let c = columnIndex; c < columnIndex + columnExtent; c++) {\n      seenIndexMap.set(`${rowIndex},${c}`, { cellType: 'skip' });\n    }\n  };\n\n  // Calculates label extents and offsets\n  const calculateLabelExtentsAndOffsets = (\n    type: string,\n    itemLevels: number,\n    currentLevel: number\n  ) => {\n    let rowExtent = 1,\n      columnExtent = 1,\n      rowOffset = 0,\n      columnOffset = 0;\n    const columnHeaderLevels = getHeaderLevels(header, _COLUMN_CONST);\n    const rowHeaderLevels = getHeaderLevels(header, _ROW_CONST);\n\n    switch (type) {\n      case 'rowEndHeaderLabel':\n        columnOffset = itemLevels - currentLevel - 1;\n        rowExtent = collision ? columnHeaderLevels + 1 : columnHeaderLevels;\n        break;\n      case 'columnEndHeaderLabel':\n        rowOffset = itemLevels - currentLevel - 1;\n        columnExtent = rowHeaderLevels > 0 ? rowHeaderLevels : 1;\n        break;\n      case 'rowHeaderLabel':\n        columnOffset = currentLevel;\n        rowExtent = collision ? 1 : columnHeaderLevels;\n        break;\n      case 'columnHeaderLabel':\n        rowOffset = currentLevel;\n        columnExtent = collision ? 1 : rowHeaderLevels;\n        break;\n    }\n\n    return { rowExtent, columnExtent, rowOffset, columnOffset };\n  };\n\n  // Walks ranges and adds appropriate cells to grid.\n  const processLabelData = (\n    item: {\n      data: (rowIndex: number, level: number) => { data: D; depth: number; extent: number };\n      levels: number;\n      label?: {\n        data: (level: number) => { data: D };\n      };\n    },\n    rowAxisStart: number,\n    columnAxisStart: number,\n    type: string,\n    isRow: boolean,\n    isEnd: boolean\n  ) => {\n    if (!item.label) {\n      return;\n    }\n    for (let i = 0; i < item.levels; i++) {\n      const labelData = item.label.data(i);\n      const { rowExtent, columnExtent, rowOffset, columnOffset } = calculateLabelExtentsAndOffsets(\n        type,\n        item.levels,\n        i\n      );\n      const rowIndex = rowAxisStart + rowOffset;\n      const columnIndex = columnAxisStart + columnOffset;\n      grid.push({\n        cellType: type,\n        rowStart: rowIndex,\n        rowExtent: rowExtent,\n        columnStart: columnIndex,\n        columnExtent: columnExtent,\n        data: labelData.data,\n        borderTop: !isRow && isEnd ? i === item.levels - 1 : false,\n        borderLeft: isRow && isEnd ? i === item.levels - 1 : false,\n        level: i\n      });\n    }\n  };\n\n  // Renders row header labels\n  if (ranges.rowHeaders && header?.row && header.row.label) {\n    processLabelData(\n      header.row,\n      collision ? rowHeaderRowStart - 1 : columnHeaderRowStart,\n      rowHeaderColumnStart,\n      'rowHeaderLabel',\n      true,\n      false\n    );\n  }\n\n  // Renders column header labels\n  if (ranges.columnHeaders && header?.column && header.column.label) {\n    processLabelData(\n      header.column,\n      columnHeaderRowStart,\n      collision ? columnHeaderColumnStart - 1 : rowHeaderColumnStart,\n      'columnHeaderLabel',\n      false,\n      false\n    );\n  }\n\n  // Renders row end header labels\n  if (ranges.rowEndHeaders && header?.rowEnd && header.rowEnd.label) {\n    processLabelData(\n      header.rowEnd,\n      columnHeaderRowStart,\n      rowEndHeaderColumnStart,\n      'rowEndHeaderLabel',\n      true,\n      true\n    );\n  }\n\n  // Renders column end header labels\n  if (ranges.columnEndHeaders && header?.columnEnd && header.columnEnd.label) {\n    processLabelData(\n      header.columnEnd,\n      columnEndHeaderRowStart,\n      rowHeaderColumnStart,\n      'columnEndHeaderLabel',\n      false,\n      true\n    );\n  }\n\n  // Renders bottom left spacer\n  if (hasBottomLeftSpacer) {\n    const columnExtent =\n      getHeaderLevels(header, _ROW_CONST) > 0 ? getHeaderLevels(header, _ROW_CONST) : 0;\n    const rowExtent = getHeaderLevels(header, _COLUMN_END_CONST);\n    const rowStart = columnEndHeaderRowStart;\n    grid.push({\n      cellType: 'bottomLeftSpacer',\n      rowStart: rowStart,\n      rowExtent: rowExtent,\n      columnStart: rowHeaderColumnStart,\n      columnExtent: columnExtent,\n      borderRight: true,\n      borderTop: true\n    });\n  }\n\n  // Renders bottom right spacer\n  if (hasBottomRightSpacer) {\n    const columnExtent = getHeaderLevels(header, _ROW_END_CONST);\n    const rowExtent = getHeaderLevels(header, _COLUMN_END_CONST);\n    const rowStart = columnEndHeaderRowStart;\n    const columnStart = gridTotalColumns - getHeaderLevels(header, _ROW_END_CONST);\n    grid.push({\n      cellType: 'bottomRightSpacer',\n      rowStart: rowStart,\n      rowExtent: rowExtent,\n      columnStart: columnStart,\n      columnExtent: columnExtent,\n      borderTop: true,\n      borderLeft: true\n    });\n  }\n\n  // Renders top right spacer\n  if (hasTopRightSpacer) {\n    const columnExtent = getHeaderLevels(header, _ROW_END_CONST);\n    let rowExtent =\n      getHeaderLevels(header, _COLUMN_CONST) > 0 ? getHeaderLevels(header, _COLUMN_CONST) : 1;\n    if (collision) {\n      rowExtent += 1;\n    }\n    const rowStart = columnHeaderRowStart;\n    const columnStart = rowEndHeaderColumnStart;\n    grid.push({\n      cellType: 'topRightSpacer',\n      rowStart: rowStart,\n      rowExtent: rowExtent,\n      columnStart: columnStart,\n      columnExtent: columnExtent,\n      borderLeft: true\n    });\n  }\n\n  // Renders top left spacer\n  if (hasTopLeftSpacer) {\n    const columnExtent = collision\n      ? getHeaderLevels(header, _ROW_CONST) - 1\n      : getHeaderLevels(header, _ROW_CONST);\n    const rowExtent = getHeaderLevels(header, _COLUMN_CONST);\n    const rowStart = 0;\n    const columnStart = 0;\n    grid.push({\n      cellType: 'topLeftSpacer',\n      rowStart: rowStart,\n      rowExtent: rowExtent,\n      columnStart: columnStart,\n      columnExtent: columnExtent\n    });\n  }\n\n  // Renders row heder spacer\n  if (hasRowHeaderSpacer) {\n    let rowStart = getHeaderLabels(header, _COLUMN_CONST)\n      ? getHeaderLevels(header, _COLUMN_CONST)\n      : 0;\n    let rowExtent = gridTotalRows;\n    if (getHeaderLabels(header, _COLUMN_CONST)) {\n      rowExtent -= getHeaderLevels(header, _COLUMN_CONST);\n    }\n    if (getHeaderLabels(header, _COLUMN_END_CONST)) {\n      rowExtent -= getHeaderLevels(header, _COLUMN_END_CONST);\n    }\n    if (hasColumnHeaderSpacer) {\n      rowExtent -= 1;\n      rowStart += 1;\n    }\n    grid.push({\n      cellType: 'rowHeaderSpacer',\n      rowStart: rowStart,\n      rowExtent: rowExtent,\n      columnStart: 0,\n      columnExtent: 1,\n      lastRow: getHeaderLabels(header, _COLUMN_END_CONST) ? true : false\n    });\n  }\n\n  // Renders column heder spacer\n  if (hasColumnHeaderSpacer) {\n    const columnStart = getHeaderLabels(header, _ROW_CONST)\n      ? getHeaderLevels(header, _ROW_CONST)\n      : 0;\n    let columnExtent = gridTotalColumns;\n    if (getHeaderLabels(header, _ROW_CONST)) {\n      columnExtent -= getHeaderLevels(header, _ROW_CONST);\n    }\n    if (getHeaderLabels(header, _ROW_END_CONST)) {\n      columnExtent -= getHeaderLevels(header, _ROW_END_CONST);\n    }\n    grid.push({\n      cellType: 'columnHeaderSpacer',\n      rowStart: 0,\n      rowExtent: 1,\n      columnStart: columnStart,\n      columnExtent: columnExtent,\n      lastColumn: getHeaderLabels(header, _ROW_END_CONST) ? true : false\n    });\n  }\n\n  // Calculates Header range bounds\n  const getHeaderRangeBounds = (\n    range: DataGridRowRange | DataGridColumnRange,\n    isRow: boolean,\n    levels: number\n  ) => {\n    if (isRow) {\n      return {\n        rowStart: (range as DataGridRowRange).rowStart,\n        rowEnd: (range as DataGridRowRange).rowCount + (range as DataGridRowRange).rowStart,\n        columnStart: 0,\n        columnEnd: levels\n      };\n    } else {\n      return {\n        rowStart: 0,\n        rowEnd: levels,\n        columnStart: (range as DataGridColumnRange).columnStart,\n        columnEnd:\n          (range as DataGridColumnRange).columnCount + (range as DataGridColumnRange).columnStart\n      };\n    }\n  };\n\n  // Calculates header offsets\n  const getHeaderOffsets = (i: number, j: number, type: string, levels: number) => {\n    let rowOffset = i;\n    let columnOffset = j;\n    if (type === 'rowEndHeader') {\n      columnOffset = levels - j - 1;\n    } else if (type === 'columnEndHeader') {\n      rowOffset = levels - i - 1;\n    }\n    return { rowOffset, columnOffset };\n  };\n\n  // Walks ranges and adds appropriate header cells to grid\n  const processHeaderData = (\n    item: {\n      data: (rowIndex: number, level: number) => { data: D; depth: number; extent: number };\n      levels: number;\n      label?: {\n        data: (level: number) => { data: D };\n      };\n    },\n    rangeArray: (DataGridRowRange | DataGridColumnRange)[],\n    rowAxisStart: number,\n    columnAxisStart: number,\n    type: string,\n    isRow: boolean,\n    isEnd: boolean\n  ) => {\n    rangeArray.forEach((range: DataGridRowRange | DataGridColumnRange) => {\n      const { rowStart, rowEnd, columnStart, columnEnd } = getHeaderRangeBounds(\n        range,\n        isRow,\n        item.levels\n      );\n      for (let i = rowStart; i < rowEnd; i++) {\n        for (let j = columnStart; j < columnEnd; j++) {\n          const { rowOffset, columnOffset } = getHeaderOffsets(i, j, type, item.levels);\n          const rowIndex = rowAxisStart + rowOffset;\n          const columnIndex = columnAxisStart + columnOffset;\n          const cellObject = seenIndexMap.get(`${rowIndex},${columnIndex}`);\n          if (cellObject?.cellType === 'skip') {\n            continue;\n          }\n          const headerData = item.data(isRow ? i : j, isRow ? j : i);\n          let extent = headerData.extent;\n          let depth = headerData.depth;\n          if (type === 'columnHeader' && i === item.levels - 1 && collision) {\n            depth += 1;\n          }\n          const maxExtent = isRow\n            ? (range as DataGridRowRange).rowStart + (range as DataGridRowRange).rowCount\n            : (range as DataGridColumnRange).columnStart +\n              (range as DataGridColumnRange).columnCount;\n\n          if ((isRow && i + extent > maxExtent) || (!isRow && j + extent > maxExtent)) {\n            extent = isRow ? maxExtent - i : maxExtent - j;\n          }\n\n          grid.push({\n            cellType: type,\n            rowStart: rowIndex,\n            rowExtent: isRow ? extent : depth,\n            columnStart: columnIndex,\n            columnExtent: isRow ? depth : extent,\n            data: headerData.data,\n            level: isRow ? j : i,\n            borderTop: !isRow && isEnd ? i === item.levels - 1 : false,\n            borderLeft: isRow && isEnd ? j === item.levels - 1 : false,\n            lastColumn: !isRow && j + extent === dataRegionColumnCount,\n            lastRow: isRow && i + extent === dataRegionRowCount\n          });\n          if (extent > 1) {\n            if (isRow) {\n              handleRowSkip(rowIndex, columnIndex, extent);\n            } else {\n              handleColumnSkip(rowIndex, columnIndex, extent);\n            }\n          }\n          if (depth > 1) {\n            if (isRow) {\n              handleColumnSkip(rowIndex, columnIndex, depth);\n            } else {\n              handleRowSkip(rowIndex, columnIndex, depth);\n            }\n          }\n        }\n      }\n    });\n  };\n\n  // Merges overlapping ranges if it exists\n  const mergeHeaderRanges = <T extends DataGridColumnRange | DataGridRowRange>(\n    ranges: T[],\n    getStart: (range: T) => number,\n    getEnd: (range: T) => number\n  ): T[] => {\n    const mergedRanges: T[] = [];\n\n    ranges.sort((a, b) => getStart(a) - getStart(b));\n\n    for (let i = 0; i < ranges.length; i++) {\n      if (\n        !mergedRanges.length ||\n        getEnd(mergedRanges[mergedRanges.length - 1]) < getStart(ranges[i])\n      ) {\n        mergedRanges.push(ranges[i]);\n      } else {\n        // Merge ranges by extending the last range in mergedRanges\n        const lastRange = mergedRanges[mergedRanges.length - 1];\n        mergedRanges[mergedRanges.length - 1] = {\n          ...lastRange,\n          // Update the end of the merged range with the maximum value of the end\n          end: Math.max(getEnd(lastRange), getEnd(ranges[i]))\n        };\n      }\n    }\n\n    return mergedRanges;\n  };\n\n  // Renders row headers\n  if (ranges.rowHeaders && header?.row) {\n    const mergedRowRanges = mergeHeaderRanges(\n      ranges.rowHeaders,\n      (range) => range.rowStart,\n      (range) => range.rowCount\n    );\n    processHeaderData(\n      header.row,\n      mergedRowRanges,\n      rowHeaderRowStart,\n      rowHeaderColumnStart,\n      'rowHeader',\n      true,\n      false\n    );\n  }\n\n  // Renders rowEnd headers\n  if (ranges.rowEndHeaders && header?.rowEnd) {\n    const mergedRowEndRanges = mergeHeaderRanges(\n      ranges.rowEndHeaders,\n      (range) => range.rowStart,\n      (range) => range.rowCount\n    );\n    processHeaderData(\n      header.rowEnd,\n      mergedRowEndRanges,\n      rowEndHeaderRowStart,\n      rowEndHeaderColumnStart,\n      'rowEndHeader',\n      true,\n      true\n    );\n  }\n\n  // Renders column headers\n  if (ranges.columnHeaders && header?.column) {\n    const mergedColumnRanges = mergeHeaderRanges(\n      ranges.columnHeaders,\n      (range) => range.columnStart,\n      (range) => range.columnCount\n    );\n    processHeaderData(\n      header.column,\n      mergedColumnRanges,\n      columnHeaderRowStart,\n      columnHeaderColumnStart,\n      'columnHeader',\n      false,\n      false\n    );\n  }\n\n  // Renders column end headers\n  if (ranges.columnEndHeaders && header?.columnEnd) {\n    const mergedColumnEndRanges = mergeHeaderRanges(\n      ranges.columnEndHeaders,\n      (range) => range.columnStart,\n      (range) => range.columnCount\n    );\n    processHeaderData(\n      header.columnEnd,\n      mergedColumnEndRanges,\n      columnEndHeaderRowStart,\n      columnEndHeaderColumnStart,\n      'columnEndHeader',\n      false,\n      true\n    );\n  }\n\n  // makes sure we are in bounds of given range\n  const getCellRangeBounds = (range: DataGridRange) => ({\n    rowStart: range.rowStart,\n    rowEnd: range.rowCount + range.rowStart,\n    columnStart: range.columnStart,\n    columnEnd: range.columnCount + range.columnStart\n  });\n\n  // Makes sure cell range is valid\n  const isValidCellRange = (range: DataGridRange): boolean =>\n    range?.rowCount != null &&\n    range?.rowStart != null &&\n    range?.columnCount != null &&\n    range?.columnStart != null;\n\n  // Makes sure we account for merged cells by adding to seenIndex\n  const handleCellSkips = (\n    rowStart: number,\n    rowExtent: number,\n    columnStart: number,\n    columnExtent: number\n  ) => {\n    for (let i = rowStart; i < rowStart + rowExtent; i++) {\n      for (let j = columnStart; j < columnStart + columnExtent; j++) {\n        seenIndexMap.set(`${i},${j}`, { cellType: 'skip' });\n      }\n    }\n  };\n\n  // Walks ranges and adds appropriate cells to grid\n  const processCellData = (\n    item: {\n      data: (\n        rowIndex: number,\n        columnIndex: number\n      ) => { data: D; rowExtent: number; columnExtent: number };\n    },\n    rangeArray: DataGridRange[]\n  ) => {\n    rangeArray.forEach((range: DataGridRange) => {\n      if (isValidCellRange(range)) {\n        const { rowStart, rowEnd, columnStart, columnEnd } = getCellRangeBounds(range);\n        for (let i = rowStart; i < rowEnd; i++) {\n          for (let j = columnStart; j < columnEnd; j++) {\n            const rowIndex = rowHeaderRowStart + i;\n            const columnIndex = columnHeaderColumnStart + j;\n            const cellObject = seenIndexMap.get(`${rowIndex},${columnIndex}`);\n            if (cellObject?.cellType === 'skip') {\n              continue;\n            }\n            const cellData = item.data(i, j);\n            const rowExtent = cellData.rowExtent;\n            const columnExtent = cellData.columnExtent;\n            grid.push({\n              cellType: 'cell',\n              rowStart: rowIndex,\n              rowExtent: rowExtent,\n              columnStart: columnIndex,\n              columnExtent: columnExtent,\n              data: cellData.data,\n              lastColumn: j + columnExtent === dataRegionColumnCount,\n              lastRow: i + rowExtent === dataRegionRowCount\n            });\n            if (rowExtent > 1 || columnExtent > 1) {\n              handleCellSkips(rowIndex, rowExtent, columnIndex, columnExtent);\n            }\n          }\n        }\n      }\n    });\n  };\n\n  // Renders cells\n  if (cell && mergedDataBody) {\n    processCellData(cell, mergedDataBody);\n  }\n\n  skeletonList.forEach((skeletonCell: any) => {\n    let rowIndex = skeletonCell.rowIndex ? skeletonCell.rowIndex : 0;\n    let rowExtent = 1;\n    const columnExtent = 1;\n    let columnIndex = skeletonCell.columnIndex ? skeletonCell.columnIndex : 0;\n    if (skeletonCell.type === 'columnHeaderSkeleton') {\n      rowIndex = columnHeaderRowStart + skeletonCell.level;\n      if (collision && skeletonCell.level + 1 === header?.column?.levels) {\n        rowExtent = 2;\n      }\n      columnIndex = columnHeaderColumnStart + columnIndex;\n    } else if (skeletonCell.type === 'columnEndHeaderSkeleton') {\n      rowIndex =\n        columnEndHeaderRowStart + getHeaderLevels(header, _COLUMN_END_CONST) - rowIndex - 1;\n      columnIndex = columnEndHeaderColumnStart + columnIndex;\n    } else if (skeletonCell.type === 'rowHeaderSkeleton') {\n      columnIndex = rowHeaderColumnStart + skeletonCell.level;\n      rowIndex = rowHeaderRowStart + rowIndex;\n    } else if (skeletonCell.type === 'rowEndHeaderSkeleton') {\n      columnIndex =\n        rowEndHeaderColumnStart + getHeaderLevels(header, _ROW_END_CONST) - columnIndex - 1;\n      rowIndex = rowEndHeaderRowStart + rowIndex;\n    } else {\n      rowIndex = rowHeaderRowStart + rowIndex;\n      columnIndex = columnHeaderColumnStart + columnIndex;\n    }\n\n    grid.push({\n      cellType: skeletonCell.type,\n      rowStart: rowIndex,\n      rowExtent: rowExtent,\n      columnStart: columnIndex,\n      columnExtent: columnExtent,\n      level: skeletonCell.level,\n      borderTop:\n        skeletonCell.type === 'columnEndHeaderSkeleton' &&\n        skeletonCell.level + 1 === header?.columnEnd?.levels\n          ? true\n          : false,\n      borderLeft:\n        skeletonCell.type === 'rowEndHeaderSkeleton' &&\n        skeletonCell.level + 1 === header?.rowEnd?.levels\n          ? true\n          : false\n    });\n  });\n\n  // need this in order to build\n  onLoadRange({} as any);\n\n  // renders the style template strings for grid.\n  const getGridStyle = () => {\n    const rows = `grid-template-rows: ${Array(gridTotalRows).fill(`${_CELL_HEIGHT}px`).join(' ')};`;\n    const columns = `grid-template-columns: ${Array(gridTotalColumns)\n      .fill(`${_CELL_WIDTH}px`)\n      .join(' ')};`;\n    const dimensions = `width: ${width}px; height: ${height}px;`;\n\n    return `${rows} ${columns} ${dimensions}`;\n  };\n\n  const classes = classNames([dataGridStyles.base]);\n  return { grid, classes, style: getGridStyle(), cellHeight: _CELL_HEIGHT, cellWidth: _CELL_WIDTH };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { StateUpdater, useEffect, useState } from 'preact/hooks';\nimport { Props } from '../PRIVATE_GridView';\nimport { DataGridCell } from './DataGridCell';\nimport { renderGrid } from './utils/DataGridRenderUtils';\n/**\n * Component that renders a basic grid.\n */\nexport const DataGrid = function DataGrid<D>(props: Props<D>) {\n  const [skeletonList, setSkeletonList] = useState<\n    (\n      | {\n          type: string;\n          rowIndex: number;\n        }\n      | {\n          type: string;\n          columnIndex: number;\n        }\n      | {\n          type: string;\n          columnIndex: number;\n          rowIndex: number;\n        }\n    )[]\n  >([]);\n  const { grid, classes, style, cellHeight, cellWidth } = renderGrid(props, skeletonList);\n\n  const calculateViewportRange = (\n    element: HTMLElement,\n    cellSize: number,\n    totalCount: number,\n    isVertical: boolean\n  ) => {\n    const totalInViewPort = Math.round(\n      (isVertical ? element.offsetHeight : element.offsetWidth) / cellSize\n    );\n    const firstPosition = Math.round(\n      (isVertical ? element.scrollTop : element.scrollLeft) / cellSize\n    );\n    const buffer = Math.round(totalInViewPort / 2);\n\n    const tempTopPosition = firstPosition - buffer;\n    const topPosition = tempTopPosition > 0 ? tempTopPosition : 0;\n\n    const tempBottomPosition = topPosition + totalInViewPort + buffer * 2;\n    const bottomPosition = tempBottomPosition < totalCount ? tempBottomPosition : totalCount;\n\n    return { topPosition, bottomPosition };\n  };\n\n  const generateSkeletonsForHeaders = (\n    levels: number | undefined,\n    ranges: any[] | undefined,\n    topViewport: number,\n    bottomViewport: number,\n    type: string,\n    tempSkeletonList: any[],\n    isRow = true\n  ) => {\n    if (ranges && levels) {\n      for (let level = 0; level < levels; level++) {\n        const skeletonArray = new Array(bottomViewport).fill(null);\n        ranges.forEach((range) => {\n          const start = isRow ? range.rowStart : range.columnStart;\n          const count = isRow ? range.rowCount : range.columnCount;\n\n          for (let i = start; i < start + count; i++) {\n            if (i < skeletonArray.length) {\n              skeletonArray[i] = true;\n            }\n          }\n        });\n\n        for (let i = topViewport; i < skeletonArray.length; i++) {\n          if (!skeletonArray[i]) {\n            tempSkeletonList.push({\n              type: `${type}Skeleton`,\n              [isRow ? 'rowIndex' : 'columnIndex']: i,\n              level: level\n            });\n          }\n        }\n      }\n    }\n  };\n\n  useEffect(() => {\n    const element = document.getElementById('dataGrid') as HTMLDivElement;\n\n    const { topPosition: topRowOfViewPort, bottomPosition: bottomRowOfViewPort } =\n      calculateViewportRange(element, cellHeight, props.totalRowCount as number, true);\n\n    const { topPosition: topColumnOfViewPort, bottomPosition: bottomColumnOfViewPort } =\n      calculateViewportRange(element, cellWidth, props.totalColumnCount as number, false);\n    const tempSkeletonList: StateUpdater<\n      (\n        | { type: string; rowIndex: number; level: number }\n        | { type: string; columnIndex: number; level: number }\n        | { type: string; columnIndex: number; rowIndex: number }\n      )[]\n    > = [];\n\n    generateSkeletonsForHeaders(\n      props.header?.row?.levels,\n      props.ranges.rowHeaders,\n      topRowOfViewPort,\n      bottomRowOfViewPort,\n      'rowHeader',\n      tempSkeletonList,\n      true\n    );\n\n    generateSkeletonsForHeaders(\n      props.header?.rowEnd?.levels,\n      props.ranges.rowEndHeaders,\n      topRowOfViewPort,\n      bottomRowOfViewPort,\n      'rowEndHeader',\n      tempSkeletonList,\n      true\n    );\n\n    generateSkeletonsForHeaders(\n      props.header?.column?.levels,\n      props.ranges.columnHeaders,\n      topColumnOfViewPort,\n      bottomColumnOfViewPort,\n      'columnHeader',\n      tempSkeletonList,\n      false\n    );\n\n    generateSkeletonsForHeaders(\n      props.header?.columnEnd?.levels,\n      props.ranges.columnEndHeaders,\n      topColumnOfViewPort,\n      bottomColumnOfViewPort,\n      'columnEndHeader',\n      tempSkeletonList,\n      false\n    );\n\n    if (props.ranges.dataBody) {\n      const skeletonArray = new Array(bottomColumnOfViewPort)\n        .fill(null)\n        .map(() => new Array(bottomRowOfViewPort).fill(null));\n\n      props.ranges.dataBody.forEach((range) => {\n        for (let i = range.columnStart; i < range.columnStart + range.columnCount; i++) {\n          if (i < skeletonArray.length) {\n            for (let j = range.rowStart; j < range.rowStart + range.rowCount; j++) {\n              if (j < skeletonArray[i].length) {\n                skeletonArray[i][j] = true;\n              }\n            }\n          }\n        }\n      });\n\n      for (let i = topColumnOfViewPort; i < skeletonArray.length; i++) {\n        for (let j = topRowOfViewPort; j < skeletonArray[i].length; j++) {\n          if (!skeletonArray[i][j]) {\n            tempSkeletonList.push({ type: 'cellSkeleton', columnIndex: i, rowIndex: j });\n          }\n        }\n      }\n    }\n    setSkeletonList(tempSkeletonList);\n  }, [cellHeight, cellWidth, props]);\n\n  return (\n    <div id=\"dataGrid\" role={'application'} class={classes} style={style}>\n      {grid.map((gridCell: any) => (\n        <DataGridCell<D> cell={gridCell} height={cellHeight} width={cellWidth} />\n      ))}\n    </div>\n  );\n};\n"],"names":["_jsx"],"mappings":"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"}