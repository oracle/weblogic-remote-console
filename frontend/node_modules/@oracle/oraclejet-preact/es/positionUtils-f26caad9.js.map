{"version":3,"file":"positionUtils-f26caad9.js","sources":["../../src/utils/PRIVATE_floatingUtils/positionUtils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { RtlSide } from '../../UNSAFE_Floating';\n\n/**\n * Returns the normalized Position depending on the reading direction\n * @param side The side that should be normalized\n * @param direction The reading direction\n * @returns The normalized 'right' or 'left' position if the side was 'start' or 'end', otherwise returns unchanged position\n */\nexport const normalizePosition = (side: RtlSide, direction: 'rtl' | 'ltr'): RtlSide => {\n  const sideHashLtr = {\n    start: 'left',\n    end: 'right'\n  };\n  const sideHashRtl = {\n    start: 'right',\n    end: 'left'\n  };\n  if (direction === 'rtl') {\n    return side.replace(/start|end/g, (matched) => (sideHashRtl as any)[matched]) as RtlSide;\n  } else {\n    return side.replace(/start|end/g, (matched) => (sideHashLtr as any)[matched]) as RtlSide;\n  }\n};\n/**\n * Returns the reversed normalized Position depending on the reading direction\n * @param side The side that should be reversed\n * @param direction The reading direction\n * @returns The 'start' or 'end' position if the side was 'right' or 'left', otherwise returns unchanged position\n */\nexport const reverseNormalizePosition = (side: RtlSide, direction: 'rtl' | 'ltr'): RtlSide => {\n  const sideHashLtr = {\n    left: 'start',\n    right: 'end'\n  };\n  const sideHashRtl = {\n    right: 'start',\n    left: 'end'\n  };\n  if (direction === 'rtl') {\n    return side.replace(/left|right/g, (matched) => (sideHashRtl as any)[matched]) as RtlSide;\n  } else {\n    return side.replace(/left|right/g, (matched) => (sideHashLtr as any)[matched]) as RtlSide;\n  }\n};\n\n/**\n * Check is 'window' is available\n */\nconst hasWindow = () => {\n  return typeof window !== 'undefined';\n};\n\n/**\n * Returns the window object for the node\n */\nconst getWindow = (node: any): typeof window => {\n  return node?.ownerDocument?.defaultView || window;\n};\n\n/**\n * Checks if the value is a valid node\n */\nconst isNode = (value: unknown): value is Node => {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n};\n\n/**\n * Checks if the node is the last traversable ancestor\n */\nconst isLastTraversableNode = (node: Node): boolean => {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n};\n\n/**\n * Returns document element for the node\n */\nconst getDocumentElement = (node: Node | Window): HTMLElement => {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document)?.documentElement;\n};\n\n/**\n * Returns normalized node name\n */\nconst getNodeName = (node: Node | Window): string => {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  return '#document';\n};\n\n/**\n * Returns node's parent\n */\nconst getParentNode = (node: Node): Node => {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  return node.parentNode || getDocumentElement(node);\n};\n\n/**\n * Checks if the value is an HTMLElement\n */\nconst isHTMLElement = (value: unknown): value is HTMLElement => {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n};\n\n/**\n * Checks if the element is a containing block\n */\nconst isContainingBlock = (element: HTMLElement) => {\n  const css = getComputedStyle(element);\n\n  return (\n    css.transform !== 'none' ||\n    css.perspective !== 'none' ||\n    (css.containerType ? css.containerType !== 'normal' : false) ||\n    ['transform', 'perspective', 'filter'].some((value) =>\n      (css.willChange || '').includes(value)\n    ) ||\n    ['paint', 'layout', 'strict', 'content'].some((value) => (css.contain || '').includes(value))\n  );\n};\n\n/**\n * Returns element's containg block or null (if no containing block exists)\n */\nexport const getContainingBlockElem = (element: HTMLElement) => {\n  let currentNode: Node | null = getParentNode(element);\n\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n};\n"],"names":[],"mappings":"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"}