/* @oracle/oraclejet-preact: undefined */
import { jsx, jsxs } from 'preact/jsx-runtime';
import { forwardRef } from 'preact/compat';
import { useRef, useCallback, useEffect, useReducer, useMemo, useImperativeHandle } from 'preact/hooks';
import { L as Label } from './Label-5c64c52d.js';
import { a as isSelectAll, b as isBackspaceOrDelete } from './keyboardUtils-986fe923.js';
import { R as ReadonlyTextField } from './StyledTextField-9c60efac.js';
import './ObfuscatedTextFieldInputStyles.styles.css';
import { R as ReadonlyTextFieldInput } from './ReadonlyTextFieldInput-7bfb1cad.js';
import { T as TextField } from './TextField-2643ae3c.js';
import './LayerHost-12489cef.js';
import './LiveRegionStyles.styles.css';
import './UNSAFE_TextField/themes/TextFieldStyles.css.js';
import './SkeletonStyles.styles.css';
import './TextFieldLoadingStyles.styles.css';
import './TextFieldStyles.styles.css';
import './UNSAFE_TextField/themes/redwood/TextFieldBaseTheme.styles.css';
import './UNSAFE_TextField/themes/redwood/TextFieldVariants.css.js';
import './logger-c92f309c.js';
import './TabbableModeContext-7d8ad946.js';
import './UserAssistanceStyles.styles.css';
import './UNSAFE_UserAssistance/themes/redwood/UserAssistanceBaseTheme.styles.css';
import './UNSAFE_UserAssistance/themes/redwood/UserAssistanceVariants.css.js';
import { a as InlineUserAssistance } from './InlineUserAssistance-f57a9043.js';
import { C as CompactUserAssistance } from './CompactUserAssistance-935892f2.js';
import './TooltipContentStyles.styles.css';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentBaseTheme.styles.css';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js';
import './tooltipUtils-466c63c4.js';
import 'preact';
import './IconStyle.styles.css';
import './Popup-0f026f03.js';
import './LabelStyles.styles.css';
import './UNSAFE_Label/themes/redwood/LabelBaseTheme.styles.css';
import './UNSAFE_Label/themes/redwood/LabelVariants.css.js';
import './InputGroupContext-20bdbd6e.js';
import './HiddenAccessibleStyles.styles.css';
import './UNSAFE_Popup/themes/redwood/PopupBaseTheme.styles.css';
import './UNSAFE_Popup/themes/redwood/PopupVariants.css.js';
import { u as useFocusableTextField } from './useFocusableTextField-8fe41cd4.js';
import './FormContext-55fb8000.js';
import { u as useFormContext } from './useFormContext-bb9dc478.js';
import { F as FormFieldContext } from './FormFieldContext-47ca0c20.js';
import { u as useTextField } from './useTextField-eb9db737.js';
import { u as useUser } from './useUser-df8ae011.js';
import { g as getAmPmMatchType, A as AM_VALUE$1, P as PM_VALUE$1, h as hasSegmentsNotDisplayed, d as displayedTimeSegmentsAreDifferent, t as timesAreDifferent, a as getHourValueStr, b as getDayPeriodValueStr, c as getDayPeriodValueFromHour, p as padWithZero, e as getAmPmStringsForLocale, f as formatTimeFromMasks, r as replaceCustomMasksValuesWithPlaceholders, i as getTimeMasksFromLocaleAndOptions, j as getLeadingZeroForHour } from './timeUtils-81fd753c.js';
import { l } from './stringUtils-0fe25200.js';
import { F as Flex } from './Flex-5befe411.js';
import { H as HiddenAccessible } from './HiddenAccessible-61197e7c.js';
import { L as LiveRegion } from './LiveRegion-79ffc814.js';
import { TextFieldInputRedwoodTheme } from './UNSAFE_TextField/themes/redwood/TextFieldInputTheme.js';
import { u as useComponentTheme } from './useComponentTheme-d2f9e47f.js';
import { u as useFormFieldContext } from './useFormFieldContext-daf7a676.js';
import { u as useTranslationBundle } from './useTranslationBundle-25469f1c.js';
import { i as isEmbeddedVariant } from './formControlUtils-84e2af0e.js';
import { c as classNames } from './classNames-4e12b00d.js';
import { segmentStyles } from './UNSAFE_InputTimeMask/themes/SegmentStyles.css.js';
import './getFormatParse-6e71bd79.js';
import { i as isNumberOnlyString } from './maskUtils-ad8f1f9b.js';
import { g as getClientHints } from './clientHints-a42b510c.js';
import { u as useDoubleTap } from './useDoubleTap-4e290707.js';
import { u as useTabbableMode } from './useTabbableMode-a2fdbb06.js';
import './MessageBannerStyles.styles.css';
import './UNSAFE_MessageBanner/themes/redwood/MessageBannerBaseTheme.styles.css';
import './UNSAFE_MessageBanner/themes/redwood/MessageBannerVariants.css.js';
import './MessageBannerVariants.styles.css';
import './vanilla-extract-recipes-createRuntimeFn.esm-2aaf8c98.js';
import './useTooltip-f442fedb.js';
import './useTooltipControlled-d7724623.js';
import './useId-03dbfdf0.js';
import './useHover-85077adb.js';
import './useToggle-8b7fcefe.js';
import './useFocus-38c95977.js';
import './useTouch-4828df25.js';
import './mergeProps-88ea8306.js';
import './useAnimation-a5eb7604.js';
import './useTestId-e5d44ab1.js';
import './useThemeInterpolations-4b48d878.js';
import './useColorScheme-96cce6a1.js';
import './useScale-0ebe15ed.js';
import './theme-63551f30.js';
import './Theme-e6dec6db.js';
import './mergeInterpolations-30cd9a69.js';
import './mergeDeepWithKey-33e3d1be.js';
import './_curry3-577eb45e.js';
import './_curry1-63949a9b.js';
import './_curry2-01c87f61.js';
import './_isObject-1fab0f5b.js';
import './useDensity-d06ae84a.js';
import './unsafeDomAccess-453eb74e.js';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentTheme.js';
import './hooks/UNSAFE_useTooltip/themes/TooltipContentStyles.css.js';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentBaseTheme.css.js';
import './TooltipContentVariants.styles.css';
import './IconButton-c91faa06.js';
import './BaseButton-c2fbaa6d.js';
import './useActive-fb6d4d52.js';
import './dimensions-ddde0eee.js';
import './size-a3d3aeaf.js';
import './utils-cfef1929.js';
import './themeContract.css-2b5a42e2.js';
import './colorUtils-b3804ee8.js';
import './UNSAFE_BaseButton/themes/redwood/BaseButtonTheme.js';
import './UNSAFE_BaseButton/themes/BaseButtonStyles.css.js';
import './BaseButtonStyles.styles.css';
import './UNSAFE_BaseButton/themes/redwood/BaseButtonVariants.css.js';
import './UNSAFE_BaseButton/themes/redwood/BaseButtonBaseTheme.styles.css';
import './BareButton-0954f33d.js';
import './useBareButton-07a3eef9.js';
import './usePress-051f5adb.js';
import './usePressClick-2ec8e098.js';
import './buttonUtils-55fb1df7.js';
import './id-83adac50.js';
import './ButtonLabelLayout-d449261a.js';
import './Text-983c749e.js';
import './UNSAFE_Text/themes/TextStyles.css.js';
import './TextStyles.styles.css';
import './useButtonLabelLayoutTheme-a1b95a52.js';
import './UNSAFE_ButtonLabelLayout/themes/redwood/ButtonLabelLayoutTheme.js';
import './UNSAFE_ButtonLabelLayout/themes/ButtonLabelLayoutStyles.css.js';
import './ButtonLabelLayoutStyles.styles.css';
import './UNSAFE_ButtonLabelLayout/themes/redwood/ButtonLabelLayoutBaseTheme.css.js';
import './UNSAFE_ButtonLabelLayout/themes/redwood/ButtonLabelLayoutBaseTheme.styles.css';
import './UNSAFE_ButtonLabelLayout/themes/redwood/ButtonLabelLayoutVariants.css.js';
import './ButtonLabelLayoutVariants.styles.css';
import './MessageStyles.styles.css';
import './MessageFormattingUtils-cdb25115.js';
import './getLocale-1c41e86a.js';
import './TransitionGroup-5fd80dc9.js';
import './MessagesContext-76544845.js';
import './ComponentMessageStyles.styles.css';
import './UNSAFE_ComponentMessage/themes/redwood/ComponentMessageBaseTheme.styles.css';
import './UNSAFE_ComponentMessage/themes/redwood/ComponentMessageVariants.css.js';
import './UNSAFE_Separator/themes/SeparatorStyles.css.js';
import './SeparatorStyles.styles.css';
import './CompactLabelAssistance-1082f67f.js';
import './Help-2b3a3ccf.js';
import './Icon-ef2ac069.js';
import './UNSAFE_Icon/themes/IconStyle.css.js';
import './useFocusWithin-30b1e2d8.js';
import './UNSAFE_UserAssistance/themes/UserAssistanceStyles.css.js';
import './UNSAFE_Label/themes/redwood/LabelTheme.js';
import './UNSAFE_Label/themes/LabelStyles.css.js';
import './UNSAFE_Label/themes/redwood/LabelBaseTheme.css.js';
import './truncationUtils-e37f95ee.js';
import './UNSAFE_TextField/themes/redwood/TextFieldTheme.js';
import './UNSAFE_TextField/themes/redwood/TextFieldBaseTheme.css.js';
import './TextFieldVariants.styles.css';
import './useAccessibleContext-5744de8b.js';
import './useTextFieldInputHandlers-8122048f.js';
import './textAlign-ad252afa.js';
import './text.styles.css';
import './vanilla-extract-sprinkles-createRuntimeSprinkles.esm-2d655d37.js';
import './TextFieldUtils-8232bca7.js';
import './UNSAFE_TextField/themes/FormControlUtilsStyles.css.js';
import './FormControlUtilsStyles.styles.css';
import './LabelValueLayout-d7a71947.js';
import './StyledLabelValueLayout-32bdf9d1.js';
import './LabelValueLayoutStyles.styles.css';
import './UNSAFE_TextField/themes/redwood/FormLayoutTheme.js';
import './UNSAFE_TextField/themes/FormLayoutStyles.css.js';
import './UNSAFE_TextField/themes/redwood/FormLayoutBaseTheme.css.js';
import './UNSAFE_TextField/themes/redwood/FormLayoutBaseTheme.styles.css';
import './formControlUtils-4ec34117.js';
import './LayoutStyles.css-6b02421a.js';
import './LayoutStyles.styles.css';
import './UNSAFE_Skeleton/themes/redwood/SkeletonTheme.js';
import './UNSAFE_Skeleton/themes/SkeletonStyles.css.js';
import './UNSAFE_Skeleton/themes/redwood/SkeletonBaseTheme.css.js';
import './UNSAFE_Skeleton/themes/redwood/SkeletonBaseTheme.styles.css';
import './UNSAFE_Skeleton/themes/redwood/SkeletonVariants.css.js';
import './useInputGroupContext-1d19411e.js';
import './UNSAFE_TextField/themes/redwood/ReadonlyTextFieldTheme.js';
import './UNSAFE_TextField/themes/ReadonlyTextFieldStyles.css.js';
import './ReadonlyTextFieldStyles.styles.css';
import './UNSAFE_TextField/themes/redwood/ReadonlyTextFieldVariants.css.js';
import './ReadonlyTextFieldVariants.styles.css';
import './UNSAFE_TextField/themes/redwood/ReadonlyTextFieldInputTheme.js';
import './UNSAFE_TextField/themes/ReadonlyTextFieldInputStyles.css.js';
import './ReadonlyTextFieldInputStyles.styles.css';
import './UNSAFE_TextField/themes/redwood/ReadonlyTextFieldInputVariants.css.js';
import './index-3e2e69c4.js';
import './UNSAFE_Layer/themes/LayerHostStyles.css.js';
import './LayerHostStyles.styles.css';
import './ComponentMessageContainer-6149c829.js';
import './MessagesManager-c46786cb.js';
import './SuccessS-49782304.js';
import './ErrorS-60a975db.js';
import './InformationS-daba658e.js';
import './WarningS-7c6d2d0e.js';
import './PRIVATE_Message/themes/MessageStyles.css.js';
import './soundUtils-88264cb5.js';
import './useMessagesContext-9e1dbe91.js';
import './Transition-f9501682.js';
import './UNSAFE_ComponentMessage/themes/redwood/ComponentMessageTheme.js';
import './UNSAFE_ComponentMessage/themes/ComponentMessageStyles.css.js';
import './UNSAFE_ComponentMessage/themes/redwood/ComponentMessageBaseTheme.css.js';
import './UNSAFE_UserAssistance/themes/redwood/UserAssistanceTheme.js';
import './UNSAFE_UserAssistance/themes/redwood/UserAssistanceBaseTheme.css.js';
import './InlineHelp-8293a502.js';
import './Separator-93c70737.js';
import './EnvironmentProvider-546b7ebd.js';
import './LayerManager-a62e619b.js';
import './Floating-6023b41d.js';
import './useFloating-e1167cb9.js';
import './positionUtils-f26caad9.js';
import './refUtils-76275c69.js';
import './useOutsideClick-73a51e1d.js';
import './arrayUtils-35a58161.js';
import './Layer-7d3dc8c7.js';
import './UNSAFE_Layer/themes/LayerStyles.css.js';
import './LayerStyles.styles.css';
import './useModal-953082f2.js';
import './UNSAFE_Floating/themes/redwood/FloatingTheme.js';
import './UNSAFE_Floating/themes/FloatingStyles.css.js';
import './FloatingStyles.styles.css';
import './UNSAFE_Floating/themes/redwood/FloatingBaseTheme.css.js';
import './UNSAFE_Floating/themes/redwood/FloatingBaseTheme.styles.css';
import './UNSAFE_Floating/themes/redwood/FloatingVariants.css.js';
import './vanilla-extract-dynamic.esm-c909758c.js';
import './UNSAFE_Floating/themes/FloatingContract.css.js';
import './useUnsafeDomElementRef-32290273.js';
import './tabbableUtils-ce19b388.js';
import './head-8f89fe66.js';
import './_arity-be492b9e.js';
import './_isArray-694cc52d.js';
import './_isString-675f1de9.js';
import './FocusTrap-9f37aa41.js';
import './FocusTracker-02ad6723.js';
import './PRIVATE_FocusTracker/themes/FocusTrackerStyles.css.js';
import './FocusTrackerStyles.styles.css';
import './Modal-678575d5.js';
import './UNSAFE_Modal/themes/ModalStyles.css.js';
import './ModalStyles.styles.css';
import './popupUtils-4edf62b5.js';
import './WindowOverlay-b380ce51.js';
import './UNSAFE_WindowOverlay/themes/WindowOverlayStyles.css.js';
import './WindowOverlayStyles.styles.css';
import './UNSAFE_WindowOverlay/themes/WindowOverlayContract.css.js';
import './UNSAFE_WindowOverlay/themes/redwood/WindowOverlayTheme.js';
import './UNSAFE_WindowOverlay/themes/redwood/WindowOverlayBaseTheme.css.js';
import './UNSAFE_WindowOverlay/themes/redwood/WindowOverlayBaseTheme.styles.css';
import './UNSAFE_WindowOverlay/themes/redwood/WindowOverlayVariants.css.js';
import './usePopupAnimation-66b186ad.js';
import './useAnimationStatus-072d6a98.js';
import './popupAnimationUtils-175151d9.js';
import './UNSAFE_Popup/themes/PopupContract.css.js';
import './UNSAFE_Popup/themes/redwood/PopupTheme.js';
import './UNSAFE_Popup/themes/redwood/PopupBaseTheme.css.js';
import './PopupStyles.styles.css';
import './colors-b6530fec.js';
import './useMessageSeverity-65295e8f.js';
import './useFormFieldContextProps-31bbc12f.js';
import './calendarDateUtils-52ee4867.js';
import './boxalignment-51b42a0f.js';
import './boxalignment.styles.css';
import './flexbox-529f25da.js';
import './flexbox.styles.css';
import './flexitem-7b7f7920.js';
import './flexitem.styles.css';
import './FlexStyles.styles.css';
import './UNSAFE_TextField/themes/TextFieldInputStyles.css.js';
import './TextFieldInputStyles.styles.css';
import './UNSAFE_TextField/themes/redwood/TextFieldInputVariants.css.js';
import './TextFieldInputVariants.styles.css';
import './SegmentStyles.styles2.css';
import './types-ad8fe56f.js';

/**
 * LiteralSegment is used to represent a literal separator in a time,
 * such as the ':' in 10:00:00:000 or the space between the time and the dayPeriod, 8:00 AM.
 */
const LiteralSegment = ({ isHidden, isHighlighted, isPlaceholder, text }) => {
    const isTextOnlyWhitespace = text.trim() === '';
    const spanClasses = classNames([
        segmentStyles.literalBase,
        isPlaceholder && segmentStyles.placeholder,
        isTextOnlyWhitespace && segmentStyles.space,
        isHighlighted && segmentStyles.highlighted,
        isHidden ? segmentStyles.hidden : segmentStyles.notHidden
    ]);
    return (jsx("span", { "aria-hidden": "true", class: spanClasses, children: isTextOnlyWhitespace ? null : text }));
};

// A hook that returns handlers for input events that spread on the day period segment so that the user
// can type in a letter to toggle the day period (e.g., AM/PM).
function useDayPeriodInputHandlers(amPm, ref, onChange) {
    // Used to record the current state of the element in beforeinput so we can restore it in the `input` event below, for inputType 'insertCompositionText'.
    const compositionRef = useRef(null);
    const updateDayPeriodSegmentState = useCallback((value) => {
        onChange?.({
            actionType: 'updateDayPeriodSegment',
            data: { type: 'dayPeriod', 'aria-valuenow': value }
        });
    }, [onChange]);
    // This is useful if the AM/PM strings start with the same
    // letter. In that case when we get a letter that matches
    // the start of both, we simply toggle the dayPeriod.
    const toggleDayPeriodSegmentState = useCallback(() => {
        onChange?.({
            actionType: 'step',
            data: { type: 'dayPeriod', direction: 'increase' }
        });
    }, [onChange]);
    const changeDayPeriodIfMatch = useCallback((data) => {
        if (data !== null && data.trim() !== '' && isLetterOnlyString(data)) {
            // In most locales the first letter of the am/pm strings uniquely identifies am or pm.
            // In a couple locales, such as 'ms' (where am is represented 'PG' and pm as 'PTG'), the first letter may not be unique.
            // In this case we toggle the day period if matchType === 'both'.
            const matchType = getAmPmMatchType(amPm, data);
            if (matchType === 'am' || matchType === 'pm') {
                const value = matchType === 'am' ? AM_VALUE$1 : PM_VALUE$1;
                updateDayPeriodSegmentState(value);
            }
            else if (matchType === 'both') {
                toggleDayPeriodSegmentState();
            }
        }
    }, [amPm, toggleDayPeriodSegmentState, updateDayPeriodSegmentState]);
    // inputType 'insertText': Android Samsung, ios, Mac, Windows.
    // inputType 'insertCompositionText': Input Method Editor (IME), such as Pinyin for Chinese, and Android Google.
    // 'insertCompositionText' represents immediate text that is part of an ongoing composition, meaning the user has not yet finalized their input.
    const handleBeforeInput = useCallback((e) => {
        e.preventDefault();
        switch (e.inputType) {
            case 'insertCompositionText':
                // insertCompositionText cannot be cancelled so preventDefault does not keep the user's input from showing in the field.
                // (https://www.w3.org/TR/input-events-2/).
                // To workaround this, record the current state of the element so we can restore it in the `input` event below.
                if (ref.current) {
                    compositionRef.current = getTextContentFilterOutAriaHidden(ref.current);
                }
                break;
            default:
                // Android Google never gets here, so we need to change the dayPeriod in handleInput's insertCompositionText.
                changeDayPeriodIfMatch(e.data);
                break;
        }
    }, [changeDayPeriodIfMatch, ref]);
    const handleInput = useCallback((e) => {
        const { inputType, data } = e;
        switch (inputType) {
            // we handle the 'insertText' case entirely in handleBeforeInput, but since you cannot cancel 'insertCompositionText' events,
            // we have to do some work here.
            case 'insertCompositionText':
                // Reset the DOM to how it was in the beforeinput event.
                // If we don't do this the user will see what they typed in multi-byte text like Chinese.
                if (ref.current && compositionRef.current !== null) {
                    setVisibleText(ref.current, compositionRef.current);
                }
                // Android Google gets here, so this is where we need to check day period.
                changeDayPeriodIfMatch(data);
                break;
        }
    }, [changeDayPeriodIfMatch, ref]);
    // NOTE: I could not get oncompositionend to be called when using Chinese or Korean IME keyboard.
    return {
        onBeforeInput: handleBeforeInput,
        onInput: handleInput
    };
}
const isLetterOnlyString = (input) => {
    // /u flag: This enables Unicode matching in Javascript regular expressions, allowing you to match Unicode characters properly,
    // including those outside of the ASCII range.
    // p{L}: This is a Unicode property escape, which matches any letter in any language, not just ASCII letters.
    // The L property refers to Letter characters, which includes
    // * Upper and lowercase letters in the Latin alphabet.
    // * Letters in non-Latin scripts (e.g., Cyrillic, Greek, Arabic, and also Chinese characters.)
    const isLetter = /^\p{L}$/u.test(input);
    return isLetter;
};
const getTextContentFilterOutAriaHidden = (elem) => {
    const textContent = getVisibleTextNodes(elem)
        .map((node) => node.textContent)
        .join('');
    return textContent;
};
const setVisibleText = (elem, newText) => {
    // there is always only one visible text node for the AM/PM segment.
    getVisibleTextNodes(elem)[0].textContent = newText;
};
const getVisibleTextNodes = (elem) => {
    return Array.from(elem.childNodes).filter((node) => !(node.nodeType === Node.ELEMENT_NODE &&
        node.getAttribute('aria-hidden') === 'true'));
};

// Used to disable browser cut and paste, which don't really work with segments (copy is fine).
const preventDefaultHandler = (e) => {
    e.preventDefault();
};
const isIos = () => getClientHints().platform === 'ios';
/**
 * A TimeSegment renders a part of a time, e.g. the hour, minute, second, millisecond, dayPeriod.
 * It can be used as a spinbutton to step or spin its value.
 */
const TimeSegment = ({ amPm, 'aria-label': ariaLabel, 'aria-valuemax': ariaValueMax, 'aria-valuemin': ariaValueMin, 'aria-valuenow': ariaValueNow, 'aria-valuetext': ariaValueText, inputRef, isDisabled, isHidden, isHighlighted, isInvalid, isRequired, isSelected, onChange, placeholder, text, type }) => {
    const hasDisplayValue = text && text.length > 0;
    const rootClasses = classNames([
        segmentStyles.base,
        isSelected && segmentStyles.selected,
        isHighlighted && segmentStyles.highlighted
    ]);
    const placeholderClasses = classNames([
        segmentStyles.placeholder,
        isHidden || hasDisplayValue ? segmentStyles.hidden : segmentStyles.notHidden
    ]);
    const translations = useTranslationBundle('@oracle/oraclejet-preact');
    const emptySegmentValueText = translations.formControl_empty_segment();
    // If a ref was passed in, use it, otherwise get a ref.
    const sRef = useRef(null);
    const segmentRef = inputRef ?? sRef;
    const onKeyDown = useCallback((event) => {
        if (isDisabled === true ||
            event.key === 'Tab' ||
            event.key === 'ArrowLeft' ||
            event.key === 'ArrowRight' ||
            event.key === 'Enter' ||
            // JET-73547: let Escape pass through in order to close a popup or dialog.
            event.key === 'Escape' ||
            isSelectAll(event)) {
            // Let the event pass through.
            return;
        }
        if (isHighlighted) {
            // If time is selected, ignore edits and let backspace/delete pass through to clear.
            if (isBackspaceOrDelete(event) || event.key === 'Backspace') {
                return;
            }
        }
        else if (isNumberOnlyString(event.key)) {
            // do not send this for a dayPeriod segment since a dayPeriod segment does not have numbers.
            if (type !== 'dayPeriod') {
                onChange?.({
                    actionType: 'updateSegment',
                    data: { type, text: event.key }
                });
            }
        }
        else if (isBackspaceOrDelete(event) || event.key === 'Backspace') {
            // Android sends Backspace as event.key, not event.code, so check for it.
            onChange?.({ actionType: 'clearSegment', data: { type } });
        }
        else if (event.key === 'ArrowUp') {
            onChange?.({ actionType: 'step', data: { direction: 'increase', type } });
        }
        else if (event.key === 'ArrowDown') {
            onChange?.({ actionType: 'step', data: { direction: 'decrease', type } });
        }
        else if (event.key === 'PageUp') {
            onChange?.({ actionType: 'page', data: { direction: 'increase', type } });
        }
        else if (event.key === 'PageDown') {
            onChange?.({ actionType: 'page', data: { direction: 'decrease', type } });
        }
        else if (event.key === 'Home') {
            onChange?.({ actionType: 'goToHome', data: { type } });
        }
        else if (event.key === 'End') {
            onChange?.({ actionType: 'goToEnd', data: { type } });
        }
        else if (type === 'dayPeriod') {
            // return and don't call preventDefault so that we can use input handlers for dayPeriod
            // that we get from useDayPeriodInputHandlers.
            // keydown does not work for Android (event.key is 'Unspecified') or IME (like Chinese), and input handlers work for everything.
            return;
        }
        event.preventDefault();
        event.stopPropagation();
    }, [isDisabled, isHighlighted, onChange, type]);
    // Gets the input handlers that we need for the dayPeriod segment to allow typing letters to toggle.
    const dayPeriodHandler = useDayPeriodInputHandlers(amPm ?? { am: 'AM', pm: 'PM' }, segmentRef, onChange);
    // Used to focus the segment when isSelected is true.
    useEffect(() => {
        if (isSelected) {
            segmentRef.current?.focus();
        }
    }, [isSelected, segmentRef, type]);
    // If ariaValueText is undefined, substitute a string that indicates the segment is empty.
    // If ariaValueNow and ariaValueText represent the same value, omit the value text; this
    // is the same as what we do in NumberInputText.
    const valueText = ariaValueText === undefined
        ? emptySegmentValueText
        : ariaValueNow?.toString() === ariaValueText
            ? undefined
            : ariaValueText;
    // This attribute is used to distinguish between segments when clicked (see TimeField.tsx).
    const customDataAttribute = { 'data-segment': [type] };
    return (
    // Introduce a div wrapper around the contentEditable element to prevent it from grabbing focus.
    // https://stackoverflow.com/questions/34354085/clicking-outside-a-contenteditable-div-stills-give-focus-to-it
    // JET-64874: We change the segment's role to "textbox" on iOS to work around a VoiceOver bug, and when we do that
    // we need to add aria-multiline={false}
    jsx("div", { children: jsxs("div", { ref: segmentRef, role: isIos() ? 'textbox' : 'spinbutton', "aria-disabled": isDisabled, "aria-invalid": isInvalid || undefined, "aria-label": ariaLabel, "aria-multiline": isIos() ? false : undefined, "aria-required": isRequired, "aria-valuemin": isIos() ? undefined : ariaValueMin, "aria-valuemax": isIos() ? undefined : ariaValueMax, "aria-valuenow": isIos() ? undefined : ariaValueNow, "aria-valuetext": isIos() ? undefined : valueText, autocapitalize: "off", autocorrect: "off", class: rootClasses, contentEditable: !isDisabled, ...(type === 'dayPeriod' ? dayPeriodHandler : {}), ...customDataAttribute, enterkeyhint: isDisabled ? undefined : 'done', inputMode: isDisabled ? 'none' : type !== 'dayPeriod' ? 'numeric' : 'text', onCut: preventDefaultHandler, onKeyDown: onKeyDown, onPaste: preventDefaultHandler, spellcheck: false, tabIndex: isSelected ? 0 : -1, children: [jsx("span", { "aria-hidden": "true", class: placeholderClasses, ...customDataAttribute, children: placeholder }), text] }) }));
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const AM_VALUE = 0;
const PM_VALUE = 12;
/**
 * Reducer function for updating TimeFieldState per the specified TimeFieldAction.
 * @param state
 * @param action
 */
const timeReducer = (state, action) => {
    // On mount, the reducer is initialized with initial state derived from the TimeField's value.
    // If that value is changed programmatically afterwards, the only way to push that update
    // into the reducer is to define a "reset" action.
    if (action.actionType === 'reset') {
        return action.data;
    }
    // Most of the dispatches include type, but not all (like 'commitOnBlur' doesn't include type).
    // Instead of setting these for every actionType that needs it, we do it once here.
    const segmentType = action.data?.type;
    const segmentState = findSegment$1(state.segments, segmentType);
    // Each action updates the state using helper functions to modify a specific segment or
    // change focus between segments.
    switch (action.actionType) {
        case 'clearTime': {
            // Resets all segments to the default (useful when clearing the entire time)
            const updatedSegments = selectFirst(clearTime(state.segments), state.orderedSegments);
            return createTimeFieldStateFromUpdatedSegments(state, updatedSegments, false);
        }
        case 'clearSegment': {
            const updatedSegment = clearSegment(segmentState);
            return createTimeFieldStateFromUpdatedSegment(state, segmentType, updatedSegment);
        }
        case 'deselectAndComplete': {
            let updatedSegments = completeAllSegmentsBasedOnHour(state.segments);
            updatedSegments = deselectAndComplete(updatedSegments);
            return createTimeFieldStateFromUpdatedSegments(state, updatedSegments, false);
        }
        case 'commitOnEnter': {
            const updatedSegments = completeAllSegmentsBasedOnHour(state.segments);
            const newState = createTimeFieldStateFromUpdatedSegments(state, updatedSegments, false);
            return { ...newState, committing: true };
        }
        case 'commitOnBlur': {
            let updatedSegments = completeAllSegmentsBasedOnHour(state.segments);
            updatedSegments = deselectAndComplete(updatedSegments);
            const newState = createTimeFieldStateFromUpdatedSegments(state, updatedSegments, false);
            return { ...newState, committing: true };
        }
        case 'committed': {
            return { ...state, committing: false };
        }
        case 'goToEnd': {
            const updatedSegment = goToEnd(segmentType, segmentState);
            return createTimeFieldStateFromUpdatedSegment(state, segmentType, updatedSegment, false);
        }
        case 'goToHome': {
            const updatedSegment = goToHome(segmentType, segmentState);
            return createTimeFieldStateFromUpdatedSegment(state, segmentType, updatedSegment, false);
        }
        case 'page': {
            const direction = action.data?.direction;
            if (direction === undefined)
                return state;
            const updatedSegment = doStepOrPage(segmentType, segmentState, 'page', direction);
            return createTimeFieldStateFromUpdatedSegment(state, segmentType, updatedSegment, false);
        }
        case 'selectTime': {
            return selectTime(state);
        }
        case 'selectFirst': {
            const updatedSegments = selectFirst(state.segments, state.orderedSegments);
            return createTimeFieldStateFromUpdatedSegments(state, updatedSegments, false);
        }
        // Select the segment following the current one.
        case 'selectNext': {
            // If hour has a value and is currently selected when we get the selectNext action, then auto-fill
            // the empty segments.
            const updatedSegments = completeAllEmptySegmentsWhenHourHasValue(state.segments, true);
            const updatedSelectedNextSegments = selectNext(updatedSegments, state.orderedSegments);
            return createTimeFieldStateFromUpdatedSegments(state, updatedSelectedNextSegments, false);
        }
        case 'selectPrevious': {
            const updatedSegments = selectPrevious(state.segments, state.orderedSegments);
            return createTimeFieldStateFromUpdatedSegments(state, updatedSegments, false);
        }
        case 'selectSegment': {
            const updatedSegments = selectSegment(state.segments, segmentType);
            return createTimeFieldStateFromUpdatedSegments(state, updatedSegments, false);
        }
        // Increments or decrements the current segment value.
        case 'step': {
            const direction = action.data?.direction;
            if (direction === undefined)
                return state;
            const updatedSegment = doStepOrPage(segmentType, segmentState, 'step', direction);
            return createTimeFieldStateFromUpdatedSegment(state, segmentType, updatedSegment, false);
        }
        case 'updateDayPeriodSegment': {
            if (segmentType === 'dayPeriod') {
                const newValue = action.data?.['aria-valuenow'];
                if (newValue === PM_VALUE || newValue === AM_VALUE) {
                    // we have a new value for the dayPeriod. Create a new state.
                    const updatedSegment = createSegmentFromKeyboardAction(segmentType, newValue, segmentState);
                    return createTimeFieldStateFromUpdatedSegment(state, segmentType, updatedSegment, false);
                }
            }
            return state;
        }
        case 'updateSegment': {
            // If hour is 1-12, ignore typing '0' under certain circumstances
            if (action.data?.text === '0' &&
                segmentType === 'hour' &&
                segmentState['aria-valuemin'] === 1 &&
                (segmentState.isComplete || segmentState['aria-valuenow'] === undefined)) {
                const updatedSegment = { ...segmentState, digitCount: 1 };
                return createTimeFieldStateFromUpdatedSegment(state, segmentType, updatedSegment, false, false);
            }
            // Modifies the value of a specific time segment while keeping the rest of the time state intact.
            // This gets called from TimeSegment onKeyDown which is called one key at a time.
            const updatedSegment = updateSegment(segmentType, segmentState, action);
            return createTimeFieldStateFromUpdatedSegment(state, segmentType, updatedSegment);
        }
        default: {
            throw new Error('Unknown action type');
        }
    }
};
const stringToNumber = (s) => +s;
const numberToString = (n) => n.toString();
const withinRange = (n, min, max) => n >= min && n <= max;
/**
 * Given the array of TimeSegmentStates and the type, returns the segment with that type.
 * @param segments
 * @param type
 * @returns the segment with that type.
 */
const findSegment$1 = (segments, type) => {
    return segments.find((segment) => segment.type === type);
};
/**
 * A time segment is considered complete if one of these is true:
 * - digitCount >= targetDigitCount
 * - appending a zero to the current value causes it
 * to exceed the max. For instance, if aria-valuemax which is 12 (for 12-hour times), and
 * 2 is in hour already, if someone typed in 0, it would be 20, and
 * that is greater than the max.
 *
 * digitCount is used to figure out if the segment is complete.
 * It is used to distinguish between
 * the user typing in all 0s or the auto-filling of 0s that happens when the user types in one 0 into an empty or complete field.
 * It is also used to figure out if the user typed in the number of digits to fill the space.
 * Like if the user typed in 0, 0, 5 in millisecond. The segment is complete because the digitCount >= targetDigitCount.

 * @param val - the value of the segment for which to check completeness.
 * @param maxVal - the maximum value for the segment. E.g., for seconds it is 59.
 * @param digitCount - the number of digits a user typed.
 * @param targetDigitCount - the number of digits in a segment.
 * @returns true if the segment is considered complete, false otherwise.
 */
const isSegmentComplete = (val, maxVal, digitCount, targetDigitCount) => {
    if (digitCount >= targetDigitCount) {
        return true;
    }
    const num = stringToNumber(numberToString(val) + '0');
    return num > maxVal;
};
/**
 * A time is considered complete if all of its segments have values.
 * We use each segment's 'text' property to determine that.
 * @param allSegments
 * @returns {boolean} every segment has a value.
 */
const isTimeComplete = (allSegments) => {
    return allSegments.every((seg) => seg.text && seg.text.length > 0);
};
/**
 * A time is considered a partial time if at least one segment has a value.
 * We use each segment's 'aria-valuenow' property to determine that.
 * @param allSegments
 * @returns {boolean} at least one segment has a value.
 */
const isPartialTime = (allSegments) => {
    // Even though the dayPeriod field does not read-out the valuenow, we use it
    // to indicate if it is filled in or not.
    return allSegments.some((seg) => seg['aria-valuenow'] !== undefined);
};
/**
 * Construct a time that reflects the values of each segment.
 * If none of the segments have a value, return undefined.
 * If only the dayPeriod has a value, return undefined, since we filter out dayPeriod; Time has 0-23 hour.
 *
 * @param segments
 * @returns The Time that reflects the values of each segment.
 */
const createTimeFromSegments = (segments) => {
    const hasAnySegmentWithAValue = isPartialTime(segments);
    if (!hasAnySegmentWithAValue) {
        return undefined;
    }
    // get the dayPeriod's value, if it exists
    const dayPeriodValue = segments.find((seg) => seg.type === 'dayPeriod')?.['aria-valuenow'];
    // get the hour segment's value if it exists.
    const hourSegmentValue = segments.find((seg) => seg.type === 'hour')?.['aria-valuenow'];
    let adjustedHour = hourSegmentValue;
    // if the hour segment has a value and the dayPeriod segment has a value, then
    // we will adjust the hour so that it is a h23 hour.
    if (dayPeriodValue !== undefined && hourSegmentValue !== undefined) {
        adjustedHour = getAdjustedH12ToH23(dayPeriodValue, hourSegmentValue);
    }
    // Filter out dayPeriod segment and map the remaining segments to values
    const segmentValues = segments
        .filter((seg) => seg.type !== 'dayPeriod') // Filter out dayPeriod
        .reduce((acc, seg) => {
        const value = seg.type === 'hour' ? adjustedHour : seg['aria-valuenow'];
        if (value !== undefined) {
            acc[seg.type] = value;
        }
        return acc;
    }, {});
    // If all that was left in the time segments at this point was the dayPeriod, we would get an empty object
    // since the value does not contain dayPeriod. If this is the case return undefined.
    return Object.entries(segmentValues).length === 0 ? undefined : segmentValues;
};
/**
 * Returns a copy of the currentState.orderedSegments. The orderedSegments is an array of the name of each segment type
 * in the order they appear to the user.
 * E.g., ['hour', 'minute, 'dayPeriod'], when the InputTimeMask component shows the hour, minute, and dayPeriod segments in that order.
 * E.g., ['hour', 'minute', 'second'] when the InputTimeMask component shows the hour, minute, and second segments in that order.
 *
 * @param {TimeFieldState} currentState - the current state of the time field.
 * @returns {OrderedTimeSegmentsArray} the orderedSegments in the current state.
 */
const getOrderedSegmentsFromState = (currentState) => {
    // Typescript loses its typing when we spread, so add it back.
    return [...currentState.orderedSegments];
};
/**
 * Replace the updated segment and return a new TimeSegmentState[].
 * @param existingSegments
 * @param updatedSegmentType
 * @param updatedSegment
 * @returns
 */
const replaceTimeSegment = (existingSegments, updatedSegmentType, updatedSegment) => {
    return existingSegments.map((seg) => (seg.type === updatedSegmentType ? updatedSegment : seg));
};
/**
 * Creates a new array of TimeSegmentState objects by updating the specified segment which might
 * affect other segments.
 *
 * If the modified segment type is 'hour', and the 'minute',
 * 'second', 'millisecond', 'dayPeriod' segments, if defined, are not set (i.e., their aria-valuenow is undefined),
 * their values are auto-filled, that is, initialized to 0 or localized version of 'AM' for dayPeriod.
 *
 * If the segment is complete, and autoAdvance is true, then the next segment will be selected.
 * @param {TimeSegmentState[]} existingSegments - The current array of time segments.
 * @param {OrderedTimeSegmentsArray} orderedSegments - The ordered list of segments used to determine
 * the segment sequence for selection and auto-advancing.
 * @param {EditableTimeSegmentType} updatedSegmentType - The type of the segment that is being updated.
 * @param {TimeSegmentState} updatedSegment - The updated segment state to replace the current one.
 * @param {boolean} autoAdvance - whether to automatically select the next segment upon completion of the current segment.
 * @param {boolean} autoFill - whether to automatically fill the next segments upon completion of the current segment.
 * @returns The new array of TimeSegmentState objects, with the segment updated and other segments
 * modified as needed.
 * If autoAdvance is true, the next segment will be automatically set to isSelected upon segment isCompleted.
 */
const createTimeSegmentStates = (existingSegments, orderedSegments, updatedSegmentType, updatedSegment, autoAdvance, autoFill) => {
    // Replace the segment with the updated version.
    const modifiedSegments = replaceTimeSegment(existingSegments, updatedSegmentType, updatedSegment);
    let updatedSegments = modifiedSegments;
    const isHourSegmentAndComplete = updatedSegmentType === 'hour' && updatedSegment.isComplete;
    if (isHourSegmentAndComplete && autoFill) {
        updatedSegments = autoFillEmptyNonHourSegments(updatedSegments);
    }
    // If the updatedSegment is complete, automatically select the next segment.
    updatedSegments =
        updatedSegment.isComplete && autoAdvance
            ? selectNext(updatedSegments, orderedSegments)
            : updatedSegments;
    return updatedSegments;
};
/**
 * This function auto-fills all empty, non-hour segments ('minute', 'second', 'millisecond' and 'dayPeriod').
 * It only auto-fills the empty fields and leaves the other fields alone.
 * For example, if milliseconds is not empty, we leave the milliseconds as is and update all the empty fields;
 * 23:--:--:400 becomes 23:00:00:400. And if there is a dayPeriod segment, 5:--:--:400 -- becomes 5:00:00:400 AM.
 *
 * @param existingSegments
 * @param hourSegmentState
 * @returns
 */
const autoFillEmptyNonHourSegments = (existingSegments) => {
    // if a segment already has a value, then do nothing.
    const initializedSegments = existingSegments.map((seg) => {
        if (seg['aria-valuenow'] !== undefined) {
            return seg;
        }
        let text;
        let ariaValue;
        if (seg.type === 'millisecond') {
            text = '000';
            ariaValue = 0;
        }
        else if (['minute', 'second'].includes(seg.type)) {
            text = '00';
            ariaValue = 0;
        }
        else if (seg.type === 'dayPeriod') {
            // seg.amPM.am always has a value for the dayPeriod segment, so there is no need to default it.
            text = seg.amPm?.am;
            ariaValue = AM_VALUE;
        }
        return text !== undefined
            ? {
                ...seg,
                'aria-valuenow': ariaValue,
                text,
                isComplete: true,
                'aria-valuetext': text,
                isAutoFilled: true
            }
            : seg;
    });
    return initializedSegments;
};
/**
 * Constructs a new TimeFieldState given an updated segment, which may affect other segments.
 * Called from actions like updateSegment, stepping/paging/home/end, clearing a segment.
 * @param {TimeFieldState} currentState - The current state of the time field.
 * @param {EditableTimeSegmentType} updatedSegmentType - The type of the segment that was updated.
 * @param {TimeSegmentState} updatedSegment - The updated state of the specified segment.
 * @param {boolean} autoAdvance - Whether to auto-advance to the next segment if the current segment is complete. Defaults to true.
 * @param {boolean} autoFill - Whether to auto-fill to the next segments if the current hour segment is complete. Defaults to true
 * since we almost always want to autoFill. The one instance where we do not auto-fill is when we ignore 0s in the hour field.
 * @returns {TimeFieldAction} - A new TimeFieldState based on the updated segment and the current state.
 */
const createTimeFieldStateFromUpdatedSegment = (currentState, updatedSegmentType, updatedSegment, autoAdvance = true, autoFill = true) => {
    let updatedSegments = createTimeSegmentStates(currentState.segments, currentState.orderedSegments, updatedSegmentType, updatedSegment, autoAdvance, autoFill);
    // If updatedSegmentType is not hour, then set isAutoFilled to false for all segments.
    // The use case that this covers is this:
    // Type in hour, this auto-fills which sets all the segments to isAutoFilled: true, then we render the aria-live.
    // Now go to change the AM field. This sets isAutoFilled: false for that segment, but we do not want to update
    // aria-live to a new time, so at this point we set isAutoFilled to false for all the other segments
    // which will cause aria-live to be cleared. This is why we have this here.
    if (!(updatedSegmentType === 'hour')) {
        updatedSegments = updatedSegments.map((seg) => {
            return { ...seg, isAutoFilled: false };
        });
    }
    return createTimeFieldStateFromUpdatedSegments(currentState, updatedSegments, currentState.isTimeSelected);
};
/**
 * The clearSegment function clears the current state of the time segment by resetting
 * specific properties to indicate that the segment no longer holds a value.
 * Specifically, it sets:
 * 'aria-valuetext': undefined,
 * 'aria-valuenow': undefined,
 *  digitCount: 0,
 *  text: undefined,
 *  isComplete: false
 *
 * This function returns a new segment state reflecting these cleared properties.
 *
 * @param {TimeSegmentState} segmentState - The current state of the time segment to clear.
 * @returns {TimeSegmentState} A new segment state with cleared properties.
 */
const clearSegment = (segmentState) => {
    return {
        ...segmentState,
        'aria-valuetext': undefined,
        'aria-valuenow': undefined,
        digitCount: 0,
        text: undefined,
        isComplete: false
    };
};
/**
 * Clears the current state of each segment.
 *
 * @param {TimeSegmentState[]} segments
 * @returns The updated state with all segments cleared.
 */
const clearTime = (segments) => {
    return segments.map((segmentState) => {
        const cleared = clearSegment(segmentState);
        return { ...cleared, isAutoFilled: false };
    });
};
/**
 * Updates the state of a time segment based on user input, one character at a time,
 * enforcing range constraints, completeness rules,
 * and zero-padding requirements for the segment types.
 * @param segmentType
 * @param segmentState
 * @param action
 * @returns A new copy of the segment state with updated values.
 */
const updateSegment = (segmentType, segmentState, action) => {
    // Process the input action text
    // actionText - This is one character, the one the user typed.
    const actionText = action.data?.text;
    // Get the current segment state.
    const maxValue = segmentState['aria-valuemax'];
    const minValue = segmentState['aria-valuemin'];
    // minute, second, millisecond always have leading zeros, but hour might not.
    const hasLeadingZeros = segmentState.hasLeadingZeros ?? minValue === 0;
    const wasComplete = segmentState.isComplete;
    // digitCount is used to figure out if the segment is complete.
    // It is used to distinguish between
    // the user typing in all 0s or the auto-filling of 0s that happens when the user types in one 0 into an empty or complete field.
    // It is also used to figure out if the user typed in the number of digits to fill the space.
    // Like if the user typed in 0, 0, 5 in millisecond. The segment is complete because the digitCount >= targetDigitCount.
    let digitCount = segmentState.digitCount || 0;
    const targetDigitCount = segmentType === 'millisecond' ? 3 : 2;
    // Set requestedValStr based on leading zero rules
    let requestedValStr = segmentState.text || '';
    if (wasComplete) {
        // If the value is complete and you type another number, it replaces what is already there.
        requestedValStr = actionText;
    }
    else {
        requestedValStr = (segmentState.text ?? '') + actionText;
    }
    if (hasLeadingZeros && requestedValStr.length > targetDigitCount) {
        requestedValStr = requestedValStr.slice(requestedValStr.length - targetDigitCount);
    }
    else if (hasLeadingZeros) {
        requestedValStr = requestedValStr.padStart(targetDigitCount, '0');
    }
    digitCount += 1;
    // Check if the value is in range and apply final adjustments
    // if not in range, then actionText overwrites requestedValStr.
    // E.g., first we type '2', then we type '5'. '25' is out of range for hour24, so we use '5'.
    const inRange = withinRange(stringToNumber(requestedValStr), minValue, maxValue);
    let finalValStr = inRange
        ? requestedValStr
        : hasLeadingZeros
            ? actionText.padStart(targetDigitCount, '0')
            : actionText;
    const finalVal = stringToNumber(finalValStr);
    // Determine if the segment is complete.
    const isComplete = isSegmentComplete(finalVal, maxValue, digitCount, targetDigitCount);
    // reset digitCount if the segment is complete.
    // When digitCount is 0, whatever is in the field will be overwritten if the user types into it again,
    // which is the desired behavior.
    digitCount = isComplete ? 0 : digitCount;
    // do the opposite of padStart by removing the leading zero if it is complete.
    if (hasLeadingZeros === false &&
        segmentType === 'hour' &&
        isComplete &&
        finalValStr.startsWith('0')) {
        finalValStr = finalValStr.substring(1);
    }
    return {
        ...segmentState,
        'aria-valuetext': finalValStr,
        'aria-valuenow': finalVal,
        digitCount,
        text: finalValStr,
        isComplete,
        isAutoFilled: false
    };
};
/**
 * Updates the selection state of the segments, setting the isSelected property to true for the
 * segment that has the segmentType and false for all others.
 * @param {TimeSegmentState[]} segments
 * @param {EditableTimeSegmentType} segmentType - The type of the segment that is being updated.
 * @returns {TimeSegmentState[]} A new array of time segments with updated isSelected state.
 */
const selectSegment = (segments, segmentType) => {
    return segments.map((seg) => {
        return { ...seg, isSelected: seg.type === segmentType ? true : false };
    });
};
/**
 * Updates the isSelected state of the first segment from the ordered segments to true,
 * while setting isSelected to false for all other segments.
 *
 * This function can be used to set the initial focus on the first time segment.
 *
 * @param {TimeSegmentState[]} segments - An array of current time segment states, each
 * representing different parts of the time (e.g., hour, minute, second, dayPeriod).
 * @param {OrderedTimeSegmentsArray} orderedSegments - An array of segment types in the
 * represented order (e.g., ['hour','minute', 'dayPeriod']). This is used to get the type
 * of the first segment.
 * @returns {TimeSegmentState[]} A new array of time segment states with the first segment's isSelected
 * property set to true and all other segment's isSelected properties set to false.
 */
const selectFirst = (segments, orderedSegments) => {
    return selectSegment(segments, orderedSegments[0]);
};
// Find the index of the selected segment in the ordered list; return -1 if there is no selection.
const getSelectedSegmentIndex = (segments, orderedSegments) => {
    const sel = segments.find((seg) => seg.isSelected === true);
    return sel === undefined ? -1 : orderedSegments.findIndex((type) => type === sel.type);
};
/**
 * Convenience function to mark the selected segment complete if it has a value.
 * @param segments
 * @returns The updated segments where if isSelected was true and it has a value, isComplete is now also true.
 */
const markSelectedSegmentComplete = (segments) => {
    return segments.map((seg) => seg.isSelected && seg['aria-valuenow'] !== undefined
        ? { ...seg, isComplete: true, digitCount: 0 }
        : seg);
};
/**
 * Selects the segment following the one that is currently selected.
 * @param segments
 * @param orderedSegments
 * @returns
 */
const selectNext = (segments, orderedSegments) => {
    const selectedIndex = getSelectedSegmentIndex(segments, orderedSegments);
    const max = orderedSegments.length - 1;
    // If we're already at the last position, do nothing. Note if nothing was currently selected
    // then selectedIndex is -1. The first segment will be selected.
    return selectedIndex === max
        ? segments
        : selectSegment(markSelectedSegmentComplete(segments), orderedSegments[selectedIndex + 1]);
};
/**
 * Selects the segment prior to the one that is currently selected.
 * @param segments
 * @param orderedSegments
 * @returns
 */
const selectPrevious = (segments, orderedSegments) => {
    const selectedIndex = getSelectedSegmentIndex(segments, orderedSegments);
    return selectedIndex === 0
        ? segments
        : selectedIndex === -1
            ? selectFirst(segments, orderedSegments)
            : selectSegment(markSelectedSegmentComplete(segments), orderedSegments[selectedIndex - 1]);
};
/**
 * Returns a new TimeSegmentState[] where all segments are unselected and any values are
 * marked complete. We want to do this when the user commits the TimeField value (on blur).
 * We do not do this when the user commits the TimeField value on Enter
 * because in that case the component still has focus on Enter, and they could continue typing in the segment.
 * @param segments
 * @returns a new TimeSegmentState[] where all segments have isSelected: false and any
 * with text has isComplete: true.
 */
const deselectAndComplete = (segments) => {
    return segments.map((seg) => {
        return { ...seg, isSelected: false, isComplete: !!seg.text };
    });
};
/**
 * Returns a new TimeSegmentState[] where all segments are unselected by setting isSelected: false.
 * @param segments
 * @returns
 */
const clearSelection = (segments) => {
    return segments.map((seg) => {
        return { ...seg, isSelected: false };
    });
};
/**
 * Checks if hour is clear and dayPeriod is not clear, and if so, clear the dayPeriod segment.
 * @param segments
 * @returns segments, with the 'dayPeriod' segment updated, if needed.
 */
const clearDayPeriodSegmentWhenHourIsEmpty = (segments) => {
    // find the dayPeriod segment if it exists.
    const dayPeriodSegment = segments.find((seg) => seg.type === 'dayPeriod');
    // find the hour segment.
    const hourSegmentState = segments.find((seg) => seg.type === 'hour');
    const hourSegmentHasText = hourSegmentState?.text !== undefined;
    const dayPeriodSegmentHasText = dayPeriodSegment?.text !== undefined;
    // If hour is clear and dayPeriod is not clear, clear dayPeriod.
    // E.g., --:00 PM becomes --:00 --.
    if (!hourSegmentHasText && dayPeriodSegmentHasText) {
        return segments.map((seg) => {
            if (seg.type === 'dayPeriod') {
                return clearSegment(seg);
            }
            return { ...seg };
        });
    }
    return segments;
};
/**
 * If the hour segment is filled in, auto-fill empty minute, second, and millisecond segments and dayPeriod segment.
 * The additional parameter checkHourSelected, if true, will make sure that the hour isSelected state is true before auto-filling.
 * This is used for the 'selectNext' action.
 * @param segments
 * @param checkHourSelected {boolean} true, if the hour segment must be selected in order to auto-fill. This is the case for the 'selectNext' action.
 * @returns segments, with the minute, second, millisecond, and dayPeriod segments updated, if needed.
 */
const completeAllEmptySegmentsWhenHourHasValue = (segments, checkHourSelected) => {
    const hourSegment = segments.find((seg) => seg.type === 'hour');
    const doAutoFill = checkHourSelected
        ? hourSegment?.isSelected && hourSegment?.text !== undefined
        : hourSegment?.text !== undefined;
    const updatedSegments = doAutoFill ? autoFillEmptyNonHourSegments(segments) : segments;
    return updatedSegments;
};
/**
 * If the hour segment is filled in, auto-fill empty minute, second, and millisecond segments and dayPeriod segment.
 * If the hour segment is empty and the dayPeriod segment is filled in, clear out the dayPeriod segment.
 * This is what we do when we leave the component.
 * @param segments
 * @returns segments, with the minute, second, millisecond, and dayPeriod segments updated, if needed.
 */
const completeAllSegmentsBasedOnHour = (segments) => {
    const updatedSegments = completeAllEmptySegmentsWhenHourHasValue(segments);
    return clearDayPeriodSegmentWhenHourIsEmpty(updatedSegments);
};
/**
 * This function is called when the user wants to select the entire date.
 * If currentState.isCompleteTime is true,
 * - returns a new TimeFieldState from the currentState where the entire time is marked as selected,
 * and the 'isSelected' property of all the individual segments is set to false.
 *
 * If the time is not complete,
 * - returns the currentState unchanged.

 * @param {TimeFieldState} currentState
 * @returns
 */
const selectTime = (currentState) => {
    if (currentState.isCompleteTime) {
        return createTimeFieldStateFromUpdatedSegments(currentState, clearSelection(currentState.segments), true);
    }
    return currentState;
};
/**
 * Creates a new TimeFieldState from the updatedSegments and the isTimeSelected param.
 * NOTE: This updates currentTime based on the segments.
 *
 * @param {TimeFieldState} currentState
 * @param {TimeFieldState[]} updatedSegments
 * @param {boolean} isTimeSelected - Indicates whether the entire time field is selected.
 * @returns {TimeFieldState} The updated state of the time field.
 */
const createTimeFieldStateFromUpdatedSegments = (currentState, updatedSegments, isTimeSelected) => {
    const orderedSegmentsFromCurrentState = getOrderedSegmentsFromState(currentState);
    const timeBeforeUpdate = currentState.currentTime;
    const timeAfterUpdate = createTimeFromSegments(updatedSegments);
    let useUpdatedValue = true;
    // if either one of these is undefined, then go ahead and update the value
    if (timeBeforeUpdate !== undefined && timeAfterUpdate !== undefined) {
        // Handle the case where the user has not updated the value, but the value we create from the segments is different only because
        // the new time represents the time with the segments shown. We do not want to update the time in this case.
        // Example, initial time value is {hour: 1, minute: 29, second: 66, millisecond: 888}, and granularity='minute', so orderedSegments is ['hour', 'minute'].
        // The updated time will be {hour:1, minute: 29}. In this case the user hasn't change the time. It's only different because of the segments, so we leave the initial time.
        const hasExtraSegments = hasSegmentsNotDisplayed(orderedSegmentsFromCurrentState, timeBeforeUpdate);
        if (hasExtraSegments) {
            useUpdatedValue = displayedTimeSegmentsAreDifferent(orderedSegmentsFromCurrentState, timeBeforeUpdate, timeAfterUpdate);
        }
    }
    // If any of the segments have isAutoFilled set to true, then set the state isTimeAutoFilled.
    const isAnySegmentAutoFilled = updatedSegments.some((seg) => seg.isAutoFilled === true);
    return {
        committing: currentState.committing,
        currentTime: useUpdatedValue ? timeAfterUpdate : timeBeforeUpdate,
        isTimeAutoFilled: isAnySegmentAutoFilled,
        isCompleteTime: isTimeComplete(updatedSegments),
        isTimeSelected,
        isPartialTime: isPartialTime(updatedSegments),
        orderedSegments: orderedSegmentsFromCurrentState,
        segments: updatedSegments
    };
};
/**
 * Gets the minimum value for the segment.
 * @param segmentState
 * @returns the minimum value for the segment.
 */
const getHomeSegmentValue = (segmentState) => {
    return segmentState['aria-valuemin'];
};
/**
 * Gets the maximum value for the segment.
 * @param segmentState
 * @returns the maximum value for the segment
 */
const getEndSegmentValue = (segmentState) => {
    return segmentState['aria-valuemax'];
};
/**
 * Adjusts the value of a time segment (e.g., hour, minute, second, millisecond) by a given step.
 * It handles both increasing and decreasing the value with wrapping logic
 * when the value exceeds the max or falls below the min.
 *
 * Uses separate paths for cases when min is 0 and when min is non-zero for clarity.
 *
 * @param {number} value - The current value of the segment.
 * @param {number} step - The amount to increment or decrement the value.
 * @param {number} min - The minimum allowed value for the segment.
 * @param {number} max - The maximum allowed value for the segment.
 * @param {TimeFieldActionData['direction']} direction - Whether to increase or decrease the value.
 * @returns {number} - The new adjusted value after wrapping.
 */
const adjustTimeSegment = (value, step, min, max, direction) => {
    const range = max - min + 1; // Total values in the range.
    if (min === 0) {
        // Path for min === 0 (e.g., minutes, seconds, 0-23 hour time).
        if (direction === 'increase') {
            const steppedValue = value + step;
            return steppedValue % range; // Wrap within range 0 to max.
        }
        else {
            // direction === 'decrease'
            const steppedValue = value - step;
            return (steppedValue + range) % range; // Wrap below min to max.
        }
    }
    else {
        // Path for any min !== 0 (e.g., 12-hour clock has min 1 and max 12, or other ranges).
        if (direction === 'increase') {
            const steppedValue = value + step;
            return ((steppedValue - min) % range) + min; // Wrap within min-based range.
        }
        else {
            // direction === 'decrease'
            const steppedValue = value - step;
            return ((steppedValue - min + range) % range) + min; // Wrap below min to max.
        }
    }
};
/**
 * Returns the result of stepping currentValue in the requested direction, taking into account min and max.
 * @param {number} currentValue
 * @param direction
 * @param {number} min
 * @param {number} max
 * @returns {number} the result of stepping currentValue in the requested direction, taking into account min and max.
 */
const getSteppedSegmentValue = (currentValue, direction, min, max) => {
    const newValue = adjustTimeSegment(currentValue, 1, min, max, direction);
    return newValue;
};
/**
 * Returns the result of paging the value up or down, taking into account min and max.
 * @param currentValue
 * @param direction
 * @param min
 * @param max
 * @param segmentType
 * @returns
 */
const getPagedSegmentValue = (currentValue, direction, min, max, segmentType) => {
    let step;
    if (segmentType === 'minute' || segmentType == 'second') {
        step = 10;
    }
    else if (segmentType === 'millisecond') {
        step = 100;
    }
    else {
        step = 2;
    }
    const newValue = adjustTimeSegment(currentValue, step, min, max, direction);
    return newValue;
};
/**
 * Creates a new segment state with an updated value from a keyboard action such as step, page, Home, or End.
 * After any keyboard action, the value is complete so that if the user types anything,
 * it will replace the stepped value.
 * @param {EditableTimeSegmentType} segmentType - The type of the segment that is being updated.
 * @param {number} newVal - new value which is used to update the aria-valuenow and aria-valuetext and text properties.
 * @param segmentState
 * @returns A new segment state with an updated value from a keyboard action such as step, page, Home, or End.
 */
const createSegmentFromKeyboardAction = (segmentType, newVal, segmentState) => {
    // Only the hour12 segment has aria-valuemin to be 1. All the other segments' aria-valuemin is 0.
    // Most locales that have hour12 by default also do not pad zero so this is why it is the default.
    const padZero = segmentState.hasLeadingZeros ?? segmentState['aria-valuemin'] === 0;
    const ariaValueText = getAriaValueText(newVal, segmentState, segmentType, padZero);
    // Create a new segment state that reflects the updated value.
    // After any keyboard action, the value is complete so that if the user types anything,
    // it will replace the stepped value.
    return {
        ...segmentState,
        'aria-valuetext': ariaValueText,
        'aria-valuenow': newVal,
        text: ariaValueText,
        isComplete: true,
        isAutoFilled: false
    };
};
// Set the segment to its minimum value.
const goToHome = (segmentType, segmentState) => {
    const newValue = getHomeSegmentValue(segmentState); // gets aria-valuemin
    return createSegmentFromKeyboardAction(segmentType, newValue, segmentState);
};
// Set the segment to its maximum value.
const goToEnd = (segmentType, segmentState) => {
    const newValue = getEndSegmentValue(segmentState); // gets aria-valuemax
    return createSegmentFromKeyboardAction(segmentType, newValue, segmentState);
};
/**
 * Steps or pages a segment's value. Pass in initialStarting of 12 for hour12, otherwise we want to use the min.
 * Creates a new segment state with an updated value.
 *
 * After any keyboard action, the value is complete so that if the user types anything, it will replace the stepped value.
 * @param segmentType
 * @param segmentState
 * @param type
 * @param direction
 * @returns A new segment state with an updated value from the keyboard action.
 */
const doStepOrPage = (segmentType, segmentState, type, direction) => {
    // aria-valuemin is 0 for all segments except the 12-hour hour segment, where it is 1.
    // The Redwood design states that when you step or page up or down when there is no initial value in the segment,
    // it initializes the hour segment to 12, and auto-fills any empty segments for a 12-hour clock,
    // and it initializes the hour segment to 0, and auto-fills any empty segments for a 24-hour clock.
    // To get the initial value, we use the aria-valuemin for all segments (which is 0) except for the 12-hour hour segment.
    // For the 12-hour segment stepping or paging starts at 12.
    const initialStarting = segmentType === 'hour' && segmentState['aria-valuemin'] === 1
        ? 12
        : segmentState['aria-valuemin'];
    const valueNow = segmentState['aria-valuenow'];
    const min = segmentState['aria-valuemin'];
    const max = segmentState['aria-valuemax'];
    let newValue;
    if (segmentType === 'dayPeriod') {
        // toggle aria-valuenow
        newValue = valueNow === AM_VALUE ? PM_VALUE : AM_VALUE;
    }
    else if (valueNow === undefined) {
        // start at the minimum if there is no value.
        newValue = initialStarting ?? min;
    }
    else if (type === 'page') {
        newValue = getPagedSegmentValue(valueNow, direction, min, max, segmentType);
    }
    else {
        newValue = getSteppedSegmentValue(valueNow, direction, min, max);
    }
    return createSegmentFromKeyboardAction(segmentType, newValue, segmentState);
};
/**
 * Get the text for the segment's aria-valuetext property. For dayPeriod segment, we use the segmentState.amPm?.am and
 * segmentState.amPm?.pm to get the localized value.
 * @param {number} newVal - the segments value.
 * @param {TimeSegmentState} segmentState - the segment's current state.
 * @param {EditableTimeSegmentType} segmentType - the segment's type.
 * @param {boolean} padZero - whether to pad the text with 0, e.g., minute segments pad 0, so 1 minute would be '01'.
 * @returns the text for the segment's aria-valuetext property.
 */
const getAriaValueText = (newVal, segmentState, segmentType, padZero) => {
    if (segmentType === 'dayPeriod') {
        // This is the segmentState for dayPeriod:
        //
        // aria-valuenow="0 // 0 if AM, 12 if PM
        // aria-valuetext="AM
        // aria-valuemin="0
        // aria-valuemax=12"
        // text=AM"
        // aria-label="AM/PM"
        // seg.amPM.am and pm always have a value for the dayPeriod segment, so there is no need to default them.
        const amValue = segmentState.amPm?.am;
        const pmValue = segmentState.amPm?.pm;
        return newVal < PM_VALUE ? amValue : pmValue;
    }
    const valStr = numberToString(newVal);
    if (!padZero) {
        return numberToString(newVal);
    }
    const targetDigitCount = segmentType === 'millisecond' ? 3 : 2;
    return valStr.padStart(targetDigitCount, '0');
};
/**
 * Returns an hour 0-23 given the hour 1-12 and the dayPeriod 0 for AM and 12 for PM.
 * @param dayPeriodValue
 * @param timeHour12
 * @returns The hour 0-23.
 */
const getAdjustedH12ToH23 = (dayPeriodValue, timeHour12) => {
    // If both dayPeriod and hour are available, adjust the hour to h23 format
    if (dayPeriodValue === AM_VALUE && timeHour12 === 12) {
        return 0; // 12 AM (midnight) adjustment.
    }
    if (dayPeriodValue === PM_VALUE && timeHour12 === 12) {
        return 12; // 12 PM, no adjustment needed
    }
    if (dayPeriodValue === PM_VALUE) {
        return timeHour12 + 12; // Convert PM hour to h23 format
    }
    return timeHour12; // AM hours, no adjustment needed.
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const MINUTE_SECOND_MAX = 59;
const MILLISECOND_MAX = 999;
/**
 * Hook that returns a TimeFieldState and a dispatch method to request changes to that state.
 *
 * This hook determines the initial state based on the provided input properties
 * and utilizes a reducer (`timeReducer`) to initialize the state.
 *
 * **Important**: Ensure that the `timeMasks` include all placeholders required by the specified `granularity`.
 * For example, if `granularity` is "second",
 * the `timeMasks` must include the second placeholder. Since 'InputTimeMask' does this validation,
 * it is not done here in the hook for efficiency sake.
 * @param {Object} props - Configuration properties for the hook.
 * @param {AmPmLocalizedValues} props.amPm - An Object containing a localized string for 'am' and one for 'pm'.
 * @param {Record<EditableTimeSegmentType, string>} props.ariaLabels - ARIA labels for each editable time segment type.
 * @param {TimePlaceholders} props.timeMasks - The time placeholders representing the structure of the time format.
 * e.g.,
 * [ { type: 'hour', value: 'hh' }, { type: 'literal', value: ':' }, { type: 'minute', value: 'mm' }, { type: 'literal', value: ' ' }, { type: 'dayPeriod', value: 'am/pm' } ]
 * @param {TimeGranularity} props.granularity - Specifies the smallest time unit that is displayed by the component.
 * @param {BCP47Locale} props.locale - The locale used for formatting the time.
 * @param {boolean} [props.hasLeadingZeroForHour] - Whether to show a leading zero in the hour field when there is only one digit or not. E.g., 01:00 AM vs 1:00 AM.
 * @param {Time | undefined} [props.value] - The current time value.
 * @returns An object containing the current 'state', a 'dispatch' function, and timeResetRef.
 */
const useTimeField = ({ ariaLabels, granularity, hasLeadingZeroForHour, locale, timeMasks, value: currentValue }) => {
    const [state, dispatch] = useReducer(timeReducer, {
        ariaLabels,
        currentValue,
        hasLeadingZeroForHour,
        granularity,
        locale,
        timeMasks
    }, reducerInitializer);
    // currentValue is the controlled value passed from the parent.
    const lastValueFromParentRef = useRef(currentValue);
    const timeResetRef = useRef(false);
    // If a new value is being pushed from the parent, and that value differs from
    // the current value of the reducer, then this is a programmatic update
    // and we need to call 'reset' to update the reducer state. Otherwise, the only
    // time the reducer state is updated from the value is on mount.
    if (timesAreDifferent(lastValueFromParentRef.current, currentValue)) {
        lastValueFromParentRef.current = currentValue;
        if (timesAreDifferent(currentValue, state.currentTime)) {
            const initialState = reducerInitializer({
                ariaLabels,
                currentValue,
                hasLeadingZeroForHour,
                granularity,
                locale,
                timeMasks
            });
            dispatch({ actionType: 'reset', data: initialState });
            timeResetRef.current = true;
        }
    }
    return { timeResetRef, dispatch, state };
};
// The bulk of the work in this hook is to derive data from currentValue
// that will become part of our initial state.
const reducerInitializer = (params) => {
    const { ariaLabels, currentValue, granularity, hasLeadingZeroForHour, locale, timeMasks } = params;
    // Construct an ordered list of the editable segments.
    const ftm = timeMasks.filter(({ type }) => type !== 'literal');
    const orderedSegments = ftm.map(({ type }) => type);
    const minuteValue = currentValue?.minute;
    const secondValue = currentValue?.second;
    const millisecondValue = currentValue?.millisecond;
    // The timeMasks has a dayPeriod part when the hour is 1-12. You never see a dayPeriod part
    // when the hour is 0-23.
    const hasDayPeriod = timeMasks.some((part) => part.type === 'dayPeriod');
    const hasHour = currentValue?.hour !== undefined;
    const hourValueStr = hasHour
        ? getHourValueStr(currentValue.hour, hasDayPeriod, hasLeadingZeroForHour)
        : undefined;
    const hourValue = hourValueStr !== undefined ? stringToNumber(hourValueStr) : undefined;
    const dayPeriodValueStr = hasDayPeriod && hasHour ? getDayPeriodValueStr(locale, currentValue.hour) : undefined;
    const dayPeriodValue = dayPeriodValueStr !== undefined ? getDayPeriodValueFromHour(currentValue.hour) : undefined;
    const minuteValueStr = currentValue?.minute === undefined ? undefined : padWithZero(currentValue.minute, 2);
    const secondValueStr = currentValue?.second === undefined ? undefined : padWithZero(currentValue.second, 2);
    const millisecondValueStr = currentValue?.millisecond === undefined ? undefined : padWithZero(currentValue.millisecond, 3);
    const isBaseTimeComplete = hourValue !== undefined &&
        minuteValue !== undefined &&
        (granularity !== 'second' || secondValue !== undefined) &&
        (granularity !== 'millisecond' ||
            (secondValue !== undefined && millisecondValue !== undefined));
    const isCompleteTime = isBaseTimeComplete && (!hasDayPeriod || dayPeriodValue !== undefined);
    // A time is considered a partial time if at least one segment has a value.
    // We need to make sure we look at the granularity, though. The time might have milliseconds only set,
    // but if milliseconds isn't in the orderedSegments, it is not a partial time.
    const isPartialTime = hourValue !== undefined ||
        minuteValue !== undefined ||
        ((granularity === 'second' || granularity === 'millisecond') && secondValue !== undefined) ||
        (granularity === 'millisecond' && millisecondValue !== undefined);
    const secondSeg = [
        {
            type: 'second',
            'aria-label': ariaLabels.second,
            'aria-valuemin': 0,
            'aria-valuemax': MINUTE_SECOND_MAX,
            'aria-valuenow': secondValue,
            'aria-valuetext': secondValueStr,
            hasLeadingZeros: true,
            isComplete: secondValue !== undefined,
            isSelected: false,
            text: secondValueStr
        }
    ];
    const millisecondSeg = [
        {
            type: 'millisecond',
            'aria-label': ariaLabels.millisecond,
            'aria-valuemin': 0,
            'aria-valuemax': MILLISECOND_MAX,
            'aria-valuenow': millisecondValue,
            'aria-valuetext': millisecondValueStr,
            hasLeadingZeros: true,
            isComplete: millisecondValueStr !== undefined,
            isSelected: false,
            text: millisecondValueStr
        }
    ];
    const dayPeriodSeg = [
        {
            type: 'dayPeriod',
            amPm: getAmPmStringsForLocale(locale),
            'aria-label': ariaLabels.dayPeriod,
            'aria-valuemin': AM_VALUE$1,
            'aria-valuemax': PM_VALUE$1,
            'aria-valuenow': dayPeriodValue,
            'aria-valuetext': dayPeriodValueStr,
            isComplete: dayPeriodValueStr !== undefined,
            isSelected: false,
            text: dayPeriodValueStr
        }
    ];
    // Create state for each editable segment of a time.
    // This does not have to be in order that you see it rendered.
    // The orderedSegments show the order.
    // The timeMasks show the order as well.
    // hour and minute are required segments.
    // hour will be 1-12 if the masks have a 'dayPeriod' part (e.g., 1:00 PM), otherwise the hour is 0-23 (e.g., 13:00).
    const editableSegments = [
        {
            type: 'hour',
            'aria-label': ariaLabels.hour,
            'aria-valuemin': hasDayPeriod ? 1 : 0,
            'aria-valuemax': hasDayPeriod ? 12 : 23,
            'aria-valuenow': hourValue,
            'aria-valuetext': hourValueStr,
            hasLeadingZeros: hasLeadingZeroForHour,
            isComplete: hourValue !== undefined,
            isSelected: false,
            text: hourValueStr
        },
        {
            type: 'minute',
            'aria-label': ariaLabels.minute,
            'aria-valuemin': 0,
            'aria-valuemax': MINUTE_SECOND_MAX,
            'aria-valuenow': minuteValue,
            'aria-valuetext': minuteValueStr,
            hasLeadingZeros: true,
            isComplete: minuteValue !== undefined,
            isSelected: false,
            text: minuteValueStr
        },
        ...(granularity === 'second' || granularity === 'millisecond' ? secondSeg : []),
        ...(granularity === 'millisecond' ? millisecondSeg : []),
        ...(hasDayPeriod ? dayPeriodSeg : [])
    ];
    // Done deriving the data for our initial state,
    // now create the initial state object to pass to our reducer.
    const initialState = {
        committing: false,
        currentTime: currentValue,
        isCompleteTime,
        isTimeAutoFilled: false,
        isTimeSelected: false,
        isPartialTime,
        orderedSegments,
        segments: editableSegments
    };
    return initialState;
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
function isMobile() {
    const deviceType = getClientHints().deviceType;
    return deviceType === 'phone' || deviceType === 'tablet';
}
/**
 * A hook that creates various handlers and manages effects for a TimeField.
 * This is extremely similar to useDateFieldHandler, and it shouldn't be too hard to share code.
 */
const useTimeFieldHandlers = ({ timeResetRef, direction, dispatch, groupRef, isDisabled, isFocused, isInputFocused, onCommit, onInput, state, value: currentValue }) => {
    const { tabbableModeProps: { tabIndex: tabbableModeIndex } } = useTabbableMode();
    const anySegmentSelected = state.segments.some((segment) => !!segment.isSelected);
    // If any segment is selected, it is contenteditable=true and it has the focus. If you shift-Tab, you will
    // land on the outer div (TimeField) first meaning it takes 2 shift-tab keys to get the previous element.
    // To prevent this, if any segment is selected the tabindex on the div is set to -1.
    // We also need to set tabindex to -1 for the disabled case, since we are dealing with a div instead
    // of an intrinsic input and have to handle it directly.
    const updatedTabIndex = tabbableModeIndex === -1 || anySegmentSelected || isDisabled ? -1 : 0;
    // Keep track of the last changed and last committed time values.
    const lastTimeRef = useRef(state.currentTime);
    const lastCommittedTimeRef = useRef(state.currentTime);
    // Keep track whether the time was cleared.
    const timeClearedRef = useRef(false);
    const lastFocusedRef = useRef(!!isFocused);
    // If the value was programmatically changed (see useTimeField.ts), then update the
    // last changed and last committed date refs to stay in sync.
    // currentValue is the controlled value passed from the parent.
    if (timeResetRef.current) {
        lastTimeRef.current = currentValue;
        lastCommittedTimeRef.current = currentValue;
    }
    // Handle requested segment changes by calling the reducer dispatch function.
    const onChange = useCallback((action) => {
        dispatch(action);
    }, [dispatch]);
    // If the user clicked on a segment, dispatch a request to select it.
    // If they clicked on the time field itself, select the first segment.
    const onClick = useCallback((e) => {
        const segmentType = e.target.getAttribute('data-segment');
        if (segmentType !== null) {
            dispatch({ actionType: 'selectSegment', data: { type: segmentType } });
        }
        else {
            dispatch({ actionType: 'selectFirst' });
        }
    }, [dispatch]);
    // If complete, select the time.
    const selectAll = useCallback((isGroupFocus = true) => {
        if (state.isCompleteTime) {
            dispatch({ actionType: 'selectTime' });
            // Focus can end up in different places depending on if the user selected a segment
            // first (via click or arrow key), and then did select all. To make shift-tabbing
            // consistent in all cases, set focus to the group when selecting the time.
            isGroupFocus && groupRef?.current?.focus();
        }
    }, [dispatch, groupRef, state.isCompleteTime]);
    const onDoubleClick = useCallback(() => {
        selectAll();
    }, [selectAll]);
    const onDoubleTap = useCallback((e) => {
        const segmentType = e.target.getAttribute('data-segment');
        // Only do select all if a segment was double tapped, which means the
        // mobile keyboard will stay up.
        !!segmentType && selectAll(false);
    }, [selectAll]);
    const doubleTapHandlers = useDoubleTap({ onDoubleTap: onDoubleTap, onSingleTap: onClick });
    // Handle arrow key navigation between segments. If no segment is currently selected, then select the first one.
    const onKeyDown = useCallback((event) => {
        if ((direction === 'ltr' && event.key === 'ArrowLeft') ||
            (direction === 'rtl' && event.key === 'ArrowRight')) {
            // Select the previous segment when pressing Left arrow (or Right arrow in rtl).
            dispatch({ actionType: 'selectPrevious' });
            event.stopPropagation();
        }
        else if ((direction === 'ltr' && event.key === 'ArrowRight') ||
            (direction === 'rtl' && event.key === 'ArrowLeft')) {
            // Select the next segment when pressing Right arrow (or Left arrow in rtl).
            dispatch({ actionType: 'selectNext' });
            event.stopPropagation();
        }
        else if ((isBackspaceOrDelete(event) || event.key === 'Backspace') &&
            state.isTimeSelected) {
            // Clear the entire date.
            dispatch({ actionType: 'clearTime' });
            timeClearedRef.current = true;
            // Kill the event to prevent weird issue with placeholders getting deleted on iOS only.
            event.preventDefault();
            event.stopPropagation();
            event.stopImmediatePropagation();
        }
        else if (isSelectAll(event)) {
            selectAll();
            event.preventDefault();
            event.stopPropagation();
        }
        else if (event.key === 'Enter') {
            // Hitting Enter commits any changes.
            // This is also where we set 'AM' if hour is set, and AM isn't set.
            // This is where we set state.committing = true.
            dispatch({ actionType: 'commitOnEnter' });
            event.preventDefault();
            event.stopPropagation();
        }
    }, [direction, dispatch, selectAll, state.isTimeSelected]);
    // Blurring commits the time value; clear any selected segments and mark non-empty segments as complete.
    // Sets state.committing = true.
    if (lastFocusedRef.current && !isFocused) {
        dispatch({ actionType: 'commitOnBlur' });
    }
    lastFocusedRef.current = !!isFocused;
    if (state.committing) {
        // Call onCommit only if the value is different.
        if (timesAreDifferent(lastCommittedTimeRef.current, state.currentTime)) {
            // freeze the object so that the app developer can't change it.
            const frozeTime = state.currentTime !== undefined
                ? Object.freeze({ ...state.currentTime })
                : state.currentTime;
            onCommit?.({ value: frozeTime });
        }
        // This will update the state.committing to false.
        dispatch({ actionType: 'committed' });
        lastCommittedTimeRef.current = state.currentTime;
    }
    if (timesAreDifferent(lastTimeRef.current, state.currentTime) && !timeResetRef.current) {
        // freeze the object so that the app developer can't change it.
        const frozeTime = state.currentTime !== undefined ? Object.freeze({ ...state.currentTime }) : state.currentTime;
        onInput({ value: frozeTime });
        lastTimeRef.current = frozeTime;
    }
    timeResetRef.current = false;
    // The following is a simplified version of how we detect keyboard vs. mouse focus
    // in the useCollectionFocusRing hook. If the user tabs onto the field, we want to
    // automatically select the first segment.
    const recentPointerRef = useRef(false);
    const pointerDownTimerRef = useRef();
    const onPointerDown = useCallback(() => {
        recentPointerRef.current = true;
        clearTimeout(pointerDownTimerRef.current);
        pointerDownTimerRef.current = setTimeout(() => {
            recentPointerRef.current = false;
        }, 200);
    }, []);
    // use ref to keep track of isInputFocused changed.
    const lastInputFocusedRef = useRef(false);
    // If we receive focus that is *not* due to the user clicking in the field, i.e. the user
    // tabbed onto the field, then select the first segment. (!recentPointerRef.current means the mouse wasn't used in the component).
    // Note: we cannot check isFocused because it includes the ? icon in compact UAD, and we don't
    // want the time selected when the help icon is focused.
    // Every call to the reducer is always producing a new object and then when we create a new object, this hook gets called again. There are libraries that would fix this.
    if (isInputFocused && !lastInputFocusedRef.current && !recentPointerRef.current) {
        dispatch({ actionType: 'selectFirst' });
    }
    // If the keyboard was used and we have changed from focused on the input to not focused on the input, i.e. shift-tabbing onto the compact UAD help icon,
    // then 'deselectAndComplete' which will unselect any selected segments and mark them complete. It also auto-fills at this point if necessary.
    // The spec says, "If the user tabs out of the field after entering a valid value in the hours segment, the rest of the segments will autofill with 00 and AM/PM
    // so that the value is complete."
    // TODO: !recentPointerRef.current is true even if I use the mouse to blur,
    // so this dispatch gets called as well as the regular blur. I can maybe protect against this by checking isFocused, no that didn't work for some reason isFocused is still true at this point.
    // JET-71717 blurring from component triggers two actions
    if (!isInputFocused && lastInputFocusedRef.current && !recentPointerRef.current) {
        dispatch({ actionType: 'deselectAndComplete' });
    }
    // If the inputFocus has changed, then set recentPointerRef.current to false to not wait until the timeout, and update the lastInputFocusedRef.
    // Setting refs does not cause a re-render.
    // TODO: Denise, why do we reset the recentPointerRef to false? We do this in useDateFieldHandler. All my tests pass without this, and demos works fine, but maybe you had a problem that this fixed in useDateFieldHandler.
    if (isInputFocused !== lastInputFocusedRef.current) {
        recentPointerRef.current = false;
        lastInputFocusedRef.current = !!isInputFocused;
    }
    const handlers = isMobile()
        ? { ...doubleTapHandlers, onKeyDown }
        : { onClick, onDoubleClick, onKeyDown, onPointerDown };
    return {
        timeClearedRef,
        timeFieldHandlers: isDisabled ? {} : handlers,
        segmentHandlers: isDisabled ? {} : { onChange },
        tabIndex: updatedTabIndex
    };
};

const findSegment = (segments, type) => {
    return segments.find((segment) => segment.type === type);
};
/**
 * Container for Segment children that represent different parts of a time with no date.
 */
const TimeField = ({ 'aria-describedby': describedBy, 'aria-invalid': ariaInvalid, 'aria-label': ariaLabel, 'aria-labelledby': ariaLabelledBy, baseId, fieldRef, granularity = 'minute', hasLeadingZeroForHour, hasInsideLabel, isRequired, masks: timeMasks, onBlur, onCommit, onFocus, onInput, testId, textAlign, value, variant = 'default' }) => {
    const { direction, locale } = useUser();
    const { am, pm } = useMemo(() => {
        return getAmPmStringsForLocale(locale);
    }, [locale]);
    const translations = useTranslationBundle('@oracle/oraclejet-preact');
    const announceTimeCleared = translations.inputTimeMask_time_cleared();
    const labels = {
        hour: translations.formControl_hour(),
        minute: translations.formControl_minute(),
        second: translations.formControl_second(),
        millisecond: translations.formControl_millisecond(),
        dayPeriod: `${am}/${pm}`
    };
    const { isDisabled, isFocused, isInputFocused } = useFormFieldContext();
    const hasValue = value !== undefined;
    // TimeField is similar to TextFieldInput for styling. The main difference
    // is TextFieldInput renders a textarea or input and TimeField renders a div, so the positioning with
    // padding is different. TimeField and TextFieldInput are both the mainContent
    // of a TextField component.
    const { classes } = useComponentTheme(TextFieldInputRedwoodTheme, {
        type: 'notPassword',
        styleVariant: isEmbeddedVariant(variant) ? 'embedded' : 'default',
        textarea: 'notTextArea',
        input: 'notInput',
        div: 'isDiv',
        prefix: 'noPrefix',
        suffix: 'noSuffix',
        startContent: 'noStartContent',
        endContent: 'noEndContent',
        insideLabel: hasInsideLabel ? 'hasInsideLabel' : 'noInsideLabel',
        value: hasValue ? 'hasValue' : 'noValue',
        focused: isFocused ? 'isFocused' : 'notFocused',
        disabled: isDisabled ? 'isDisabled' : 'notDisabled'
    });
    const compClasses = classNames([classes]);
    const { state, dispatch, timeResetRef } = useTimeField({
        ariaLabels: labels,
        timeMasks,
        granularity,
        hasLeadingZeroForHour,
        locale,
        value
    });
    const { isTimeSelected, isPartialTime, segments: editableSegments } = state;
    const hourSegment = findSegment(editableSegments, 'hour');
    const minuteSegment = findSegment(editableSegments, 'minute');
    const secondSegment = granularity === 'second' || granularity === 'millisecond'
        ? findSegment(editableSegments, 'second')
        : undefined;
    const millisecondSegment = granularity === 'millisecond' ? findSegment(editableSegments, 'millisecond') : undefined;
    const dayPeriodSegment = findSegment(editableSegments, 'dayPeriod');
    const segmentsMap = {
        hour: hourSegment,
        minute: minuteSegment,
        second: secondSegment,
        millisecond: millisecondSegment,
        dayPeriod: dayPeriodSegment
    };
    const groupRef = useRef(null);
    const { timeFieldHandlers, timeClearedRef, segmentHandlers, tabIndex } = useTimeFieldHandlers({
        timeResetRef,
        direction,
        dispatch,
        groupRef,
        isDisabled,
        isFocused,
        isInputFocused,
        onCommit,
        onInput,
        state,
        value
    });
    // Like other form components, don't show placeholders for inside labels unless focused.
    // This flag causes the segment placeholders to be hidden.
    const isHidden = value === undefined && hasInsideLabel && !isFocused;
    // If the time is complete, create a hidden accessible region with the full formatted time.
    const formattedTimeStr = !state.isCompleteTime
        ? ''
        : formatTimeFromMasks(locale, state.currentTime, granularity, timeMasks, hasLeadingZeroForHour);
    const formattedTimeAriaId = `${baseId}-time`;
    const formattedTimeAria = state.isCompleteTime ? (jsx(HiddenAccessible, { id: formattedTimeAriaId, children: formattedTimeStr })) : undefined;
    const ariaDescribedBy = state.isCompleteTime
        ? l([describedBy, formattedTimeAriaId])
        : describedBy;
    // Add an announcement to the live region if the time was cleared.
    // Note: we deliberately do not reset timeClearedRef because there are multiple
    // rerenders after clearing the time and we want to make sure the announcement
    // has time to be heard.
    const announceTimeClearedText = timeClearedRef.current ? announceTimeCleared : '';
    const announceAutoFilledTime = state.isTimeAutoFilled ? formattedTimeStr : '';
    // firstSegmentType is used to determine on what TimeSegment to put the fieldRef,
    // and fieldRef is a ref to the element that receives focus when the field's label is clicked.
    const firstSegmentType = state.orderedSegments[0];
    return (jsxs("div", { "aria-describedby": ariaDescribedBy, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, class: compClasses, onFocusIn: onFocus, onFocusOut: onBlur, ref: groupRef, role: "group", tabIndex: tabIndex, ...timeFieldHandlers, children: [jsx(Flex, { direction: "row", wrap: "nowrap", justify: textAlign, children: timeMasks.map(({ type, value: placeholder }) => {
                    const segmentProps = type !== 'literal' ? segmentsMap[type] : {};
                    if (type === 'literal') {
                        return (jsx(LiteralSegment, { isHidden: isHidden, isHighlighted: isTimeSelected, isPlaceholder: !isPartialTime, text: placeholder }));
                    }
                    else {
                        return (jsx(TimeSegment, { inputRef: type === firstSegmentType ? fieldRef : undefined, isDisabled: isDisabled, isInvalid: !!ariaInvalid, isHidden: isHidden, isHighlighted: isTimeSelected, isRequired: isRequired, placeholder: placeholder, type: type, ...segmentHandlers, ...segmentProps }));
                    }
                }) }), formattedTimeAria, !isDisabled && jsx(LiveRegion, { children: announceTimeClearedText }), !isDisabled && (jsx(LiveRegion, { testId: testId ? testId + '_autoFilledTime' : undefined, children: announceAutoFilledTime }))] }));
};

/**
 * An InputTimeMask allows the user to enter, edit, or display a time value.
 */
const InputTimeMask = forwardRef(({ 'aria-describedby': ariaDescribedBy, assistiveText, columnSpan, endContent, granularity = 'minute', helpSourceLink, helpSourceText, hourClock = 'fromLocale', isDisabled: propIsDisabled, isReadonly: propIsReadonly, isRequired, isRequiredShown, label, labelEdge: propLabelEdge, labelStartWidth: propLabelStartWidth, leadingZeroForHour = 'fromLocale', mainFieldRef, messages, masks, testId, textAlign: propTextAlign, userAssistanceDensity: propUserAssistanceDensity, value, variant, onCommit, onInput }, ref) => {
    const { isDisabled: isFormDisabled, isReadonly: isFormReadonly, labelEdge: formLabelEdge, labelStartWidth: formLabelStartWidth, textAlign: formTextAlign, userAssistanceDensity: formUserAssistanceDensity } = useFormContext();
    // default to FormContext values if component properties are not specified
    const isDisabled = propIsDisabled ?? isFormDisabled;
    const isReadonly = propIsReadonly ?? isFormReadonly;
    const labelEdge = propLabelEdge ?? formLabelEdge;
    const labelStartWidth = propLabelStartWidth ?? formLabelStartWidth;
    // JET-72775 - Form control alignment in tables
    // default to 'start' if no text align is set
    const textAlign = propTextAlign ?? formTextAlign ?? 'start';
    const userAssistanceDensity = propUserAssistanceDensity ?? formUserAssistanceDensity;
    const enabledElementRef = useRef(null);
    const readonlyElementRef = useRef(null);
    const { focusProps, isFocused, methods: focusMethods } = useFocusableTextField({
        isDisabled,
        isReadonly,
        enabledElementRef,
        readonlyElementRef
    });
    useImperativeHandle(ref, () => focusMethods, [focusMethods]);
    const isComponentFocused = isFocused;
    const { baseId, formFieldContext, inputProps, labelProps: origLabelProps, textFieldProps, userAssistanceProps } = useTextField({
        ariaDescribedBy,
        helpSourceLink,
        helpSourceText,
        isDisabled,
        isFocused: isComponentFocused,
        isReadonly,
        isRequiredShown,
        labelEdge,
        messages,
        styleVariant: variant,
        userAssistanceDensity,
        value
    });
    // When using a div with role=group (i.e. TimeField), you need aria-labelledby instead of a
    // for-id association with a label. Remove forId and id and use aria-labelledby instead.
    const { forId, ...labelProps } = origLabelProps;
    const { id, ...timeFieldProps } = inputProps;
    const ariaLabelledBy = labelProps.id;
    // Because we don't use for-id, clicking the label does not automatically focus the field.
    // We have to do it manually.
    const onClick = useCallback(() => {
        enabledElementRef.current?.focus();
    }, [enabledElementRef]);
    const labelComp = labelEdge !== 'none' ? (jsx(Label, { ...(!isDisabled && !isReadonly ? { onClick } : {}), ...labelProps, children: label })) : undefined;
    const fieldLabelProps = {
        label: labelEdge !== 'none' ? labelComp : undefined,
        labelEdge: labelEdge !== 'none' ? labelEdge : undefined,
        labelStartWidth: labelEdge !== 'none' ? labelStartWidth : undefined,
        labelText: labelEdge === 'inside' && !isDisabled ? label : undefined
    };
    const ariaLabel = labelEdge === 'none' ? label : undefined;
    const hasInsideLabel = label !== undefined && labelEdge === 'inside';
    const isInlineDensity = userAssistanceDensity === 'efficient' || userAssistanceDensity === 'reflow';
    const inlineUserAssistance = isInlineDensity ? (isDisabled ? (
    // save space for user assistance if density is 'efficient', even though we don't
    // render user assistance for disabled fields
    userAssistanceDensity !== 'efficient' ? undefined : (jsx(InlineUserAssistance, { userAssistanceDensity: userAssistanceDensity, ...userAssistanceProps }))) : isReadonly ? (jsx(InlineUserAssistance, { fieldLabel: label, messages: messages, userAssistanceDensity: userAssistanceDensity, ...userAssistanceProps })) : (jsx(InlineUserAssistance, { assistiveText: assistiveText, fieldLabel: label, helpSourceLink: helpSourceLink, helpSourceText: helpSourceText, messages: messages, isRequiredShown: isRequiredShown, userAssistanceDensity: userAssistanceDensity, ...userAssistanceProps }))) : undefined;
    const aRef = useRef(null);
    const anchorRef = mainFieldRef ?? aRef;
    const compactUserAssistance = userAssistanceDensity === 'compact' ? (jsx(CompactUserAssistance, { anchorRef: anchorRef, messages: messages, assistiveText: assistiveText, ...userAssistanceProps })) : undefined;
    const { locale } = useUser();
    // Make sure the masks and properties do not conflict. This throws an error if they do conflict.
    validateTimeMasksAgainstProperties(masks, granularity, hourClock);
    // hour12 is true or false or undefined in TimeField because it is passed directly to Intl.DateTimeFormat and this is the api for that.
    let hour12;
    if (masks !== undefined && hourClock === 'fromLocale') {
        // If we have masks and the hourClock is set to 'fromLocale' which is the default as well, then we look at the masks
        // to set what hour12 we want to pass on to TimeField. If masks include a dayPeriod, then hour12 is true.
        const hasDayPeriod = masks.find((part) => part.type === 'dayPeriod') !== undefined;
        hour12 = hasDayPeriod;
    }
    else {
        hour12 = hourClock === '12' ? true : hourClock === '24' ? false : undefined;
    }
    // masks look like this:
    // const masks: TimePlaceholder = [
    //   {type: 'dayPeriod', value: 'am/pm'},
    //   {type: 'hour', value: 'hh'},
    //   {type: 'literal', value: ':'},
    //   {type: 'minute', value: 'mm'}
    // ]
    const timeMasks = useMemo(() => {
        // Determine the locale specific placeholder masks and separators in the correct order
        // for the locale, unless a custom set of masks was passed in. Each mask represents a
        // placeholder for a segment of a time. The hour/minute/second/millisecond's order never changes.
        // The dayPeriod segment can change: it can be at the start or at the end.
        // Memoize because we shouldn't need to recreate this data often.
        const placeholderMasks = masks
            ? replaceCustomMasksValuesWithPlaceholders(locale, masks) // no need to pass in hourClock. if masks has dayPeriod, then we use it since we checked before this if mask has dayPeriod and hour 12 is explicitly set to false, we throw an error.
            : // we get masks from locale.
                // hour12, if explicitly set, will take precedence.
                // This works: new Intl.DateTimeFormat('en-GB', {timeStyle: 'short', hour12: true}).format(datetime),
                getTimeMasksFromLocaleAndOptions(locale, granularity, hour12);
        return placeholderMasks;
    }, [granularity, hour12, locale, masks]);
    // We want the app dev to be able to force the hour to have a leading zero or force the hour to not have a leading zero.
    // This is useful for user preferences where the user wants the time to be in a particular format that is different than their locale.
    // Most commonly apps want to determine the leading zero from the locale, and therefore that is the default.
    const resolvedHasLeadingZeroForHour = leadingZeroForHour === 'fromLocale'
        ? getLeadingZeroForHour(locale)
        : leadingZeroForHour === 'show';
    if (isReadonly) {
        return (jsx(FormFieldContext.Provider, { value: formFieldContext, children: jsx(ReadonlyTextField, { role: "presentation", columnSpan: columnSpan, compactUserAssistance: compactUserAssistance, inlineUserAssistance: inlineUserAssistance, onBlur: focusProps.onFocusOut, onFocus: focusProps.onFocusIn, ref: anchorRef, testId: testId, mainContent: jsx(ReadonlyTextFieldInput, { "aria-describedby": timeFieldProps['aria-describedby'], "aria-label": ariaLabel, "aria-labelledby": labelProps.id, as: "div", elementRef: readonlyElementRef, textAlign: textAlign, value: value === undefined
                        ? ''
                        : formatTimeFromMasks(locale, value, granularity, timeMasks, resolvedHasLeadingZeroForHour), hasEmptyLabel: label === '' && labelEdge === 'none', hasInsideLabel: hasInsideLabel, onBlur: inputProps.onBlur, onFocus: inputProps.onFocus }), ...fieldLabelProps }) }));
    }
    // The main content inside TextField is a TimeField (not TextFieldInput) in this case.
    // We reuse the TextField building blocks and hooks, but recompose them.
    const mainContent = (jsx(TimeField, { "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, baseId: baseId, fieldRef: enabledElementRef, granularity: granularity, hasInsideLabel: labelComp !== undefined && labelEdge === 'inside', hasLeadingZeroForHour: resolvedHasLeadingZeroForHour, isRequired: isRequired, masks: timeMasks, onCommit: onCommit, onInput: onInput, testId: testId ? testId + '_timeField' : undefined, textAlign: textAlign, value: value, ...timeFieldProps }));
    return (jsx(FormFieldContext.Provider, { value: formFieldContext, children: jsx(TextField, { columnSpan: columnSpan, compactUserAssistance: compactUserAssistance, endContent: endContent, inlineUserAssistance: inlineUserAssistance, mainContent: mainContent, onBlur: focusProps.onFocusOut, onFocus: focusProps.onFocusIn, mainFieldRef: anchorRef, testId: testId, ...textFieldProps, ...fieldLabelProps }) }));
});
/**
 * This function checks the following:
 * - If both 'masks' and 'hourClock' are provided, it ensures that the 'hourClock' flag matches the presence of a 'dayPeriod' in the 'masks'.
 * - It verifies that the 'masks' contain the correct time placeholders based on the granularity.
 *
 * It throws an error if anything is not set correctly.
 * It never throws an error if masks is undefined; it just returns.
 * @param masks
 * @param granularity
 * @param hourClock
 * @throws if there is a conflict between masks and the granularity and hourClock properties.
 */
const validateTimeMasksAgainstProperties = (masks, granularity, hourClock) => {
    if (masks === undefined) {
        return;
    }
    // If the user passes in masks and hourClock, we look at masks to see what the hourClock should be.
    // If hourClock is passed in and it is different than what we expect, we throw an error.
    if (hourClock !== undefined && hourClock !== 'fromLocale') {
        const hasDayPeriod = masks.find((part) => part.type === 'dayPeriod') !== undefined;
        if (!hasDayPeriod && hourClock === '12') {
            throw new Error(`The masks object does not have a dayPeriod property. hourClock should be set to '24' to match masks.`);
        }
        if (hasDayPeriod && hourClock === '24') {
            throw new Error(`The masks object does have a dayPeriod property. hourClock should be set to '12' to match masks.`);
        }
    }
    // Type checking will make sure hour and minute are there since they are required.
    // Throw errors if masks does not contain the properties it should based on granularity.
    const hasSecond = masks.find((part) => part.type === 'second') !== undefined;
    const hasMillisecond = masks.find((part) => part.type === 'millisecond') !== undefined;
    const commonErrorMsg = `Change granularity to match the properties you have in the masks object.`;
    if (granularity === 'second' && !hasSecond) {
        const errorMsg = `granularity is second, but the masks does not contain the second property. 
      ${commonErrorMsg}`;
        throw new Error(errorMsg);
    }
    if (granularity === 'second' && hasMillisecond) {
        const errorMsg = `granularity is second, but the masks object contains the millisecond property. 
      ${commonErrorMsg}`;
        throw new Error(errorMsg);
    }
    if (granularity === 'millisecond' && (!hasSecond || !hasMillisecond)) {
        const errorMsg = `"Granularity is set to millisecond. The masks object should contain both the second and millisecond properties, but one or both are missing." 
      ${commonErrorMsg}`;
        throw new Error(errorMsg);
    }
    if (granularity === 'minute') {
        if (hasSecond || hasMillisecond) {
            throw new Error(`granularity is minute, but the masks object contains the second and/or millisecond property.
        ${commonErrorMsg}`);
        }
    }
};

export { InputTimeMask };
//# sourceMappingURL=UNSAFE_InputTimeMask.js.map
