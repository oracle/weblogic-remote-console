/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
import { ComponentProps } from 'preact';
import type { BCP47Locale } from "../UNSAFE_IntlDateTime";
import type { TimeSegment } from './TimeSegment';
import type { EditableTimeSegmentType, OrderedTimeSegmentsArray, Time, TimeGranularity, TimePlaceholders } from './types';
import { TimeField } from './TimeField';
type TimeFieldType = ComponentProps<typeof TimeField>;
type UseTimeFieldProps = {
    ariaLabels: Record<EditableTimeSegmentType, string>;
    granularity: TimeGranularity;
    hasLeadingZeroForHour: boolean;
    locale: BCP47Locale;
    timeMasks: TimePlaceholders;
    value?: TimeFieldType['value'];
};
type TimeSegmentState = Readonly<ComponentProps<typeof TimeSegment> & {
    /** The current digit count for the segment. When the segment is complete or cleared, this will be set to 0.
     * This is useful for figuring out if the segment is complete.
     */
    digitCount?: number;
    /**
     * True if the segment has leading zeros. minute, second, millisecond always have leading zeros, but hour might not;
     * it is based on the locale, and can be overridden with the InputTimeMask's leadingZeroForHour api.
     * Most h23 clocks use a leading zero, and most h12 clocks do not.
     */
    hasLeadingZeros?: boolean;
    /**
     * True if the segment is auto-filled. If any segment has isAutoFilled set to true,
     * then the TimeFieldState's isTimeAutoFilled is set to true, and isTimeAutoFilled is
     * used to figure out when to render an aria-live region with the full time so
     * a screen reader user will know the time has been auto-filled.
     */
    isAutoFilled?: boolean;
}>;
type TimeFieldState = {
    readonly committing: boolean;
    readonly currentTime: Time | undefined;
    readonly isCompleteTime: boolean;
    /**
     * This will be true if any segment has isAutoFilled set to true.
     * This is used to figure out when to render an aria-live region with the full time so
     * a screen reader user will know the time has been auto-filled.
     */
    readonly isTimeAutoFilled: boolean;
    readonly isTimeSelected: boolean;
    readonly isPartialTime: boolean;
    /**
     * An array of the name of each segment type in the order they appear to the user.
     * E.g., ['hour', 'minute, 'dayPeriod'], when the InputTimeMask component shows the hour, minute, and dayPeriod segments in that order.
     * E.g., ['hour', 'minute', 'second'] when the InputTimeMask component shows the hour, minute, and second segments in that order.
     */
    readonly orderedSegments: OrderedTimeSegmentsArray;
    readonly segments: TimeSegmentState[];
};
/**
 * Hook that returns a TimeFieldState and a dispatch method to request changes to that state.
 *
 * This hook determines the initial state based on the provided input properties
 * and utilizes a reducer (`timeReducer`) to initialize the state.
 *
 * **Important**: Ensure that the `timeMasks` include all placeholders required by the specified `granularity`.
 * For example, if `granularity` is "second",
 * the `timeMasks` must include the second placeholder. Since 'InputTimeMask' does this validation,
 * it is not done here in the hook for efficiency sake.
 * @param {Object} props - Configuration properties for the hook.
 * @param {AmPmLocalizedValues} props.amPm - An Object containing a localized string for 'am' and one for 'pm'.
 * @param {Record<EditableTimeSegmentType, string>} props.ariaLabels - ARIA labels for each editable time segment type.
 * @param {TimePlaceholders} props.timeMasks - The time placeholders representing the structure of the time format.
 * e.g.,
 * [ { type: 'hour', value: 'hh' }, { type: 'literal', value: ':' }, { type: 'minute', value: 'mm' }, { type: 'literal', value: ' ' }, { type: 'dayPeriod', value: 'am/pm' } ]
 * @param {TimeGranularity} props.granularity - Specifies the smallest time unit that is displayed by the component.
 * @param {BCP47Locale} props.locale - The locale used for formatting the time.
 * @param {boolean} [props.hasLeadingZeroForHour] - Whether to show a leading zero in the hour field when there is only one digit or not. E.g., 01:00 AM vs 1:00 AM.
 * @param {Time | undefined} [props.value] - The current time value.
 * @returns An object containing the current 'state', a 'dispatch' function, and timeResetRef.
 */
declare const useTimeField: ({ ariaLabels, granularity, hasLeadingZeroForHour, locale, timeMasks, value: currentValue }: UseTimeFieldProps) => {
    timeResetRef: import("preact/hooks").MutableRef<boolean>;
    dispatch: import("preact/hooks").Dispatch<import("./timeReducer").TimeFieldAction | {
        actionType: "reset";
        data: TimeFieldState;
    }>;
    state: TimeFieldState | {
        committing: boolean;
        currentTime: Time | Record<string, number | undefined> | undefined;
        isTimeAutoFilled: boolean;
        isCompleteTime: boolean;
        isTimeSelected: boolean;
        isPartialTime: boolean;
        orderedSegments: OrderedTimeSegmentsArray;
        segments: Readonly<{
            'aria-label'?: string | undefined;
            'aria-valuemax'?: number | undefined;
            'aria-valuemin'?: number | undefined;
            'aria-valuenow'?: number | undefined;
            'aria-valuetext'?: string | undefined;
        } & {
            amPm?: import("#utils/UNSAFE_timeUtils").AmPmLocalizedValues;
            inputRef?: import("preact").RefObject<HTMLDivElement>;
            isComplete?: boolean;
            isDisabled?: boolean;
            isHidden?: boolean;
            isHighlighted?: boolean;
            isInvalid?: boolean;
            isRequired?: boolean;
            isSelected?: boolean;
            placeholder?: string;
            text?: string;
            type: EditableTimeSegmentType;
            onChange?: (action: import("./timeReducer").TimeFieldAction) => void;
        } & {
            /** The current digit count for the segment. When the segment is complete or cleared, this will be set to 0.
             * This is useful for figuring out if the segment is complete.
             */
            digitCount?: number;
            /**
             * True if the segment has leading zeros. minute, second, millisecond always have leading zeros, but hour might not;
             * it is based on the locale, and can be overridden with the InputTimeMask's leadingZeroForHour api.
             * Most h23 clocks use a leading zero, and most h12 clocks do not.
             */
            hasLeadingZeros?: boolean;
            /**
             * True if the segment is auto-filled. If any segment has isAutoFilled set to true,
             * then the TimeFieldState's isTimeAutoFilled is set to true, and isTimeAutoFilled is
             * used to figure out when to render an aria-live region with the full time so
             * a screen reader user will know the time has been auto-filled.
             */
            isAutoFilled?: boolean;
        }>[];
    };
};
export { useTimeField };
export type { TimeFieldState, TimeSegmentState };
