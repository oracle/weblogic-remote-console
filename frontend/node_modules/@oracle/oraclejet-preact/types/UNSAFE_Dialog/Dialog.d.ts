import type { ComponentChild, RefObject, JSX } from 'preact';
import { Offset, WindowOverlayPlacement } from '../UNSAFE_WindowOverlay';
import { TestIdProps } from '../hooks/UNSAFE_useTestId';
import type { UnpackSignals } from "../PRIVATE_oraclejet-internal-utilities/attributeUtils";
import { DimensionProps } from '../utils/UNSAFE_interpolations/dimensions';
import { Coords } from '../UNSAFE_Floating';
import { Position, Rect } from '../utils/UNSAFE_flexibleComponentUtils';
import type { UnsafeDomHandle } from "../utils/UNSAFE_unsafeDomAccess";
type IntrinsicProps = Pick<UnpackSignals<JSX.IntrinsicElements['div']>, 'children' | 'role'>;
type OnCloseDetail = {
    /**
     * reason for closing the dialog
     */
    reason: 'escapeKey' | 'icon';
};
export type CancelBehavior = 'none' | 'escape' | 'icon';
type DialogProps = IntrinsicProps & DimensionProps & {
    /**
     * Optional ref for an element to focus on when component mounts
     */
    autoFocusRef?: RefObject<{
        focus: () => void;
    }>;
    /**
     * On Close callback.
     */
    onClose?: (detail: OnCloseDetail) => void;
    /**
     * On opening or closing transition end callback.
     */
    onTransitionEnd?: (value: boolean) => void;
    /**
     * Determines whether the Dialog is open.
     */
    isOpen: boolean;
    /**
     * Dialog header content. Can be a string or VNode (Component Child).
     * <p>
     * When a plain string is passed, it will be used as the dialog title. Otherwise, the prop value
     * will be used as the header content.
     * </p>
     * <p>
     * Dialog will automatically refer to the header content as the accessible label.
     * The user can override this behavior by specifying the <code>aria-labelledby</code> property
     * and setting its value as needed.
     * </p>
     */
    header?: ComponentChild;
    /**
     * Dialog footer content.
     */
    footer?: ComponentChild;
    /**
     * Determines dialog modality. Default is 'modal'.
     */
    modality?: 'modal' | 'modeless';
    /**
     * Specifies dialog's cancel behavior. Default is 'none'.
     */
    cancelBehavior?: CancelBehavior;
    /**
     * Specifies dialog's launcher. After dialog closes, it returns focus to the launcher.
     * If not specified, focus goes back to the last active element before dialog opened.
     */
    launcherRef?: RefObject<HTMLElement | UnsafeDomHandle<HTMLElement>>;
    /**
     * Specifies dialog's anchor. Dialog is placed relative to its anchor. If not specified,
     * it is placed relatively to window.
     */
    anchorRef?: RefObject<Element | Coords>;
    /**
     * Determines placement of the dialog relative to the viewport.
     * Supported values are:
     * <p> <code>center</code>, <code>top</code>, <code>top-start</code>, <code>top-end</code>,
     * <code>end</code>, <code>end-top</code>, <code>end-bottom</code>,
     * <code>bottom</code>, <code>bottom-start</code>, <code>bottom-end</code>,
     * <code>start</code>, <code>start-top</code>, <code>start-bottom</code>
     * </p>
     * Default is <code>center</code>.
     */
    placement?: WindowOverlayPlacement;
    /**
     * Determines the offset of the Dialog from its core placement along the specified axes.
     *
     * Offset could be a number or an object
     *
     * An object has the following type:
     * <pre>
     *   {
     *     mainAxis?: number;
     *     crossAxis?: number;
     *   }
     * </pre>
     * For the <code>center</code> placement the convention for the offset type is that mainAxis defines
     * offset from the top, crossAxis defines offset from the left side of the view port.
     *
     * A number is a shortcut for setting the mainAxis.
     */
    offset?: Offset;
    /**
     * Determines if the Dialog should be sensitive to drag gestures. To create a draggable dialog,
     * set <code>dragAffordance='header'</code> and specify the <code>onDragMove</code> handler.
     */
    dragAffordance?: 'none' | 'header';
    /**
     * Determines if the Dialog should support resizing. To create a resizable dialog,
     * set <code>resizeBehavior='resizable'</code> and specify the <code>onResize</code> handler.
     */
    resizeBehavior?: 'none' | 'resizable';
    /**
     * Callback to be invoked if <code>dragAffordance</code> is set to <code>header</code> and a drag gesture is initiated.
     * The current position is reported in the <code>pos</code> parameter.
     *
     * @param pos
     */
    onDragStart?: (pos: Position) => void;
    /**
     * Callback to be invoked if <code>dragAffordance</code> is set to <code>header</code> and a drag gesture is detected.
     * The current position is reported in the <code>pos</code> parameter.
     *
     * @param pos
     */
    onDragMove?: (pos: Position) => void;
    /**
     * Callback to be invoked if <code>dragAffordance</code> is set to <code>header</code> and a drag gesture is completed.
     * The current position is reported in the <code>pos</code> parameter.
     *
     * @param pos
     */
    onDragEnd?: (pos: Position) => void;
    /**
     * Callback to be invoked if <code>resizeBehavior</code> is set to <code>resizable</code> and
     * a resize gesture is initiated. The current position and dimensions are reported in the
     * <code>rect</code> parameter.
     *
     * @param rect
     */
    onResizeStart?: (rect: Rect) => void;
    /**
     * Callback to be invoked if <code>resizeBehavior</code> is set to <code>resizable</code> and
     * a resize gesture is detected. The current position and dimensions are reported in the
     * <code>rect</code> parameter.
     *
     * @param rect
     */
    onResize?: (rect: Rect) => void;
    /**
     * Callback to be invoked if <code>resizeBehavior</code> is set to <code>resizable</code> and
     * a resize gesture is completed. The current position and dimensions are reported in the
     * <code>rect</code> parameter.
     *
     * @param rect
     */
    onResizeEnd?: (rect: Rect) => void;
    /**
     * Specifies callback triggered when initial focus is set or when a modeless dialog receives focus
     * via the F6 key.
     */
    onFocusSet?: () => void;
    /**
     * Determines if the header decoration should be displayed. The default is <code>on</code>
     * which renders a textured strip at the top of the dialog header in the Redwood theme.
     * If set to <code>off</code>, no decoration is rendered.
     */
    headerDecoration?: 'off' | 'on';
    /**
     * Specifies the ARIA role type. Depending on how the dialog is used in the page, the developer
     * should choose from the following:
     * <ul>
     *   <li><code>dialog</code> defines an application window that is designed to interrupt the current
     *      processing of an application in order to prompt the user to enter information or require
     *      a response.</li>
     *   <li><code>alertdialog</code> defines type of dialog that contains an alert message, where initial
     *      focus goes to an element within the dialog.</li>
     * </ul>
     */
    role?: string;
    /**
     * Optional <code>aria-labelledby</code> property referring to the content to be used as Dialog's
     * accessible <label htmlFor="" className=""></label>
     * If not specified, the Dialog will automatically refer to the entire header content as the accessible label.
     */
    'aria-labelledby'?: string;
    /**
     * Optional accessible description for the dialog.
     */
    'aria-describedby'?: string;
} & TestIdProps;
/**
 * WAI-ARIA-compliant dialog component. A dialog is a floating window that typically contains
 * a title bar and a content area.
 * The dialog is generally placed on top of the rest of the page content. It can be either modal
 * (only the content in the dialog can be interacted with) or non-modal (it's still possible
 * to interact with content outside of the dialog).
 */
export declare const Dialog: import("preact").FunctionalComponent<import("preact/compat").PropsWithoutRef<DialogProps> & {
    ref?: import("preact").Ref<HTMLDivElement | null> | undefined;
}>;
export {};
