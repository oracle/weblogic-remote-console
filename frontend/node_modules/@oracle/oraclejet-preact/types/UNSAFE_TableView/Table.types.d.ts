/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
import { ComponentChild, ComponentChildren, Ref, RefObject } from 'preact';
import { UnsafeDomHandle } from '../utils/UNSAFE_unsafeDomAccess';
import { Keys } from '../utils/UNSAFE_keys';
export type TableViewHandle<K, C> = {
    focus: () => void;
    getHorizontalScrollPosition: () => TableHorizontalScrollPosition<C>;
    getVerticalScrollPosition: () => TableVerticalScrollPosition<K>;
};
export type TableViewportConfig = {
    scroller: () => RefObject<HTMLElement>;
    scrollerOffsetTop?: number;
    scrollerOffsetBottom?: number;
    scrollerOffsetStart?: number;
    scrollerOffsetEnd?: number;
};
type ColumnSelectionMode = 'single' | 'multiple' | 'none';
type RowSelectionMode = 'single' | 'multiple' | 'multipleToggle' | 'none';
export type TableSelectionMode = {
    row?: RowSelectionMode;
    column?: ColumnSelectionMode;
};
export type TableHorizontalScrollPosition<C> = {
    columnKey?: C;
    offsetX?: number;
    x?: number;
};
export type TableVerticalScrollPosition<K> = {
    offsetY?: number;
    rowKey?: K;
    y?: number;
};
export type TableRowContext<K, D> = {
    data: D;
    key: K;
};
export type TableRendererContext<K, D, C> = {
    rowData: D;
    rowKey: K;
    columnKey: C;
    field?: keyof D;
    selector?: () => ComponentChildren;
    isTabbable: boolean;
};
type EnabledOrDisabled = 'enabled' | 'disabled';
export type TableHeaderRendererContext<C> = {
    key: C;
    headerText?: string;
    sortable?: EnabledOrDisabled;
    sortDirection?: 'ascending' | 'descending' | 'unsorted';
    selector?: () => ComponentChildren;
    isTabbable: boolean;
};
export type TableFooterRendererContext<C> = {
    key: C;
    footerText?: string;
    isTabbable: boolean;
};
export type TableNoDataRendererContext = {
    isTabbable: boolean;
};
export type RowActionDetail<K, D> = {
    context: TableRowContext<K, D>;
    target: EventTarget | null;
};
export type SortCriterionDetail<C> = {
    key: C;
    sortDirection: 'ascending' | 'descending';
}[];
export type ColumnWidths<C extends string> = Record<C, number>;
export type ColumnResizingDetail<C extends string> = {
    key: C;
    delta: number;
    allColumnWidths: ColumnWidths<C>;
    paddingWidth: number;
};
export type ColumnResizeDetail<C extends string> = {
    key: C;
    delta: number;
    newWidth?: never;
    allColumnWidths: ColumnWidths<C>;
    paddingWidth: number;
    gesture: 'contextMenu' | 'pointer';
    type: 'delta';
} | {
    key: C;
    delta?: never;
    newWidth: number;
    allColumnWidths: ColumnWidths<C>;
    paddingWidth: number;
    gesture: 'contextMenu' | 'pointer';
    type: 'absolute';
};
export type TableSelectionDetail<K, C> = {
    value: {
        row?: Keys<K>;
        column?: Keys<C>;
    };
    target: EventTarget | null;
};
type ComplexPadding = {
    bottom?: EnabledOrDisabled;
    end?: EnabledOrDisabled;
    start?: EnabledOrDisabled;
    top?: EnabledOrDisabled;
};
export type CellPadding = EnabledOrDisabled | ComplexPadding;
export type DataCellPadding<K, D> = CellPadding | ((context: TableRowContext<K, D>) => CellPadding);
export type DataCellTooltip<K, D> = EnabledOrDisabled | ((context: TableRowContext<K, D>) => EnabledOrDisabled);
type FocusTarget = 'cell' | 'content';
export type DataCellFocusTarget<K, D> = FocusTarget | ((context: TableRowContext<K, D>) => FocusTarget);
type HorizontalAlignment = 'start' | 'end' | 'left' | 'right' | 'center';
type VerticalAlignment = 'top' | 'center' | 'bottom';
type CellAlignment = {
    horizontal?: HorizontalAlignment;
    vertical?: VerticalAlignment;
};
/**
 * Type of the column object passed to the Table
 */
export type Column<K, D, C> = {
    /**
     * whether this column's header should be considered an accessible column header
     */
    accessibleColumnHeader?: EnabledOrDisabled;
    /**
     * data attribue for the column
     */
    field?: keyof D;
    /**
     * text for the column footer
     */
    footerText?: string;
    /**
     * text for the column header
     */
    headerText?: string;
    /**
     * optional renderer for cell contents
     */
    renderer?: (context: TableRendererContext<K, D, C>) => ComponentChildren;
    /**
     * optional renderer for header cell contents
     */
    headerRenderer?: (context: TableHeaderRendererContext<C>) => ComponentChildren;
    /**
     * optional renderer for footer cell contents
     */
    footerRenderer?: (context: TableFooterRendererContext<C>) => ComponentChildren;
    /**
     * whether this column is selectable
     */
    selectable?: EnabledOrDisabled;
    /**
     * whether this column should be prevented from scrolling out of view
     */
    sticky?: EnabledOrDisabled;
    /**
     * whether this column is sortable
     */
    sortable?: EnabledOrDisabled;
    /**
     * the padding specified for data cells in this column
     */
    padding?: DataCellPadding<K, D>;
    /**
     * the padding specified for the header cell in this column
     */
    headerPadding?: CellPadding;
    /**
     * the padding specified for the footer cell in this column
     */
    footerPadding?: CellPadding;
    /**
     * whether this column's edge is resizable via dnd
     */
    edgeResizable?: EnabledOrDisabled;
    /**
     * whether this column is resizable
     */
    resizable?: EnabledOrDisabled;
    /**
     * where focus should be set during keyboard navigation of the data cells in this column
     */
    focusTarget?: DataCellFocusTarget<K, D>;
    /**
     * where focus should be set during keyboard navigation of the header cell in this column
     */
    headerFocusTarget?: FocusTarget;
    /**
     * where focus should be set during keyboard navigation of the footer cell in this column
     */
    footerFocusTarget?: FocusTarget;
    /**
     * whether the data cells in this column support default tooltips
     */
    tooltip?: DataCellTooltip<K, D>;
    /**
     * whether the header cell in this column supports the default tooltip
     */
    headerTooltip?: EnabledOrDisabled;
    /**
     * whether the footer cell in this column supports the default tooltip
     */
    footerTooltip?: EnabledOrDisabled;
    /**
     * the maximum width in pixels of this column
     */
    maxWidth?: number;
    /**
     * the minimum width in pixels of this column
     */
    minWidth?: number;
    /**
     * the weight of the column
     */
    weight?: number;
    /**
     * the horizontal alignment of the column
     */
    horizontalAlignment?: HorizontalAlignment;
    /**
     * the alignment specified for data cells in this column
     */
    alignment?: CellAlignment;
    /**
     * the alignment specified for the header cell in this column
     */
    headerAlignment?: CellAlignment;
    /**
     * the alignment specified for the footer cell in this column
     */
    footerAlignment?: CellAlignment;
};
/**
 * Type for columns property of the Table.
 */
export type Columns<K, D, C extends string> = Record<C, Column<K, D, C>>;
/**
 * Type of the current cell passed to the Table
 */
export type Cell<K, C> = {
    rowKey: K;
    columnKey: C;
    type: 'data';
} | {
    rowKey?: never;
    columnKey: C;
    type: 'header' | 'footer';
} | {
    rowKey?: never;
    columnKey?: never;
    type: 'noData';
};
/**
 * Type of the current cell override passed to the Table
 */
export type CellOverride<K, C> = {
    rowKey: K;
    columnKey?: C;
    type?: 'data';
} | {
    rowKey?: K;
    columnKey: C;
    type?: 'data';
} | {
    rowKey?: K;
    columnKey?: C;
    type: 'data';
} | {
    rowKey?: never;
    columnKey?: C;
    type: 'header' | 'footer';
} | {
    rowKey?: never;
    columnKey: C;
    type?: 'header' | 'footer';
} | {
    rowKey?: never;
    columnKey?: never;
    type: 'noData';
};
/**
 * useCurrentKey type for payload of current cell change event handler
 */
export type CurrentCellDetail<K, C> = {
    value?: Cell<K, C>;
};
type ContextMenuContext<M extends string = string> = {
    allMenuItems?: Record<M, ComponentChild>;
    defaultMenuItems?: ComponentChild;
};
export type ContextMenuItemKey = 'resizeColumn' | 'sortColumn';
/**
 * Type of the cell context passed to the Table context menu renderer
 */
export type CellContextMenuContext<K, D, C> = (ContextMenuContext<ContextMenuItemKey> & {
    rowData: D;
    rowKey: K;
    columnKey: C;
    type: 'data';
}) | (ContextMenuContext<ContextMenuItemKey> & {
    rowData?: never;
    rowKey?: never;
    columnKey: C;
    type: 'header' | 'footer';
});
export type TableContextMenuConfig<K, D, C> = {
    itemsRenderer: (context: CellContextMenuContext<K, D, C>) => ComponentChildren;
    accessibleLabel?: string;
};
/**
 * Type for current cell/row highlight mode.
 */
export type CurrentRowVariant = 'highlight' | 'none';
/**
 * Full set of props exposed in the Internal Table Component
 */
export type TableProps<K, D, C extends string> = {
    /**
     * An aria-label which defines a string value that labels this TableView.
     * Either aria-label or aria-labelledby should be specified in order to make TableView accessible.
     */
    'aria-label'?: string;
    /**
     * An aria-labelledby which identifies the element(s) that labels this TableView.
     * Either aria-label or aria-labelledby should be specified in order to make TableView accessible.
     */
    'aria-labelledby'?: string;
    /**
     * A callback function to determine the column keys corresponding to the accessible row headers for the
     * specified row. This is required in order for the table to be accessible.
     */
    getAccessibleRowHeaders: (context: TableRowContext<K, D>) => Set<C>;
    /**
     * The Table does not support children at this time
     */
    children?: never;
    /**
     * The column definitions for the TableView.
     */
    columns: Columns<K, D, C>;
    /**
     * An array of column keys representing the order of columns to be displayed. If not provided, all columns
     * defined in the 'columns' property will be displayed in the order returned by Object.entries(columns).
     */
    columnOrder?: C[];
    /**
     * The current cell to apply to the TableView. This will be applied each time its value instance changes.
     */
    currentCellOverride?: CellOverride<K, C>;
    /**
     * A property that can specify highlight styles on the row containing the current data cell.
     */
    currentRowVariant?: CurrentRowVariant;
    /**
     * Callback function to handle when the current cell has changed.
     */
    onPersistCurrentCell?: (detail: CurrentCellDetail<K, C>) => void;
    /**
     * What type of gridlines should be shown by the Table.
     */
    gridlines?: {
        horizontal?: 'visible' | 'hidden';
        vertical?: 'visible' | 'hidden';
    };
    /**
     * What type of columns layout is specified for the Table.
     */
    layout?: 'contents' | 'fixed' | 'pending';
    /**
     * The type of selection behavior that is enabled on the TableView. This property controls the number
     * of selections of rows and columns that can be made via selection gestures at any given time. When
     * multiple row selection is enabled, the application is responsible for including a 'selector' column
     * to ensure the TableView is fully accessible.
     */
    selectionMode?: TableSelectionMode;
    /**
     * The keys of the current selected rows and columns in the TableView.
     */
    selected?: {
        row?: Keys<K>;
        column?: Keys<C>;
    };
    /**
     * Callback function to handle when selection has changed.  The function should update
     * the selected prop with a new set of selected keys.
     */
    onSelectionChange?: (detail: TableSelectionDetail<K, C>) => void;
    /**
     * Callback function to handle a row action gesture. (Click or spacebar)
     */
    onRowAction?: (detail: RowActionDetail<K, D>) => void;
    /**
     * Set of sort criterion representing the sort state of this Table's columns.
     */
    sortCriterion?: {
        key: C;
        sortDirection: 'ascending' | 'descending';
    }[];
    /**
     * Callback function to handle sort gesture from the Table.
     */
    onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;
    /**
     * The horizontal scroll position to apply to the TableView. This will be applied each time its value instance changes.
     */
    horizontalScrollPositionOverride?: TableHorizontalScrollPosition<C>;
    /**
     * The vertical scroll position to apply to the TableView. This will be applied each time its value instance changes.
     */
    verticalScrollPositionOverride?: TableVerticalScrollPosition<K>;
    /**
     * The static column width sizes to apply to the Table. Any column widths specified will be honored in all cases.
     */
    columnWidths?: ColumnWidths<C>;
    /**
     * Object representing the location of a column resize indicator line. When specified, a line will be rendered
     * on the end edge of the column corresponding to the provided key. Optionally, a delta from that location can
     * also be specified.
     */
    columnResizingIndicator?: {
        key: C;
        delta?: number;
    };
    /**
     * Callback function made during column resize gestures.
     */
    onColumnResizing?: (detail: ColumnResizingDetail<C>) => void;
    /**
     * Callback function made at the completion of a column resize gesture.
     */
    onColumnResize?: (detail: ColumnResizeDetail<C>) => void;
    /**
     * Optional custom renderer function to control the rendering of a Table when no rows are present.
     */
    noDataRenderer?: (context: TableNoDataRendererContext) => ComponentChildren;
    /**
     * Configuration used to specify a context menu.
     */
    contextMenuConfig?: TableContextMenuConfig<K, D, C>;
    /**
     * Configuration used to specify an external scroller.
     */
    viewportConfig?: TableViewportConfig;
    /**
     * Access to the element currently being used as the Table's scroller.
     */
    scrollerRef?: Ref<UnsafeDomHandle>;
};
export {};
