/* @oracle/oraclejet-preact: undefined */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('preact/jsx-runtime');
var TrackResizeContainer = require('./TrackResizeContainer-100be103.js');
var preact = require('preact');
var hooks = require('preact/hooks');
var UNSAFE_PictoChart_themes_PictoChartStyles_css = require('./UNSAFE_PictoChart/themes/PictoChartStyles.css.js');
var classNames = require('./classNames-c14c6ef3.js');
var useSelection = require('./useSelection-b5b55bdd.js');
var useTranslationBundle = require('./useTranslationBundle-18b7bf8b.js');
var mergeProps = require('./mergeProps-e3da7237.js');
var themeContract_css = require('./themeContract.css-a53fd740.js');
var utils = require('./utils-a66430fc.js');
var SvgSymbol = require('./SvgSymbol-d6be74d9.js');
var accUtils = require('./accUtils-5c7d3255.js');
var useUser = require('./useUser-f900ddf1.js');
var layoutUtils = require('./layoutUtils-e52005dc.js');
var eventsUtils = require('./eventsUtils-d34f8647.js');
var useVisHover = require('./useVisHover-ad36112d.js');
var useVisDrill = require('./useVisDrill-61cccf0f.js');
var useDatatip = require('./useDatatip-4f6d3759.js');
var useItemFocus = require('./useItemFocus-0c5fbee7.js');
require('./LayerHost-aee0e070.js');
require('preact/compat');
require('./datatipUtils-d1ca81a1.js');
var useTestId = require('./useTestId-9093a54b.js');
var useVisTouchResponse = require('./useVisTouchResponse-376e11d5.js');
var stringUtils = require('./stringUtils-3e19c8af.js');
var useContextMenu = require('./useContextMenu-e90f401c.js');
require('./SelectMenuGroupContext-ae5e1373.js');
require('./logger-2b636482.js');


require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js');
require('./tooltipUtils-ae48fed6.js');

require('./UNSAFE_Menu/themes/MenuItemStyles.css.js');
require('./UNSAFE_Separator/themes/SeparatorStyles.css.js');


require('./UNSAFE_Menu/themes/redwood/MenuSeparatorVariants.css.js');

require('./useSize-8115eae0.js');
require('./useResizeObserver-a9e97180.js');
require('./useAddBusyState-d19ae1fa.js');
require('./BusyStateContext-86f40d3c.js');
require('./useBusyStateContext-362eee2a.js');
require('./unsafeDomAccess-c3a492f0.js');
require('./size-0717c0bd.js');

require('./BaseButton-f6eb6de1.js');
require('./useHover-49b0430d.js');
require('./useToggle-3ebba7d8.js');
require('./useActive-6770f917.js');
require('./useColorScheme-23e4aab4.js');
require('./dimensions-2fcc0acf.js');
require('./colorUtils-01f3caa2.js');
require('./_curry1-e8f0d7ea.js');
require('./mergeInterpolations-6727b536.js');
require('./mergeDeepWithKey-210b024d.js');
require('./_curry3-18677bca.js');
require('./_curry2-c15d89cd.js');
require('./_isObject-28636267.js');
require('./clientHints-c40c5250.js');
require('./UNSAFE_BaseButton/themes/redwood/BaseButtonTheme.js');
require('./UNSAFE_BaseButton/themes/BaseButtonStyles.css.js');

require('./UNSAFE_BaseButton/themes/redwood/BaseButtonVariants.css.js');
require('./vanilla-extract-recipes-createRuntimeFn.esm-d1301b2d.js');

require('./useComponentTheme-082fc8e4.js');
require('./BareButton-814ae4b7.js');
require('./useBareButton-8c4f3b41.js');
require('./usePress-886180e4.js');
require('./usePressClick-421494df.js');
require('./TabbableModeContext-e99d527e.js');
require('./useTabbableMode-a275583f.js');
require('./useId-6c0eeb27.js');
require('./buttonUtils-dff2ea3e.js');
require('./id-86356250.js');
require('./Text-436e8b56.js');
require('./UNSAFE_Text/themes/TextStyles.css.js');

require('./hooks/PRIVATE_useVisSelection/themes/ClearSelection.css.js');

require('./Layer-28b1afce.js');
require('./UNSAFE_Layer/themes/LayerStyles.css.js');

require('./useThemeInterpolations-4faece98.js');
require('./useScale-adc62f41.js');
require('./theme-dfd6a9fe.js');
require('./Theme-f06687af.js');
require('./useDensity-022a8f80.js');
require('./Floating-5a704a27.js');
require('./useFloating-13101293.js');
require('./positionUtils-a780137e.js');
require('./refUtils-a9872e75.js');
require('./useOutsideClick-c3802f86.js');
require('./arrayUtils-7d8dcfc3.js');
require('./useModal-0739a528.js');
require('./UNSAFE_Floating/themes/redwood/FloatingTheme.js');
require('./UNSAFE_Floating/themes/FloatingStyles.css.js');

require('./UNSAFE_Floating/themes/redwood/FloatingBaseTheme.css.js');

require('./UNSAFE_Floating/themes/redwood/FloatingVariants.css.js');
require('./vanilla-extract-dynamic.esm-2e1b7c25.js');
require('./UNSAFE_Floating/themes/FloatingContract.css.js');
require('./useUnsafeDomElementRef-f22a2f0c.js');
require('./Marker-b40392cc.js');
require('./PRIVATE_SvgShapes/themes/SvgShapesStyles.css.js');

require('./useDoubleTap-d3937fb6.js');
require('./clientUtils-ef5e20ce.js');
require('./hooks/PRIVATE_useDatatip/themes/useDatatip.css.js');

require('./index-15e13649.js');
require('./UNSAFE_Layer/themes/LayerHostStyles.css.js');

require('./clientUtils-a4619fcd.js');
require('./useContextMenuGesture-03ba6353.js');
require('./textSelectionUtils-432ab66b.js');
require('./Sheet-44b25f1d.js');
require('./Modal-0cea796e.js');
require('./UNSAFE_Modal/themes/ModalStyles.css.js');

require('./tabbableUtils-7e41d383.js');
require('./head-68d0992f.js');
require('./_arity-c228159c.js');
require('./_isArray-73160ad5.js');
require('./_isString-f4443c9e.js');
require('./popupUtils-488fe8f7.js');
require('./WindowOverlay-a10f995e.js');
require('./UNSAFE_WindowOverlay/themes/WindowOverlayStyles.css.js');

require('./UNSAFE_WindowOverlay/themes/WindowOverlayContract.css.js');
require('./UNSAFE_WindowOverlay/themes/redwood/WindowOverlayTheme.js');
require('./UNSAFE_WindowOverlay/themes/redwood/WindowOverlayBaseTheme.css.js');

require('./UNSAFE_WindowOverlay/themes/redwood/WindowOverlayVariants.css.js');
require('./UNSAFE_Sheet/themes/SheetStyles.css.js');

require('./useAnimationStatus-c0c14bcc.js');
require('./useAnimation-fb11e4cc.js');
require('./animationUtils-54852d03.js');
require('./Dropdown-b2579045.js');
require('./keyboardUtils-b42fe7d5.js');
require('./usePopupAnimation-18040396.js');
require('./popupAnimationUtils-dcace427.js');
require('./CollectionInteractionContext-f84ff7a1.js');
require('./UNSAFE_Dropdown/themes/dropdownStyles.css.js');

require('./useOutsideMousedown-8f913d1a.js');
require('./UNSAFE_Menu/themes/MenuStyles.css.js');
require('./UNSAFE_Menu/themes/DropdownMenuStyles.css.js');

require('./Flex-6ca216a7.js');
require('./boxalignment-6dde2812.js');

require('./vanilla-extract-sprinkles-createRuntimeSprinkles.esm-d68f3e0f.js');
require('./flexbox-2cae9a01.js');

require('./flexitem-fee13e26.js');


require('./Skeleton-e746e396.js');
require('./borders-4b8488cb.js');
require('./UNSAFE_Skeleton/themes/redwood/SkeletonTheme.js');
require('./UNSAFE_Skeleton/themes/SkeletonStyles.css.js');

require('./UNSAFE_Skeleton/themes/redwood/SkeletonBaseTheme.css.js');

require('./UNSAFE_Skeleton/themes/redwood/SkeletonVariants.css.js');
require('./UNSAFE_Menu/themes/MenuSkeletonStyles.css.js');

require('./LiveRegion-e410e187.js');

require('./UNSAFE_Menu/themes/redwood/MenuItemTheme.js');
require('./UNSAFE_Menu/themes/redwood/MenuItemBaseTheme.css.js');

require('./UNSAFE_Menu/themes/redwood/MenuItemVariants.css.js');


require('./useInteractionStyle-c203a8a0.js');

require('./EnvironmentProvider-8696a5b8.js');
require('./LayerManager-fc4df14f.js');


/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const PictoChartContext = preact.createContext({});
const usePictoChartContext = () => hooks.useContext(PictoChartContext);

const GAP_RATIO = 0.25;
function _ceil(a, b) {
    return Math.ceil(a / b) * b;
}
function getFlowingInfo(items, isVert, width, height, isFlowingWidth, isFlowingHeight, colCount, rowCount, colWidth, rowHeight) {
    let numCells = 0;
    let maxColSpan = 1;
    let maxRowSpan = 1;
    let minSpan = Infinity;
    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const columnSpan = item.columnSpan || 1;
        const rowSpan = item.rowSpan || 1;
        if (columnSpan <= 0 || rowSpan <= 0)
            continue;
        // Compute the maximum columnSpan and rowSpan
        if (columnSpan > maxColSpan)
            maxColSpan = columnSpan;
        if (rowSpan > maxRowSpan)
            maxRowSpan = rowSpan;
        // Compute minimum span for gap computation
        if (columnSpan < minSpan)
            minSpan = columnSpan;
        if (rowSpan < minSpan)
            minSpan = rowSpan;
        numCells += columnSpan * rowSpan * (item.count || 1);
    }
    if (numCells === 0)
        return {};
    // Default colWidth and rowHeight for flowing layout
    if (isFlowingWidth || isFlowingHeight) {
        if (!colWidth)
            colWidth = rowHeight ? rowHeight : UNSAFE_PictoChart_themes_PictoChartStyles_css.DEFAULT_SIZE;
        if (!rowHeight)
            rowHeight = colWidth;
    }
    // Default colCount and rowCount for both layouts
    // We set the default colCount (or rowCount) to be an integer multiple of the maxColSpan (or maxRowSpan) to
    // ensure that all the items can find a spot to occupy in the mixed sizes case.
    if (!colCount && !rowCount) {
        // Try to achieve square cells, (width / colCount) = (height / rowCount)
        if (!isFlowingWidth && !isFlowingHeight) {
            if (isVert)
                rowCount = _ceil(Math.sqrt((numCells * height) / width), maxRowSpan);
            else
                colCount = _ceil(Math.sqrt((numCells * width) / height), maxColSpan);
        }
        else if (!isFlowingWidth)
            colCount = Math.max(Math.floor(width / (colWidth || 1)), 1);
        else if (!isFlowingHeight)
            rowCount = Math.max(Math.floor(height / (rowHeight || 1)), 1);
        else {
            if (isVert)
                rowCount = _ceil(Math.sqrt(numCells), maxRowSpan);
            else
                colCount = _ceil(Math.sqrt(numCells), maxColSpan);
        }
    }
    // Now only either colCount or rowCount is undefined
    if (!colCount)
        colCount = _ceil(numCells / (rowCount || 1), maxColSpan);
    else if (!rowCount)
        rowCount = _ceil(numCells / colCount, maxRowSpan);
    const gridGap = GAP_RATIO * minSpan;
    // Default colWidth and rowHeight for fixed layout
    if (!isFlowingWidth && !isFlowingHeight) {
        if (!colWidth)
            colWidth = rowHeight ? rowHeight : Math.min(width / colCount, height / (rowCount || 1));
        if (!rowHeight)
            rowHeight = colWidth;
    }
    if (colCount <= 0 ||
        !rowCount ||
        rowCount <= 0 ||
        !colWidth ||
        colWidth <= 0 ||
        !rowHeight ||
        rowHeight <= 0)
        return {};
    return {
        calcColCount: colCount,
        calcRowCount: rowCount,
        calcColWidth: colWidth ? colWidth - gridGap : colWidth,
        calcRowHeight: rowHeight ? rowHeight - gridGap : rowHeight,
        gridGap: gridGap
    };
}
/**
 * Returns whether the pictoChart is layout from bottom to top.
 */
const isOriginBottom = (origin) => {
    return origin === 'bottomStart' || origin === 'bottomEnd';
};
/**
 * Returns whether the pictoChart is layout from right to left.
 */
const isOriginRight = (origin) => {
    const isEnd = origin === 'topEnd' || origin === 'bottomEnd';
    return isEnd;
};
/**
 * Returns whether the cells are available given col, row and columnSpan, rowSpan needed.
 */
const areCellsAvailable = (map, col, row, columnSpan, rowSpan) => {
    for (let r = 0; r < rowSpan; r++) {
        for (let c = 0; c < columnSpan; c++) {
            if (map[row + r][col + c])
                return false;
        }
    }
    return true;
};
/**
 * Occupies the cell in the map given col, row and columnSpan, rowSpan.
 */
const occupyCells = (map, col, row, columnSpan, rowSpan) => {
    for (let r = 0; r < rowSpan; r++) {
        for (let c = 0; c < columnSpan; c++) {
            map[row + r][col + c] = true;
        }
    }
};
/**
 * Returns whether the cells are available given col, row and the colCount and rowCount of the pictochart.
 */
const findNextAvailableCell = (map, columnSpan, rowSpan, colCount, rowCount, isVert) => {
    if (isVert) {
        for (let c = 0; c <= colCount - columnSpan; c++) {
            for (let r = 0; r <= rowCount - rowSpan; r++) {
                if (areCellsAvailable(map, c, r, columnSpan, rowSpan)) {
                    occupyCells(map, c, r, columnSpan, rowSpan);
                    return { col: c, row: r };
                }
            }
        }
        return;
    }
    for (let r = 0; r < rowCount - rowSpan + 1; r++) {
        for (let c = 0; c < colCount - columnSpan + 1; c++) {
            if (areCellsAvailable(map, c, r, columnSpan, rowSpan)) {
                occupyCells(map, c, r, columnSpan, rowSpan);
                return { col: c, row: r };
            }
        }
    }
    return;
};
/**
 * Returns the picto items with row and col of the pictochart.
 */
function generateElementCoords(items, row, column, layoutOrigin, isVert) {
    const rowCount = row;
    const colCount = column;
    const isLayoutBottom = isOriginBottom(layoutOrigin);
    const isLayoutRight = isOriginRight(layoutOrigin);
    const pictoItems = [];
    const map = new Array(rowCount);
    for (let i = 0; i < rowCount; i++) {
        map[i] = new Array(colCount).fill(false);
    }
    const isFractionalLeft = true;
    let lastFractionalCell = {
        row: -1,
        col: -1,
        count: 0,
        direction: isFractionalLeft,
        rowSpan: 1,
        columnSpan: 1
    };
    for (let i = 0; i < items.length; i++) {
        const currItem = items[i];
        const rowSpan = currItem.rowSpan ?? 1;
        const columnSpan = currItem.columnSpan ?? 1;
        let totalCount = currItem.count ?? 1;
        // fill previous fractional cell if needed
        if (lastFractionalCell.count > 0 && lastFractionalCell.count < 1
            && lastFractionalCell.rowSpan === rowSpan &&
            lastFractionalCell.columnSpan === columnSpan) {
            const amountToFill = 1 - lastFractionalCell.count;
            const fillAmount = Math.min(amountToFill, totalCount);
            const filledRow = isLayoutBottom
                ? rowCount - lastFractionalCell.row - rowSpan
                : lastFractionalCell.row;
            const filledCol = isLayoutRight
                ? colCount - lastFractionalCell.col - columnSpan
                : lastFractionalCell.col;
            pictoItems.push({
                row: filledRow,
                col: filledCol,
                countIdx: i,
                itemIdx: i,
                item: currItem,
                fractionalStart: lastFractionalCell.count,
                fractionalEnd: lastFractionalCell.count + fillAmount
            });
            lastFractionalCell.count += fillAmount;
            totalCount -= fillAmount;
            if (lastFractionalCell.count >= 1) {
                lastFractionalCell = { row: -1, col: -1, count: 0, direction: isFractionalLeft, rowSpan, columnSpan };
            }
            else {
                continue;
            }
        }
        // fill with full units first
        const fullUnits = Math.floor(totalCount);
        for (let j = 0; j < fullUnits; j++) {
            const cell = findNextAvailableCell(map, columnSpan, rowSpan, colCount, rowCount, isVert);
            if (cell) {
                const currRow = isLayoutBottom ? rowCount - cell.row - rowSpan : cell.row;
                const currCol = isLayoutRight ? colCount - cell.col - columnSpan : cell.col;
                pictoItems.push({
                    row: currRow,
                    col: currCol,
                    countIdx: j,
                    itemIdx: i,
                    item: currItem,
                    fractionalStart: 0,
                    fractionalEnd: 1
                });
            }
        }
        // fill with the current item's remaining fractional cell
        const remainder = totalCount - fullUnits;
        if (remainder > 0 && remainder < 1) {
            const cell = findNextAvailableCell(map, columnSpan, rowSpan, colCount, rowCount, isVert);
            if (cell) {
                lastFractionalCell = {
                    row: cell.row,
                    col: cell.col,
                    count: remainder,
                    direction: true,
                    rowSpan,
                    columnSpan
                };
                const newRow = isLayoutBottom ? rowCount - cell.row - rowSpan : cell.row;
                const newCol = isLayoutRight ? colCount - cell.col - columnSpan : cell.col;
                pictoItems.push({
                    row: newRow,
                    col: newCol,
                    countIdx: remainder,
                    itemIdx: i,
                    item: currItem,
                    fractionalStart: 0,
                    fractionalEnd: remainder
                });
            }
        }
    }
    return pictoItems;
}

/**
 * Checks if the item is highlighted.
 * @param id Id of the item
 * @param highlighted The set of highlighted item
 */
function isItemHighlighted(id, highlightedIds) {
    if (!highlightedIds || highlightedIds.length === 0) {
        return true;
    }
    return new Set(highlightedIds).has(id);
}
/**
 * Checks if the item is highlighted.
 * @param id Id of the item
 * @param selectedIds The set of highlighted item
 */
function isItemSelected(id, selectedIds) {
    if (!selectedIds || selectedIds.length === 0) {
        return false;
    }
    return new Set(selectedIds).has(id);
}
/**
 * Returns the value of the data-oj-private-item-index attribute for a given element.
 * @param element The HTML element.
 */
function getItemInfo(element) {
    const itemIdx = element.dataset['idx'];
    if (itemIdx === undefined)
        return;
    return {
        idx: Number(itemIdx)
    };
}
/**
 * Returns the item props for PictoChart.
 * @param item The picto chart item.
 * @param itemIdx The item index of the item.
 * @param countIdx The item count of the item.
 * @param isReadOnly Whether the picto chart is readonly.
 * @param hoveredItem The info of the currently hovered item.
 * @param selectedIds The selected Ids
 * @param focusedItem The info of currently focused item.
 * @param highlightedIds The highlighted ids.
 * @param activeId The active Id
 */
function getItemProps(item, itemIdx, countIdx, isReadOnly, hoveredItem, selectedIds, focusedItem, highlightedIds, activeId, isVert, layoutOrigin) {
    let isCurrent = false;
    if (!isReadOnly) {
        const isFocusedItem = !!focusedItem && itemIdx === focusedItem.idx;
        const isHoveredItem = !!hoveredItem && itemIdx === hoveredItem.idx;
        isCurrent = !!((isFocusedItem && focusedItem?.isCurrent) ||
            (isHoveredItem && hoveredItem?.isCurrent));
    }
    const isHighlighted = isItemHighlighted(item.id, highlightedIds);
    const isSelected = isItemSelected(item.id, selectedIds);
    const hasSelection = selectedIds && selectedIds.length !== 0;
    return {
        isCurrent,
        isHighlighted: isHighlighted,
        isSelected: isSelected,
        hasSelection,
        isFocused: focusedItem ? hasFocusRing(focusedItem, itemIdx) : false,
        key: item.id,
        itemIdx,
        countIdx,
        activeId: isCurrent ? activeId : undefined,
        isReadOnly,
        item: item,
        isVerticalLayout: isVert,
        layoutOrigin: layoutOrigin
    };
}
/**
 * Compares if two ItemInfo are equal
 * @param item1
 * @param item2
 * @returns
 */
function isEqualItem(item1, item2) {
    return item1?.idx === item2?.idx;
}
/**
 * Checks if the item is the currentItem and if the focus ring
 * is visible.
 * @param itemInfo ItemInfo
 * @param itemIdx Item index
 */
function hasFocusRing(itemInfo, itemIdx) {
    if (!itemInfo.isFocusVisible)
        return false;
    return itemInfo.idx === itemIdx;
}
/**
 *
 */
function getCountWithTotal(itemCount, totalCount, translations) {
    const totalWithCountLabel = `${translations?.vis_labelCountWithTotal({
        itemCount: itemCount.toString(),
        totalCount: totalCount.toString()
    })}`;
    return totalWithCountLabel;
}
/**
 * Returns the aria properties for the picto chart.
 * @param isReadOnly { boolean } If the picto chart is readonly.
 * @param accessibleLabel { string } The aria-label set by the app.
 * @returns The aria props.
 */
function getItemAriaProps(itemCount, totalCount, supportsSelection, label, translations, isSelected, hasSelection, accessibleLabel, activeId) {
    const totalWithCountLabel = translations
        ? getCountWithTotal(itemCount, totalCount, translations)
        : '';
    accessibleLabel = accessibleLabel || `${label ? label + ': ' : ''}${totalWithCountLabel}`; // TODO: use a translation string for :
    return {
        'aria-label': accUtils.generateAriaLabel(translations, accessibleLabel, {
            isSelected: !supportsSelection && !hasSelection ? undefined : isSelected
        }) || undefined,
        role: 'img',
        id: activeId
    };
}
/**
 * Returns the marker props for SVGSymbol
 */
function getMarkerProps(shape, color, isFocused, isSelected, isCurrent, supportsSelection) {
    const isHuman = shape === 'human';
    const applyHover = isFocused || (isCurrent && supportsSelection);
    const isNoneEqualSides = shape === 'ellipse' || shape === 'rectangle';
    color = color !== '' ? color : utils.rgba(themeContract_css.colorSchemeVars.palette.neutral['190'], 0.15);
    const outerBorderColor = isSelected ? themeContract_css.colorSchemeVars.textIcon.primary : applyHover ? color : '';
    return {
        markerShape: shape,
        tx: isHuman ? 70 : undefined,
        ty: isHuman ? 60 : undefined,
        markerColor: color,
        borderColor: isSelected || applyHover ? utils.rgb(themeContract_css.colorSchemeVars.palette.neutral[0]) : color,
        outerBorderColor,
        markerScale: isNoneEqualSides && !outerBorderColor ? 1 : 0.85,
        setAspectRatioNone: isNoneEqualSides ? true : false
    };
}
// Creating component to read the context
const PictoRenderer = ({ context, markerProps }) => {
    const { supportsSelection } = usePictoChartContext();
    const markerProp = getMarkerProps(markerProps.shape, markerProps.color, context.state.focused, context.state.selected, context.state.hovered, supportsSelection);
    return jsxRuntime.jsx(SvgSymbol.SvgSymbol, { ...markerProp });
};
/**
 * Returns the marker renderer for SVGSymbol
 */
function getPictoDefaultRenderers(rendererOptions) {
    return {
        markerRenderer: (context) => {
            const props = rendererOptions(context.data); // TODO: should we add default values
            return jsxRuntime.jsx(PictoRenderer, { context: context, markerProps: props });
        },
        datatipRenderer: (context) => {
            const props = rendererOptions(context.data);
            return { borderColor: props.color };
        }
    };
}
function getTotalCount(items) {
    let totalCount = 0;
    for (let i = 0; i < items.length; i++) {
        totalCount += items[i].count || 1;
    }
    return totalCount;
}
/**
 * Returns the text for the picto chart datatip.
 * @param items The picto chart items data.
 * @param focusedItem The item currently keyboard focused.
 * @param hoveredItem The item that is currently hovered.
 * @param datatip The datatip.
 */
function getDatatipContent(items, getItem, totalCount, focusedItem, hoveredItem, datatip, translations) {
    let itemInfo;
    const isPointerActive = hoveredItem?.isCurrent;
    if (isPointerActive && items[hoveredItem.idx].id != null) {
        itemInfo = hoveredItem;
    }
    if (focusedItem && focusedItem.isCurrent) {
        itemInfo = focusedItem;
    }
    let _content, countWithTotal;
    let _borderColor = utils.rgba(themeContract_css.colorSchemeVars.palette.neutral['190'], 0.15);
    const item = itemInfo && getItem(itemInfo, items);
    if (item && datatip) {
        // custom datatip
        const datatipContext = item && { data: item };
        const { content, borderColor } = datatip(datatipContext);
        _content = content;
        _borderColor = borderColor || _borderColor;
        countWithTotal = translations
            ? getCountWithTotal(item.count || 1, totalCount, translations)
            : '';
    }
    return {
        borderColor: _borderColor,
        content: _content ||
            (itemInfo && getItem(itemInfo, items)?.accessibleLabel) ||
            (itemInfo && getItem(itemInfo, items)?.label + ': ' + countWithTotal) ||
            countWithTotal
    };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Returns the item based on item info in a picto chart.
 * @param itemInfo
 * @param items
 * @returns
 */
function getItem(itemInfo, items) {
    const { idx } = itemInfo;
    return items[idx];
}
/**
 * Returns the next item's info in a picto chart.
 * @param itemInfo
 * @param items
 * @returns
 */
function getNextItemInfo(itemInfo, items) {
    let idx = itemInfo.idx;
    idx = Math.min(items.length - 1, idx + 1);
    return { idx: idx };
}
/**
 * Returns the previous item's info in a picto chart.
 * @param itemInfo
 * @returns
 */
function getPrevItemInfo(itemInfo) {
    let idx = itemInfo.idx;
    idx = Math.max(0, idx - 1);
    return { idx: idx };
}
/**
 * Returns utils functions for navigation in a picto chart.
 * @param items
 * @returns
 */
function getPictoChartNavUtils(items) {
    return {
        getItem: (itemInfo) => {
            return getItem(itemInfo, items);
        },
        getDetailFromInfo: (itemInfo) => {
            if (!itemInfo) {
                return { id: undefined, data: undefined };
            }
            const item = getItem(itemInfo, items);
            return { id: item ? item.id : undefined, data: item };
        },
        getPrevItemInfo: (itemInfo) => {
            return getPrevItemInfo(itemInfo);
        },
        getNextItemInfo: (itemInfo) => {
            return getNextItemInfo(itemInfo, items);
        }
    };
}

function useEvents(touchResponse, isInteractive, selectionMode, getDetailFromInfo, getPrevItemInfo, getNextItemInfo, drilling, onItemDrill, onItemHover, onItemFocus) {
    const [focusedItemInfo, setfocusedItemInfo] = hooks.useState({ idx: 0 });
    const [hoveredItemInfo, sethoveredItemInfo] = hooks.useState();
    const activeId = hooks.useRef();
    const { direction } = useUser.useUser();
    const isRtl = direction === 'rtl';
    const onHover = (event) => {
        const itemInfo = getItemInfo(event.target);
        if (!isEqualItem(itemInfo, hoveredItemInfo)) {
            sethoveredItemInfo(itemInfo && { ...itemInfo, isCurrent: true });
            activeId.current = layoutUtils.getRandomId();
            if (isInteractive) {
                setfocusedItemInfo({ ...focusedItemInfo, isCurrent: false });
                onItemHover?.(getDetailFromInfo(itemInfo));
            }
        }
    };
    const onHoverLeave = () => {
        sethoveredItemInfo(undefined);
        activeId.current = undefined;
        if (isInteractive) {
            onItemHover?.(getDetailFromInfo());
        }
    };
    const hoverHandlers = useVisHover.useVisHover(onHover, undefined, onHoverLeave, touchResponse);
    const processDrill = hooks.useCallback((info) => {
        const { id, data } = getDetailFromInfo(info);
        if (id != null && data) {
            onItemDrill?.({ id, data });
            activeId.current = layoutUtils.getRandomId();
        }
    }, [getDetailFromInfo, onItemDrill]);
    const onDrill = hooks.useCallback((event) => {
        if (event.type === 'keydown') {
            if (drilling == 'on')
                processDrill(focusedItemInfo);
        }
        else {
            processDrill(getItemInfo(event.target));
        }
    }, [drilling, focusedItemInfo, processDrill]);
    const drillProps = useVisDrill.useVisDrill(selectionMode, onDrill);
    if (!isInteractive) {
        return {
            focusedItemInfo,
            hoveredItemInfo,
            // include relevant hover handlers for datatip
            eventsProps: hoverHandlers
        };
    }
    function updatefocusedItemInfo(itemInfo) {
        onItemFocus?.(getDetailFromInfo(itemInfo));
        activeId.current = layoutUtils.getRandomId();
        setfocusedItemInfo(itemInfo);
    }
    function handleKeyboardInput(item) {
        if (!isEqualItem(item, focusedItemInfo)) {
            item.isCurrent = true;
            item.isFocusVisible = true;
            if (hoveredItemInfo) {
                sethoveredItemInfo({ ...hoveredItemInfo, isCurrent: false });
            }
            updatefocusedItemInfo(item);
        }
    }
    const onKeyDown = (event) => {
        const key = event.key;
        switch (key) {
            case 'Tab':
                return;
            case 'ArrowDown': {
                const nextItemInfo = getNextItemInfo(focusedItemInfo);
                handleKeyboardInput(nextItemInfo);
                eventsUtils.cancelEvent(event);
                break;
            }
            case 'ArrowUp': {
                const nextItemInfo = getPrevItemInfo(focusedItemInfo);
                handleKeyboardInput(nextItemInfo);
                eventsUtils.cancelEvent(event);
                break;
            }
            case 'ArrowRight': {
                const nextItemInfo = isRtl
                    ? getPrevItemInfo(focusedItemInfo)
                    : getNextItemInfo(focusedItemInfo);
                handleKeyboardInput(nextItemInfo);
                eventsUtils.cancelEvent(event);
                break;
            }
            case 'ArrowLeft': {
                const nextItemInfo = isRtl
                    ? getNextItemInfo(focusedItemInfo)
                    : getPrevItemInfo(focusedItemInfo);
                handleKeyboardInput(nextItemInfo);
                eventsUtils.cancelEvent(event);
                break;
            }
        }
    };
    const onKeyUp = (event) => {
        const key = event.code;
        switch (key) {
            case 'Tab': {
                updatefocusedItemInfo({
                    ...focusedItemInfo,
                    isCurrent: true,
                    isFocusVisible: true
                });
                eventsUtils.cancelEvent(event);
                break;
            }
        }
    };
    const onBlur = () => {
        if (hoveredItemInfo != null || focusedItemInfo.isCurrent) {
            onItemFocus?.(getDetailFromInfo(undefined));
        }
        const itemInfo = { ...focusedItemInfo, isCurrent: false, isFocusVisible: false };
        setfocusedItemInfo(itemInfo);
    };
    const onContextMenuDismissed = (gesture) => {
        if (gesture === 'keyboard') {
            updatefocusedItemInfo({
                ...focusedItemInfo,
                isFocusVisible: true,
                isCurrent: true
            });
        }
    };
    return {
        focusedItemInfo,
        hoveredItemInfo,
        activeId: activeId.current,
        onContextMenuDismissed,
        eventsProps: mergeProps.mergeProps(drillProps, hoverHandlers, {
            onKeyUp,
            onKeyDown,
            onBlur
        })
    };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Returns the datatip.
 * @param content The text string for the picto chart item.
 * @param focusedItemRef The ref for focused item node.
 * @param focusedItemInfo The ItemInfo for focused item node.
 * @returns
 */
const usePictoChartDatatip = ({ touchResponse, content, borderColor, width, focusedItemRef, focusedItemInfo }) => {
    const { direction } = useUser.useUser();
    const isRtl = direction === 'rtl';
    const itemDim = focusedItemRef.current?.getBoundingClientRect();
    const { datatipContent, datatipProps } = useDatatip.useDatatip({
        content,
        placement: 'top-start',
        offset: layoutUtils.calculateOffset(isRtl, width, focusedItemInfo.isCurrent ? itemDim : undefined),
        borderColor,
        anchor: focusedItemInfo?.isCurrent ? 'element' : 'pointer',
        touchResponse
    });
    return { datatipContent: datatipContent, datatipProps: datatipProps };
};

const PictoChartElement = (props) => {
    const { direction } = useUser.useUser();
    const isRtl = direction === 'rtl';
    const isVert = props.isVerticalLayout;
    let start = props.fractionalStart ?? 0;
    let end = props.fractionalEnd ?? 1;
    const layoutOrigin = props.layoutOrigin;
    if (isVert) {
        if (layoutOrigin === 'bottomStart' || layoutOrigin === 'bottomEnd') {
            [start, end] = [1 - end, 1 - start];
        }
    }
    else {
        if (layoutOrigin === 'bottomEnd' || layoutOrigin === 'topEnd') {
            [start, end] = [1 - end, 1 - start];
        }
    }
    const shouldClip = start !== 0 || end !== 1;
    const clipPolygon = shouldClip ?
        (isVert ?
            `polygon(0% ${start * 100}%, 100% ${start * 100}%, 100% ${end * 100}%, 0% ${end * 100}%)`
            : isRtl
                ? `polygon(${100 - end * 100}% 0%, ${100 - start * 100}% 0%, ${100 - start * 100}% 100%, ${100 - end * 100}% 100%)`
                : `polygon(${start * 100}% 0%, ${end * 100}% 0%, ${end * 100}% 100%, ${start * 100}% 100%)`)
        : undefined;
    const isInteractive = props.supportsSelection || props.supportsDrill;
    const { dimmedItemStyle, interactiveItemStyle } = UNSAFE_PictoChart_themes_PictoChartStyles_css.styles;
    const itemClasses = classNames.classNames([
        isInteractive && interactiveItemStyle,
        !props.isHighlighted && dimmedItemStyle
    ]);
    const isFirstElement = props.countIdx === 0;
    const itemAriaProps = (isFirstElement &&
        getItemAriaProps(props.item.count || 1, props.totalCount, !!props.supportsSelection, props.item.label, props.translations, props.isSelected, props.hasSelection, props.item.accessibleLabel, props.activeId)) ||
        {};
    return (jsxRuntime.jsx("div", { ref: isFirstElement ? props.focusedItemRef : undefined, id: props.activeId, "data-idx": props.itemIdx, "data-count-idx": props.countIdx, style: {
            gridRow: `${props.row + 1} / span ${props.item.rowSpan || 1}`,
            gridColumn: `${props.column + 1} / span ${props.item.columnSpan || 1}`,
            clipPath: clipPolygon
        }, class: itemClasses, ...itemAriaProps, children: props.children }));
};

const usePictoChartContextMenu = ({ rootRef, contextMenuConfig, focusedItemInfo, items, onContextMenuDismissed, getItemInfo }) => {
    const { contextMenuProps, contextMenuContent } = useContextMenu.useContextMenu({
        onContextMenuHandler: ({ gesture, target }) => {
            if (gesture === 'keyboard') {
                const idx = focusedItemInfo.idx;
                const elem = rootRef.current?.querySelector(`[data-idx="${idx}"]`) || null;
                const data = items[idx];
                return {
                    type: 'element',
                    context: {
                        type: 'item',
                        data
                    },
                    elem
                };
            }
            const idx = getItemInfo(target)?.idx;
            const data = idx !== undefined ? items[idx] : null;
            if (data) {
                return {
                    type: 'pointer',
                    context: {
                        type: 'item',
                        data
                    }
                };
            }
            return {
                type: 'pointer',
                context: { type: 'background' }
            };
        },
        contextMenuOptions: {
            isDisabled: !contextMenuConfig //If there is no context menu renderer we disable the hook
        },
        rootRef,
        contextMenuConfig,
        onContextMenuDismissed
    });
    return { contextMenuContent, contextMenuProps };
};

function PictoChartWithDimensions({ width, height, columnWidth, rowHeight, items, columnCount, rowCount, layout, layoutOrigin = 'topStart', selectionMode = 'none', highlightedIds = [], selectedIds = [], drilling = 'off', onItemDrill, onItemHover, isFlowingWidth, isFlowingHeight, onItemFocus, contextMenuConfig, ...props }) {
    const rootRef = hooks.useRef(null);
    const hasData = items.length !== 0;
    const totalCount = getTotalCount(items);
    const translations = useTranslationBundle.useTranslationBundle('@oracle/oraclejet-preact');
    const supportsSelection = !!(selectionMode && selectionMode !== 'none');
    const supportsDrill = onItemDrill != null;
    const isReadOnly = !supportsSelection && !supportsDrill && onItemHover === null && onItemFocus === null;
    const testIdProps = useTestId.useTestId(props.testId);
    const idToDataMap = new Map(items.map((obj) => [obj.id, obj]));
    const { getItem, getDetailFromInfo, getPrevItemInfo, getNextItemInfo } = getPictoChartNavUtils(items);
    const { touchResponse, touchResponseStyle } = useVisTouchResponse.useVisTouchResponse({ type: 'touchStart' });
    const { hoveredItemInfo, focusedItemInfo, activeId, eventsProps, onContextMenuDismissed } = useEvents(touchResponse, !isReadOnly && hasData, selectionMode, getDetailFromInfo, getPrevItemInfo, getNextItemInfo, drilling, onItemDrill, onItemHover, onItemFocus);
    const idExtracter = (event) => {
        // return focused item for keyboard event.
        // eventsProps should have already updated the focused item
        const info = event.type === 'keyup' ? focusedItemInfo : getItemInfo(event.target);
        return getDetailFromInfo(info).id;
    };
    const { selectionContent, selectionProps } = useSelection.useSelection({
        idExtracter,
        isDrillEnabled: drilling != 'off',
        selection: selectedIds,
        selectionMode: selectionMode,
        getDataById: (id) => idToDataMap.get(id),
        onChange: props.onSelectionChange
    });
    const rectangleWidth = columnWidth && parseFloat(columnWidth);
    const rectangleHeight = rowHeight && parseFloat(rowHeight);
    const pictoStyleClasses = classNames.classNames([UNSAFE_PictoChart_themes_PictoChartStyles_css.baseStyles]);
    const { focusedItemRef } = useItemFocus.useItemFocus(focusedItemInfo);
    const { content, borderColor } = getDatatipContent(items, getItem, totalCount, focusedItemInfo, hoveredItemInfo, props.datatip, translations);
    const { calcColCount, calcRowCount, calcColWidth, calcRowHeight, gridGap } = getFlowingInfo(items, layout === 'vertical', width, height, isFlowingWidth, isFlowingHeight, columnCount, rowCount, rectangleWidth, rectangleHeight);
    const { datatipContent, datatipProps: { 'aria-describedby': datatipAriaDescribedby, ...datatipProps } } = usePictoChartDatatip({
        touchResponse,
        content,
        width,
        borderColor,
        focusedItemRef,
        focusedItemInfo
    });
    const { contextMenuContent, contextMenuProps } = usePictoChartContextMenu({
        getItemInfo,
        focusedItemInfo,
        rootRef,
        contextMenuConfig: hasData ? contextMenuConfig : undefined,
        items,
        onContextMenuDismissed
    });
    if (!calcColCount)
        // Nothing to render.
        return null;
    const elements = generateElementCoords(items, calcRowCount, calcColCount, layoutOrigin, layout === 'vertical');
    const mergedEventProps = mergeProps.mergeProps(eventsProps, datatipProps, selectionProps, contextMenuProps);
    return (jsxRuntime.jsxs("div", { ref: rootRef, tabIndex: 0, "aria-label": props['aria-label'], "aria-describedby": stringUtils.l([props['aria-describedby'], datatipAriaDescribedby]), "aria-labelledby": props['aria-labelledby'], "aria-activedescendant": activeId, role: "application", style: {
            width: isFlowingWidth ? 'max-content' : `${width}px`,
            height: isFlowingHeight ? 'max-content' : `${height}px`,
            gridTemplateRows: `repeat(${calcRowCount}, ${calcRowHeight}px)`,
            gridTemplateColumns: `repeat(${calcColCount}, ${calcColWidth}px)`,
            gap: `${gridGap}px`,
            ...touchResponseStyle
        }, class: pictoStyleClasses, ...testIdProps, ...mergedEventProps, children: [elements.map((elt) => {
                const isFocusedItem = focusedItemInfo.idx === elt.itemIdx;
                const itemProps = getItemProps(elt.item, elt.itemIdx, elt.countIdx, isReadOnly, hoveredItemInfo, selectedIds, focusedItemInfo, highlightedIds, activeId, layout === 'vertical', layoutOrigin);
                const context = {
                    data: elt.item,
                    state: {
                        selected: itemProps.isSelected,
                        focused: itemProps.isFocused,
                        hovered: itemProps.isCurrent
                    }
                };
                return (jsxRuntime.jsx(PictoChartElement, { focusedItemRef: isFocusedItem ? focusedItemRef : undefined, row: elt.row, column: elt.col, supportsSelection: supportsSelection, supportsDrill: supportsDrill, translations: translations, totalCount: totalCount, fractionalStart: elt.fractionalStart, fractionalEnd: elt.fractionalEnd, ...itemProps, children: props.children(context) }));
            }), datatipContent, contextMenuContent, selectionContent] }));
}

/**
 * A picto chart displays information using icons to visualize an absolute number or the relative sizes of the different parts of a population.
 */
function PictoChart({ width, height, ...props }) {
    //  TODO: investigate if we need to handle empty items for performance reasons.
    const supportsSelection = !!(props.selectionMode && props.selectionMode !== 'none');
    const isFlowingWidth = width === undefined;
    const isFlowingHeight = height === undefined;
    return (jsxRuntime.jsx(PictoChartContext.Provider, { value: { supportsSelection }, children: jsxRuntime.jsx(TrackResizeContainer.TrackResizeContainer, { width: isFlowingWidth ? 'initial' : width, height: isFlowingHeight ? 'initial' : height, children: (width, height) => (jsxRuntime.jsx(PictoChartWithDimensions, { width: width, height: height, isFlowingWidth: isFlowingWidth, isFlowingHeight: isFlowingHeight, ...props })) }) }));
}

exports.PictoChart = PictoChart;
exports.getPictoDefaultRenderers = getPictoDefaultRenderers;
//# sourceMappingURL=UNSAFE_PictoChart.js.map
