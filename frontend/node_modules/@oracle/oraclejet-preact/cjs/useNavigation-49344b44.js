/* @oracle/oraclejet-preact: undefined */
'use strict';

var hooks = require('preact/hooks');
var useCurrentKey = require('./useCurrentKey-76fed320.js');
var useReorderableContext = require('./useReorderableContext-92514102.js');
var useCollectionFocusRing = require('./useCollectionFocusRing-7fcfe8f7.js');
var useTabbableModeSet = require('./useTabbableModeSet-029f209c.js');
var collectionUtils = require('./collectionUtils-fe12edac.js');
var mergeProps = require('./mergeProps-e3da7237.js');
var keys = require('./keys-25710458.js');

/**
 * This hook converts the new API (i.e. currentItemOverride and onPersistCurrentItem) back to
 * the old API (i.e. currentKey and onCurrentKeyChange), keeps the internal current item, and
 * also triggers an update when a new currentItemOverride is passed by the app
 *
 * @param currentItemOverride
 * @param onPersistCurrentItem
 */
const useCurrentItemOverride = (currentItemOverride, onPersistCurrentItem) => {
    // the internal state of current item
    const [currentItem, setCurrentItem] = hooks.useState();
    // track the currentItemOverride props
    const currentItemOverrideRef = hooks.useRef();
    // whether the current item is overridden by the app
    const isCurrentItemOverridden = hooks.useRef(false);
    // if reorder is enabled, need to update the context here when current item is changed
    const reorderContext = useReorderableContext.useReorderableContext();
    // intercept onPersistCurrentItem calls to ensure internal state is updated appropriately
    const handleCurrentItemChanged = hooks.useMemo(() => {
        return (detail) => {
            const rowKey = detail.value;
            setCurrentItem({ rowKey });
            onPersistCurrentItem?.(detail);
            if (reorderContext?.currentItemKey != null) {
                reorderContext.currentItemKey.current = rowKey;
            }
        };
    }, [onPersistCurrentItem, reorderContext?.currentItemKey]);
    // ensure any new currentItemOverride settings are applied only on that render
    // (same as how Table handles the changes)
    if (currentItemOverrideRef.current !== currentItemOverride) {
        currentItemOverrideRef.current = currentItemOverride;
        if (currentItem?.rowKey !== currentItemOverride?.rowKey) {
            isCurrentItemOverridden.current = true;
            handleCurrentItemChanged({ value: currentItemOverride?.rowKey });
        }
    }
    hooks.useEffect(() => {
        isCurrentItemOverridden.current = false;
    });
    return {
        currentKey: currentItem?.rowKey,
        onCurrentKeyChange: handleCurrentItemChanged,
        isCurrentItemOverridden: isCurrentItemOverridden.current
    };
};

/**
 * Helper function to only include keys of leaf items.
 */
const excludeGroup = (data, keys) => {
    if (!keys.all) {
        const groups = data.data
            .filter((dataMetadata) => {
            return !dataMetadata.metadata.isLeaf;
        })
            .map((dataMetadata) => {
            return dataMetadata.metadata.key;
        });
        const leafOnly = Array.from(keys.keys.values()).filter((key) => {
            return !groups.includes(key);
        });
        return { ...keys, keys: new Set(leafOnly) };
    }
    return keys;
};
/**
 * A helper function to make sure specified elem is visible in the specified container
 */
const scrollToVisible = (elem, scroller, offset) => {
    if (elem && scroller) {
        if (elem.scrollIntoViewIfNeeded) {
            // for Safari, we'll need the non-standard scrollIntoViewIfNeeded
            elem.scrollIntoViewIfNeeded();
        }
        else {
            elem.scrollIntoView({ block: 'nearest' });
        }
        if (offset > 0) {
            const scrollerBounds = scroller.getBoundingClientRect();
            const elemBounds = elem.getBoundingClientRect();
            const diff = scrollerBounds.top + offset - elemBounds.top;
            if (diff > 0) {
                scroller.scrollTop = scroller.scrollTop - diff;
            }
        }
    }
};
/**
 * Helper method to determine whether the selection mode is multiple or multipleToggle
 */
const isMultipleSelection = (selectionMode) => {
    return selectionMode === 'multiple' || selectionMode === 'multipleToggle';
};

/**
 * A hook to set up the currentKey, focus ring and F2 mode.
 *
 * The current key setup includes convert the currentItemOverride to currentKey syntax, set initial currentKey,
 * scroll current item into view, update aria-activedescendant when currentKey changed.
 *
 * This hook can be shared across ListView, CardView, TreeView
 */
const useNavigation = (data, rootRef, idExtractor, arrowKeyAndHandlers, currentItemOverride, onPersistCurrentItem, viewportConfig, scrollToVisibleOffset, allowShiftKey, allowTabbableMode, allowActiveDescendant, isEmbedded, allowEnterKey) => {
    // tracking pending current key in pointer down event
    const pendingCurrentKey = hooks.useRef();
    // ensure current item scroll into view when treeview regains focus
    // unless pendingCurrentKey gets updated to something different than currentKey
    const focusAndScrollIntoView = hooks.useRef(true);
    const { currentKey, onCurrentKeyChange, isCurrentItemOverridden } = useCurrentItemOverride(currentItemOverride, onPersistCurrentItem);
    const { currentKeyProps } = useCurrentKey.useCurrentKey((element) => collectionUtils.keyExtractor(element, collectionUtils.ITEM_SELECTOR), allowShiftKey, arrowKeyAndHandlers.ArrowUp(currentKey), arrowKeyAndHandlers.ArrowDown(currentKey), arrowKeyAndHandlers.ArrowLeft?.(currentKey), arrowKeyAndHandlers.ArrowRight?.(currentKey), currentKey, onCurrentKeyChange);
    const [showFocusRing, focusRingProps] = useCollectionFocusRing.useCollectionFocusRing(rootRef, Object.keys(arrowKeyAndHandlers));
    const [isCurrentTabbableKey, tabbableModeProps] = useTabbableModeSet.useTabbableModeSet(rootRef, (element) => {
        // we don't want the component to go into Tabbable mode when user clicks on expander
        return isExpander(element) ? null : collectionUtils.keyExtractor(element, collectionUtils.ITEM_SELECTOR);
    }, currentKey, onCurrentKeyChange, undefined, undefined, allowEnterKey);
    // need to track pointer down element to set currentKey when initial focus happens
    const handlePointerDown = hooks.useCallback((event) => {
        const key = collectionUtils.keyExtractor(event.target, collectionUtils.ITEM_SELECTOR);
        if (keys.isKeyDefined(key)) {
            pendingCurrentKey.current = key;
            if (key !== currentKey) {
                focusAndScrollIntoView.current = false;
            }
        }
    }, [currentKey]);
    // handle undefined currentKey at the initial focus or invalid currentKey that doesn't exist
    const handleInvalidCurrentKey = hooks.useCallback(() => {
        if (rootRef.current && (!allowTabbableMode || isCurrentTabbableKey(undefined))) {
            const firstKey = pendingCurrentKey.current || collectionUtils.getFirstVisibleKey(rootRef.current, collectionUtils.ITEM_SELECTOR);
            if (keys.isKeyDefined(firstKey)) {
                onCurrentKeyChange({ value: firstKey });
            }
        }
    }, [rootRef, currentKey, onCurrentKeyChange, allowTabbableMode, isCurrentTabbableKey]);
    // handle currenKey and scroll into view during focus
    const handleFocus = hooks.useCallback((event) => {
        // avoid the focus get trapped in the expander
        if (isExpander(event.target)) {
            rootRef.current?.focus({ preventScroll: true });
            return;
        }
        if (rootRef.current) {
            if (!keys.isKeyDefined(currentKey)) {
                handleInvalidCurrentKey();
            }
            else {
                const elem = collectionUtils.findElementByKey(rootRef.current, currentKey, collectionUtils.ITEM_SELECTOR);
                if (elem) {
                    // if currentKey is defined, make sure scroll the current item into view only when the component regains focus,
                    // unless pendingCurrentKey gets updated to something different than currentKey
                    if (focusAndScrollIntoView.current) {
                        scrollIntoView(elem, rootRef, viewportConfig, scrollToVisibleOffset);
                    }
                    focusAndScrollIntoView.current = true;
                }
                else {
                    // if elem is not found, meaning the currentKey is not valid,
                    // we should pick the first item as current item
                    handleInvalidCurrentKey();
                }
            }
        }
    }, [rootRef, currentKey, handleInvalidCurrentKey, viewportConfig, scrollToVisibleOffset]);
    // update aria-activedescendant for screen reader
    hooks.useEffect(() => {
        if (allowActiveDescendant && rootRef.current && keys.isKeyDefined(currentKey)) {
            const elem = collectionUtils.findElementByKey(rootRef.current, currentKey, collectionUtils.ITEM_SELECTOR);
            if (elem) {
                const id = idExtractor(elem);
                const activeDescendant = rootRef.current.getAttribute('aria-activedescendant');
                if (id !== '' && activeDescendant !== id) {
                    rootRef.current.setAttribute('aria-activedescendant', id);
                    // scroll the current item into view only when:
                    // 1. the current item is updated internally and listview has focus
                    // 2. the current item is updated by the app when the collection gesture is 'embedded'
                    const hasFocus = rootRef.current?.contains(document.activeElement);
                    if ((!isCurrentItemOverridden && hasFocus) || isEmbedded) {
                        scrollIntoView(elem, rootRef, viewportConfig, scrollToVisibleOffset);
                    }
                }
            }
        }
        // listen to data because the current item would re-render when data is updated, i.e. the id
        // of current item would be updated, so the currentKey itself couldn't guarantee the root has
        // the latest aria-activedescendant
    }, [
        data,
        rootRef,
        currentKey,
        idExtractor,
        viewportConfig,
        scrollToVisibleOffset,
        isCurrentItemOverridden,
        allowActiveDescendant,
        isEmbedded
    ]);
    return {
        navigationProps: mergeProps.mergeProps(currentKeyProps, focusRingProps, allowTabbableMode ? tabbableModeProps : {}, {
            onFocus: handleFocus,
            onPointerDown: handlePointerDown
        }),
        currentKey,
        onCurrentKeyChange,
        isCurrentItemOverridden,
        showFocusRing,
        isCurrentTabbableKey
    };
};
/**
 * A private helper function to handle scroll into view
 */
const scrollIntoView = (elem, rootRef, viewportConfig, scrollToVisibleOffset) => {
    if (rootRef.current) {
        const scroller = viewportConfig?.scroller();
        const offset = scrollToVisibleOffset ? scrollToVisibleOffset(rootRef.current) : 0;
        scrollToVisible(elem, scroller || rootRef.current, offset);
    }
};
// TODO: should update the class 'oj-listview-expander' to something more general
// when we add treeview or expander components
const isExpander = (elem) => {
    if (elem.parentElement && elem.parentElement.classList.contains('oj-listview-expander')) {
        return true;
    }
    return false;
};

exports.excludeGroup = excludeGroup;
exports.isMultipleSelection = isMultipleSelection;
exports.scrollToVisible = scrollToVisible;
exports.useCurrentItemOverride = useCurrentItemOverride;
exports.useNavigation = useNavigation;
//# sourceMappingURL=useNavigation-49344b44.js.map
