/* @oracle/oraclejet-preact: undefined */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
require('./LayerHost-aee0e070.js');
var EnvironmentProvider = require('./EnvironmentProvider-8696a5b8.js');
var Floating = require('./Floating-5a704a27.js');
var Layer = require('./Layer-28b1afce.js');
require('preact/compat');

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const FocusTriggerKeys = ['Tab', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'];
/**
 * A global tooltip manager that
 * - ensures that only one tooltip is shown at a time
 * - detects a Tab key press and allows tooltips to check if their target was focused via keyboard
 */
class TooltipManager {
    constructor() {
        this.keyDownHandler = (event) => {
            if (FocusTriggerKeys.includes(event.key)) {
                this.triggerKeyActive = true;
                setTimeout(() => {
                    this.triggerKeyActive = false;
                }, 100);
            }
            if (this.activeCallback && event.key === 'Escape') {
                // hide active tooltip on Escape
                this.activeCallback();
            }
        };
        /**
         * notifies the previously registered active tooltip callback and registers a new one
         */
        this.register = (callback) => {
            if (this.activeCallback && this.activeCallback !== callback) {
                this.activeCallback();
            }
            this.activeCallback = callback;
        };
        /**
         * resets the registered active callback
         */
        this.unregister = (callback) => {
            if (this.activeCallback === callback) {
                this.activeCallback = null;
            }
        };
        /**
         * returns the active Tab key status ('active' means a Tab key press within the last 100ms)
         */
        this.isTabKeyActive = () => {
            return this.triggerKeyActive;
        };
        this.activeCallback = null;
        this.triggerKeyActive = false;
        window.addEventListener('keydown', this.keyDownHandler, true);
    }
}

// Global TooltipManager singleton instance
const globalTooltipManager = new TooltipManager();
/**
 * The delays (in ms) for Redwood tooltips.
 */
const SHOW_TOOLTIP_DELAY = 1000;
const HIDE_TOOLTIP_DELAY = 150;
/**
 * Returns a global TooltipManager singleton instance
 */
const getGlobalTooltipManager = () => {
    return globalTooltipManager;
};
/**
 * Wraps the tooltip content provided in the appropriate layering and returns the result for display.
 */
const getWrappedTooltipContent = (tooltipContent, variant, colorScheme, anchorRef, placement, offset) => {
    const defaultOffset = 8; // Redwood tooltip has a default offset of 8 pixels
    const newOffset = offset ? offset : { mainAxis: defaultOffset, crossAxis: 0 };
    const newColorScheme = !colorScheme || colorScheme === 'light' ? 'dark' : 'light';
    const renderTooltipOrDatatip = () => {
        if (variant === 'tooltip') {
            return (jsxRuntime.jsx(EnvironmentProvider.EnvironmentProvider, { environment: { colorScheme: newColorScheme }, children: tooltipContent }));
        }
        else {
            return jsxRuntime.jsx(jsxRuntime.Fragment, { children: tooltipContent });
        }
    };
    return (jsxRuntime.jsx(Layer.Layer, { priority: "tooltip", children: jsxRuntime.jsx(Floating.Floating, { anchorRef: anchorRef, placement: placement, offsetValue: newOffset, children: renderTooltipOrDatatip() }) }));
};

exports.HIDE_TOOLTIP_DELAY = HIDE_TOOLTIP_DELAY;
exports.SHOW_TOOLTIP_DELAY = SHOW_TOOLTIP_DELAY;
exports.getGlobalTooltipManager = getGlobalTooltipManager;
exports.getWrappedTooltipContent = getWrappedTooltipContent;
//# sourceMappingURL=tooltipUtils-ae48fed6.js.map
