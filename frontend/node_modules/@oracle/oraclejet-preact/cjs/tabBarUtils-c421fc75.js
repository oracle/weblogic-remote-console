/* @oracle/oraclejet-preact: undefined */
'use strict';

var collectionUtils = require('./collectionUtils-fe12edac.js');

const ITEM_SELECTOR = '[role="tab"]';
const LABEL_MIN_WIDTH = 96;
const TAB_BORDER = 6;
//This is the minWidth a tab will have if it has only a label.
const TAB_MIN_WIDTH = LABEL_MIN_WIDTH + TAB_BORDER;
const getTrailingContentInfo = (elem, cache) => {
    let trailingContentWidth = 0;
    const hasSeverity = elem.querySelector('[data-oj-tab-severity]') !== null;
    //A tab can have only one type of trailing content i.e either badge or metadata or severity so we would calculate only for one of them
    let badge, metadata;
    if (hasSeverity) {
        trailingContentWidth = 20;
    }
    else {
        const badgeElem = elem.querySelector('[data-oj-tab-badge]');
        if (badgeElem) {
            badge = badgeElem.getAttribute('data-oj-tab-badge');
            trailingContentWidth = badge === cache.badge ? cache.contentWidth : badgeElem.clientWidth;
        }
        else {
            const metadataElem = elem.querySelector('[data-oj-tab-metadata]');
            if (metadataElem) {
                metadata = metadataElem.getAttribute('data-oj-tab-metadata');
                trailingContentWidth =
                    metadata === cache.metadata ? cache.contentWidth : metadataElem.clientWidth;
            }
        }
    }
    return { badge, metadata, contentWidth: trailingContentWidth };
};
const getNonTextWidth = (elem, trailingContentWidth, isLastKey) => {
    const tabBarItemBorder = 6;
    //Gap between one item and it's adjacent neighbor also account's for an item's non text width with the exception of last item.
    const gapBetweenItems = isLastKey ? 0 : 32;
    //Gap between each content within the item, example gap between metadata and label.
    const gapBetweenItemContent = 8;
    const hasIcon = elem.querySelector('[data-oj-tab-icon]') !== null;
    const iconWidth = hasIcon ? 20 + gapBetweenItemContent : 0;
    const isRemovable = elem.querySelector('[data-oj-tabbar-item-remove-icon]') !== null;
    const removeIconWidth = isRemovable ? 24 + gapBetweenItemContent : 0;
    const nonTextWidth = tabBarItemBorder +
        iconWidth +
        removeIconWidth +
        (trailingContentWidth > 0 ? trailingContentWidth + gapBetweenItemContent + gapBetweenItems : 0);
    return nonTextWidth;
};
const getTabWidths = (container, trailingContentWidths, isTruncationDisabled, tabBarWidth, isAllItemsTruncatedMax, keysArray) => {
    let sumofItemsWidth = 0;
    const tabWidths = Array.from(container.querySelectorAll(ITEM_SELECTOR)).map((elem) => {
        const maxWidth = elem.offsetWidth;
        const hasReachedLimit = maxWidth <= LABEL_MIN_WIDTH ? true : false;
        const itemKey = collectionUtils.getKey(elem);
        const cacheInfo = trailingContentWidths?.current?.get(itemKey);
        const trailingContentInfo = getTrailingContentInfo(elem, cacheInfo ? cacheInfo : { contentWidth: 0 });
        trailingContentWidths.current.set(itemKey, trailingContentInfo);
        const isLastKey = keysArray && itemKey === keysArray[keysArray.length - 1] ? true : false;
        const nonTextWidth = getNonTextWidth(elem, trailingContentInfo.contentWidth, isLastKey);
        sumofItemsWidth += Math.max(96, maxWidth) + nonTextWidth;
        return {
            key: itemKey,
            maxWidth: maxWidth,
            nonTextWidth: nonTextWidth,
            cumulativeWidth: sumofItemsWidth,
            hasReachedLimit: hasReachedLimit
        };
    });
    //If all items have reached max treshold of truncation then we do not have to re-calculate or re-distribute any width
    if (tabWidths.length > 0 && !isTruncationDisabled && !isAllItemsTruncatedMax) {
        const gap = (tabWidths.length - 1) * 32;
        const avgWidth = (tabBarWidth - gap) / tabWidths.length;
        let extraWidth = 0;
        const wideTabIndex = [];
        tabWidths.forEach((record, index) => {
            //If an item has reached max treshold of truncation then we do not have to re-calculate or re-distribute any width
            if (!record.hasReachedLimit) {
                if (record.maxWidth <= avgWidth) {
                    extraWidth = extraWidth + (avgWidth - record.maxWidth);
                }
                else {
                    wideTabIndex.push(index);
                }
                record.maxWidth = avgWidth;
            }
        });
        if (wideTabIndex.length > 0 && extraWidth > 0) {
            const distributeWidth = extraWidth / wideTabIndex.length;
            wideTabIndex.forEach((index) => {
                //If an item has reached max treshold of truncation then we do not have to re-calculate or re-distribute any width
                if (!tabWidths[index].hasReachedLimit) {
                    tabWidths[index].maxWidth += distributeWidth;
                    //The hook should add distributed width to the wide tab item's cumulativeWidth
                    tabWidths[index].cumulativeWidth += distributeWidth;
                    //The hook should return the maximumWidth label can have accounting for non text content as well
                    tabWidths[index].maxWidth -= tabWidths[index].nonTextWidth;
                }
                //If the maximum width is lesser than threshold of truncation i.e 96px + tab's border then reset maxWidth to that and none of the tabs need truncation
                if (tabWidths[index].maxWidth <= TAB_MIN_WIDTH) {
                    tabWidths[index].needsTruncation = false;
                    tabWidths[index].maxWidth = TAB_MIN_WIDTH;
                }
            });
        }
    }
    return tabWidths;
};
/**
 * Provides the reordered keys and reference item position after performing the move operation
 */
const handleMove = (moveDirection, tabKeys, itemKey) => {
    const newArray = [...tabKeys];
    const currentItemIndex = newArray.indexOf(itemKey);
    let referenceItemIndex;
    if (moveDirection === 'forward') {
        referenceItemIndex = currentItemIndex + 1;
        newArray.splice(currentItemIndex, 1);
        newArray.splice(referenceItemIndex, 0, itemKey);
    }
    else {
        referenceItemIndex = currentItemIndex - 1;
        newArray.splice(currentItemIndex, 1);
        newArray.splice(referenceItemIndex, 0, itemKey);
    }
    return {
        newArray,
        referenceItemIndex
    };
};

exports.getTabWidths = getTabWidths;
exports.handleMove = handleMove;
//# sourceMappingURL=tabBarUtils-c421fc75.js.map
