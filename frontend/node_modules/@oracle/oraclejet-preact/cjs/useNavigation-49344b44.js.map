{"version":3,"file":"useNavigation-49344b44.js","sources":["../../src/hooks/PRIVATE_useListCommon/useCurrentItemOverride.ts","../../src/PRIVATE_List/ListUtils.ts","../../src/hooks/PRIVATE_useListCommon/useNavigation.ts"],"sourcesContent":["import { useRef, useMemo, useState, useEffect } from 'preact/hooks';\nimport { CurrentItemProps, CurrentKeyDetail, Item } from '#UNSAFE_Collection';\nimport { useReorderableContext } from '#hooks/PRIVATE_useReorderable/useReorderableContext';\n\n/**\n * This hook converts the new API (i.e. currentItemOverride and onPersistCurrentItem) back to\n * the old API (i.e. currentKey and onCurrentKeyChange), keeps the internal current item, and\n * also triggers an update when a new currentItemOverride is passed by the app\n *\n * @param currentItemOverride\n * @param onPersistCurrentItem\n */\nexport const useCurrentItemOverride = <K extends string | number>(\n  currentItemOverride: CurrentItemProps<K>['currentItemOverride'],\n  onPersistCurrentItem: CurrentItemProps<K>['onPersistCurrentItem']\n) => {\n  // the internal state of current item\n  const [currentItem, setCurrentItem] = useState<Item<K>>();\n  // track the currentItemOverride props\n  const currentItemOverrideRef = useRef<Item<K>>();\n  // whether the current item is overridden by the app\n  const isCurrentItemOverridden = useRef(false);\n\n  // if reorder is enabled, need to update the context here when current item is changed\n  const reorderContext = useReorderableContext();\n\n  // intercept onPersistCurrentItem calls to ensure internal state is updated appropriately\n  const handleCurrentItemChanged = useMemo(() => {\n    return (detail: CurrentKeyDetail<K>) => {\n      const rowKey = detail.value;\n      setCurrentItem({ rowKey });\n      onPersistCurrentItem?.(detail);\n      if (reorderContext?.currentItemKey != null) {\n        reorderContext.currentItemKey.current = rowKey;\n      }\n    };\n  }, [onPersistCurrentItem, reorderContext?.currentItemKey]);\n\n  // ensure any new currentItemOverride settings are applied only on that render\n  // (same as how Table handles the changes)\n  if (currentItemOverrideRef.current !== currentItemOverride) {\n    currentItemOverrideRef.current = currentItemOverride;\n    if (currentItem?.rowKey !== currentItemOverride?.rowKey) {\n      isCurrentItemOverridden.current = true;\n      handleCurrentItemChanged({ value: currentItemOverride?.rowKey as K });\n    }\n  }\n\n  useEffect(() => {\n    isCurrentItemOverridden.current = false;\n  });\n\n  return {\n    currentKey: currentItem?.rowKey,\n    onCurrentKeyChange: handleCurrentItemChanged,\n    isCurrentItemOverridden: isCurrentItemOverridden.current\n  };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { FlattenedDataState } from '../UNSAFE_Collection';\nimport { Keys } from '../utils/UNSAFE_keys';\nimport { ListProps } from '../UNSAFE_ListView/List.types';\n\n/**\n * Helper function to only include keys of leaf items.\n */\nexport const excludeGroup = <K, D>(data: FlattenedDataState<K, D>, keys: Keys<K>) => {\n  if (!keys.all) {\n    const groups = data.data\n      .filter((dataMetadata) => {\n        return !dataMetadata.metadata.isLeaf;\n      })\n      .map((dataMetadata) => {\n        return dataMetadata.metadata.key;\n      });\n    const leafOnly = Array.from(keys.keys.values()).filter((key: K) => {\n      return !groups.includes(key);\n    });\n    return { ...keys, keys: new Set(leafOnly) };\n  }\n  return keys;\n};\n\n/**\n * A helper function to make sure specified elem is visible in the specified container\n */\nexport const scrollToVisible = (elem: Element, scroller: Element, offset: number) => {\n  if (elem && scroller) {\n    if ((elem as any).scrollIntoViewIfNeeded) {\n      // for Safari, we'll need the non-standard scrollIntoViewIfNeeded\n      (elem as any).scrollIntoViewIfNeeded();\n    } else {\n      elem.scrollIntoView({ block: 'nearest' });\n    }\n    if (offset > 0) {\n      const scrollerBounds = scroller.getBoundingClientRect();\n      const elemBounds = elem.getBoundingClientRect();\n      const diff = scrollerBounds.top + offset - elemBounds.top;\n      if (diff > 0) {\n        scroller.scrollTop = scroller.scrollTop - diff;\n      }\n    }\n  }\n};\n\n/**\n * Helper method to determine whether the selection mode is multiple or multipleToggle\n */\nexport const isMultipleSelection = (selectionMode: ListProps<any, any>['selectionMode']) => {\n  return selectionMode === 'multiple' || selectionMode === 'multipleToggle';\n};\n","import type { RefObject } from 'preact';\nimport { useEffect, useCallback, useRef } from 'preact/hooks';\nimport { ListProps as CommonProps } from '#UNSAFE_ListView/List.types';\nimport { scrollToVisible } from '#PRIVATE_List/ListUtils';\nimport { useCurrentKey } from '#hooks/PRIVATE_useCurrentKey';\nimport { useCurrentItemOverride } from './useCurrentItemOverride';\nimport { useCollectionFocusRing } from '#hooks/PRIVATE_useCollectionFocusRing';\nimport { useTabbableModeSet } from '#hooks/PRIVATE_useTabbableModeSet';\nimport {\n  getFirstVisibleKey,\n  keyExtractor,\n  findElementByKey,\n  ITEM_SELECTOR\n} from '#utils/PRIVATE_collectionUtils';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport { isKeyDefined } from '#utils/UNSAFE_keys';\n\ntype ArrowKeyHandler<K> = (key?: K) => () => K | null;\ntype ArrowKeyAndHandlers<K> = {\n  ArrowUp: ArrowKeyHandler<K>;\n  ArrowDown: ArrowKeyHandler<K>;\n  ArrowLeft?: ArrowKeyHandler<K>;\n  ArrowRight?: ArrowKeyHandler<K>;\n};\n\n/**\n * A hook to set up the currentKey, focus ring and F2 mode.\n *\n * The current key setup includes convert the currentItemOverride to currentKey syntax, set initial currentKey,\n * scroll current item into view, update aria-activedescendant when currentKey changed.\n *\n * This hook can be shared across ListView, CardView, TreeView\n */\nexport const useNavigation = <K extends string | number, D>(\n  data: any | null,\n  rootRef: RefObject<HTMLDivElement>,\n  idExtractor: (elem: Element) => string,\n  arrowKeyAndHandlers: ArrowKeyAndHandlers<K>,\n  currentItemOverride: CommonProps<K, D>['currentItemOverride'],\n  onPersistCurrentItem: CommonProps<K, D>['onPersistCurrentItem'],\n  viewportConfig: CommonProps<K, D>['viewportConfig'],\n  scrollToVisibleOffset: CommonProps<K, D>['scrollToVisibleOffset'],\n  allowShiftKey: boolean,\n  allowTabbableMode?: boolean,\n  allowActiveDescendant?: boolean,\n  isEmbedded?: boolean,\n  allowEnterKey?: boolean\n) => {\n  // tracking pending current key in pointer down event\n  const pendingCurrentKey = useRef<K>();\n  // ensure current item scroll into view when treeview regains focus\n  // unless pendingCurrentKey gets updated to something different than currentKey\n  const focusAndScrollIntoView = useRef(true);\n\n  const { currentKey, onCurrentKeyChange, isCurrentItemOverridden } = useCurrentItemOverride(\n    currentItemOverride,\n    onPersistCurrentItem\n  );\n\n  const { currentKeyProps } = useCurrentKey(\n    (element) => keyExtractor(element, ITEM_SELECTOR),\n    allowShiftKey,\n    arrowKeyAndHandlers.ArrowUp(currentKey),\n    arrowKeyAndHandlers.ArrowDown(currentKey),\n    arrowKeyAndHandlers.ArrowLeft?.(currentKey),\n    arrowKeyAndHandlers.ArrowRight?.(currentKey),\n    currentKey,\n    onCurrentKeyChange\n  );\n\n  const [showFocusRing, focusRingProps] = useCollectionFocusRing(\n    rootRef,\n    Object.keys(arrowKeyAndHandlers)\n  );\n\n  const [isCurrentTabbableKey, tabbableModeProps] = useTabbableModeSet(\n    rootRef,\n    (element) => {\n      // we don't want the component to go into Tabbable mode when user clicks on expander\n      return isExpander(element) ? null : (keyExtractor(element, ITEM_SELECTOR) as K);\n    },\n    currentKey,\n    onCurrentKeyChange,\n    undefined,\n    undefined,\n    allowEnterKey\n  );\n\n  // need to track pointer down element to set currentKey when initial focus happens\n  const handlePointerDown = useCallback(\n    (event: PointerEvent) => {\n      const key = keyExtractor(event.target as HTMLElement, ITEM_SELECTOR);\n      if (isKeyDefined(key)) {\n        pendingCurrentKey.current = key as K;\n        if (key !== currentKey) {\n          focusAndScrollIntoView.current = false;\n        }\n      }\n    },\n    [currentKey]\n  );\n\n  // handle undefined currentKey at the initial focus or invalid currentKey that doesn't exist\n  const handleInvalidCurrentKey = useCallback(() => {\n    if (rootRef.current && (!allowTabbableMode || isCurrentTabbableKey(undefined))) {\n      const firstKey =\n        pendingCurrentKey.current || (getFirstVisibleKey(rootRef.current, ITEM_SELECTOR) as K);\n      if (isKeyDefined(firstKey)) {\n        onCurrentKeyChange({ value: firstKey });\n      }\n    }\n  }, [rootRef, currentKey, onCurrentKeyChange, allowTabbableMode, isCurrentTabbableKey]);\n\n  // handle currenKey and scroll into view during focus\n  const handleFocus = useCallback(\n    (event: FocusEvent) => {\n      // avoid the focus get trapped in the expander\n      if (isExpander(event.target as HTMLElement)) {\n        rootRef.current?.focus({ preventScroll: true });\n        return;\n      }\n      if (rootRef.current) {\n        if (!isKeyDefined(currentKey)) {\n          handleInvalidCurrentKey();\n        } else {\n          const elem = findElementByKey(rootRef.current, currentKey!, ITEM_SELECTOR);\n          if (elem) {\n            // if currentKey is defined, make sure scroll the current item into view only when the component regains focus,\n            // unless pendingCurrentKey gets updated to something different than currentKey\n            if (focusAndScrollIntoView.current) {\n              scrollIntoView(elem, rootRef, viewportConfig, scrollToVisibleOffset);\n            }\n            focusAndScrollIntoView.current = true;\n          } else {\n            // if elem is not found, meaning the currentKey is not valid,\n            // we should pick the first item as current item\n            handleInvalidCurrentKey();\n          }\n        }\n      }\n    },\n    [rootRef, currentKey, handleInvalidCurrentKey, viewportConfig, scrollToVisibleOffset]\n  );\n\n  // update aria-activedescendant for screen reader\n  useEffect(() => {\n    if (allowActiveDescendant && rootRef.current && isKeyDefined(currentKey)) {\n      const elem = findElementByKey(rootRef.current, currentKey!, ITEM_SELECTOR);\n      if (elem) {\n        const id = idExtractor(elem);\n        const activeDescendant = rootRef.current.getAttribute('aria-activedescendant');\n        if (id !== '' && activeDescendant !== id) {\n          rootRef.current.setAttribute('aria-activedescendant', id);\n          // scroll the current item into view only when:\n          // 1. the current item is updated internally and listview has focus\n          // 2. the current item is updated by the app when the collection gesture is 'embedded'\n          const hasFocus = rootRef.current?.contains(document.activeElement as HTMLElement);\n          if ((!isCurrentItemOverridden && hasFocus) || isEmbedded) {\n            scrollIntoView(elem, rootRef, viewportConfig, scrollToVisibleOffset);\n          }\n        }\n      }\n    }\n    // listen to data because the current item would re-render when data is updated, i.e. the id\n    // of current item would be updated, so the currentKey itself couldn't guarantee the root has\n    // the latest aria-activedescendant\n  }, [\n    data,\n    rootRef,\n    currentKey,\n    idExtractor,\n    viewportConfig,\n    scrollToVisibleOffset,\n    isCurrentItemOverridden,\n    allowActiveDescendant,\n    isEmbedded\n  ]);\n\n  return {\n    navigationProps: mergeProps(\n      currentKeyProps,\n      focusRingProps,\n      allowTabbableMode ? tabbableModeProps : {},\n      {\n        onFocus: handleFocus,\n        onPointerDown: handlePointerDown\n      }\n    ),\n    currentKey,\n    onCurrentKeyChange,\n    isCurrentItemOverridden,\n    showFocusRing,\n    isCurrentTabbableKey\n  };\n};\n\n/**\n * A private helper function to handle scroll into view\n */\nconst scrollIntoView = <K, D>(\n  elem: Element,\n  rootRef: RefObject<HTMLDivElement>,\n  viewportConfig: CommonProps<K, D>['viewportConfig'],\n  scrollToVisibleOffset: CommonProps<K, D>['scrollToVisibleOffset']\n) => {\n  if (rootRef.current) {\n    const scroller = viewportConfig?.scroller();\n    const offset = scrollToVisibleOffset ? scrollToVisibleOffset(rootRef.current) : 0;\n    scrollToVisible(elem, scroller || rootRef.current, offset);\n  }\n};\n\n// TODO: should update the class 'oj-listview-expander' to something more general\n// when we add treeview or expander components\nconst isExpander = (elem: HTMLElement) => {\n  if (elem.parentElement && elem.parentElement.classList.contains('oj-listview-expander')) {\n    return true;\n  }\n  return false;\n};\n"],"names":["useState","useRef","useReorderableContext","useMemo","useEffect","useCurrentKey","keyExtractor","ITEM_SELECTOR","useCollectionFocusRing","useTabbableModeSet","useCallback","isKeyDefined","getFirstVisibleKey","findElementByKey","mergeProps"],"mappings":"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"}