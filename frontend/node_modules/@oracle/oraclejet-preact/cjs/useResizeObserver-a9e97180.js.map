{"version":3,"file":"useResizeObserver-a9e97180.js","sources":["../../src/hooks/UNSAFE_useResizeObserver/useResizeObserver.tsx"],"sourcesContent":["import { useAddBusyState } from '#hooks/PRIVATE_useAddBusyState';\nimport { UnsafeDomHandle, UNSAFE_DOM_ACCESS } from '#utils/UNSAFE_unsafeDomAccess';\nimport type { RefObject } from 'preact';\nimport { useLayoutEffect } from 'preact/hooks';\n\ntype Options = {\n  /**\n   * When set to true, the callback will not be invoked even if the target element's size changes.\n   */\n  isDisabled?: boolean;\n\n  /**\n   * Sets which box model the observer will observe changes to.\n   */\n  box?: ResizeObserverBoxOptions;\n};\n\n/**\n * A hook for observing and responding to changes to the size of a DOM element.\n * It utilizes a ResizeObserver to observe changes to the size of the specified element\n * and accepts a callback function to respond to these changes.\n *\n * @param ref The ref to the target DOM element to observe.\n *     Note that if the element is dynamically added or remounted (e.g., due to conditional rendering or changes in dynamic lists),\n *     a simple useRef object will not automatically trigger the hook to re-observe the new element.\n *     To handle such cases, ensure that the hook receives a new ref whenever the DOM element changes.\n *     One way to achieve this is by storing the ref in state and updating it using a callback ref.\n * @param callback A callback function to be called when the size of the observed element changes.\n *     If the provided callback triggers the consuming component to re-render, then\n *     it's important to pass the same instance of the callback function during each render\n *     to prevent infinite re-render loops. One way to achieve this is by using useCallback.\n * @param options Configuration options.\n */\nconst useResizeObserver = (\n  ref: RefObject<Element> | RefObject<UnsafeDomHandle<Element>>,\n  callback: (entry: ResizeObserverEntry) => void,\n  options?: Options\n) => {\n  const { box, isDisabled = false } = options || {};\n  const { onBusyStart, onBusyEnd } = useAddBusyState('useResizeObserver: resizing');\n\n  useLayoutEffect(() => {\n    // Note ref may be undefined in the hooks storybook demo\n    if (!ref?.current || isDisabled) return;\n\n    const target = ref.current instanceof Element ? ref.current : ref.current[UNSAFE_DOM_ACCESS];\n    if (!target) return;\n\n    onBusyStart();\n    const resizeObserver = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        callback(entry);\n      }\n      onBusyEnd();\n    });\n    resizeObserver.observe(target, { box });\n\n    return () => {\n      resizeObserver.disconnect();\n      onBusyEnd();\n    };\n  }, [ref, callback, box, isDisabled, onBusyStart, onBusyEnd]);\n};\n\nexport { useResizeObserver };\n"],"names":["useAddBusyState","useLayoutEffect","UNSAFE_DOM_ACCESS"],"mappings":";;;;;;;AAiBA;;;;;;;;;;;;;;;AAeG;AACG,MAAA,iBAAiB,GAAG,CACxB,GAA6D,EAC7D,QAA8C,EAC9C,OAAiB,KACf;IACF,MAAM,EAAE,GAAG,EAAE,UAAU,GAAG,KAAK,EAAE,GAAG,OAAO,IAAI,EAAE,CAAC;IAClD,MAAM,EAAE,WAAW,EAAE,SAAS,EAAE,GAAGA,+BAAe,CAAC,6BAA6B,CAAC,CAAC;IAElFC,qBAAe,CAAC,MAAK;;AAEnB,QAAA,IAAI,CAAC,GAAG,EAAE,OAAO,IAAI,UAAU;YAAE,OAAO;QAExC,MAAM,MAAM,GAAG,GAAG,CAAC,OAAO,YAAY,OAAO,GAAG,GAAG,CAAC,OAAO,GAAG,GAAG,CAAC,OAAO,CAACC,iCAAiB,CAAC,CAAC;AAC7F,QAAA,IAAI,CAAC,MAAM;YAAE,OAAO;AAEpB,QAAA,WAAW,EAAE,CAAC;QACd,MAAM,cAAc,GAAG,IAAI,cAAc,CAAC,CAAC,OAAO,KAAI;AACpD,YAAA,KAAK,MAAM,KAAK,IAAI,OAAO,EAAE;gBAC3B,QAAQ,CAAC,KAAK,CAAC,CAAC;aACjB;AACD,YAAA,SAAS,EAAE,CAAC;AACd,SAAC,CAAC,CAAC;QACH,cAAc,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,GAAG,EAAE,CAAC,CAAC;AAExC,QAAA,OAAO,MAAK;YACV,cAAc,CAAC,UAAU,EAAE,CAAC;AAC5B,YAAA,SAAS,EAAE,CAAC;AACd,SAAC,CAAC;AACJ,KAAC,EAAE,CAAC,GAAG,EAAE,QAAQ,EAAE,GAAG,EAAE,UAAU,EAAE,WAAW,EAAE,SAAS,CAAC,CAAC,CAAC;AAC/D;;;;"}