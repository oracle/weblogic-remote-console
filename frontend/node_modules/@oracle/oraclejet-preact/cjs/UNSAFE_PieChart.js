/* @oracle/oraclejet-preact: undefined */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('preact/jsx-runtime');
var UNSAFE_PieChart_themes_PieChartStyles_css = require('./UNSAFE_PieChart/themes/PieChartStyles.css.js');
var TrackResizeContainer = require('./TrackResizeContainer-100be103.js');
require('./datatipUtils-d1ca81a1.js');
require('./accUtils-5c7d3255.js');
var lineUtils = require('./lineUtils-34a63fb2.js');
var utils$1 = require('./utils-7c1b4abe.js');
var classNames = require('./classNames-c14c6ef3.js');
var usePieChartNav = require('./usePieChartNav-d47d78a3.js');
var useDatatip = require('./useDatatip-4f6d3759.js');
var layoutUtils = require('./layoutUtils-e52005dc.js');
var mergeProps = require('./mergeProps-e3da7237.js');
var VisTabularDatatip = require('./VisTabularDatatip-9e44a7dd.js');
var useUser = require('./useUser-f900ddf1.js');
var useTestId = require('./useTestId-9093a54b.js');
var useVisTouchResponse = require('./useVisTouchResponse-376e11d5.js');
var hooks = require('preact/hooks');
var stringUtils = require('./stringUtils-3e19c8af.js');
var useContextMenu = require('./useContextMenu-e90f401c.js');
require('./SelectMenuGroupContext-ae5e1373.js');
require('preact');
require('./logger-2b636482.js');
require('./LayerHost-aee0e070.js');
require('preact/compat');


require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js');
require('./tooltipUtils-ae48fed6.js');

require('./UNSAFE_Menu/themes/MenuItemStyles.css.js');
require('./UNSAFE_Separator/themes/SeparatorStyles.css.js');


require('./UNSAFE_Menu/themes/redwood/MenuSeparatorVariants.css.js');

var eventsUtils = require('./eventsUtils-d34f8647.js');
var utils = require('./utils-ca441171.js');
var useTextDimensions = require('./useTextDimensions-c8b41697.js');
var useCssVars = require('./useCssVars-cc025013.js');
var cssUtils = require('./cssUtils-3318fbe2.js');
var colorUtils = require('./colorUtils-01f3caa2.js');

require('./useSize-8115eae0.js');
require('./useResizeObserver-a9e97180.js');
require('./useAddBusyState-d19ae1fa.js');
require('./BusyStateContext-86f40d3c.js');
require('./useBusyStateContext-362eee2a.js');
require('./unsafeDomAccess-c3a492f0.js');
require('./size-0717c0bd.js');
require('./utils-a66430fc.js');
require('./themeContract.css-a53fd740.js');
require('./clientUtils-a4619fcd.js');
require('./clientHints-c40c5250.js');
require('./getLocale-8e17dc46.js');
require('./labelUtils-a3deed57.js');
require('./textUtils-e779c845.js');
require('./dimensionUtils-3919753d.js');
require('./scale-9e43a5f6.js');
require('./useVisHover-ad36112d.js');
require('./useVisDrill-61cccf0f.js');
require('./useDoubleTap-d3937fb6.js');
require('./clientUtils-ef5e20ce.js');
require('./Layer-28b1afce.js');
require('./UNSAFE_Layer/themes/LayerStyles.css.js');

require('./useThemeInterpolations-4faece98.js');
require('./useColorScheme-23e4aab4.js');
require('./useScale-adc62f41.js');
require('./theme-dfd6a9fe.js');
require('./Theme-f06687af.js');
require('./mergeInterpolations-6727b536.js');
require('./mergeDeepWithKey-210b024d.js');
require('./_curry3-18677bca.js');
require('./_curry1-e8f0d7ea.js');
require('./_curry2-c15d89cd.js');
require('./_isObject-28636267.js');
require('./useDensity-022a8f80.js');
require('./Floating-5a704a27.js');
require('./useFloating-13101293.js');
require('./positionUtils-a780137e.js');
require('./refUtils-a9872e75.js');
require('./useOutsideClick-c3802f86.js');
require('./arrayUtils-7d8dcfc3.js');
require('./useModal-0739a528.js');
require('./useComponentTheme-082fc8e4.js');
require('./UNSAFE_Floating/themes/redwood/FloatingTheme.js');
require('./UNSAFE_Floating/themes/FloatingStyles.css.js');

require('./UNSAFE_Floating/themes/redwood/FloatingBaseTheme.css.js');

require('./UNSAFE_Floating/themes/redwood/FloatingVariants.css.js');
require('./vanilla-extract-recipes-createRuntimeFn.esm-d1301b2d.js');
require('./vanilla-extract-dynamic.esm-2e1b7c25.js');
require('./UNSAFE_Floating/themes/FloatingContract.css.js');
require('./useUnsafeDomElementRef-f22a2f0c.js');
require('./hooks/PRIVATE_useDatatip/themes/useDatatip.css.js');

require('./useId-6c0eeb27.js');
require('./PRIVATE_VisTabularDatatip/themes/VisTabularDatatipStyles.css.js');

require('./useContextMenuGesture-03ba6353.js');
require('./textSelectionUtils-432ab66b.js');
require('./Sheet-44b25f1d.js');
require('./Modal-0cea796e.js');
require('./UNSAFE_Modal/themes/ModalStyles.css.js');

require('./tabbableUtils-7e41d383.js');
require('./head-68d0992f.js');
require('./_arity-c228159c.js');
require('./_isArray-73160ad5.js');
require('./_isString-f4443c9e.js');
require('./popupUtils-488fe8f7.js');
require('./WindowOverlay-a10f995e.js');
require('./UNSAFE_WindowOverlay/themes/WindowOverlayStyles.css.js');

require('./UNSAFE_WindowOverlay/themes/WindowOverlayContract.css.js');
require('./UNSAFE_WindowOverlay/themes/redwood/WindowOverlayTheme.js');
require('./UNSAFE_WindowOverlay/themes/redwood/WindowOverlayBaseTheme.css.js');

require('./UNSAFE_WindowOverlay/themes/redwood/WindowOverlayVariants.css.js');
require('./UNSAFE_Sheet/themes/SheetStyles.css.js');

require('./useAnimationStatus-c0c14bcc.js');
require('./useAnimation-fb11e4cc.js');
require('./animationUtils-54852d03.js');
require('./useTranslationBundle-18b7bf8b.js');
require('./Dropdown-b2579045.js');
require('./keyboardUtils-b42fe7d5.js');
require('./usePopupAnimation-18040396.js');
require('./popupAnimationUtils-dcace427.js');
require('./CollectionInteractionContext-f84ff7a1.js');
require('./UNSAFE_Dropdown/themes/dropdownStyles.css.js');

require('./useOutsideMousedown-8f913d1a.js');
require('./UNSAFE_Menu/themes/MenuStyles.css.js');
require('./UNSAFE_Menu/themes/DropdownMenuStyles.css.js');

require('./Flex-6ca216a7.js');
require('./boxalignment-6dde2812.js');

require('./vanilla-extract-sprinkles-createRuntimeSprinkles.esm-d68f3e0f.js');
require('./dimensions-2fcc0acf.js');
require('./flexbox-2cae9a01.js');

require('./flexitem-fee13e26.js');


require('./Skeleton-e746e396.js');
require('./borders-4b8488cb.js');
require('./UNSAFE_Skeleton/themes/redwood/SkeletonTheme.js');
require('./UNSAFE_Skeleton/themes/SkeletonStyles.css.js');

require('./UNSAFE_Skeleton/themes/redwood/SkeletonBaseTheme.css.js');

require('./UNSAFE_Skeleton/themes/redwood/SkeletonVariants.css.js');
require('./UNSAFE_Menu/themes/MenuSkeletonStyles.css.js');

require('./LiveRegion-e410e187.js');

require('./UNSAFE_Menu/themes/redwood/MenuItemTheme.js');
require('./UNSAFE_Menu/themes/redwood/MenuItemBaseTheme.css.js');

require('./UNSAFE_Menu/themes/redwood/MenuItemVariants.css.js');


require('./Text-436e8b56.js');
require('./UNSAFE_Text/themes/TextStyles.css.js');

require('./usePress-886180e4.js');
require('./useInteractionStyle-c203a8a0.js');
require('./useHover-49b0430d.js');
require('./useToggle-3ebba7d8.js');
require('./useActive-6770f917.js');
require('./index-15e13649.js');
require('./UNSAFE_Layer/themes/LayerHostStyles.css.js');


require('./EnvironmentProvider-8696a5b8.js');
require('./LayerManager-fc4df14f.js');

require('./useTheme-09dfbb78.js');

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const RADIUS_RATIO = 0.45;
const RADIUS_RATIO_WITH_LABELS = 0.38;
const SLICE_GAP_RATIO = 3;
const MIN_ARC_LENGTH = 1.5;
const START_ANGLE = 90;
/**
 * Converts the angle from degrees to radians.
 * @param degree The angle in degrees
 * @returns
 */
function degreesToRads(degree) {
    return degree * (Math.PI / 180);
}
/**
 * Calculates the angle between two vectors.
 * @param vector1X The x component of first vector.
 * @param vector1Y The y component of first vector.
 * @param vector2X The x component of second vector.
 * @param vector2Y The y component of second vector.
 * @returns
 */
function calculateAngleBetweenTwoVectors(vector1X, vector1Y, vector2X, vector2Y) {
    const angle = Math.atan2(vector2Y, vector2X) - Math.atan2(vector1Y, vector1X);
    return angle < 0 ? angle + 2 * Math.PI : angle;
}
/**
 * Get the center coord of the pie chart.
 * @param availSpace The available space.
 * @returns
 */
function getPieCenter(availSpace) {
    return {
        cx: availSpace.x + Math.floor(availSpace.width / 2),
        cy: availSpace.y + Math.floor(availSpace.height / 2)
    };
}
/**
 * Returns the radius of the pie chart.
 * @param availSpace The available space.
 * @param labelPosition The position of labels.
 * @returns
 */
function getRadius(availSpace, isLabelOutside) {
    const radiusScale = isLabelOutside ? RADIUS_RATIO_WITH_LABELS : RADIUS_RATIO;
    return Math.floor(Math.min(availSpace.width, availSpace.height) * radiusScale);
}
/**
 * Returns the total value of the pie chart.
 * @param items
 */
function getPieChartInfo(items) {
    return items.reduce(({ totalValue, isLabelOutside }, item) => {
        return {
            totalValue: totalValue + item.value,
            isLabelOutside: isLabelOutside || (!!item.label && (item.labelPosition === 'outside' || item.labelPosition === 'auto'))
        };
    }, { totalValue: 0, isLabelOutside: false });
}
/**
 * Returns the startAngle and angleOffset for the rendered items.
 * @param items
 * @param totalValue
 */
function getSliceInfo(items, totalValue, colors, isRtl) {
    let anchorOffset = START_ANGLE;
    let percentage;
    const sliceInfo = [];
    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const value = item.value;
        if (value === totalValue) {
            percentage = 100;
        }
        else if (totalValue === 0) {
            percentage = 0;
        }
        else {
            // if value is not 100%, cap it at 99.99%
            percentage = Math.min((value / totalValue) * 100, 99.99);
        }
        const arc = percentage * 3.6;
        let angle = anchorOffset - arc;
        if (angle < 0)
            angle += 360;
        sliceInfo.push({
            color: colors[(isRtl ? items.length - 1 - i : i) % colors.length],
            index: i,
            startAngle: angle,
            angleExtent: arc,
            ...item
        });
        anchorOffset = angle;
    }
    return sliceInfo;
}
/**
 * Returns the pie slice gaps.
 * @param  pieSliceGap The ratio of maximum supported pie slice gap.
 * @returns
 */
function getPieSliceGap(pieSliceGap) {
    return SLICE_GAP_RATIO * pieSliceGap;
}
/**
 * Returns the array of layouts to render without skipping.
 * @param layouts
 * @param hasLargeItemCount
 * @param radius
 * @returns
 */
function getRenderedSlices(itemInfo, hasLargeItemCount, radius) {
    if (!hasLargeItemCount) {
        return itemInfo;
    }
    const perimeter = 2 * Math.PI * radius;
    let prevEndCoord = 0;
    return itemInfo.filter(({ startAngle, angleExtent }) => {
        const arcLength = (angleExtent / 360) * perimeter;
        const endCoord = ((angleExtent + startAngle) / 360) * perimeter;
        if (arcLength < MIN_ARC_LENGTH && Math.abs(prevEndCoord - endCoord) < MIN_ARC_LENGTH) {
            return false;
        }
        else {
            prevEndCoord = endCoord;
            return true;
        }
    });
}
/**
 * Returns the path of the pie slice wedge.
 * @param inset The inset.
 * @param cx The x coordinate of the center of the pie chart.
 * @param cy The y coordinate of the center of the pie chart.
 * @param radiusX The x radius of the slice.
 * @param radiusY The y radius of the slice.
 * @param innerRadius The inner radius.
 * @param angleExtent The angle extent.
 * @param wedgeGap The gap beteen the pie slices.
 * @param startAngle The start angle of the pie slice.
 * @returns
 */
function makeWedgePath(inset, cx, cy, radiusX, radiusY, innerRadius, angleExtent, wedgeGap, startAngle) {
    const rx = Math.max(radiusX - inset, 0);
    const ry = Math.max(radiusY - inset, 0);
    const gap = angleExtent == 360 || rx < inset ? 0 : wedgeGap + 2 * inset;
    const ir = innerRadius ? innerRadius + inset : 0;
    // if angle extent is not 360, cap it  at 359.99
    const angleExtentRads = angleExtent == 360 ? degreesToRads(359.99) : degreesToRads(angleExtent);
    const startAngleRads = degreesToRads(startAngle);
    const dataItemGaps = gap / 2;
    const gapAngle = dataItemGaps < rx ? Math.asin(dataItemGaps / rx) : 0;
    const centerLineAngle = -angleExtentRads / 2 - startAngleRads;
    // cap at 5* dataItemsGap. logic from legacy dvt toolkit
    const distanceToStartPointX = Math.min(dataItemGaps * 5, angleExtentRads > 0 ? Math.abs(dataItemGaps / Math.sin(angleExtentRads / 2)) : 0);
    const distanceToStartPointY = rx == 0 ? distanceToStartPointX : (distanceToStartPointX * ry) / rx;
    const startPointX = cx + Math.cos(centerLineAngle) * distanceToStartPointX;
    const startPointY = cy + Math.sin(centerLineAngle) * distanceToStartPointY;
    const arcPointX = cx + Math.cos(-gapAngle - startAngleRads) * rx;
    const arcPointY = cy + Math.sin(-gapAngle - startAngleRads) * ry;
    const arcPoint2X = cx + Math.cos(-startAngleRads - angleExtentRads + gapAngle) * rx;
    const arcPoint2Y = cy + Math.sin(-startAngleRads - angleExtentRads + gapAngle) * ry;
    let outerAngle = calculateAngleBetweenTwoVectors(arcPoint2X - cx, arcPoint2Y - cy, arcPointX - cx, arcPointY - cy);
    outerAngle = Math.min(outerAngle, angleExtentRads);
    let pathCommands;
    if (ir > 0) {
        const innerGapAngle = dataItemGaps < ir ? Math.asin(dataItemGaps / ir) : 0;
        const innerPointX = cx + Math.cos(-innerGapAngle - startAngleRads) * ir;
        const innerPointY = cy + Math.sin(-innerGapAngle - startAngleRads) * ir;
        const innerPoint2X = cx + Math.cos(-startAngleRads - angleExtentRads + innerGapAngle) * ir;
        const innerPoint2Y = cy + Math.sin(-startAngleRads - angleExtentRads + innerGapAngle) * ir;
        let innerAngle = calculateAngleBetweenTwoVectors(innerPoint2X - cx, innerPoint2Y - cy, innerPointX - cx, innerPointY - cy);
        innerAngle = Math.min(innerAngle, outerAngle, angleExtentRads);
        if (angleExtent == 360) {
            pathCommands = lineUtils.moveTo(arcPoint2X, arcPoint2Y);
            pathCommands += lineUtils.arcTo(rx, ry, angleExtentRads, 1, arcPointX, arcPointY);
            pathCommands += lineUtils.lineTo(arcPoint2X, arcPoint2Y);
            pathCommands += lineUtils.moveTo(innerPointX, innerPointY);
            pathCommands += lineUtils.arcTo(ir, ir, angleExtentRads, 0, innerPoint2X, innerPoint2Y);
        }
        else {
            pathCommands = lineUtils.moveTo(innerPoint2X, innerPoint2Y);
            pathCommands += lineUtils.lineTo(arcPoint2X, arcPoint2Y);
            pathCommands += lineUtils.arcTo(rx, ry, outerAngle, 1, arcPointX, arcPointY);
            pathCommands += lineUtils.lineTo(innerPointX, innerPointY);
            pathCommands += lineUtils.arcTo(ir, ir, innerAngle, 0, innerPoint2X, innerPoint2Y);
        }
    }
    else {
        if (angleExtent == 360) {
            pathCommands = lineUtils.moveTo(arcPoint2X, arcPoint2Y);
            pathCommands += lineUtils.arcTo(rx, ry, angleExtentRads, 1, arcPointX, arcPointY);
        }
        else {
            pathCommands = lineUtils.moveTo(startPointX, startPointY);
            pathCommands += lineUtils.lineTo(arcPoint2X, arcPoint2Y);
            pathCommands += lineUtils.arcTo(rx, ry, outerAngle, 1, arcPointX, arcPointY);
        }
    }
    pathCommands += lineUtils.closePath();
    return pathCommands;
}
/**
 * Returns the pie chart center context.
 * @param cx The x coordinate of the center of the pie chart.
 * @param cy The y coordinate of the center of the pie chart.
 * @param innerRadius The inner radius of the pie chart.
 * @returns
 */
function getCenterContext(cx, cy, innerRadius) {
    return {
        innerBounds: {
            width: Math.sqrt(2) * innerRadius,
            height: Math.sqrt(2) * innerRadius,
            x: cx - innerRadius / Math.sqrt(2),
            y: cy - innerRadius / Math.sqrt(2)
        },
        outerBounds: {
            width: 2 * innerRadius,
            height: 2 * innerRadius,
            x: cx - innerRadius,
            y: cy - innerRadius
        }
    };
}
/**
 * Returns the position of the datatip for a given slice.
 * @param startAngle The start angle of the pie slice.
 * @param angleExtent The angle extent of the pie slice.
 * @param cx The x coordinate of the center of the pie slice.
 * @param cy The y coordinate of the center of the pie slice.
 * @param innerRadius The inner radius.
 * @param radius The radius of the pie slice.
 * @returns
 */
function getPieItemCenterCoord(startAngle, angleExtent, cx, cy, innerRadius, radius) {
    const angle = startAngle + angleExtent / 2;
    const theta = (angle / 180) * Math.PI;
    const r = (innerRadius + radius) / 2;
    return {
        x: cx + r * Math.cos(theta),
        y: cy - r * Math.sin(theta),
        width: 0,
        height: 0
    };
}
/**
 * Returns the element bound for active item.
 * @param renderedSlices The array of info for rendered slices.
 * @param cx The x coordinate of pie chart center.
 * @param cy The y coordinate of pie chart center.
 * @param ir The inner radius of the pie chart.
 * @param radius The radius of the pie chart.
 * @param activeItem The active item.
 * @returns
 */
function getElementBounds(renderedSlices, cx, cy, ir, radius, activeItem) {
    return activeItem
        ? getPieItemCenterCoord(renderedSlices[activeItem.itemIndex].startAngle, renderedSlices[activeItem.itemIndex].angleExtent, cx, cy, ir, radius)
        : undefined;
}
/**
 * Returns default border color for datatip.
 * @param colors The color ramp.
 * @param activeItem The active item info.
 * @param activeData The active pie chart data item.
 * @returns
 */
function getDefaultBorderColor(colors, activeItem, activeData) {
    return activeData?.color || activeItem?.itemIndex != undefined
        ? colors[activeItem.itemIndex]
        : undefined;
}

/**
 * The Pie Slice component.
 */
function PieSlice({ cx, cy, r, startAngle, angleExtent, gap, innerRadius, color, id, itemIndex, isFocused = false, isInteractive, ...props }) {
    const { interactiveItemStyle, contrastBorder, innerShapes } = UNSAFE_PieChart_themes_PieChartStyles_css.styles;
    const itemClasses = classNames.classNames([
        isInteractive && interactiveItemStyle,
        contrastBorder,
        innerShapes
    ]);
    const path = makeWedgePath(0, cx, cy, r, r, innerRadius, angleExtent, gap, startAngle);
    let innerPath;
    if (isFocused) {
        innerPath = makeWedgePath(2, cx, cy, r, r, innerRadius, angleExtent, gap, startAngle);
        return (jsxRuntime.jsxs("g", { id: id, role: props.accessibleLabel ? 'img' : undefined, "data-oj-private-item-index": itemIndex, "data-oj-private-object": "pieSlice", "aria-label": props.accessibleLabel, children: [jsxRuntime.jsx("path", { d: path, fill: color, stroke: color, className: UNSAFE_PieChart_themes_PieChartStyles_css.styles.innerShapes }), jsxRuntime.jsx("path", { d: innerPath, fill: color, className: itemClasses })] }));
    }
    return (jsxRuntime.jsx("path", { role: props.accessibleLabel ? 'img' : undefined, "aria-label": props.accessibleLabel, d: path, "data-oj-private-object": "pieSlice", fill: color, id: id, "data-oj-private-item-index": itemIndex, className: isInteractive ? interactiveItemStyle : undefined }));
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Returns the item based on item info in a pie chart.
 * @param itemInfo
 * @param items
 * @returns
 */
function getItem(itemInfo, items) {
    const { itemIndex } = itemInfo;
    return items[itemIndex];
}
/**
 * Returns the nav util for pie chart.
 * @param data
 * @param isRtl
 * @returns
 */
function getPieChartNavUtils(data, isRtl) {
    return {
        getNextChartItem: ({ itemIndex }, arrow) => {
            let newItemIndex = itemIndex;
            if ((isRtl && (arrow === 'ArrowRight' || arrow === 'ArrowUp')) ||
                (!isRtl && (arrow === 'ArrowLeft' || arrow === 'ArrowDown'))) {
                newItemIndex = itemIndex - 1;
            }
            else {
                newItemIndex = itemIndex + 1;
            }
            return {
                itemIndex: ((newItemIndex % data.length) + data.length) % data.length
            };
        },
        getDetailFromInfo: (itemInfo) => {
            if (!itemInfo) {
                return { id: undefined, data: undefined };
            }
            const item = getItem(itemInfo, data);
            return { id: item ? item.id : undefined, data: item };
        }
    };
}

const usePieChartContextMenu = ({ offset, rootRef, contextMenuConfig, focusedItemInfo, items, onContextMenuDismissed, width, isRtl }) => {
    const { contextMenuProps, contextMenuContent } = useContextMenu.useContextMenu({
        onContextMenuHandler: ({ gesture, target }) => {
            if (gesture === 'keyboard') {
                const itemIndex = focusedItemInfo.itemIndex;
                const data = items[itemIndex];
                const context = {
                    type: 'item',
                    data
                };
                return {
                    type: 'offset',
                    context,
                    offsetValue: offset,
                    isRtl,
                    width
                };
            }
            const itemIndex = eventsUtils.getInfo(rootRef, target)?.itemIndex;
            const data = itemIndex !== undefined ? items[itemIndex] : null;
            let context;
            if (data) {
                context = {
                    type: 'item',
                    data: data
                };
            }
            else if (rootRef.current?.children[1].contains(target)) {
                context = { type: 'centerLabel' };
            }
            else {
                context = { type: 'background' };
            }
            return {
                type: 'pointer',
                context
            };
        },
        contextMenuOptions: {
            isDisabled: !contextMenuConfig //If there is no context menu renderer, we disable the hook
        },
        rootRef,
        contextMenuConfig,
        onContextMenuDismissed
    });
    return { contextMenuContent, contextMenuProps };
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const OUTSIDE_LABEL_DISTANCE = 1.04;
const _COLLISION_MARGIN = 1;
const _FEELER_RAD_MINSIZE = 0.1;
const _FEELER_HORIZ_MINSIZE = 0.1;
const _LABEL_TO_FEELER_OFFSET = 0.5;
const _ALL_COLLISION = 2;
const _HALF_COLLISION = 1;
const _NO_COLLISION = 0;
const _LABEL_TO_FEELER_DISTANCE = 3;
function degreesToRadians(degrees) {
    return degrees * (Math.PI / 180);
}
function reflectAngleOverYAxis(angle, cx, cy, rx, ry) {
    const radian = degreesToRadians(360 - angle);
    const cosine = Math.cos(radian);
    const sine = Math.sin(radian);
    return { x: cx + cosine * rx, y: cy + sine * ry };
}
function skipSliceLabel(slice, seriesCount) {
    const { angleExtent } = slice;
    return angleExtent < 3 && seriesCount > 120;
}
/**
 * Returns true if this slice contains the given coordinates.
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */
function sliceContainsPoint(slice, x, y, cx, cy, innerRadius, radius) {
    const { angleExtent, startAngle } = slice;
    const ir = innerRadius;
    const c = { x: cx, y: cy };
    const cos = (x - c.x) / radius;
    const sin = (y - c.y) / radius;
    // Compute the angle
    let angle = -Math.atan2(sin, cos) * (180 / Math.PI); // in degrees
    // First adjust angle to be greater than the start angle.
    while (angle < startAngle)
        angle += 360;
    // Then adjust to be within 360 degrees of it
    while (angle - startAngle >= 360)
        angle -= 360;
    const distance = Math.pow(cos, 2) + Math.pow(sin, 2);
    const containsRadius = Math.sqrt(distance) > ir / radius && distance <= 1;
    const containsAngle = angle <= startAngle + angleExtent;
    return containsRadius && containsAngle;
}
function getInsideLabelsInfo(slices, innerRadius, radius, pieCenter, defaultFontSize, getTextDimensions) {
    const insideLabels = [];
    const outsideLabelsIndex = new Set();
    const { cx, cy } = pieCenter;
    for (const slice of slices) {
        const { labelPosition: l, startAngle, angleExtent, label, labelStyle } = slice;
        const labelPosition = l || 'auto';
        if (labelPosition === 'none') {
            continue;
        }
        if (labelPosition === 'outside' || skipSliceLabel(slice, slices.length) || label == null) {
            outsideLabelsIndex.add(slice.index);
            continue;
        }
        const midAngle = startAngle + angleExtent / 2;
        const ir = innerRadius;
        const center = pieCenter;
        let posX, posY;
        if (slices.length === 1) {
            posX = center.cx;
            posY = center.cy;
        }
        else {
            const offset = Math.max(0.45, 0.65 - (0.45 * ir) / Math.max(radius, 0.001));
            const midPt = reflectAngleOverYAxis(midAngle, center.cx, center.cy, ir + (radius - ir) * offset, ir + (radius - ir) * offset);
            posX = midPt.x;
            posY = midPt.y;
        }
        const sliceLabelPosition = {
            x: posX,
            y: posY
        };
        const sliceLabelDims = getTextDimensions(label, { fontSize: defaultFontSize, ...labelStyle });
        let x1 = posX;
        let x2 = posX;
        const y1 = posY - sliceLabelDims.height / 2;
        const y2 = posY + sliceLabelDims.height / 2;
        while (sliceContainsPoint(slice, x1, y1, cx, cy, innerRadius, radius) &&
            sliceContainsPoint(slice, x1, y2, cx, cy, innerRadius, radius)) {
            x1--;
        }
        while (sliceContainsPoint(slice, x2, y1, cx, cy, innerRadius, radius) &&
            sliceContainsPoint(slice, x2, y2, cx, cy, innerRadius, radius)) {
            x2++;
        }
        x1 = Math.ceil(x1 + 3);
        x2 = Math.floor(x2 - 3);
        let usableSpace = 2 * Math.min(posX - x1, x2 - posX);
        if (usableSpace < sliceLabelDims.width) {
            sliceLabelPosition.x = (x1 + x2) / 2;
            usableSpace = x2 - x1;
        }
        if (labelPosition === 'inside') {
            const textWidth = sliceLabelDims.width;
            if (textWidth < usableSpace) {
                insideLabels.push({
                    position: midAngle,
                    angle: midAngle,
                    slice,
                    textInfo: utils.getTextInfo(label, { fontSize: defaultFontSize, ...labelStyle }, usableSpace, sliceLabelDims.height, false, label.length, getTextDimensions),
                    ...sliceLabelDims,
                    ...sliceLabelPosition
                });
            }
        }
        else {
            const minChars = label.length;
            const textInfo = utils.getTextInfo(label, { fontSize: defaultFontSize, ...labelStyle }, usableSpace, sliceLabelDims.height, false, minChars, getTextDimensions);
            if (!textInfo.didNotFit) {
                insideLabels.push({
                    position: midAngle,
                    angle: midAngle,
                    slice,
                    textInfo,
                    ...sliceLabelDims,
                    ...sliceLabelPosition
                });
            }
            else {
                outsideLabelsIndex.add(slice.index); // Indicates outside label is needed
            }
        }
    }
    return [insideLabels, outsideLabelsIndex];
}
const layoutPieChartLabels = (slices, pieCenter, innerRadius, radius, availSpace, getTextDimensions, defaultFontSize) => {
    const [insideLabels, outsideLabels] = getInsideLabelsInfo(slices, innerRadius, radius, pieCenter, defaultFontSize, getTextDimensions);
    const { leftLabels, rightLabels } = generateInitialLayout(slices, outsideLabels, availSpace, pieCenter, radius, defaultFontSize, getTextDimensions);
    const leftColl = _refineInitialLayout(slices, radius, pieCenter, availSpace, leftLabels, 'left');
    const rightColl = _refineInitialLayout(slices, radius, pieCenter, availSpace, rightLabels, 'right');
    if (leftColl === _HALF_COLLISION && rightColl !== _NO_COLLISION) {
        _columnLabels(slices, availSpace, pieCenter, radius, leftLabels, true, true, true);
    }
    if (leftColl !== _NO_COLLISION && rightColl === _HALF_COLLISION) {
        _columnLabels(slices, availSpace, pieCenter, radius, rightLabels, false, true, true);
    }
    setLabelsAndFeelers(leftLabels, availSpace, pieCenter, radius, 'left', { fontSize: defaultFontSize }, getTextDimensions);
    setLabelsAndFeelers(rightLabels, availSpace, pieCenter, radius, 'right', { fontSize: defaultFontSize }, getTextDimensions);
    return { insideLabels, rightLabels, leftLabels };
};
function generateInitialLayout(slices, outsideLabels, availSpace, center, radius, defaultFontSize, getTextDimensions) {
    const leftLabels = [];
    const rightLabels = [];
    const { cx, cy } = center;
    for (let i = 0; i < slices.length; i++) {
        const slice = slices[i];
        const { labelPosition, startAngle, angleExtent, label, labelStyle } = slice;
        if (label == null ||
            labelPosition == 'none' ||
            labelPosition == 'inside' ||
            skipSliceLabel(slices[i], slices.length) ||
            !outsideLabels.has(slice.index)) {
            continue;
        }
        let middleAngle = startAngle + angleExtent / 2;
        if (middleAngle > 360)
            middleAngle -= 360;
        if (middleAngle < 0)
            middleAngle += 360;
        const labelPt = reflectAngleOverYAxis(middleAngle, cx, cy, radius * OUTSIDE_LABEL_DISTANCE, radius * OUTSIDE_LABEL_DISTANCE);
        const isLeftSide = middleAngle >= 90 && middleAngle < 270;
        const maxLabelWidth = getMaxLabelWidth(availSpace, labelPt.x, isLeftSide);
        const textInfo = utils.getTextInfo(label, { fontSize: defaultFontSize, ...labelStyle }, maxLabelWidth, Infinity, true, 1, getTextDimensions);
        const tmDimPt = { x: textInfo.width, y: textInfo.height };
        const midArea = 15;
        if (middleAngle < 180 - midArea && middleAngle > midArea) {
            //upper half
            labelPt.y -= tmDimPt.y * 1;
        }
        else if (middleAngle < midArea || middleAngle > 360 - midArea) {
            //right side, near horizontal
            labelPt.y -= tmDimPt.y * 0.5;
            labelPt.x += tmDimPt.y * 0.2;
        }
        else if (middleAngle > 180 - midArea && middleAngle < 180 + midArea) {
            //left side, near horizontal
            labelPt.y -= tmDimPt.y * 0.5;
            labelPt.x -= tmDimPt.y * 0.2;
        }
        if (slices.length == 1)
            // only 1 label
            labelPt.x -= tmDimPt.x / 2; //position the label at the center
        if (labelPt.y < availSpace.y || labelPt.y + tmDimPt.y > availSpace.y + availSpace.height)
            // label will not fit with appropriate spacing
            continue;
        let pa;
        if (middleAngle >= 90.0 && middleAngle < 270.0) {
            pa = middleAngle - 90.0;
            createLabelInfo(slice, middleAngle, pa, tmDimPt, labelPt, textInfo, leftLabels);
        }
        else {
            // right side
            // normalize from 0 to 180
            pa = middleAngle <= 90.0 ? Math.abs(90 - middleAngle) : 180 - (middleAngle - 270);
            createLabelInfo(slice, middleAngle, pa, tmDimPt, labelPt, textInfo, rightLabels);
        }
    }
    return { leftLabels, rightLabels };
}
function getMaxLabelWidth(availSpace, labelX, isLeftSide) {
    return isLeftSide ? labelX - availSpace.x : availSpace.x + availSpace.width - labelX;
}
function createLabelInfo(slice, midAngle, position, tmDimPt, labelPt, textInfo, labelInfoArray) {
    let insertPos = -1;
    // insertion "sort"
    for (let j = 0; j < labelInfoArray.length; j++) {
        const labelInfo = labelInfoArray[j];
        if (labelInfo['position'] && labelInfo['position'] > position) {
            insertPos = j;
            break;
        }
    }
    if (insertPos == -1)
        insertPos = labelInfoArray.length;
    const labelInfo = {
        position,
        angle: midAngle,
        width: tmDimPt.x,
        height: tmDimPt.y,
        x: labelPt.x,
        y: labelPt.y,
        slice,
        textInfo
    };
    labelInfoArray.splice(insertPos, 0, labelInfo);
}
function _refineInitialLayout(slices, radius, center, availableSpace, labelInfoArray, side) {
    if (labelInfoArray.length < 1) {
        return;
    }
    let lastY = availableSpace.y; //think again!!
    let collisionTop = false;
    let collisionCentral = false;
    let collisionBottom = false;
    let labelBottom = 0;
    let labelInfo;
    let bottomQuarter = false;
    let prevBottomQuarter;
    let collide = false;
    const isLeftSideLabels = side == 'left';
    for (let i = 0; i < labelInfoArray.length; i++) {
        labelInfo = labelInfoArray[i];
        prevBottomQuarter = bottomQuarter;
        if (labelInfo.position > 90)
            bottomQuarter = true;
        labelBottom = labelInfo.y + labelInfo.height;
        collide = lastY - labelInfo.y > _COLLISION_MARGIN;
        if (collide) {
            if (!bottomQuarter) {
                collisionTop = true;
            }
            else if (!prevBottomQuarter) {
                collisionCentral = true;
            }
            else {
                collisionBottom = true;
            }
        }
        if (labelBottom > lastY) {
            lastY = labelBottom;
        }
    }
    if ((collisionTop && collisionBottom) || collisionCentral) {
        _columnLabels(slices, availableSpace, center, radius, labelInfoArray, isLeftSideLabels, true, true);
        return _ALL_COLLISION;
    }
    else if (collisionTop) {
        _columnLabels(slices, availableSpace, center, radius, labelInfoArray, isLeftSideLabels, true, false);
        return _HALF_COLLISION;
    }
    else if (collisionBottom) {
        _columnLabels(slices, availableSpace, center, radius, labelInfoArray, isLeftSideLabels, false, true);
        return _HALF_COLLISION;
    }
    return _NO_COLLISION;
}
function _getRadFeelerAngle(labelInfo, x, y, radius, center) {
    const ma = labelInfo.angle;
    const startPt = reflectAngleOverYAxis(ma, center.cx, center.cy, radius, radius);
    return Math.atan2(Math.abs(x - startPt.x), startPt.y - y);
}
function getMiddleLabel(alabels) {
    let bestAngle = 91;
    let bestIndex = -1;
    for (let i = 0; i < alabels.length; i++) {
        const pa = alabels[i]['position'];
        if (Math.abs(pa - 90) < bestAngle) {
            bestAngle = Math.abs(pa - 90);
            bestIndex = i;
        }
    }
    return bestIndex;
}
function setOptimalLabelPos(radius, labelInfo, vertX, center) {
    //set optimal X
    labelInfo['x'] = vertX;
    const b = radius * (1 + _FEELER_RAD_MINSIZE);
    const angleInRad = degreesToRads(labelInfo['position']);
    const heightFromCenter = b * Math.cos(angleInRad);
    const tilt = 0;
    let optimalY = center.cy - heightFromCenter - labelInfo.height * _LABEL_TO_FEELER_OFFSET + tilt;
    const _minY = labelInfo['minY'];
    const _maxY = labelInfo['maxY'];
    if (_minY <= _maxY) {
        optimalY = Math.max(optimalY, _minY);
        optimalY = Math.min(optimalY, _maxY);
    }
    labelInfo['y'] = optimalY;
}
function _columnLabels(slices, availableSpace, center, radius, alabels, isLeft, isTop, isBottom) {
    const frame = availableSpace;
    let minY = frame.y;
    let maxY = frame.y + frame.height;
    let i;
    let labelInfo;
    let pa = 0;
    let radFeelerAngle;
    //determine the position where the column will be aligned
    let vertX = center.cx;
    let feelerX;
    const minFeelerDist = radius * (1 + _FEELER_RAD_MINSIZE + _FEELER_HORIZ_MINSIZE);
    if (isLeft) {
        vertX -= minFeelerDist;
        feelerX = vertX + radius * _FEELER_HORIZ_MINSIZE;
    }
    else {
        vertX += minFeelerDist;
        feelerX = vertX - radius * _FEELER_HORIZ_MINSIZE;
    }
    //set the minimum heights that ensures as many labels as possible are displayed
    for (i = 0; i < alabels.length; i++) {
        labelInfo = alabels[i];
        pa = degreesToRads(labelInfo.position);
        radFeelerAngle = _getRadFeelerAngle(labelInfo, feelerX, minY, radius, center);
        // Remove labels that are more than a certain angle away from the slice.
        if (radFeelerAngle - pa > 0.45 * Math.PI || skipSliceLabel(alabels[i].slice, slices.length)) {
            alabels.splice(i, 1);
            i--;
        }
        else {
            alabels[i].minY = minY;
            minY += alabels[i].height;
        }
    }
    //set the maximum heights that ensures as many labels as possible are displayed
    for (i = alabels.length - 1; i >= 0; i--) {
        labelInfo = alabels[i];
        const position = labelInfo['position'];
        pa = degreesToRads(position);
        radFeelerAngle = _getRadFeelerAngle(labelInfo, feelerX, maxY, radius, center);
        // Remove labels that are more than a certain angle away from the slice.
        if (pa - radFeelerAngle > 0.45 * Math.PI || skipSliceLabel(alabels[i].slice, slices.length)) {
            alabels.splice(i, 1);
        }
        else {
            maxY -= alabels[i].height;
            alabels[i].maxY = maxY;
        }
    }
    if (alabels.length == 0)
        return;
    const startIndex = getMiddleLabel(alabels);
    const startLabel = alabels[startIndex];
    //if the column is only partial but there are too many labels, then set the whole side as column
    if (isTop && !isBottom) {
        if (startLabel.minY + startLabel.height > center.cy) {
            isBottom = true;
        }
    }
    if (isBottom && !isTop) {
        if (startLabel.maxY < center.cy) {
            isTop = true;
        }
    }
    const labelPostion = startLabel['position'];
    if ((isBottom && isTop) || (labelPostion > 90 && isBottom) || (labelPostion <= 90 && isTop)) {
        setOptimalLabelPos(radius, startLabel, vertX, center);
        startLabel.slice.hasFeelers = true;
    }
    let highestY = startLabel.y;
    let lowestY = startLabel.y + startLabel.height;
    let optimalY;
    let labelHeight;
    if (isTop) {
        //labels above the start label
        for (i = startIndex - 1; i >= 0; i--) {
            labelInfo = alabels[i];
            labelHeight = labelInfo.height;
            setOptimalLabelPos(radius, labelInfo, vertX, center);
            labelInfo.slice.hasFeelers = true;
            //avoid collision with the label below
            optimalY = labelInfo.y;
            if (optimalY + labelHeight < highestY) {
                highestY = optimalY;
            }
            else {
                highestY -= labelHeight;
            }
            labelInfo.y = highestY;
        }
    }
    if (isBottom) {
        //labels below the start label
        for (i = startIndex + 1; i < alabels.length; i++) {
            labelInfo = alabels[i];
            labelHeight = labelInfo.height;
            setOptimalLabelPos(radius, labelInfo, vertX, center);
            labelInfo.slice.hasFeelers = true;
            //avoid collision with the label above
            optimalY = labelInfo.y;
            if (optimalY > lowestY) {
                lowestY = optimalY + labelHeight;
            }
            else {
                lowestY += labelHeight;
            }
            labelInfo.y = lowestY - labelHeight;
        }
    }
}
function setLabelsAndFeelers(alabels, availSpace, center, radius, side, labelStyle, getTextDimension) {
    if (alabels == null || alabels.length <= 0)
        return;
    let i;
    let slice;
    let sliceLabel;
    const isLeftSide = side === 'left';
    const frame = availSpace;
    let excessWidth = Infinity;
    let excessLength;
    // Determine how much the horizontal feelers can be shortened
    for (i = 0; i < alabels.length; i++) {
        const labelInfo = alabels[i];
        const style = { ...labelStyle, ...labelInfo.slice.labelStyle };
        if (labelInfo.slice['hasFeelers']) {
            excessLength = _calculateFeeler(labelInfo, center, radius, isLeftSide);
            const fontHeight = getTextDimension('MW', style).height;
            const labelWidth = labelInfo['width'];
            const minLabelWidth = Math.min(2 * fontHeight, labelWidth);
            const maxLabelWidth = getMaxLabelWidth(availSpace, labelInfo['x'], isLeftSide);
            // Remove feelers for labels that will not be rendered and ignore for excess width calculation
            if (maxLabelWidth + excessLength < minLabelWidth || labelInfo['width'] == 0) {
                labelInfo.textInfo = undefined;
                labelInfo.slice.hasFeelers = false;
                continue;
            }
            excessWidth = Math.min(excessWidth, excessLength);
        }
        else {
            labelInfo.slice.hasFeelers = false;
        }
    }
    for (i = 0; i < alabels.length; i++) {
        const labelInfo = alabels[i];
        slice = labelInfo.slice;
        sliceLabel = labelInfo.slice.label;
        if (!sliceLabel)
            continue;
        if (labelInfo.slice.hasFeelers) {
            // shorten the horizontal feelers
            if (isLeftSide) {
                labelInfo.x = labelInfo.x + excessWidth;
            }
            else {
                labelInfo.x = labelInfo.x - excessWidth;
            }
            // setup the feeler line (let it clip if needed)
            _calculateFeeler(labelInfo, center, radius, isLeftSide);
        }
        // perform 'logical' clipping ourselves
        if (labelInfo.y < frame.y || labelInfo.y + labelInfo.height > frame.y + frame.height) {
            slice.label = '';
            slice.hasFeelers = false;
        }
        else {
            const maxLabelWidth = getMaxLabelWidth(availSpace, labelInfo.x, isLeftSide);
            const textInfo = labelInfo.textInfo &&
                utils.getTextInfo(labelInfo.slice.label, { ...labelStyle, ...labelInfo.slice.labelStyle }, maxLabelWidth, labelInfo.textInfo.height, true, 1, getTextDimension);
            labelInfo.textInfo = textInfo;
            if (labelInfo.height === 0 || labelInfo.width === 0) {
                slice.label = '';
                slice.hasFeelers = false;
            }
        }
    }
}
function _calculateFeeler(labelInfo, center, radius, isLeft) {
    const { x, y, height } = labelInfo;
    let targetX = x;
    const targetY = y + height * _LABEL_TO_FEELER_OFFSET;
    const minHorizLength = _FEELER_HORIZ_MINSIZE * radius;
    let midX;
    if (isLeft) {
        targetX += _LABEL_TO_FEELER_DISTANCE;
        midX = targetX + minHorizLength;
    }
    else {
        targetX -= _LABEL_TO_FEELER_DISTANCE;
        midX = targetX - minHorizLength;
    }
    const midPt = {
        x: midX,
        y: targetY
    };
    const endPt = {
        x: targetX,
        y: targetY
    };
    const ma = labelInfo.angle;
    const startPt = reflectAngleOverYAxis(ma, center.cx, center.cy, radius, radius);
    // make set the first section of the feeler radial if possible
    const pa = degreesToRads(labelInfo['position']);
    const radFeelerAngle = Math.abs(Math.atan2(midPt.x - startPt.x, startPt.y - midPt.y));
    const horizOffset = (startPt.y - midPt.y) * Math.tan(pa); // * pieChart.getRadiusX() / pieChart.getRadiusY();
    if ((pa > Math.PI / 2 && radFeelerAngle > Math.PI / 2 && radFeelerAngle < pa) ||
        (pa < Math.PI / 2 && radFeelerAngle < Math.PI / 2 && radFeelerAngle > pa)) {
        if (isLeft) {
            midPt.x = startPt.x - horizOffset;
        }
        else {
            midPt.x = startPt.x + horizOffset;
        }
    }
    //store outside feeler points on slice
    //and let slice draw the feeler so that we can
    //easily redraw it when selecting
    labelInfo['startPt'] = startPt;
    labelInfo['midPt'] = midPt;
    labelInfo['endPt'] = endPt;
    return Math.abs(endPt.x - midPt.x) - minHorizLength;
}

function PieChartLabel({ pieLabelInfo, labelPos, fontSize, isRtl }) {
    const { x, y, textInfo, slice, startPt, midPt, endPt } = pieLabelInfo;
    const color = slice.color;
    const fill = labelPos === 'inside' ? colorUtils.getContrastingTextColor(color) : undefined;
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: textInfo?.lines.map((line, i) => {
            const lineX = x;
            const lineY = y + (i + 0.5) * textInfo.dims[i].height;
            const textAnchor = (isRtl && labelPos === 'left') || (!isRtl && labelPos === 'right')
                ? 'start'
                : labelPos === 'inside'
                    ? 'middle'
                    : 'end';
            return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [slice.label && (jsxRuntime.jsx("text", { className: UNSAFE_PieChart_themes_PieChartStyles_css.styles.labelStyle, x: lineX, y: lineY, textAnchor: textAnchor, dominantBaseline: labelPos === 'inside' ? 'center' : 'middle', style: {
                            fill,
                            fontSize
                        }, children: line })), slice.hasFeelers && startPt && midPt && endPt && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("line", { x1: startPt.x, x2: midPt.x, y1: startPt.y, y2: midPt.y, className: UNSAFE_PieChart_themes_PieChartStyles_css.styles.fillerLineStyle }), jsxRuntime.jsx("line", { x1: endPt.x, x2: midPt.x, y1: endPt.y, y2: midPt.y, className: UNSAFE_PieChart_themes_PieChartStyles_css.styles.fillerLineStyle })] }))] }));
        }) }));
}

const NUM_PIE_SLICE_THRESHOLD = 100;
const chartVars = cssUtils.getChartVars();
function PieChartWithDimensions({ width, height, testId, innerRadius = 0, contextMenuConfig, drilling = 'off', selectionMode = 'none', onItemDrill, onItemHover, onItemFocus, ...props }) {
    const rootRef = hooks.useRef(null);
    const { direction } = useUser.useUser();
    const isRtl = direction === 'rtl';
    const { resolvedVars, cssContent } = useCssVars.useCssVars(chartVars);
    const colors = Array.from(Array(12)).map((_, index) => {
        return resolvedVars[`color${index + 1}`];
    });
    const data = isRtl ? props.data.slice().reverse() : props.data;
    const { totalValue, isLabelOutside } = getPieChartInfo(data);
    const sliceInfos = getSliceInfo(data, totalValue, colors, isRtl);
    const hasData = data.length > 0;
    // default data item gaps is 0.5. TODO: replace 0.5 with pie dataItemGaps/pieSliceGaps
    const pieSliceGap = getPieSliceGap(0.5);
    const hasLargeSeriesCount = data.length > NUM_PIE_SLICE_THRESHOLD;
    const testIdProps = useTestId.useTestId(testId);
    const availSpace = utils$1.getAvailSpace(width, height, false);
    const { cx, cy } = getPieCenter(availSpace);
    const radius = getRadius(availSpace, isLabelOutside);
    const ir = innerRadius * radius;
    const renderedSlices = getRenderedSlices(sliceInfos, hasLargeSeriesCount, radius);
    const { getDetailFromInfo, getNextChartItem } = getPieChartNavUtils(data, direction === 'rtl');
    const { textMeasureContent, getTextDimensions } = useTextDimensions.useTextDimensions();
    const supportsSelection = !!(selectionMode && selectionMode !== 'none');
    const supportsDrill = drilling === 'on';
    // const isReadOnly = !supportsSelection && !supportsDrill && onItemHover === null && onItemFocus === null;
    const { touchResponse, touchResponseStyle } = useVisTouchResponse.useVisTouchResponse({
        type: 'auto',
        supportsTouchDragGestures: false,
        rootRef
    });
    const { activeId, focusedItemInfo, hoveredItemInfo, eventsProps, onContextMenuDismissed } = usePieChartNav.usePieChartNav(touchResponse, getDetailFromInfo, getNextChartItem, drilling, onItemDrill);
    const activeItem = focusedItemInfo.isFocusVisible ? focusedItemInfo : hoveredItemInfo;
    const activeData = activeItem ? data[renderedSlices[activeItem.itemIndex].index] : undefined;
    const defaultDatatip = (activeData, activeItem) => {
        if (!activeData) {
            return {
                content: undefined,
                borderColor: undefined
            };
        }
        if (activeData.accessibleLabel) {
            return {
                content: activeData.accessibleLabel,
                borderColor: getDefaultBorderColor(colors, activeItem, activeData)
            };
        }
        return {
            content: (jsxRuntime.jsx(VisTabularDatatip.VisTabularDatatip, { tableData: [
                    {
                        key: 'Value',
                        value: activeData.value
                    }
                ] })),
            borderColor: getDefaultBorderColor(colors, activeItem, activeData)
        };
    };
    const { content: datatipString, borderColor } = activeData && props.datatip
        ? props.datatip({ data: activeData })
        : defaultDatatip(activeData, activeItem);
    const anchor = focusedItemInfo.isFocusVisible ? 'element' : 'pointer';
    const elementBounds = activeItem?.isFocusVisible
        ? getElementBounds(renderedSlices, cx, cy, ir, radius, activeItem)
        : undefined;
    const offset = layoutUtils.calculateOffset(isRtl, width, elementBounds);
    const { datatipContent, datatipProps } = useDatatip.useDatatip({
        content: datatipString,
        offset,
        anchor,
        placement: 'top-start',
        borderColor,
        touchResponse
    });
    datatipProps['aria-describedby'] = stringUtils.l([
        props['aria-describedby'],
        datatipProps['aria-describedby']
    ]);
    const { contextMenuContent, contextMenuProps } = usePieChartContextMenu({
        offset,
        rootRef,
        contextMenuConfig: hasData ? contextMenuConfig : undefined,
        onContextMenuDismissed,
        focusedItemInfo,
        items: sliceInfos,
        width,
        isRtl
    });
    const mergedProps = mergeProps.mergeProps(eventsProps, datatipProps, contextMenuProps);
    let insideLabels = [];
    let rightLabels = [];
    let leftLabels = [];
    const defaultFontSize = resolvedVars['labelFontSize'];
    if (getTextDimensions) {
        const labels = layoutPieChartLabels(renderedSlices, { cx, cy }, ir, radius, availSpace, getTextDimensions, defaultFontSize);
        insideLabels = labels.insideLabels;
        rightLabels = labels.rightLabels;
        leftLabels = labels.leftLabels;
    }
    return (jsxRuntime.jsxs("div", { ref: rootRef, tabIndex: 0, "aria-label": props['aria-label'], "aria-labelledby": props['aria-labelledby'], "aria-activedescendant": activeId, role: "application", ...mergedProps, ...testIdProps, className: UNSAFE_PieChart_themes_PieChartStyles_css.styles.chart, style: {
            width,
            height,
            ...touchResponseStyle
        }, children: [renderedSlices.length > 0 && (jsxRuntime.jsxs("svg", { className: UNSAFE_PieChart_themes_PieChartStyles_css.styles.svg, children: [renderedSlices.map((item, index) => {
                        return (jsxRuntime.jsx(PieSlice, { isInteractive: supportsSelection || supportsDrill, cx: cx, cy: cy, itemIndex: index, id: activeItem?.itemIndex === index ? activeId : undefined, isFocused: focusedItemInfo?.itemIndex === index && focusedItemInfo?.isFocusVisible, isHovered: hoveredItemInfo?.itemIndex === index, r: radius, startAngle: item.startAngle, gap: pieSliceGap, innerRadius: ir, angleExtent: item.angleExtent, color: item.color, accessibleLabel: item.accessibleLabel }, item.id));
                    }), insideLabels?.map((v) => {
                        return (jsxRuntime.jsx(PieChartLabel, { isRtl: isRtl, pieLabelInfo: v, labelPos: "inside", fontSize: defaultFontSize }));
                    }), leftLabels?.map((v) => {
                        return (jsxRuntime.jsx(PieChartLabel, { isRtl: isRtl, pieLabelInfo: v, labelPos: "left", fontSize: defaultFontSize }));
                    }), rightLabels?.map((v) => {
                        return (jsxRuntime.jsx(PieChartLabel, { isRtl: isRtl, pieLabelInfo: v, labelPos: "right", fontSize: defaultFontSize }));
                    })] })), props.children?.(getCenterContext(cx, cy, ir)), datatipContent, cssContent, contextMenuContent, textMeasureContent] }));
}

/**
 * Pie charts are useful for visualizing parts of a whole, but do not display zero or negative values so they are not recommended for data sets that may have negative or null data
 */
function PieChart({ width, height, ...props }) {
    return (jsxRuntime.jsx(TrackResizeContainer.TrackResizeContainer, { width: width, height: height, class: UNSAFE_PieChart_themes_PieChartStyles_css.dimensionStyle, children: (width, height) => jsxRuntime.jsx(PieChartWithDimensions, { width: width, height: height, ...props }) }));
}

exports.PieChart = PieChart;
//# sourceMappingURL=UNSAFE_PieChart.js.map
