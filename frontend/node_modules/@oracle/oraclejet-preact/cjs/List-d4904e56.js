/* @oracle/oraclejet-preact: undefined */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
var classNames = require('./classNames-c14c6ef3.js');
var mergeProps = require('./mergeProps-e3da7237.js');
var keys = require('./keys-25710458.js');
var collectionUtils = require('./collectionUtils-fe12edac.js');
var LoadMoreCollection = require('./LoadMoreCollection-3cd7e9a9.js');
var VirtualizedCollection = require('./VirtualizedCollection-4a246f0e.js');
var compat = require('preact/compat');
var TabbableModeContext = require('./TabbableModeContext-e99d527e.js');
var useId = require('./useId-6c0eeb27.js');
var FocusTrap = require('./FocusTrap-fbb0c20f.js');
var useNavigation = require('./useNavigation-49344b44.js');
var useInteractionStyle = require('./useInteractionStyle-c203a8a0.js');
var mergeInterpolations = require('./mergeInterpolations-6727b536.js');
var flexitem = require('./flexitem-fee13e26.js');
var PRIVATE_List_themes_ListStyles_css = require('./PRIVATE_List/themes/ListStyles.css.js');
var Skeleton = require('./Skeleton-e746e396.js');
var Flex = require('./Flex-6ca216a7.js');
var Selector = require('./Selector-9b72f861.js');
var ImageVars_css = require('./ImageVars.css-3fbb1c0b.js');
var useTheme = require('./useTheme-09dfbb78.js');
var useTestId = require('./useTestId-9093a54b.js');
require('./ReorderableContext-16396e17.js');
require('./LayerHost-aee0e070.js');
require('./CollectionInteractionContext-f84ff7a1.js');
var useCollectionInteractionContext = require('./useCollectionInteractionContext-6fc0200e.js');
require('preact');
var useSelection = require('./useSelection-e11d979f.js');
var useAdditiveSelection = require('./useAdditiveSelection-b8ae3a18.js');
var useItemAction = require('./useItemAction-a35b3fa0.js');
var Inset = require('./Inset-b9ec3b93.js');


/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * List Roles need to be kept in matching sets, this module encapsulates the sets
 *
 * @param ariaRole
 * @returns matching, valid set of roles
 */
const getListViewRoles = (ariaRole) => {
    switch (ariaRole) {
        case 'listbox':
            return { list: 'listbox', item: 'presentation', cell: 'option' };
        case 'treegrid':
            return { list: 'treegrid', item: 'row', cell: 'gridcell' };
        default:
            return { list: 'grid', item: 'row', cell: 'gridcell' };
    }
};

const ITEM_SELECTOR = '[data-oj-key]';
/**
 * The internal component used to render a single item in ListView.
 */
function ListViewItem({ children, context, itemDepth, isFocused, isFocusRingVisible, isActive, isGridlineVisible, isSelected, isTopGridlineVisible = false, isTabbable = false, role, selectionMode, suggestion, currentItemVariant, padding }) {
    const rootRef = hooks.useRef(null);
    const roles = hooks.useMemo(() => getListViewRoles(role), [role]);
    const itemKey = context.metadata.key;
    const itemIndex = context.index;
    // some roles come with related aria attributes which need to be set
    const cellRoleAttributes = roles.cell === 'option'
        ? {
            role: roles.cell,
            'aria-posinset': itemIndex + 1,
            'aria-setsize': -1
        }
        : {
            role: roles.cell
        };
    // don't bubble Arrow Up and Down events to parent when in isTabbable mode
    // this bubbling causes the outer CollectionFocus ring to change index while in the isTabbable mode.
    const handleKeyDown = (event) => {
        if (isTabbable && (event.key === 'ArrowDown' || event.key === 'ArrowUp')) {
            event.stopPropagation();
        }
    };
    const { interactionProps, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle } = useInteractionStyle.useInteractionStyle();
    const variantClasses = PRIVATE_List_themes_ListStyles_css.listItemMultiVariantStyles({
        selectable: isSelectable(selectionMode, isSelected) ? 'isSelectable' : 'notSelectable',
        selected: isSelected ? 'isSelected' : 'notSelected',
        selectedSingle: isSelected && selectionMode === 'single' ? 'isSelectedSingle' : 'notSelectedSingle',
        needsEventsHover: applyHoverStyle ? 'isNeedsEventsHover' : 'notNeedsEventsHover',
        pseudoHover: applyPseudoHoverStyle ? 'isPseudoHover' : 'notPseudoHover',
        active: applyActiveStyle || isActive ? 'isActive' : 'notActive',
        focusHighlight: currentItemVariant === 'highlight' && isFocused ? 'isFocusHighlight' : 'notFocusHighlight',
        focusRingVisible: isFocusRingVisible && isFocused ? 'isFocusRingVisible' : 'notFocusRingVisible',
        gridlineTop: isTopGridlineVisible ? 'visible' : 'hidden',
        gridlineBottom: isGridlineVisible ||
            (suggestion === 'end' && !isGridlineVisible && (!isSelected || selectionMode !== 'single'))
            ? 'visible'
            : 'hidden'
    });
    const paddingClasses = [];
    if (padding) {
        if (padding === 'enabled') {
            paddingClasses.push(PRIVATE_List_themes_ListStyles_css.paddingStyles.allPadding);
        }
        else if (padding !== 'disabled') {
            if (padding.top === 'enabled') {
                paddingClasses.push(PRIVATE_List_themes_ListStyles_css.paddingStyles.topItemPadding);
            }
            if (padding.bottom === 'enabled') {
                paddingClasses.push(PRIVATE_List_themes_ListStyles_css.paddingStyles.bottomItemPadding);
            }
            if (padding.start === 'enabled') {
                paddingClasses.push(PRIVATE_List_themes_ListStyles_css.paddingStyles.startItemPadding);
            }
            if (padding.end === 'enabled') {
                paddingClasses.push(PRIVATE_List_themes_ListStyles_css.paddingStyles.endItemPadding);
            }
        }
    }
    const classes = classNames.classNames([variantClasses, ...paddingClasses]);
    const styleInterpolations = mergeInterpolations.mergeInterpolations([
        ...Object.values(flexitem.flexitemInterpolations)
    ]);
    const { class: cls, ...cellStyles } = styleInterpolations({
        flex: '1 1 auto',
        alignSelf: 'center'
    });
    const cellClasses = classNames.classNames([
        cls,
        useNavigation.isMultipleSelection(selectionMode) && PRIVATE_List_themes_ListStyles_css.listItemStyles.checkboxContainer
    ]);
    // todo: use translated text for selector
    // note cannot put focus on gridcell div since JAWS will not read the aria-rowindex
    // correctly, so unfortunately needed another div
    return (jsxRuntime.jsx("div", { "aria-rowindex": role === 'grid' ? itemIndex + 1 : undefined, "aria-level": itemDepth, "data-oj-key": itemKey, class: classes, ref: rootRef, role: roles.item, ...(suggestion && { 'data-oj-suggestion': true }), ...(typeof itemKey === 'number' && { 'data-oj-key-type': 'number' }), ...interactionProps, children: jsxRuntime.jsx("div", { id: useId.useId(), style: cellStyles, class: cellClasses, "aria-posinset": role === 'grid' ? undefined : itemIndex + 1, "aria-setsize": role === 'grid' ? undefined : -1, onKeyDown: handleKeyDown, "aria-colindex": role === 'grid' ? 1 : undefined, "aria-selected": selectionMode !== 'none' ? isSelected : undefined, ...cellRoleAttributes, children: jsxRuntime.jsx(TabbableModeContext.TabbableModeContext.Provider, { value: { isTabbable }, children: jsxRuntime.jsx(FocusTrap.FocusTrap, { isDisabled: !isTabbable, restoreFocusRef: false, children: children(context) }) }) }) }));
}
/**
 * Helper method to determine whether item is selectable
 * @returns true if item is selectable (show hover effect), false otherwise
 */
const isSelectable = (selectionMode, isItemSelected) => {
    return selectionMode !== 'none' && (useNavigation.isMultipleSelection(selectionMode) || !isItemSelected);
};
const MemoizeListViewItem = compat.memo(ListViewItem, (prev, next) => {
    if (prev && next) {
        return (prev.children === next.children &&
            prev.isFocused === next.isFocused &&
            prev.isFocusRingVisible === next.isFocusRingVisible &&
            prev.isSelected === next.isSelected &&
            prev.isTabbable === next.isTabbable &&
            prev.isActive === next.isActive &&
            prev.suggestion === next.suggestion &&
            prev.isGridlineVisible === next.isGridlineVisible &&
            prev.isTopGridlineVisible === next.isTopGridlineVisible &&
            prev.padding === next.padding &&
            collectionUtils.compareListItemContext(prev.context, next.context));
    }
    return false;
});

/**
 * Allows to specify the time delay for rendering the component
 **/
const timerValue = 50;
/**
 * SkeletonContainer renders 'minimumCount' number of skeletons
 * of the variant specified from its child element - Skeleton's prop after
 * 'timerValue' ms delay
 **/
function SkeletonContainer({ children, minimumCount = 1 }) {
    const [isVisible, setIsVisible] = hooks.useState(false);
    hooks.useEffect(() => {
        setTimeout(() => {
            setIsVisible(true);
        }, timerValue);
    }, []);
    const containerClasses = classNames.classNames([PRIVATE_List_themes_ListStyles_css.skeletonStyles.container]);
    return isVisible && children ? (jsxRuntime.jsx("div", { class: containerClasses, role: "presentation", children: [...Array(minimumCount)].map((_element, index) => children(index)) })) : null;
}

const SPARKLE_STYLE_CLASS = 'oj-collection-sparkle';
/**
 * A sparkle component for smart suggestion indicator in ListView
 * @param sparkleHeight the height of sparkle
 */
function Sparkle({ sparkleHeight }) {
    const { name } = useTheme.useTheme();
    if (sparkleHeight <= 0) {
        return null;
    }
    const height = sparkleHeight + 'px';
    const sparkleClasses = classNames.classNames([PRIVATE_List_themes_ListStyles_css.sparkleStyles.base]);
    const containerClasses = classNames.classNames([
        PRIVATE_List_themes_ListStyles_css.sparkleStyles.container,
        SPARKLE_STYLE_CLASS,
        // TODO: this component should create separate theme definitions to only show the image in redwood
        name === 'redwood' && ImageVars_css.globalImages
    ]);
    return (jsxRuntime.jsx("div", { class: containerClasses, children: jsxRuntime.jsx("div", { class: sparkleClasses, style: { height } }) }, "sparkle"));
}

const usePromotedSection = (data, promotedSection, rootRef) => {
    // tracking sparkle height
    const [sparkleHeight, setSparkleHeight] = hooks.useState(0);
    const suggestions = hooks.useMemo(() => data && promotedSection && findSuggestions(data.data, promotedSection.count), [data, promotedSection]);
    hooks.useEffect(() => {
        // update sparkleHeight only when we have suggestions
        // avoid unnecessary iterating through elements
        if (suggestions) {
            const placeholder = rootRef.current?.querySelector('.' + VirtualizedCollection.PLACEHOLDER_STYLE_CLASS);
            let height = placeholder?.offsetHeight || 0;
            const suggestionItems = rootRef.current?.querySelectorAll('[data-oj-suggestion]');
            suggestionItems?.forEach((item) => (height += item.offsetHeight));
            setSparkleHeight(height);
        }
    }, [rootRef, suggestions]);
    return { sparkleHeight, suggestions };
};
/**
 * A helper function that finds the data with suggestions, and
 * returns the corresponding keys
 * @param dataState
 */
const findSuggestions = (data, count) => {
    if (count === 0) {
        return null;
    }
    const suggestionsData = data.slice(0, count);
    return suggestionsData.reduce((suggestions, value, index) => {
        const key = value.metadata.key;
        if (index === count - 1) {
            suggestions.set(key, 'end');
        }
        else {
            suggestions.set(key, true);
        }
        return suggestions;
    }, new Map());
};

const useSelectionItemAction = (currentKey, selectedKeys, selectionMode = 'none', onSelectionChange, onItemAction, data, viewportConfig, scrollToVisibleOffset, rootRef, pendingSelectionCallback, isEmbedded) => {
    // tracking the anchor key which is used for shift+click selection
    const anchorKey = hooks.useRef();
    const handleSelectionChange = hooks.useCallback((detail) => {
        if (onSelectionChange) {
            if (detail.value.all === false && detail.value.keys.size > 0) {
                // during regular selection, the last key selected by a user gesture is the anchor key
                anchorKey.current = Array.from(detail.value.keys.values()).pop();
            }
            onSelectionChange(detail);
        }
    }, [anchorKey, onSelectionChange]);
    const handleSelectionRangeChange = hooks.useCallback((detail) => {
        if (data && onSelectionChange) {
            const value = handleSelectionRange(detail, data);
            if (Array.isArray(value)) {
                if (detail.eventType === 'shiftSpace') {
                    // during range selection by shift+space, the first key selected by a user gesture is the anchor key
                    anchorKey.current = detail.value.start;
                }
                else {
                    // during range selection by shift+click/arrow keys, the last key selected by a user gesture is the anchor key
                    anchorKey.current = detail.value.end;
                }
                if (isEmbedded || selectionMode === 'multipleToggle') {
                    const keys$1 = keys.addKeys(selectedKeys, value);
                    onSelectionChange({ value: keys$1, target: null });
                }
                else {
                    onSelectionChange({ value: { all: false, keys: new Set(value) }, target: null });
                }
            }
            else {
                pendingSelectionCallback(detail, value);
            }
        }
    }, [data, isEmbedded, selectedKeys, onSelectionChange, pendingSelectionCallback]);
    const { selectionProps } = useSelection.useSelection((element) => {
        if (element === rootRef.current) {
            return currentKey === undefined ? null : currentKey;
        }
        return collectionUtils.keyExtractor(element, ITEM_SELECTOR);
    }, selectedKeys, isEmbedded || selectionMode === 'multipleToggle' ? 'none' : selectionMode, false, 'replace', handleSelectionChange, anchorKey.current, currentKey, (currentKey, isPrev) => collectionUtils.getPrevNextKey(rootRef.current, currentKey, isPrev, ITEM_SELECTOR), undefined, (key) => {
        if (rootRef.current) {
            const elem = collectionUtils.findElementByKey(rootRef.current, key, ITEM_SELECTOR);
            if (elem) {
                const scroller = viewportConfig?.scroller();
                const offset = scrollToVisibleOffset ? scrollToVisibleOffset(rootRef.current) : 0;
                useNavigation.scrollToVisible(elem, scroller != null ? scroller : rootRef.current, offset);
            }
        }
    }, handleSelectionRangeChange);
    const { eventProps: additiveSelectionProps, setAdditiveSelectionACKey } = useAdditiveSelection.useAdditiveSelection((element) => {
        if (element === rootRef.current) {
            return currentKey === undefined ? null : currentKey;
        }
        return collectionUtils.keyExtractor(element, ITEM_SELECTOR);
    }, selectedKeys, selectionMode === 'multipleToggle' ? 'multiple' : isEmbedded ? selectionMode : 'none', false, (key) => {
        if (data) {
            return data.data.findIndex((value) => value.metadata.key === key);
        }
        return -1;
    }, (startIndex, endIndex) => {
        if (data) {
            const keys = data.data.map((value) => value.metadata.key);
            return keys.slice(startIndex, endIndex);
        }
        return [];
    }, (currentKey, isPrev) => collectionUtils.getPrevNextKey(rootRef.current, currentKey, isPrev, ITEM_SELECTOR), currentKey, handleSelectionChange, handleSelectionRangeChange, selectionMode === 'multipleToggle' ? false : isEmbedded);
    const itemActionProps = useItemAction.useItemAction(currentKey, data, onItemAction, ITEM_SELECTOR, isEmbedded);
    return {
        eventProps: mergeProps.mergeProps(selectionProps, itemActionProps, additiveSelectionProps),
        handleSelectionChange,
        setAdditiveSelectionACKey
    };
};
const handleSelectionRange = (detail, dataState) => {
    const keys = dataState.data.map((value) => {
        return value.metadata.key;
    });
    const startIndex = keys.indexOf(detail.value.start);
    const endIndex = keys.indexOf(detail.value.end);
    const minIndex = Math.min(startIndex, endIndex);
    const maxIndex = Math.max(startIndex, endIndex);
    if (minIndex === -1) {
        // return a range to fetch so we can find all the keys, maxIndex should not be -1
        return { offset: 0, count: dataState.totalSize };
    }
    else {
        // range of keys are in the current viewport, return them
        return keys.slice(minIndex, maxIndex + 1);
    }
};

/**
 * Component that renders items as a flat list.
 * In order to maximize performance, only items that are visible in the viewport are rendered.
 */
function List({ 'aria-label': ariaLabel, 'aria-labelledby': ariaLabelledBy, 'aria-describedby': ariaDescribedBy, allowTabbableMode = true, children, data, gridlines, loadingIndicator = defaultLoadingIndicator, loadMoreIndicator = defaultLoadMoreIndicator, currentItemOverride, onPersistCurrentItem, onLoadRange, onSelectionChange, onItemAction, rangeExtractor, role = 'grid', selectedKeys = emptyKeys, selectionMode = 'none', viewportConfig, currentItemVariant, promotedSection, isVirtualized = false, customItemRenderer, scrollToVisibleOffset, testId, scrollerRef, reorderProps, contextMenuTriggerProps, itemPadding, itemEnterKeyFocusBehavior = 'focusWithin', ...props }) {
    const rootRef = hooks.useRef(null);
    const isFetching = hooks.useRef(false);
    // tracking pending selection key that is not in current data
    const pendingSelection = hooks.useRef();
    const [active, setActive] = hooks.useState(false);
    const showGridline = (index) => {
        // show bottom gridlines for each item, and for the last item if specified
        return (gridlines?.item === 'visible' &&
            (index + 1 !== data?.totalSize || gridlines?.bottom === 'visible'));
    };
    const showGridlineTop = () => {
        // show the top gridline for the first item
        return gridlines?.item === 'visible' && gridlines?.top === 'visible';
    };
    const ariaMultiSelectable = selectionMode === 'none' ? undefined : useNavigation.isMultipleSelection(selectionMode);
    const ariaRowCount = data === null ? undefined : data.sizePrecision === 'exact' ? data.totalSize : -1;
    const classes = classNames.classNames([PRIVATE_List_themes_ListStyles_css.listStyles.base]);
    const isEmbedded = useCollectionInteractionContext.useCollectionInteractionContext() === 'embedded';
    const itemVariant = currentItemVariant !== undefined ? currentItemVariant : isEmbedded ? 'highlight' : 'none';
    const pendingSelectionCallback = hooks.useCallback((detail, value) => {
        if (data) {
            pendingSelection.current = {
                detail: detail,
                range: { offset: data.offset, count: data.data.length }
            };
            onLoadRange(value);
        }
    }, [data, onLoadRange]);
    /*****************************************************************************************/
    /************************************* Load More *****************************************/
    /*****************************************************************************************/
    const lastRange = hooks.useRef({ offset: 0, count: 0 });
    const handleLoadRange = hooks.useCallback((newRange) => {
        // check isFetching to avoid multiple load more at the same time (details in JET-68994)
        if (!isFetching.current ||
            lastRange.current.offset !== newRange.offset ||
            lastRange.current.count !== newRange.count) {
            isFetching.current = true;
            lastRange.current = newRange;
            onLoadRange(newRange);
        }
    }, [isFetching, onLoadRange]);
    hooks.useEffect(() => {
        isFetching.current = false;
        // listen to data because when one of them gets updated, the fetching is done
    }, [data]);
    const listRoles = hooks.useMemo(() => getListViewRoles(role), [role]);
    const arrowKeyAndHandlers = {
        ArrowUp: (key) => collectionUtils.getPrevNextKey(rootRef.current, key, true, collectionUtils.ITEM_SELECTOR),
        ArrowDown: (key) => collectionUtils.getPrevNextKey(rootRef.current, key, false, collectionUtils.ITEM_SELECTOR)
    };
    const { navigationProps, currentKey, showFocusRing, isCurrentTabbableKey } = useNavigation.useNavigation(data, rootRef, (elem) => {
        return idExtractor(elem, listRoles.cell);
    }, arrowKeyAndHandlers, currentItemOverride, onPersistCurrentItem, viewportConfig, scrollToVisibleOffset, selectionMode !== 'multiple' || isEmbedded, allowTabbableMode, true, isEmbedded, itemEnterKeyFocusBehavior === 'focusWithin');
    const { eventProps, handleSelectionChange, setAdditiveSelectionACKey } = useSelectionItemAction(currentKey, selectedKeys, selectionMode, onSelectionChange, onItemAction, data, viewportConfig, scrollToVisibleOffset, rootRef, pendingSelectionCallback, isEmbedded);
    if (data && pendingSelection.current !== undefined && onSelectionChange) {
        const keys$1 = handleSelectionRange(pendingSelection.current.detail, data);
        if (Array.isArray(keys$1)) {
            if (!isEmbedded) {
                onSelectionChange({ value: { all: false, keys: new Set(keys$1) }, target: null });
            }
            else {
                const value = keys.addKeys(selectedKeys, keys$1);
                onSelectionChange({ value, target: null });
            }
        }
        const range = pendingSelection.current
            ? pendingSelection.current.range
            : { offset: data.offset, count: data.data.length };
        data = adjustDataState(data, range);
        pendingSelection.current = undefined;
        onLoadRange(range);
    }
    const { sparkleHeight, suggestions } = usePromotedSection(data, promotedSection, rootRef);
    // TODO: check suggestions before Sparkle would cause a scrolling issue
    const sparkleIndicator = jsxRuntime.jsx(Sparkle, { sparkleHeight: sparkleHeight });
    // returns an ListItemContext based on ItemContext (added metadata and selector)
    // note the type for ItemContext, this is the context coming from Collection
    const getItemContext = hooks.useCallback((context) => {
        const dataStateData = context.data;
        const selectorRenderer = useNavigation.isMultipleSelection(selectionMode)
            ? () => (jsxRuntime.jsx(Selector.Selector, { onChange: (detail) => {
                    handleSelectionChange(detail);
                    setAdditiveSelectionACKey(dataStateData.metadata.key);
                }, rowKey: dataStateData.metadata.key, selectedKeys: selectedKeys }))
            : undefined;
        return {
            index: context.index,
            data: dataStateData.data,
            metadata: dataStateData.metadata,
            selector: selectorRenderer
        };
    }, [selectionMode, selectedKeys, handleSelectionChange]);
    const ItemComponent = isVirtualized ? ListViewItem : MemoizeListViewItem;
    const childrenComponent = (context) => {
        const listItemContext = getItemContext(context);
        const suggestion = suggestions?.get(listItemContext.metadata.key);
        const isTabbable = allowTabbableMode && isCurrentTabbableKey(listItemContext.metadata.key);
        const isFocused = currentKey === listItemContext.metadata.key && !isTabbable;
        const isActive = isFocused && active;
        const isSelected = keys.containsKey(selectedKeys, listItemContext.metadata.key);
        const isFocusRingVisible = isFocused && showFocusRing;
        const listItemFunc = (ctx, otherProps) => (jsxRuntime.jsx(ItemComponent, { context: ctx, isFocused: isFocused, isFocusRingVisible: isFocusRingVisible, isActive: isActive, isGridlineVisible: showGridline(listItemContext.index), isSelected: isSelected, isTabbable: allowTabbableMode && isCurrentTabbableKey(listItemContext.metadata.key), role: role, selectionMode: selectionMode, currentItemVariant: itemVariant, padding: itemPadding, ...(suggestion && { suggestion }), ...(listItemContext.index === 0 && { isTopGridlineVisible: showGridlineTop() }), ...otherProps, children: children }, listItemContext.metadata.key));
        // if customItemRenderer is specified (ExpandableList and GroupedList)
        // create a custom context with additional info including a function
        // that helps create the default item component
        if (customItemRenderer) {
            const customRendererContext = {
                listItemContext,
                isFocused,
                isFocusRingVisible,
                isSelected,
                isTabbable,
                isActive,
                defaultListItem: listItemFunc
            };
            return customItemRenderer(customRendererContext);
        }
        return listItemFunc(listItemContext);
    };
    viewportConfig = getViewportConfig(rootRef, viewportConfig);
    const handleKeyDown = hooks.useCallback((event) => {
        if (event.key === ' ' && keys.isKeyDefined(currentKey) && selectionMode !== 'none') {
            setActive(true);
        }
    }, [currentKey, selectionMode, setActive]);
    const handleKeyUp = hooks.useCallback(() => {
        setActive(false);
    }, [setActive]);
    hooks.useImperativeHandle(scrollerRef, () => rootRef.current);
    // if data is not specified, listview should show loading indicator
    // todo: replace placeholder with actual SkeletonContainer component (Ash is working on)
    const testIdProps = useTestId.useTestId(testId);
    return (jsxRuntime.jsx("div", { ...mergeProps.mergeProps(eventProps, navigationProps, contextMenuTriggerProps || {}, reorderProps || {}, {
            onKeyDown: handleKeyDown,
            onKeyUp: handleKeyUp
        }, props), ...testIdProps, role: role, "aria-rowcount": role === 'grid' ? ariaRowCount : undefined, "aria-colcount": role === 'grid' ? 1 : undefined, ref: rootRef, class: classes, tabIndex: 0, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, "aria-multiselectable": ariaMultiSelectable, children: data == null ? (loadingIndicator) : isVirtualized ? (jsxRuntime.jsx(VirtualizedCollection.VirtualizedCollection, { data: data, itemSelector: collectionUtils.ITEM_SELECTOR, loadMoreIndicator: loadMoreIndicator, onLoadRange: onLoadRange, rangeExtractor: rangeExtractor, suggestions: sparkleIndicator, viewportConfig: viewportConfig, children: childrenComponent })) : (jsxRuntime.jsx(LoadMoreCollection.LoadMoreCollection, { data: data.data, loadMoreIndicator: loadMoreIndicator, hasMore: data.sizePrecision === 'atLeast' && data.data.length <= data.totalSize, onLoadMore: () => {
                data && handleLoadRange({ offset: 0, count: data.data.length + 25 });
            }, suggestions: sparkleIndicator, viewportConfig: viewportConfig, children: childrenComponent })) }));
}
const getViewportConfig = (rootRef, config) => {
    return (config ?? {
        scroller: () => {
            return rootRef.current;
        }
    });
};
const idExtractor = (elem, role) => {
    return elem.querySelector(`[role=${role}]`)?.id || '';
};
const emptyKeys = { all: false, keys: new Set() };
const defaultLoadingIndicator = (jsxRuntime.jsx(SkeletonContainer, { minimumCount: 25, children: () => {
        return (jsxRuntime.jsx(Inset.Inset, { variant: "listview", children: jsxRuntime.jsx(Flex.Flex, { height: "6x", align: "center", children: jsxRuntime.jsx(Skeleton.Skeleton, { height: "4x" }) }) }));
    } }));
const defaultLoadMoreIndicator = (jsxRuntime.jsx("div", { class: LoadMoreCollection.LOADMORE_STYLE_CLASS, children: jsxRuntime.jsx(SkeletonContainer, { minimumCount: 3, children: () => {
            return (jsxRuntime.jsx(Inset.Inset, { variant: "listview", children: jsxRuntime.jsx(Flex.Flex, { height: "6x", align: "center", children: jsxRuntime.jsx(Skeleton.Skeleton, { height: "4x" }) }) }));
        } }) }));
/**
 * Adjust the DataState as needed if it contains more than needed for the specified range
 */
const adjustDataState = (dataState, range) => {
    if (range) {
        // prevent range offset from being larger than the data state
        const safeRangeOffset = Math.min(range.offset, dataState.offset + dataState.totalSize);
        const diff = safeRangeOffset - dataState.offset;
        if (diff > 0) {
            dataState = {
                offset: safeRangeOffset,
                data: dataState.data.slice(diff, diff + range.count),
                totalSize: dataState.totalSize,
                sizePrecision: dataState.sizePrecision
            };
        }
    }
    return dataState;
};

exports.List = List;
exports.SkeletonContainer = SkeletonContainer;
//# sourceMappingURL=List-d4904e56.js.map
