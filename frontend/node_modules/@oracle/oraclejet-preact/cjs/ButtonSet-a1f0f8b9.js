/* @oracle/oraclejet-preact: undefined */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var compat = require('preact/compat');
var dimensions = require('./dimensions-2fcc0acf.js');
var mergeInterpolations = require('./mergeInterpolations-6727b536.js');
var classNames = require('./classNames-c14c6ef3.js');
var UNSAFE_ButtonSet_themes_ButtonSetStyles_css = require('./UNSAFE_ButtonSet/themes/ButtonSetStyles.css.js');
var useButtonSetContext = require('./useButtonSetContext-a2f31c8e.js');
var preact = require('preact');
var ButtonSetPositionContext = require('./ButtonSetPositionContext-6a358667.js');
var hooks = require('preact/hooks');
var toggleButtonUtils = require('./toggleButtonUtils-245111a7.js');
var useTestId = require('./useTestId-9093a54b.js');
var useRovingTabIndexContainer = require('./useRovingTabIndexContainer-a3594203.js');
var TabbableModeContext = require('./TabbableModeContext-e99d527e.js');
var useTabbableMode = require('./useTabbableMode-a275583f.js');
var refUtils = require('./refUtils-a9872e75.js');

/**
 * ButtonSetItems renders the ButtonSet children
 */
function ButtonSetItems({ children }) {
    const childrenArray = preact.toChildArray(children);
    return (jsxRuntime.jsx(preact.Fragment, { children: childrenArray.map((value, index) => {
            if (!preact.isValidElement(value))
                return null;
            else
                return (jsxRuntime.jsx(ButtonSetPositionContext.ButtonSetPositionContext.Provider, { value: {
                        position: toggleButtonUtils.indexToPosition(index, childrenArray.length)
                    }, children: value }));
        }) }));
}
ButtonSetItems.displayName = 'ButtonSetItems';

const interpolations = [...Object.values(dimensions.dimensionInterpolations)];
const styleInterpolations = mergeInterpolations.mergeInterpolations(interpolations);
/**
 * ButtonSet allow users to select the state of one or more related options.
 */
const ButtonSet = compat.forwardRef(({ children, testId, 'aria-label': accessibleLabel, 'aria-labelledby': ariaLabelledBy, 'aria-controls': ariaControls, 'aria-describedby': ariaDescribedBy, width }, ref) => {
    const { layoutWidth, isDisabled } = useButtonSetContext.useButtonSetContext();
    const testIdProps = useTestId.useTestId(testId);
    const { isTabbable } = useTabbableMode.useTabbableMode(isDisabled);
    const { isRoving } = hooks.useContext(TabbableModeContext.TabbableModeContext);
    const { focusedId, rovingTabIndexContainerProps: { ref: rovingRef, tabIndex, ...rovingProps } } = useRovingTabIndexContainer.useRovingTabIndexContainer(!isTabbable);
    const { class: cls, ...intStyles } = styleInterpolations({ width });
    const rootStyles = classNames.classNames([
        UNSAFE_ButtonSet_themes_ButtonSetStyles_css.styles.base,
        cls,
        layoutWidth === 'equal' ? UNSAFE_ButtonSet_themes_ButtonSetStyles_css.styles.fullWidth : undefined
    ]);
    return (jsxRuntime.jsx("span", { role: "toolbar", class: rootStyles, style: intStyles, ref: isRoving ? ref : refUtils.mergeRefs(ref, rovingRef), "aria-label": accessibleLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, "aria-controls": ariaControls, tabIndex: !isDisabled && !isRoving ? tabIndex : undefined, ...testIdProps, ...rovingProps, children: isRoving ? (jsxRuntime.jsx(ButtonSetItems, { children: children })) : (jsxRuntime.jsx(TabbableModeContext.TabbableModeContext.Provider, { value: { isTabbable: isTabbable, isRoving: true, focusedId: focusedId }, children: jsxRuntime.jsx(ButtonSetItems, { children: children }) })) }));
});
ButtonSet.displayName = 'ButtonSet';

exports.ButtonSet = ButtonSet;
//# sourceMappingURL=ButtonSet-a1f0f8b9.js.map
