{"version":3,"file":"UNSAFE_DrawerLayout.js","sources":["../../src/UNSAFE_DrawerLayout/DrawerLayout.tsx"],"sourcesContent":["import { JSX, ComponentChildren, type RefObject } from 'preact';\nimport { useState, useRef, useLayoutEffect, useEffect, useCallback } from 'preact/hooks';\nimport { normalizePosition } from '../utils/PRIVATE_floatingUtils';\nimport { Floating, ShiftOptions, RtlSide } from '../UNSAFE_Floating';\nimport { Layer } from '../UNSAFE_Layer';\nimport {\n  getAutofocusFocusables,\n  focusOn,\n  focusWithin,\n  focusOnElementOrNearestAncestor\n} from '../utils/PRIVATE_tabbableUtils';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { allTabbableElements, getActiveElement } from '../utils/PRIVATE_tabbableUtils';\n\n// Hooks\nimport { useAnimation } from '../hooks/UNSAFE_useAnimation';\nimport { DURATION_LARGE } from '../utils/PRIVATE_animationUtils';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { useTestId, TestIdProps } from '../hooks/UNSAFE_useTestId';\nimport { useBreakpointValues } from '../hooks/UNSAFE_useBreakpointValues';\nimport { useResizeObserver } from '../hooks/UNSAFE_useResizeObserver';\n\n// Style imports\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { DrawerLayoutStyles } from './themes/DrawerLayoutStyles.css';\nimport { DrawerLayoutRedwoodTheme } from './themes/redwood/DrawerLayoutTheme';\n\n// Types\ntype IntrinsicProps = Pick<JSX.HTMLAttributes<HTMLDivElement>, 'children'>;\ntype Placement = 'start' | 'end' | 'bottom';\ntype Status = 'unmounted' | 'initial' | 'opening' | 'open' | 'closing';\n\ntype OnCloseDetail = {\n  placement: Placement;\n  reason: 'escapeKey';\n};\ntype OnTransitionEndDetail = {\n  placement: Placement;\n  value: boolean;\n};\ntype DisplayMode = 'overlay' | 'reflow';\ntype ResolvedDisplayMode = 'full-overlay' | 'overlay' | 'reflow';\ntype Visibility = 'hidden' | 'visible';\n\ntype AnimationEffect =\n  | 'expandVertically'\n  | 'collapseVertically'\n  | 'expandHorizontally'\n  | 'collapseHorizontally'\n  | 'slideUp'\n  | 'slideDown'\n  | 'slideOpenLeft'\n  | 'slideCloseLeft'\n  | 'slideOpenRight'\n  | 'slideCloseRight'\n  | '';\n\ntype Props = IntrinsicProps & {\n  /**\n   * The content node to be shown within the Start Drawer\n   */\n  startDrawer?: ComponentChildren;\n  /**\n   * The content node to be shown within the End Drawer\n   */\n  endDrawer?: ComponentChildren;\n  /**\n   * The content node to be shown within the Bottom Drawer\n   */\n  bottomDrawer?: ComponentChildren;\n  /**\n   * Specifies whether Start drawer is open.\n   */\n  isStartOpen?: boolean;\n  /**\n   * Specifies the display mode of the Start drawer.\n   *\n   * Supported values are:\n   * <p><code>overlay</code>, <code>reflow</code></p>\n   * Default is <code>undefined</code>.\n   */\n  startDisplay?: DisplayMode;\n  /**\n   * Specifies whether End drawer is open.\n   */\n  isEndOpen?: boolean;\n  /**\n   * Specifies the display mode of the End drawer.\n   *\n   * Supported values are:\n   * <p><code>overlay</code>, <code>reflow</code></p>\n   * Default is <code>undefined</code>.\n   */\n  endDisplay?: DisplayMode;\n  /**\n   * Specifies whether Bottom drawer is open.\n   */\n  isBottomOpen?: boolean;\n  /**\n   * Specifies the display mode of the Bottom drawer.\n   *\n   * Supported values are:\n   * <p><code>overlay</code>, <code>reflow</code></p>\n   * Default is <code>undefined</code>.\n   */\n  bottomDisplay?: DisplayMode;\n  /**\n   * Specifies callback triggered when a user tries to close a Drawer through UI interaction.\n   * The parent should listen to this event and close the Drawer. If the parent fails to remove\n   * the Popup, then no change will be done in the UI by the component.\n   *\n   * Supported detail values are:\n   * <p><code>placement: start | end | bottom</code></p>\n   * <p><code>reason: escapeKey</code></p>\n   */\n  onClose?: (detail: OnCloseDetail) => void;\n  /**\n   * Specifies callback triggered after the animation ends.\n   *\n   * Supported detail values are:\n   * <p><code>placement: start | end | bottom</code></p>\n   * <p><code>value: boolean</code></p>\n   */\n  onTransitionEnd?: (detail: OnTransitionEndDetail) => void;\n} & TestIdProps;\n\n/**\n * A drawer layout adds expandable side contents (drawers) alongside some primary content.\n *\n * These drawers automatically swap 'reflow' and 'overlay' display mode based on width of the page and can be placed at the 'start', 'end' or 'bottom' edge.\n */\nexport const DrawerLayout = ({\n  children,\n  startDrawer,\n  endDrawer,\n  bottomDrawer,\n  isStartOpen = false,\n  isEndOpen = false,\n  isBottomOpen = false,\n  startDisplay,\n  endDisplay,\n  bottomDisplay,\n  onClose,\n  onTransitionEnd,\n  testId // ...props\n}: Props) => {\n  // Constants\n  const zeroPx = '0px';\n  const verticalBreakpoint = 600;\n  const stringStart = 'start';\n  const stringEnd = 'end';\n  const stringBottom = 'bottom';\n  const stringInitial = 'initial';\n  const stringOpening = 'opening';\n  const stringOpen = 'open';\n  const stringClosing = 'closing';\n  const stringUnmounted = 'unmounted';\n  const stringFullOverlay = 'full-overlay';\n  const stringOverlay = 'overlay';\n  const stringReflow = 'reflow';\n  const stringHidden = 'hidden';\n  const stringVisible = 'visible';\n\n  // Initialize states\n  const [startDrawerStatus, setStartDrawerStatus] = useState<Status>(\n    isStartOpen ? stringInitial : stringUnmounted\n  );\n  const [endDrawerStatus, setEndDrawerStatus] = useState<Status>(\n    isEndOpen ? stringInitial : stringUnmounted\n  );\n  const [bottomDrawerStatus, setBottomDrawerStatus] = useState<Status>(\n    isBottomOpen ? stringInitial : stringUnmounted\n  );\n  const [startVisibility, setStartVisibility] = useState<Visibility>(stringHidden);\n  const [endVisibility, setEndVisibility] = useState<Visibility>(stringHidden);\n  const [bottomVisibility, setBottomVisibility] = useState<Visibility>(stringHidden);\n\n  const [startOffset, setStartOffset] = useState<number>();\n  const [endOffset, setEndOffset] = useState<number>();\n  const [bottomOffset, setBottomOffset] = useState<number>();\n\n  // Breakpoints:\n  // sm: 0-600px (full-overlay)\n  // md: 600-1024px (overlay)\n  // lg: >1024px (reflow)\n  const displayMode: ResolvedDisplayMode = useBreakpointValues({\n    sm: stringFullOverlay,\n    md: stringOverlay,\n    lg: stringReflow\n  });\n  const [viewportDisplayModeHorizontal, setViewportDisplayModeHorizontal] =\n    useState<ResolvedDisplayMode>(displayMode);\n  const [viewportDisplayModeVertical, setViewportDisplayModeVertical] =\n    useState<ResolvedDisplayMode>(displayMode);\n\n  // Refs\n  const rootRef = useRef<HTMLDivElement>(null);\n  const centerRef = useRef<HTMLDivElement>(null);\n  const startDrawerRef = useRef<HTMLDivElement>(null);\n  const endDrawerRef = useRef<HTMLDivElement>(null);\n  const bottomDrawerRef = useRef<HTMLDivElement>(null);\n  const placementOfLastlyFocusedRef = useRef<Placement | null>(null);\n  const indexOfLastlyFocusedRef = useRef<number | null>(null);\n  const stretchedOverlayClippingRef = useRef<HTMLDivElement>(null);\n\n  const startLauncherRef = useRef<HTMLElement | null>(null);\n  const endLauncherRef = useRef<HTMLElement | null>(null);\n  const bottomLauncherRef = useRef<HTMLElement | null>(null);\n  const elementWithFocusBeforeDrawerClosesRef = useRef<HTMLElement | null>(null);\n\n  const [startResolvedDisplayMode, setStartResolvedDisplayMode] =\n    useState<ResolvedDisplayMode | null>(null);\n  const [endResolvedDisplayMode, setEndResolvedDisplayMode] = useState<ResolvedDisplayMode | null>(\n    null\n  );\n  const [bottomResolvedDisplayMode, setBottomResolvedDisplayMode] =\n    useState<ResolvedDisplayMode | null>(null);\n\n  const getDrawerEl = useCallback((placement: Placement) => {\n    return getDrawerRef(placement).current;\n  }, []);\n\n  const getPlacementOfDrawerWithFocus = useCallback(() => {\n    const startDrawerEl = getDrawerEl(stringStart);\n    const endDrawerEl = getDrawerEl(stringEnd);\n    const bottomDrawerEl = getDrawerEl(stringBottom);\n    const activeElement = getActiveElement();\n    if (startDrawerEl && startDrawerEl.contains(activeElement)) {\n      return stringStart;\n    } else if (endDrawerEl && endDrawerEl.contains(activeElement)) {\n      return stringEnd;\n    } else if (bottomDrawerEl && bottomDrawerEl.contains(activeElement)) {\n      return stringBottom;\n    } else return null;\n  }, [getDrawerEl]);\n\n  const triggerFocusTransferStrategy = useCallback((): void => {\n    // Focus strategy - find focused element.\n    // Save what drawer and what element had focus before it was eventually conditionally re-rendered\n\n    // In 'auto' display mode we swap 'reflow' and 'overlay' automatically\n    // When this change happens, conditional rendering mechanism destroys\n    // reflow drawer DOM and creates overlay drawer DOM. This, of course,\n    // applies vice versa. In such cases focus gets lost.\n    // In DOM destroy cases focus is usually moved to <body>.\n\n    // In standard open cases we trigger focus strategy from animationEnd callback.\n    // However, in 'reflow' <> 'overlay' cases animation hook is not used/wanted at all.\n    // In addition, we should keep focus on the lastly/customly focused elemenet,\n    // e.g. the lastly focused element of a form\n\n    // 1. useBreakpoint hook is triggered even there's no drawer present.\n    // Handle focus only if there's at least one drawer open\n    if (isStartOpen || isEndOpen || isBottomOpen) {\n      // 2. Focus might not be in drawers.\n      // In modeless cases user can bring the focus out of open drawers by clicking outside them.\n\n      // Check whether focused element lives in a drawer (one of drawers).\n      // Do not handle focus at all if it is not within a drawer.\n      // Note: returns null if focus is not within a drawer\n      const activeElementPlacement = getPlacementOfDrawerWithFocus();\n      if (activeElementPlacement) {\n        // Save in which drawer focus lives (save its placement).\n        placementOfLastlyFocusedRef.current = activeElementPlacement;\n\n        // 3. Focus was detected in a particular drawer\n        // Save index of this element\n        const allTabbables = allTabbableElements(\n          getDrawerRef(placementOfLastlyFocusedRef.current).current as HTMLDivElement,\n          true\n        );\n        // Save index of lastly focused element\n        indexOfLastlyFocusedRef.current = allTabbables.indexOf(getActiveElement() as HTMLElement);\n      }\n    }\n  }, [getPlacementOfDrawerWithFocus, isStartOpen, isBottomOpen, isEndOpen]);\n\n  const isDrawerOpen = useCallback(\n    (placement: Placement): boolean => {\n      let isOpen = false;\n      switch (placement) {\n        case stringStart:\n          isOpen = isStartOpen;\n          break;\n        case stringEnd:\n          isOpen = isEndOpen;\n          break;\n        case stringBottom:\n          isOpen = isBottomOpen;\n          break;\n      }\n      return isOpen;\n    },\n    [isStartOpen, isEndOpen, isBottomOpen]\n  );\n\n  useEffect((): void => {\n    // Focus strategy - apply focus back\n    // Return focus to a drawer if applicable\n    // 1a. useBreakpoint hook, which monitors viewport resolution, is triggered even drawer(s) are not open.\n    // This hook causes changes to 'viewportDisplayModeHorizontal', a dependency of this effect.\n    // 1b. This effect can be also triggered by a change to\n    // start-display/end-display/bottom-display properties of the DrawerLayout.\n    // Make sure that drawer, in which we previously found focus, is still open.\n    const placementOflastlyFocusedDrawer = placementOfLastlyFocusedRef.current;\n    if (placementOflastlyFocusedDrawer) {\n      const drawerRefReceivingFocus: RefObject<any> = getDrawerRef(placementOflastlyFocusedDrawer);\n\n      if (drawerRefReceivingFocus.current && isDrawerOpen(placementOflastlyFocusedDrawer)) {\n        // 2. Find all tabbables in newly rendered focus receiving focus\n        const allTabbables = allTabbableElements(drawerRefReceivingFocus.current, true);\n\n        // 3. Try to focus the same element that had focus in previous display mode\n        // In theory drawer's content could be modified.\n        // Check whether there are more tababble elements than the index value we saved\n        if (\n          indexOfLastlyFocusedRef.current != null &&\n          allTabbables.length > indexOfLastlyFocusedRef.current\n        ) {\n          // Focus element using the saved index\n          focusOn(allTabbables[indexOfLastlyFocusedRef.current]);\n        } else {\n          // Focus first tabbable\n          focusWithin(drawerRefReceivingFocus.current);\n        }\n\n        // Reset saved values to avoid possible side effects\n        placementOfLastlyFocusedRef.current = null;\n        indexOfLastlyFocusedRef.current = null;\n      }\n    }\n  }, [startResolvedDisplayMode, endResolvedDisplayMode, bottomResolvedDisplayMode, isDrawerOpen]);\n\n  useEffect(() => {\n    // Size breakpoint crossed\n    triggerFocusTransferStrategy();\n    // Reschedules the effect to occur after the ResizeObserver’s loop has completed.\n    setTimeout((): void => {\n      setViewportDisplayModeHorizontal(displayMode);\n    }, 0);\n  }, [displayMode, triggerFocusTransferStrategy]);\n\n  const getElementHeight = (element: HTMLDivElement): number => {\n    return element ? Math.round(element.offsetHeight) : 0;\n  };\n\n  const getElementHeightPx = useCallback((element: HTMLDivElement): string => {\n    return `${getElementHeight(element)}px`;\n  }, []);\n\n  const getElementWidth = useCallback((element: HTMLDivElement): number => {\n    return element ? Math.round(element.getBoundingClientRect().width) : 0;\n  }, []);\n\n  const getElementWidthPx = useCallback(\n    (element: HTMLDivElement): string => {\n      return `${getElementWidth(element)}px`;\n    },\n    [getElementWidth]\n  );\n\n  // Normalizing position\n  const { direction } = useUser();\n  const isLtr = direction === 'ltr';\n\n  const getNormalizedPlacement = useCallback(\n    (placement: Placement): RtlSide => {\n      return normalizePosition(placement, direction);\n    },\n    [direction]\n  );\n\n  const isSidePlacement = (placement: Placement): boolean => {\n    return [stringStart, stringEnd].indexOf(placement) > -1;\n  };\n\n  const isBottomPlacement = (placement: Placement): boolean => {\n    return placement === stringBottom;\n  };\n\n  const isAnimationPending = (status: Status): boolean => {\n    return [stringOpening, stringClosing].indexOf(status) > -1;\n  };\n\n  const isDrawerAnimationPending = (placement: Placement): boolean => {\n    switch (placement) {\n      case stringStart:\n        return isAnimationPending(startDrawerStatus);\n      case stringEnd:\n        return isAnimationPending(endDrawerStatus);\n      case stringBottom:\n        return isAnimationPending(bottomDrawerStatus);\n    }\n  };\n\n  const getDrawerVisibility = (placement: Placement): Visibility => {\n    switch (placement) {\n      case stringStart:\n        return startVisibility;\n      case stringEnd:\n        return endVisibility;\n      case stringBottom:\n        return bottomVisibility;\n    }\n  };\n\n  const setDrawerVisibility = (placement: Placement, visibility: Visibility): void => {\n    switch (placement) {\n      case stringStart:\n        return setStartVisibility(visibility);\n      case stringEnd:\n        return setEndVisibility(visibility);\n      case stringBottom:\n        return setBottomVisibility(visibility);\n    }\n  };\n\n  const getDrawerRef = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startDrawerRef;\n      case stringEnd:\n        return endDrawerRef;\n      case stringBottom:\n        return bottomDrawerRef;\n    }\n  };\n\n  const getAnimatedNodeRef = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startAnimatedNodeRef;\n      case stringEnd:\n        return endAnimatedNodeRef;\n      case stringBottom:\n        return bottomAnimatedNodeRef;\n    }\n  };\n\n  const getDrawerStatus = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startDrawerStatus;\n      case stringEnd:\n        return endDrawerStatus;\n      case stringBottom:\n        return bottomDrawerStatus;\n    }\n  };\n\n  const setDrawerStatus = (placement: Placement, status: Status): void => {\n    switch (placement) {\n      case stringStart:\n        setStartDrawerStatus(status);\n        break;\n      case stringEnd:\n        setEndDrawerStatus(status);\n        break;\n      case stringBottom:\n        setBottomDrawerStatus(status);\n        break;\n    }\n  };\n\n  const resetAnimatedNodeRef = (placement: Placement): void => {\n    switch (placement) {\n      case stringStart:\n        startAnimatedNodeRef(null);\n        break;\n      case stringEnd:\n        endAnimatedNodeRef(null);\n        break;\n      case stringBottom:\n        bottomAnimatedNodeRef(null);\n        break;\n    }\n  };\n\n  const getDrawerDisplayProp = useCallback(\n    (placement: Placement) => {\n      switch (placement) {\n        case stringStart:\n          return startDisplay;\n        case stringEnd:\n          return endDisplay;\n        case stringBottom:\n          return bottomDisplay;\n      }\n    },\n    [startDisplay, endDisplay, bottomDisplay]\n  );\n\n  const getDrawerResolvedDisplayMode = useCallback(\n    (placement: Placement) => {\n      const displayProp = getDrawerDisplayProp(placement);\n      if (displayProp) {\n        return displayProp;\n      } else {\n        if (isSidePlacement(placement)) {\n          return viewportDisplayModeHorizontal;\n        }\n        return viewportDisplayModeVertical;\n      }\n    },\n    [getDrawerDisplayProp, viewportDisplayModeHorizontal, viewportDisplayModeVertical]\n  );\n\n  // Animation effects config\n  const getAnimationStates = (ref: RefObject<HTMLElement>) => {\n    return {\n      expandVertically: {\n        from: {\n          maxHeight: zeroPx\n        },\n        to: {\n          maxHeight: '100%'\n        },\n        options: {\n          duration: DURATION_LARGE\n        }\n      },\n      collapseVertically: {\n        from: {\n          maxHeight: '100%'\n        },\n        to: {\n          maxHeight: zeroPx\n        },\n        options: {\n          duration: DURATION_LARGE\n        }\n      },\n      expandHorizontally: () => {\n        return {\n          from: {\n            maxWidth: zeroPx\n          },\n          to: {\n            // We need a function here as the width is dynamic\n            // and percentage can't be used in reflow mode\n            maxWidth: getElementWidthPx(ref.current as HTMLDivElement)\n          },\n          options: {\n            duration: DURATION_LARGE\n          }\n        };\n      },\n      collapseHorizontally: () => {\n        return {\n          from: {\n            // We need a function here as the width is dynamic\n            // and percentage can't be used in reflow mode\n            maxWidth: getElementWidthPx(ref.current as HTMLDivElement)\n          },\n          to: {\n            maxWidth: zeroPx\n          },\n          options: {\n            duration: DURATION_LARGE\n          }\n        };\n      },\n      slideUp: {\n        from: {\n          // We need a function here as the height is dynamic\n          // and percentage can't be used in reflow mode\n          translateY: '100%'\n        },\n        to: {\n          translateY: zeroPx\n        },\n        options: {\n          duration: DURATION_LARGE\n        }\n      },\n      slideDown: {\n        from: {\n          translateY: zeroPx\n        },\n        to: {\n          translateY: '100%'\n        },\n        options: {\n          duration: DURATION_LARGE\n        }\n      },\n      slideOpenLeft: {\n        from: {\n          translateX: '-100%'\n        },\n        to: {\n          translateX: zeroPx\n        },\n        options: {\n          duration: DURATION_LARGE\n        }\n      },\n      slideCloseLeft: {\n        from: {\n          translateX: '0'\n        },\n        to: {\n          translateX: '-100%'\n        },\n        options: {\n          duration: DURATION_LARGE\n        }\n      },\n      slideOpenRight: {\n        from: {\n          translateX: '100%'\n        },\n        to: {\n          translateX: zeroPx\n        },\n        options: {\n          duration: DURATION_LARGE\n        }\n      },\n      slideCloseRight: {\n        from: {\n          translateX: '0'\n        },\n        to: {\n          translateX: '100%'\n        },\n        options: {\n          duration: DURATION_LARGE\n        }\n      }\n    };\n  };\n\n  const removeAnimationInlineStyles = (placement: Placement): void => {\n    // Remove style attribute left on the element by the Animation util\n    const drawerRef: RefObject<any> = getDrawerRef(placement);\n    drawerRef.current.removeAttribute('style');\n  };\n\n  const setInitialFocus = (placement: Placement): void => {\n    // Set focus to the first match:\n    const drawerRef: RefObject<any> = getDrawerRef(placement);\n\n    // 1. First element inside the drawer matching [autofocus]\n    const autofocusItems: HTMLElement[] = getAutofocusFocusables(drawerRef.current);\n    if (autofocusItems.length > 0) {\n      focusOn(autofocusItems[0]);\n      return;\n    }\n    // 2. Tabbable element inside the content element\n    // 3. The drawer itself\n    focusWithin(drawerRef.current);\n  };\n\n  const getLauncherRef = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startLauncherRef;\n      case stringEnd:\n        return endLauncherRef;\n      case stringBottom:\n        return bottomLauncherRef;\n    }\n  };\n\n  const returnFocusToLauncher = (placement: Placement): void => {\n    // Return the focus to the drawer's launcher only if the focus\n    // is currently living within a drawer.\n    // As we do not apply focus-trap in modeless mode, user is able to\n    // get the focus out of the drawer. In this case we do not want to handle it.\n    if (getDrawerRef(placement).current?.contains(elementWithFocusBeforeDrawerClosesRef.current)) {\n      focusOnElementOrNearestAncestor(getLauncherRef(placement).current as HTMLElement);\n    }\n  };\n\n  // Animation effect\n  const getAnimationEffect = (placement: Placement) => {\n    const bottomPlacement = isBottomPlacement(placement);\n    const status = getDrawerStatus(placement);\n    if (getDrawerResolvedDisplayMode(placement) === stringReflow) {\n      // Reflow display mode\n      // Effect: Expand/Collapse\n      if (bottomPlacement) {\n        // useAnimation hook ignores to apply effect if it matches the previous one.\n        // if (currentAnimationState.current === animationState) return;\n        // That's why we need to pair particular with particualar status and\n        // send empty stirng in all other cases\n        if (status === 'opening') {\n          return 'expandVertically';\n        }\n        if (status === 'closing') {\n          return 'collapseVertically';\n        }\n        return '';\n      } else {\n        if (status === 'opening') {\n          return 'expandHorizontally';\n        }\n        if (status === 'closing') {\n          return 'collapseHorizontally';\n        }\n        return '';\n      }\n    } else {\n      // Overlay display mode\n      // Effect: SlideIn/SlideOut\n      if (bottomPlacement) {\n        if (status === 'opening') {\n          return 'slideUp';\n        }\n        if (status === 'closing') {\n          return 'slideDown';\n        }\n        return '';\n      } else {\n        if (status === 'opening') {\n          return getNormalizedPlacement(placement) === 'left' ? 'slideOpenLeft' : 'slideOpenRight';\n        }\n        if (status === 'closing') {\n          return getNormalizedPlacement(placement) === 'left'\n            ? 'slideCloseLeft'\n            : 'slideCloseRight';\n        }\n        return '';\n      }\n    }\n  };\n\n  // Custom hook to be shared for each side\n  // It can't be a function as a hook can only be called within a custom hook\n  function useNodeRef(placement: Placement, ref: RefObject<HTMLElement>) {\n    const isOpen: boolean = isDrawerOpen(placement);\n    const status = getDrawerStatus(placement);\n    return useAnimation<AnimationEffect, HTMLDivElement>(getAnimationEffect(placement), {\n      animationStates: getAnimationStates(ref),\n      isAnimatedOnMount: true,\n      onAnimationEnd: () => {\n        if (status === stringOpening) {\n          if (isOverlay(placement)) {\n            setInitialFocus(placement);\n          }\n          // Remove animation's inline style\n          removeAnimationInlineStyles(placement);\n\n          // In case drawer display mode changed at runtime (reflow <> overlay)\n          // we need to reset animation node ref otherwise animation state is not refelected.\n          // Case:\n          // <oj-c-drawer-layout> opens on wide screen by default in reflow mode (flex layout).\n          // useAnimation effect was 'expand'\n          // Viewport is shrinked under 1024px, display mode changes to overlay.\n          // This means DOM is reparented.\n          // For overlay mode, closing animation effect should be 'slideout'\n          // If animation nodeRef is not reset, closing effect is neither 'collapse' nor 'slideout'.\n          resetAnimatedNodeRef(placement);\n\n          setDrawerStatus(placement, stringOpen);\n          onTransitionEnd?.({\n            placement: placement,\n            value: true\n          });\n        } else if (!isOpen) {\n          if (isOverlay(placement)) {\n            returnFocusToLauncher(placement);\n          }\n          resetAnimatedNodeRef(placement);\n          setDrawerVisibility(placement, stringHidden);\n          setDrawerStatus(placement, stringUnmounted);\n          onTransitionEnd?.({\n            placement: placement,\n            value: false\n          });\n        }\n      }\n    }).nodeRef;\n  }\n\n  // Drawer refs\n  const startAnimatedNodeRef = useNodeRef(stringStart, startDrawerRef);\n  const endAnimatedNodeRef = useNodeRef(stringEnd, endDrawerRef);\n  const bottomAnimatedNodeRef = useNodeRef(stringBottom, bottomDrawerRef);\n\n  //testId support\n  const testIdProps = useTestId(testId);\n\n  const setLauncherRef = (placement: Placement) => {\n    const activeElement = getActiveElement() as HTMLElement;\n    switch (placement) {\n      case stringStart:\n        startLauncherRef.current = activeElement;\n        break;\n      case stringEnd:\n        endLauncherRef.current = activeElement;\n        break;\n      case stringBottom:\n        bottomLauncherRef.current = activeElement;\n        break;\n    }\n  };\n\n  // Custom hook to be shared for each side\n  // It can't be a function as a hook can only be called within a custom hook\n  function useDrawerStatus(placement: Placement): void {\n    const isOpen = isDrawerOpen(placement);\n    const drawerStatus = getDrawerStatus(placement);\n\n    useEffect(() => {\n      // Ignore initial render\n      // 1. Ignore status update on initial render\n      if (drawerStatus === stringUnmounted && !isOpen) {\n        return;\n      }\n\n      // 2. Unmounted\n      // Mount visually hidden component.\n      // Component gets mounted, but will be visually hidden to avoid flickering.\n      // Flickering happens because it gets rendered before animation hook repositions\n      // it in next render cycle\n      if (drawerStatus === stringUnmounted && isOpen) {\n        setDrawerStatus(placement, stringInitial);\n        return;\n      }\n\n      // 3. Initial\n      // Setup animation\n      // Component has been mounted.\n      // We will kick out animation as node is already present in DOM.\n      // To avoid flickering, we still keep it visually hidden until the next render cycle.\n      if (drawerStatus === stringInitial && isOpen) {\n        if (isOverlay(placement)) {\n          const drawerRef = getDrawerRef(placement);\n          const animatedNodeRef = getAnimatedNodeRef(placement);\n          animatedNodeRef(drawerRef.current);\n          setDrawerStatus(placement, stringOpening);\n          return;\n        }\n      }\n\n      // 4. Opening\n      // Unhide component. It becomes visible.\n      if (drawerStatus === stringOpening && isOpen) {\n        if (isOverlay(placement)) {\n          setDrawerVisibility(placement, stringVisible);\n          // Remember launcher\n          setLauncherRef(placement);\n          return;\n        }\n      }\n\n      // 5. Open\n      // Status 'open' is set in 'onAnimationEnd' handler\n\n      // 6. Closing\n      if (!isOpen) {\n        // As animatedNodeRef was reset in onAnimationEnd we need to set it again\n        // see useAnimation transition end for details\n        const drawerRef = getDrawerRef(placement);\n        const animatedNodeRef = getAnimatedNodeRef(placement);\n        animatedNodeRef(drawerRef.current);\n\n        elementWithFocusBeforeDrawerClosesRef.current = getActiveElement() as HTMLElement;\n        setDrawerStatus(placement, stringClosing);\n      }\n    }, [isOpen, drawerStatus, placement]);\n\n    // For reflow only\n    useLayoutEffect(() => {\n      // 3. Initial\n      // Setup animation\n      // Component has been mounted.\n      // We will kick out animation as node is already present in DOM.\n      // To avoid flickering, we still keep it visually hidden until the next render cycle.\n      if (drawerStatus === stringInitial && isOpen) {\n        if (!isOverlay(placement)) {\n          const drawerRef = getDrawerRef(placement);\n          const animatedNodeRef = getAnimatedNodeRef(placement);\n          animatedNodeRef(drawerRef.current);\n          setDrawerStatus(placement, stringOpening);\n          return;\n        }\n      }\n\n      // 4. Opening\n      // Unhide component. It becomes visible.\n      if (drawerStatus === stringOpening && isOpen) {\n        if (!isOverlay(placement)) {\n          setDrawerVisibility(placement, stringVisible);\n          // Remember launcher\n          setLauncherRef(placement);\n          return;\n        }\n      }\n    }, [drawerStatus, isOpen, placement]);\n  }\n\n  // Drawers' status handler±\n  useDrawerStatus(stringStart);\n  useDrawerStatus(stringEnd);\n  useDrawerStatus(stringBottom);\n\n  // Keydown handlers\n  const handleKeyDownStart = (event: Event): void => {\n    handleKeyDown(stringStart, event);\n  };\n  const handleKeyDownEnd = (event: Event): void => {\n    handleKeyDown(stringEnd, event);\n  };\n  const handleKeyDownBottom = (event: Event): void => {\n    handleKeyDown(stringBottom, event);\n  };\n\n  const handleKeyDown = (placement: Placement, event: any): void => {\n    if (event.code === 'Escape') {\n      // Handle only in overlay mode\n      if (isOverlay(placement)) {\n        onClose?.({\n          placement,\n          reason: 'escapeKey'\n        });\n      }\n    }\n  };\n\n  // Styles\n  const { classes, styles } = useComponentTheme<never, DrawerLayoutStyles>(\n    DrawerLayoutRedwoodTheme\n  );\n\n  const getVisibilityClass = (visibility: Visibility) => {\n    return visibility === stringHidden ? styles.visibilityHidden : styles.visibilityVisible;\n  };\n\n  const isStretched = (): boolean => {\n    return displayMode === stringFullOverlay;\n  };\n\n  const isOverlay = useCallback(\n    (placement: Placement): boolean => {\n      return (\n        [stringFullOverlay, stringOverlay].indexOf(getDrawerResolvedDisplayMode(placement)) > -1\n      );\n    },\n    [getDrawerResolvedDisplayMode]\n  );\n\n  const isFullOverlay = (placement: Placement): boolean => {\n    return getDrawerResolvedDisplayMode(placement) === stringFullOverlay;\n  };\n\n  const getDrawerClassNames = (placement: Placement): string => {\n    // Visibility style is always added\n    const visibility: Visibility = getDrawerVisibility(placement);\n    const classNamesArr: string[] = [getVisibilityClass(visibility)];\n\n    // Styles for overlay vs. full-overlay vs. reflow\n    if (isOverlay(placement)) {\n      classNamesArr.push(styles.overlayDrawer);\n      if (isSidePlacement(placement) && !isFullOverlay(placement)) {\n        classNamesArr.push(styles.overlaySideDrawerNonFullWidth);\n      }\n\n      // Styles for stretched overlay drawer\n      if (isStretched() && isSidePlacement(placement)) {\n        classNamesArr.push(styles.stretchedOverlaySideDrawer);\n      }\n    } else {\n      classNamesArr.push(styles.reflowDrawer);\n    }\n\n    // Styles for animation\n    if (isDrawerAnimationPending(placement)) {\n      classNamesArr.push(styles.animatedDrawer);\n    }\n\n    const getPlacementSpecificStyles = (placement: Placement): string => {\n      switch (placement) {\n        case stringStart:\n          if (isOverlay(stringStart)) {\n            return isLtr ? styles.overlayDrawerLeft : styles.overlayDrawerRight;\n          } else {\n            return isLtr ? styles.reflowDrawerLeft : styles.reflowDrawerRight;\n          }\n        case stringEnd:\n          if (isOverlay(stringEnd)) {\n            return isLtr ? styles.overlayDrawerRight : styles.overlayDrawerLeft;\n          } else {\n            return isLtr ? styles.reflowDrawerRight : styles.reflowDrawerLeft;\n          }\n        case stringBottom:\n          return isOverlay(stringBottom) ? styles.overlayDrawerBottom : styles.reflowDrawerBottom;\n      }\n    };\n    // Placement specific styles\n    classNamesArr.push(getPlacementSpecificStyles(placement));\n\n    return classNames(classNamesArr);\n  };\n\n  const getDrawerProp = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startDrawer;\n      case stringEnd:\n        return endDrawer;\n      case stringBottom:\n        return bottomDrawer;\n    }\n  };\n\n  const getKeyDownHandler = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return handleKeyDownStart;\n      case stringEnd:\n        return handleKeyDownEnd;\n      case stringBottom:\n        return handleKeyDownBottom;\n    }\n  };\n\n  const renderOverlayDrawer = (placement: Placement) => {\n    if (isStretched() && isSidePlacement(placement)) {\n      const clippingAreaStyles = [styles.stretchedOverlaySideDrawerClippingArea];\n      switch (placement) {\n        case stringStart:\n          clippingAreaStyles.push(\n            isLtr\n              ? styles.stretchedOverlaySideDrawerClippingAreaLeft\n              : styles.stretchedOverlaySideDrawerClippingAreaRight\n          );\n          break;\n        case stringEnd:\n          clippingAreaStyles.push(\n            isLtr\n              ? styles.stretchedOverlaySideDrawerClippingAreaRight\n              : styles.stretchedOverlaySideDrawerClippingAreaLeft\n          );\n          break;\n      }\n\n      // Add clipping div\n      return (\n        <div ref={stretchedOverlayClippingRef} className={classNames(clippingAreaStyles)}>\n          {renderDrawer(placement)}\n        </div>\n      );\n    } else {\n      // Overlay bottom drawer or not stretched side drawer\n      return renderDrawer(placement);\n    }\n  };\n\n  // Single drawer template\n  const renderDrawer = (placement: Placement) => {\n    return (\n      <div\n        ref={getDrawerRef(placement)}\n        className={getDrawerClassNames(placement)}\n        tabIndex={isOverlay(placement) ? -1 : undefined}\n        onKeyDown={getKeyDownHandler(placement)}>\n        {getDrawerProp(placement)}\n      </div>\n    );\n  };\n\n  const clientHints = getClientHints();\n\n  const getViewportHeight = useCallback((): number => {\n    if (clientHints.platform === 'ios') {\n      // On ios window.innerHeight is not recommended way of measuring the viewport\n      return document.documentElement.clientHeight;\n    }\n    return window.innerHeight;\n  }, [clientHints.platform]);\n\n  // We faced error in KM test environment\n  // Error: ResizeObserver loop completed with undelivered notifications.\n  // This happens when an observed element is resized again during a notification.\n  // Another cause can be rounding values and then setting the rounded value back.\n  // If this is in the same loop as the resize notification, it will cause another resize on the element.\n  // Wrapping ResizeObserver’s callback in a setTimeout with a delay of 0 milliseconds\n  // reschedules the effect to occur after the ResizeObserver’s loop has completed.\n  const rescheduleObserverHandler = (callback: any) => {\n    setTimeout(() => {\n      callback();\n    }, 0);\n  };\n\n  const handleRescheduledVerticalResize = useCallback(() => {\n    const viewportHeight = getViewportHeight();\n    if (viewportHeight >= verticalBreakpoint) {\n      if (viewportDisplayModeVertical != stringReflow) {\n        triggerFocusTransferStrategy();\n        setViewportDisplayModeVertical(stringReflow);\n      }\n    } else {\n      if (viewportDisplayModeVertical != stringOverlay) {\n        triggerFocusTransferStrategy();\n        setViewportDisplayModeVertical(stringOverlay);\n      }\n    }\n  }, [viewportDisplayModeVertical, getViewportHeight, triggerFocusTransferStrategy]);\n\n  const handleVerticalResize = useCallback(() => {\n    rescheduleObserverHandler(handleRescheduledVerticalResize);\n  }, [handleRescheduledVerticalResize]);\n\n  // Window resize listener\n  // useBreakpoint hook is designed for horizontal breakpoints only\n  // This listener is used for 600px (overlay vs. reflow) breakpoint\n  // used for bottom drawer\n  useEffect(() => {\n    const resizeObserver = new ResizeObserver(() => {\n      handleVerticalResize();\n    });\n    resizeObserver.observe(document.body);\n    // Deregister resize observer when Drawer layout unmounts\n    return () => {\n      resizeObserver.unobserve(document.body);\n    };\n  }, [handleVerticalResize]);\n\n  const measureOffset = (placement: Placement): number => {\n    const drawerEl = getDrawerEl(placement);\n    if (drawerEl) {\n      return isSidePlacement(placement) ? -getElementWidth(drawerEl) : -getElementHeight(drawerEl);\n    }\n    return 0;\n  };\n\n  const getOffsetState = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startOffset;\n      case stringEnd:\n        return endOffset;\n      case stringBottom:\n        return bottomOffset;\n    }\n  };\n\n  const setSideOverlayDrawerHeight = useCallback(\n    (placement: Placement) => {\n      // By default PopupElements have no predefined height.\n      // In 'overlay' mode drawers should be\n      // of the same height as their parent <oj-drawer-layout>\n      const centerSectionHeight = getElementHeightPx(centerRef.current as HTMLDivElement);\n\n      const drawerEl = getDrawerRef(placement).current;\n      if (drawerEl && !isStretched() && isDrawerOpen(placement) && isOverlay(placement)) {\n        drawerEl.style.height = centerSectionHeight;\n      }\n    },\n    [getElementHeightPx, isDrawerOpen, isOverlay, isStretched]\n  );\n\n  const handleSideDrawerFullWidth = (placement: Placement) => {\n    const drawerEl = getDrawerRef(placement).current;\n    if (drawerEl) {\n      if (isDrawerOpen(placement)) {\n        const drawerInlineStyle = drawerEl.style;\n        if (isFullOverlay(placement)) {\n          drawerInlineStyle.width = getElementWidthPx(rootRef.current as HTMLDivElement);\n        } else {\n          drawerInlineStyle.removeProperty('width');\n        }\n      }\n    }\n  };\n\n  const setBottomOverlayDrawerWidth = useCallback(() => {\n    const bottomDrawerElement = bottomDrawerRef.current;\n    if (bottomDrawerElement && isDrawerOpen(stringBottom) && isOverlay(stringBottom)) {\n      const centerSectionWidth = getElementWidthPx(centerRef.current as HTMLDivElement);\n      bottomDrawerElement.style.width = centerSectionWidth;\n    }\n  }, [getElementWidthPx, isDrawerOpen, isOverlay]);\n\n  useEffect(() => {\n    // Stretched case - set side drawer size\n    const start: Placement = 'start';\n    const end: Placement = 'end';\n    [start, end].forEach((placement: Placement) => {\n      if (isDrawerOpen(placement) && isStretched()) {\n        // When opening the drawer its ref and its clipping area\n        // are not present on the first run of this effect.\n        // That's why we are using question mark when manipulating their styles.\n\n        // Remove residual inline style when changing overlayHeight\n        // from 'inset' to 'stretch' at Runtime\n        // In 'inset' mode we calculate the height to fit the parent container.\n        getDrawerEl(placement)?.style.removeProperty('height');\n\n        // Do the same removal also on the wrapping clipping area.\n        // DrawerLayout component is not setting this style. This is probably added by Floating.\n        const clippingArea = getDrawerEl(placement)?.parentNode as HTMLElement;\n        clippingArea?.style.removeProperty('height');\n      }\n    });\n  }, [isDrawerOpen, getDrawerEl, getElementWidth, isStretched]);\n\n  const setDrawerSize = (placement: Placement) => {\n    // Not stretched overlay drawer\n    if (isSidePlacement(placement)) {\n      setSideOverlayDrawerHeight(placement);\n      handleSideDrawerFullWidth(placement);\n    }\n    if (isBottomPlacement(placement)) {\n      setBottomOverlayDrawerWidth();\n    }\n  };\n\n  // DrawerLayout resize observer\n  const handleDrawerLayoutResize = () => {\n    rescheduleObserverHandler(handleRescheduledDrawerLayoutResize);\n  };\n  const handleRescheduledDrawerLayoutResize = useCallback(() => {\n    // If the DrawerLayout (page content) changes size,\n    // adjust OVERLAY side drawers (start/end) height to fit the drawer\n    // Note that these two functions checks that 'overlay' condition is fulfilled\n    if (!isStretched()) {\n      setSideOverlayDrawerHeight(stringStart);\n      setSideOverlayDrawerHeight(stringEnd);\n    }\n    setBottomOverlayDrawerWidth();\n  }, [setSideOverlayDrawerHeight, setBottomOverlayDrawerWidth, isStretched]);\n  useResizeObserver(rootRef, handleDrawerLayoutResize);\n\n  const setOffsetState = (placement: Placement) => {\n    // This method sets offset used only in overlay mode\n    if (isOverlay(placement)) {\n      const offset = measureOffset(placement);\n      switch (placement) {\n        case stringStart:\n          // Fixed strategy calculates position from left to right.\n          // Stretched drawer needs no offset\n          setStartOffset(isStretched() ? 0 : offset);\n          break;\n        case stringEnd:\n          // Fixed strategy calculates position from left to right.\n          // Stretched drawer needs no offset\n          setEndOffset(isStretched() ? offset - 20 : offset);\n          break;\n        case stringBottom:\n          setBottomOffset(offset);\n          break;\n      }\n    }\n  };\n\n  // Start drawer resize observer\n  const handleStartDrawerResize = () => {\n    rescheduleObserverHandler(handleRescheduledStartDrawerResize);\n  };\n  const handleRescheduledStartDrawerResize = () => {\n    setOffsetState(stringStart);\n    setBottomOverlayDrawerWidth();\n  };\n  useResizeObserver(startDrawerRef, handleStartDrawerResize);\n\n  // End drawer resize observer\n  const handleEndDrawerResize = () => {\n    rescheduleObserverHandler(handleRescheduledEndDrawerResize);\n  };\n  const handleRescheduledEndDrawerResize = () => {\n    setOffsetState(stringEnd);\n    setBottomOverlayDrawerWidth();\n  };\n  useResizeObserver(endDrawerRef, handleEndDrawerResize);\n\n  // Bottom drawer resize observer\n  const handleBottomDrawerResize = () => {\n    rescheduleObserverHandler(handleRescheduledBottomDrawerResize);\n  };\n  const handleRescheduledBottomDrawerResize = () => {\n    setOffsetState(stringBottom);\n  };\n  useResizeObserver(bottomDrawerRef, handleBottomDrawerResize);\n\n  const getDrawerPreviousResolvedDisplayMode = (placement: Placement) => {\n    switch (placement) {\n      case stringStart:\n        return startResolvedDisplayMode;\n      case stringEnd:\n        return endResolvedDisplayMode;\n      case stringBottom:\n        return bottomResolvedDisplayMode;\n    }\n  };\n\n  const saveResolvedDisplayMode = (placement: Placement) => {\n    const currentResolvedDisplayMode = getDrawerResolvedDisplayMode(placement);\n    if (getDrawerPreviousResolvedDisplayMode(placement) != currentResolvedDisplayMode) {\n      switch (placement) {\n        case stringStart:\n          setStartResolvedDisplayMode(currentResolvedDisplayMode);\n          break;\n        case stringEnd:\n          setEndResolvedDisplayMode(currentResolvedDisplayMode);\n          break;\n        case stringBottom:\n          setBottomResolvedDisplayMode(currentResolvedDisplayMode);\n          break;\n      }\n\n      // In case of 'reflow <> overlay' change conditional rendering of a drawer happens.\n      // The old DOM is destoryed and a new DOM is created. In this case focus gets lost.\n      // Browser moves the focus to body.\n      // We try to prevent it by eventually applying focus in the newly created DOM.\n      // If at least one drawer is open, we will check whether focus lives whithin.\n      // See the following method for more details.\n      triggerFocusTransferStrategy();\n    }\n  };\n\n  const getReflowOrOverlayDrawer = (placement: Placement) => {\n    const shiftOptions: ShiftOptions = {\n      mainAxis: false,\n      crossAxis: false\n    };\n\n    const flipOptions = {\n      mainAxis: false,\n      crossAxis: false\n    };\n\n    // Save resolved display mode of a drawer so that we can compare it with 'next' value\n    saveResolvedDisplayMode(placement);\n\n    // Reflow vs. overlay drawer\n    if (isOverlay(placement)) {\n      setDrawerSize(placement);\n\n      // Initial offset\n      if (!getOffsetState(placement)) {\n        setOffsetState(placement);\n      }\n\n      return (\n        // Reconciliation issue. Reparented node must\n        // be a single child of a <div>\n        <div>\n          <Layer>\n            <Floating\n              anchorRef={placement === stringBottom ? centerRef : rootRef}\n              placement={placement}\n              class={isDrawerAnimationPending(placement) ? styles.floating : ''}\n              strategy={isStretched() && isSidePlacement(placement) ? 'fixed' : 'absolute'}\n              offsetValue={getOffsetState(placement)}\n              flipOptions={flipOptions}\n              shiftOptions={shiftOptions}>\n              {renderOverlayDrawer(placement)}\n            </Floating>\n          </Layer>\n        </div>\n      );\n    } else {\n      // Reflow display mode - flex layout\n      return renderDrawer(placement);\n    }\n  };\n\n  // React calculates how your component should look and prepares the updates\n  // React applies those updates to the DOM, making the changes ready for display\n  //   useLayoutEffect hook runs right after the DOM is updated but before the screen shows anything. it lets you make adjustments here that will be applied before the screen updates\n  // the browser then paints the updated content to the screen\n  // useEffect hook runs after the screen updates, so any changes here will cause another re-render but only after the user has already seen the initial update\n\n  // Render drawer conditionally\n  const getDrawer = (placement: Placement): any => {\n    const isMounted = getDrawerStatus(placement) !== stringUnmounted;\n    return isMounted ? getReflowOrOverlayDrawer(placement) : null;\n  };\n\n  return (\n    <div ref={rootRef} className={classes} {...testIdProps}>\n      {/*Start drawer*/}\n      {getDrawer(stringStart)}\n      {/*Center section*/}\n      <div ref={centerRef} className={styles.centerSection}>\n        <div className={styles.mainContent}>\n          {/*<main content*/}\n          {children}\n        </div>\n        {/*Bottom drawer*/}\n        {getDrawer(stringBottom)}\n      </div>\n      {/*End drawer*/}\n      {getDrawer(stringEnd)}\n    </div>\n  );\n};\n"],"names":["useState","useBreakpointValues","useRef","useCallback","getActiveElement","allTabbableElements","useEffect","focusOn","focusWithin","useUser","normalizePosition","DURATION_LARGE","getAutofocusFocusables","focusOnElementOrNearestAncestor","useAnimation","useTestId","useLayoutEffect","useComponentTheme","DrawerLayoutRedwoodTheme","classNames","_jsx","clientHints","getClientHints","useResizeObserver","Layer","Floating","_jsxs"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+HA;;;;AAIG;AACU,MAAA,YAAY,GAAG,CAAC,EAC3B,QAAQ,EACR,WAAW,EACX,SAAS,EACT,YAAY,EACZ,WAAW,GAAG,KAAK,EACnB,SAAS,GAAG,KAAK,EACjB,YAAY,GAAG,KAAK,EACpB,YAAY,EACZ,UAAU,EACV,aAAa,EACb,OAAO,EACP,eAAe,EACf,MAAM;AACA,EAAA,KAAI;;IAEV,MAAM,MAAM,GAAG,KAAK,CAAC;IACrB,MAAM,kBAAkB,GAAG,GAAG,CAAC;IAC/B,MAAM,WAAW,GAAG,OAAO,CAAC;IAC5B,MAAM,SAAS,GAAG,KAAK,CAAC;IACxB,MAAM,YAAY,GAAG,QAAQ,CAAC;IAC9B,MAAM,aAAa,GAAG,SAAS,CAAC;IAChC,MAAM,aAAa,GAAG,SAAS,CAAC;IAChC,MAAM,UAAU,GAAG,MAAM,CAAC;IAC1B,MAAM,aAAa,GAAG,SAAS,CAAC;IAChC,MAAM,eAAe,GAAG,WAAW,CAAC;IACpC,MAAM,iBAAiB,GAAG,cAAc,CAAC;IACzC,MAAM,aAAa,GAAG,SAAS,CAAC;IAChC,MAAM,YAAY,GAAG,QAAQ,CAAC;IAC9B,MAAM,YAAY,GAAG,QAAQ,CAAC;IAC9B,MAAM,aAAa,GAAG,SAAS,CAAC;;AAGhC,IAAA,MAAM,CAAC,iBAAiB,EAAE,oBAAoB,CAAC,GAAGA,cAAQ,CACxD,WAAW,GAAG,aAAa,GAAG,eAAe,CAC9C,CAAC;AACF,IAAA,MAAM,CAAC,eAAe,EAAE,kBAAkB,CAAC,GAAGA,cAAQ,CACpD,SAAS,GAAG,aAAa,GAAG,eAAe,CAC5C,CAAC;AACF,IAAA,MAAM,CAAC,kBAAkB,EAAE,qBAAqB,CAAC,GAAGA,cAAQ,CAC1D,YAAY,GAAG,aAAa,GAAG,eAAe,CAC/C,CAAC;IACF,MAAM,CAAC,eAAe,EAAE,kBAAkB,CAAC,GAAGA,cAAQ,CAAa,YAAY,CAAC,CAAC;IACjF,MAAM,CAAC,aAAa,EAAE,gBAAgB,CAAC,GAAGA,cAAQ,CAAa,YAAY,CAAC,CAAC;IAC7E,MAAM,CAAC,gBAAgB,EAAE,mBAAmB,CAAC,GAAGA,cAAQ,CAAa,YAAY,CAAC,CAAC;IAEnF,MAAM,CAAC,WAAW,EAAE,cAAc,CAAC,GAAGA,cAAQ,EAAU,CAAC;IACzD,MAAM,CAAC,SAAS,EAAE,YAAY,CAAC,GAAGA,cAAQ,EAAU,CAAC;IACrD,MAAM,CAAC,YAAY,EAAE,eAAe,CAAC,GAAGA,cAAQ,EAAU,CAAC;;;;;IAM3D,MAAM,WAAW,GAAwBC,uCAAmB,CAAC;AAC3D,QAAA,EAAE,EAAE,iBAAiB;AACrB,QAAA,EAAE,EAAE,aAAa;AACjB,QAAA,EAAE,EAAE,YAAY;AACjB,KAAA,CAAC,CAAC;IACH,MAAM,CAAC,6BAA6B,EAAE,gCAAgC,CAAC,GACrED,cAAQ,CAAsB,WAAW,CAAC,CAAC;IAC7C,MAAM,CAAC,2BAA2B,EAAE,8BAA8B,CAAC,GACjEA,cAAQ,CAAsB,WAAW,CAAC,CAAC;;AAG7C,IAAA,MAAM,OAAO,GAAGE,YAAM,CAAiB,IAAI,CAAC,CAAC;AAC7C,IAAA,MAAM,SAAS,GAAGA,YAAM,CAAiB,IAAI,CAAC,CAAC;AAC/C,IAAA,MAAM,cAAc,GAAGA,YAAM,CAAiB,IAAI,CAAC,CAAC;AACpD,IAAA,MAAM,YAAY,GAAGA,YAAM,CAAiB,IAAI,CAAC,CAAC;AAClD,IAAA,MAAM,eAAe,GAAGA,YAAM,CAAiB,IAAI,CAAC,CAAC;AACrD,IAAA,MAAM,2BAA2B,GAAGA,YAAM,CAAmB,IAAI,CAAC,CAAC;AACnE,IAAA,MAAM,uBAAuB,GAAGA,YAAM,CAAgB,IAAI,CAAC,CAAC;AAC5D,IAAA,MAAM,2BAA2B,GAAGA,YAAM,CAAiB,IAAI,CAAC,CAAC;AAEjE,IAAA,MAAM,gBAAgB,GAAGA,YAAM,CAAqB,IAAI,CAAC,CAAC;AAC1D,IAAA,MAAM,cAAc,GAAGA,YAAM,CAAqB,IAAI,CAAC,CAAC;AACxD,IAAA,MAAM,iBAAiB,GAAGA,YAAM,CAAqB,IAAI,CAAC,CAAC;AAC3D,IAAA,MAAM,qCAAqC,GAAGA,YAAM,CAAqB,IAAI,CAAC,CAAC;IAE/E,MAAM,CAAC,wBAAwB,EAAE,2BAA2B,CAAC,GAC3DF,cAAQ,CAA6B,IAAI,CAAC,CAAC;IAC7C,MAAM,CAAC,sBAAsB,EAAE,yBAAyB,CAAC,GAAGA,cAAQ,CAClE,IAAI,CACL,CAAC;IACF,MAAM,CAAC,yBAAyB,EAAE,4BAA4B,CAAC,GAC7DA,cAAQ,CAA6B,IAAI,CAAC,CAAC;AAE7C,IAAA,MAAM,WAAW,GAAGG,iBAAW,CAAC,CAAC,SAAoB,KAAI;AACvD,QAAA,OAAO,YAAY,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC;KACxC,EAAE,EAAE,CAAC,CAAC;AAEP,IAAA,MAAM,6BAA6B,GAAGA,iBAAW,CAAC,MAAK;AACrD,QAAA,MAAM,aAAa,GAAG,WAAW,CAAC,WAAW,CAAC,CAAC;AAC/C,QAAA,MAAM,WAAW,GAAG,WAAW,CAAC,SAAS,CAAC,CAAC;AAC3C,QAAA,MAAM,cAAc,GAAG,WAAW,CAAC,YAAY,CAAC,CAAC;AACjD,QAAA,MAAM,aAAa,GAAGC,8BAAgB,EAAE,CAAC;QACzC,IAAI,aAAa,IAAI,aAAa,CAAC,QAAQ,CAAC,aAAa,CAAC,EAAE;AAC1D,YAAA,OAAO,WAAW,CAAC;SACpB;aAAM,IAAI,WAAW,IAAI,WAAW,CAAC,QAAQ,CAAC,aAAa,CAAC,EAAE;AAC7D,YAAA,OAAO,SAAS,CAAC;SAClB;aAAM,IAAI,cAAc,IAAI,cAAc,CAAC,QAAQ,CAAC,aAAa,CAAC,EAAE;AACnE,YAAA,OAAO,YAAY,CAAC;SACrB;;AAAM,YAAA,OAAO,IAAI,CAAC;AACrB,KAAC,EAAE,CAAC,WAAW,CAAC,CAAC,CAAC;AAElB,IAAA,MAAM,4BAA4B,GAAGD,iBAAW,CAAC,MAAW;;;;;;;;;;;;;;AAiB1D,QAAA,IAAI,WAAW,IAAI,SAAS,IAAI,YAAY,EAAE;;;;;;AAO5C,YAAA,MAAM,sBAAsB,GAAG,6BAA6B,EAAE,CAAC;YAC/D,IAAI,sBAAsB,EAAE;;AAE1B,gBAAA,2BAA2B,CAAC,OAAO,GAAG,sBAAsB,CAAC;;;AAI7D,gBAAA,MAAM,YAAY,GAAGE,iCAAmB,CACtC,YAAY,CAAC,2BAA2B,CAAC,OAAO,CAAC,CAAC,OAAyB,EAC3E,IAAI,CACL,CAAC;;gBAEF,uBAAuB,CAAC,OAAO,GAAG,YAAY,CAAC,OAAO,CAACD,8BAAgB,EAAiB,CAAC,CAAC;aAC3F;SACF;KACF,EAAE,CAAC,6BAA6B,EAAE,WAAW,EAAE,YAAY,EAAE,SAAS,CAAC,CAAC,CAAC;AAE1E,IAAA,MAAM,YAAY,GAAGD,iBAAW,CAC9B,CAAC,SAAoB,KAAa;QAChC,IAAI,MAAM,GAAG,KAAK,CAAC;QACnB,QAAQ,SAAS;AACf,YAAA,KAAK,WAAW;gBACd,MAAM,GAAG,WAAW,CAAC;gBACrB,MAAM;AACR,YAAA,KAAK,SAAS;gBACZ,MAAM,GAAG,SAAS,CAAC;gBACnB,MAAM;AACR,YAAA,KAAK,YAAY;gBACf,MAAM,GAAG,YAAY,CAAC;gBACtB,MAAM;SACT;AACD,QAAA,OAAO,MAAM,CAAC;KACf,EACD,CAAC,WAAW,EAAE,SAAS,EAAE,YAAY,CAAC,CACvC,CAAC;IAEFG,eAAS,CAAC,MAAW;;;;;;;;AAQnB,QAAA,MAAM,8BAA8B,GAAG,2BAA2B,CAAC,OAAO,CAAC;QAC3E,IAAI,8BAA8B,EAAE;AAClC,YAAA,MAAM,uBAAuB,GAAmB,YAAY,CAAC,8BAA8B,CAAC,CAAC;YAE7F,IAAI,uBAAuB,CAAC,OAAO,IAAI,YAAY,CAAC,8BAA8B,CAAC,EAAE;;gBAEnF,MAAM,YAAY,GAAGD,iCAAmB,CAAC,uBAAuB,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;;;;AAKhF,gBAAA,IACE,uBAAuB,CAAC,OAAO,IAAI,IAAI;AACvC,oBAAA,YAAY,CAAC,MAAM,GAAG,uBAAuB,CAAC,OAAO,EACrD;;oBAEAE,qBAAO,CAAC,YAAY,CAAC,uBAAuB,CAAC,OAAO,CAAC,CAAC,CAAC;iBACxD;qBAAM;;AAEL,oBAAAC,yBAAW,CAAC,uBAAuB,CAAC,OAAO,CAAC,CAAC;iBAC9C;;AAGD,gBAAA,2BAA2B,CAAC,OAAO,GAAG,IAAI,CAAC;AAC3C,gBAAA,uBAAuB,CAAC,OAAO,GAAG,IAAI,CAAC;aACxC;SACF;KACF,EAAE,CAAC,wBAAwB,EAAE,sBAAsB,EAAE,yBAAyB,EAAE,YAAY,CAAC,CAAC,CAAC;IAEhGF,eAAS,CAAC,MAAK;;AAEb,QAAA,4BAA4B,EAAE,CAAC;;QAE/B,UAAU,CAAC,MAAW;YACpB,gCAAgC,CAAC,WAAW,CAAC,CAAC;SAC/C,EAAE,CAAC,CAAC,CAAC;AACR,KAAC,EAAE,CAAC,WAAW,EAAE,4BAA4B,CAAC,CAAC,CAAC;AAEhD,IAAA,MAAM,gBAAgB,GAAG,CAAC,OAAuB,KAAY;AAC3D,QAAA,OAAO,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC;AACxD,KAAC,CAAC;AAEF,IAAA,MAAM,kBAAkB,GAAGH,iBAAW,CAAC,CAAC,OAAuB,KAAY;AACzE,QAAA,OAAO,GAAG,gBAAgB,CAAC,OAAO,CAAC,IAAI,CAAC;KACzC,EAAE,EAAE,CAAC,CAAC;AAEP,IAAA,MAAM,eAAe,GAAGA,iBAAW,CAAC,CAAC,OAAuB,KAAY;AACtE,QAAA,OAAO,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,qBAAqB,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;KACxE,EAAE,EAAE,CAAC,CAAC;AAEP,IAAA,MAAM,iBAAiB,GAAGA,iBAAW,CACnC,CAAC,OAAuB,KAAY;AAClC,QAAA,OAAO,GAAG,eAAe,CAAC,OAAO,CAAC,IAAI,CAAC;AACzC,KAAC,EACD,CAAC,eAAe,CAAC,CAClB,CAAC;;AAGF,IAAA,MAAM,EAAE,SAAS,EAAE,GAAGM,eAAO,EAAE,CAAC;AAChC,IAAA,MAAM,KAAK,GAAG,SAAS,KAAK,KAAK,CAAC;AAElC,IAAA,MAAM,sBAAsB,GAAGN,iBAAW,CACxC,CAAC,SAAoB,KAAa;AAChC,QAAA,OAAOO,+BAAiB,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;AACjD,KAAC,EACD,CAAC,SAAS,CAAC,CACZ,CAAC;AAEF,IAAA,MAAM,eAAe,GAAG,CAAC,SAAoB,KAAa;AACxD,QAAA,OAAO,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;AAC1D,KAAC,CAAC;AAEF,IAAA,MAAM,iBAAiB,GAAG,CAAC,SAAoB,KAAa;QAC1D,OAAO,SAAS,KAAK,YAAY,CAAC;AACpC,KAAC,CAAC;AAEF,IAAA,MAAM,kBAAkB,GAAG,CAAC,MAAc,KAAa;AACrD,QAAA,OAAO,CAAC,aAAa,EAAE,aAAa,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;AAC7D,KAAC,CAAC;AAEF,IAAA,MAAM,wBAAwB,GAAG,CAAC,SAAoB,KAAa;QACjE,QAAQ,SAAS;AACf,YAAA,KAAK,WAAW;AACd,gBAAA,OAAO,kBAAkB,CAAC,iBAAiB,CAAC,CAAC;AAC/C,YAAA,KAAK,SAAS;AACZ,gBAAA,OAAO,kBAAkB,CAAC,eAAe,CAAC,CAAC;AAC7C,YAAA,KAAK,YAAY;AACf,gBAAA,OAAO,kBAAkB,CAAC,kBAAkB,CAAC,CAAC;SACjD;AACH,KAAC,CAAC;AAEF,IAAA,MAAM,mBAAmB,GAAG,CAAC,SAAoB,KAAgB;QAC/D,QAAQ,SAAS;AACf,YAAA,KAAK,WAAW;AACd,gBAAA,OAAO,eAAe,CAAC;AACzB,YAAA,KAAK,SAAS;AACZ,gBAAA,OAAO,aAAa,CAAC;AACvB,YAAA,KAAK,YAAY;AACf,gBAAA,OAAO,gBAAgB,CAAC;SAC3B;AACH,KAAC,CAAC;AAEF,IAAA,MAAM,mBAAmB,GAAG,CAAC,SAAoB,EAAE,UAAsB,KAAU;QACjF,QAAQ,SAAS;AACf,YAAA,KAAK,WAAW;AACd,gBAAA,OAAO,kBAAkB,CAAC,UAAU,CAAC,CAAC;AACxC,YAAA,KAAK,SAAS;AACZ,gBAAA,OAAO,gBAAgB,CAAC,UAAU,CAAC,CAAC;AACtC,YAAA,KAAK,YAAY;AACf,gBAAA,OAAO,mBAAmB,CAAC,UAAU,CAAC,CAAC;SAC1C;AACH,KAAC,CAAC;AAEF,IAAA,MAAM,YAAY,GAAG,CAAC,SAAoB,KAAI;QAC5C,QAAQ,SAAS;AACf,YAAA,KAAK,WAAW;AACd,gBAAA,OAAO,cAAc,CAAC;AACxB,YAAA,KAAK,SAAS;AACZ,gBAAA,OAAO,YAAY,CAAC;AACtB,YAAA,KAAK,YAAY;AACf,gBAAA,OAAO,eAAe,CAAC;SAC1B;AACH,KAAC,CAAC;AAEF,IAAA,MAAM,kBAAkB,GAAG,CAAC,SAAoB,KAAI;QAClD,QAAQ,SAAS;AACf,YAAA,KAAK,WAAW;AACd,gBAAA,OAAO,oBAAoB,CAAC;AAC9B,YAAA,KAAK,SAAS;AACZ,gBAAA,OAAO,kBAAkB,CAAC;AAC5B,YAAA,KAAK,YAAY;AACf,gBAAA,OAAO,qBAAqB,CAAC;SAChC;AACH,KAAC,CAAC;AAEF,IAAA,MAAM,eAAe,GAAG,CAAC,SAAoB,KAAI;QAC/C,QAAQ,SAAS;AACf,YAAA,KAAK,WAAW;AACd,gBAAA,OAAO,iBAAiB,CAAC;AAC3B,YAAA,KAAK,SAAS;AACZ,gBAAA,OAAO,eAAe,CAAC;AACzB,YAAA,KAAK,YAAY;AACf,gBAAA,OAAO,kBAAkB,CAAC;SAC7B;AACH,KAAC,CAAC;AAEF,IAAA,MAAM,eAAe,GAAG,CAAC,SAAoB,EAAE,MAAc,KAAU;QACrE,QAAQ,SAAS;AACf,YAAA,KAAK,WAAW;gBACd,oBAAoB,CAAC,MAAM,CAAC,CAAC;gBAC7B,MAAM;AACR,YAAA,KAAK,SAAS;gBACZ,kBAAkB,CAAC,MAAM,CAAC,CAAC;gBAC3B,MAAM;AACR,YAAA,KAAK,YAAY;gBACf,qBAAqB,CAAC,MAAM,CAAC,CAAC;gBAC9B,MAAM;SACT;AACH,KAAC,CAAC;AAEF,IAAA,MAAM,oBAAoB,GAAG,CAAC,SAAoB,KAAU;QAC1D,QAAQ,SAAS;AACf,YAAA,KAAK,WAAW;gBACd,oBAAoB,CAAC,IAAI,CAAC,CAAC;gBAC3B,MAAM;AACR,YAAA,KAAK,SAAS;gBACZ,kBAAkB,CAAC,IAAI,CAAC,CAAC;gBACzB,MAAM;AACR,YAAA,KAAK,YAAY;gBACf,qBAAqB,CAAC,IAAI,CAAC,CAAC;gBAC5B,MAAM;SACT;AACH,KAAC,CAAC;AAEF,IAAA,MAAM,oBAAoB,GAAGP,iBAAW,CACtC,CAAC,SAAoB,KAAI;QACvB,QAAQ,SAAS;AACf,YAAA,KAAK,WAAW;AACd,gBAAA,OAAO,YAAY,CAAC;AACtB,YAAA,KAAK,SAAS;AACZ,gBAAA,OAAO,UAAU,CAAC;AACpB,YAAA,KAAK,YAAY;AACf,gBAAA,OAAO,aAAa,CAAC;SACxB;KACF,EACD,CAAC,YAAY,EAAE,UAAU,EAAE,aAAa,CAAC,CAC1C,CAAC;AAEF,IAAA,MAAM,4BAA4B,GAAGA,iBAAW,CAC9C,CAAC,SAAoB,KAAI;AACvB,QAAA,MAAM,WAAW,GAAG,oBAAoB,CAAC,SAAS,CAAC,CAAC;QACpD,IAAI,WAAW,EAAE;AACf,YAAA,OAAO,WAAW,CAAC;SACpB;aAAM;AACL,YAAA,IAAI,eAAe,CAAC,SAAS,CAAC,EAAE;AAC9B,gBAAA,OAAO,6BAA6B,CAAC;aACtC;AACD,YAAA,OAAO,2BAA2B,CAAC;SACpC;KACF,EACD,CAAC,oBAAoB,EAAE,6BAA6B,EAAE,2BAA2B,CAAC,CACnF,CAAC;;AAGF,IAAA,MAAM,kBAAkB,GAAG,CAAC,GAA2B,KAAI;QACzD,OAAO;AACL,YAAA,gBAAgB,EAAE;AAChB,gBAAA,IAAI,EAAE;AACJ,oBAAA,SAAS,EAAE,MAAM;AAClB,iBAAA;AACD,gBAAA,EAAE,EAAE;AACF,oBAAA,SAAS,EAAE,MAAM;AAClB,iBAAA;AACD,gBAAA,OAAO,EAAE;AACP,oBAAA,QAAQ,EAAEQ,6BAAc;AACzB,iBAAA;AACF,aAAA;AACD,YAAA,kBAAkB,EAAE;AAClB,gBAAA,IAAI,EAAE;AACJ,oBAAA,SAAS,EAAE,MAAM;AAClB,iBAAA;AACD,gBAAA,EAAE,EAAE;AACF,oBAAA,SAAS,EAAE,MAAM;AAClB,iBAAA;AACD,gBAAA,OAAO,EAAE;AACP,oBAAA,QAAQ,EAAEA,6BAAc;AACzB,iBAAA;AACF,aAAA;YACD,kBAAkB,EAAE,MAAK;gBACvB,OAAO;AACL,oBAAA,IAAI,EAAE;AACJ,wBAAA,QAAQ,EAAE,MAAM;AACjB,qBAAA;AACD,oBAAA,EAAE,EAAE;;;AAGF,wBAAA,QAAQ,EAAE,iBAAiB,CAAC,GAAG,CAAC,OAAyB,CAAC;AAC3D,qBAAA;AACD,oBAAA,OAAO,EAAE;AACP,wBAAA,QAAQ,EAAEA,6BAAc;AACzB,qBAAA;iBACF,CAAC;aACH;YACD,oBAAoB,EAAE,MAAK;gBACzB,OAAO;AACL,oBAAA,IAAI,EAAE;;;AAGJ,wBAAA,QAAQ,EAAE,iBAAiB,CAAC,GAAG,CAAC,OAAyB,CAAC;AAC3D,qBAAA;AACD,oBAAA,EAAE,EAAE;AACF,wBAAA,QAAQ,EAAE,MAAM;AACjB,qBAAA;AACD,oBAAA,OAAO,EAAE;AACP,wBAAA,QAAQ,EAAEA,6BAAc;AACzB,qBAAA;iBACF,CAAC;aACH;AACD,YAAA,OAAO,EAAE;AACP,gBAAA,IAAI,EAAE;;;AAGJ,oBAAA,UAAU,EAAE,MAAM;AACnB,iBAAA;AACD,gBAAA,EAAE,EAAE;AACF,oBAAA,UAAU,EAAE,MAAM;AACnB,iBAAA;AACD,gBAAA,OAAO,EAAE;AACP,oBAAA,QAAQ,EAAEA,6BAAc;AACzB,iBAAA;AACF,aAAA;AACD,YAAA,SAAS,EAAE;AACT,gBAAA,IAAI,EAAE;AACJ,oBAAA,UAAU,EAAE,MAAM;AACnB,iBAAA;AACD,gBAAA,EAAE,EAAE;AACF,oBAAA,UAAU,EAAE,MAAM;AACnB,iBAAA;AACD,gBAAA,OAAO,EAAE;AACP,oBAAA,QAAQ,EAAEA,6BAAc;AACzB,iBAAA;AACF,aAAA;AACD,YAAA,aAAa,EAAE;AACb,gBAAA,IAAI,EAAE;AACJ,oBAAA,UAAU,EAAE,OAAO;AACpB,iBAAA;AACD,gBAAA,EAAE,EAAE;AACF,oBAAA,UAAU,EAAE,MAAM;AACnB,iBAAA;AACD,gBAAA,OAAO,EAAE;AACP,oBAAA,QAAQ,EAAEA,6BAAc;AACzB,iBAAA;AACF,aAAA;AACD,YAAA,cAAc,EAAE;AACd,gBAAA,IAAI,EAAE;AACJ,oBAAA,UAAU,EAAE,GAAG;AAChB,iBAAA;AACD,gBAAA,EAAE,EAAE;AACF,oBAAA,UAAU,EAAE,OAAO;AACpB,iBAAA;AACD,gBAAA,OAAO,EAAE;AACP,oBAAA,QAAQ,EAAEA,6BAAc;AACzB,iBAAA;AACF,aAAA;AACD,YAAA,cAAc,EAAE;AACd,gBAAA,IAAI,EAAE;AACJ,oBAAA,UAAU,EAAE,MAAM;AACnB,iBAAA;AACD,gBAAA,EAAE,EAAE;AACF,oBAAA,UAAU,EAAE,MAAM;AACnB,iBAAA;AACD,gBAAA,OAAO,EAAE;AACP,oBAAA,QAAQ,EAAEA,6BAAc;AACzB,iBAAA;AACF,aAAA;AACD,YAAA,eAAe,EAAE;AACf,gBAAA,IAAI,EAAE;AACJ,oBAAA,UAAU,EAAE,GAAG;AAChB,iBAAA;AACD,gBAAA,EAAE,EAAE;AACF,oBAAA,UAAU,EAAE,MAAM;AACnB,iBAAA;AACD,gBAAA,OAAO,EAAE;AACP,oBAAA,QAAQ,EAAEA,6BAAc;AACzB,iBAAA;AACF,aAAA;SACF,CAAC;AACJ,KAAC,CAAC;AAEF,IAAA,MAAM,2BAA2B,GAAG,CAAC,SAAoB,KAAU;;AAEjE,QAAA,MAAM,SAAS,GAAmB,YAAY,CAAC,SAAS,CAAC,CAAC;AAC1D,QAAA,SAAS,CAAC,OAAO,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC;AAC7C,KAAC,CAAC;AAEF,IAAA,MAAM,eAAe,GAAG,CAAC,SAAoB,KAAU;;AAErD,QAAA,MAAM,SAAS,GAAmB,YAAY,CAAC,SAAS,CAAC,CAAC;;QAG1D,MAAM,cAAc,GAAkBC,oCAAsB,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;AAChF,QAAA,IAAI,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE;AAC7B,YAAAL,qBAAO,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;YAC3B,OAAO;SACR;;;AAGD,QAAAC,yBAAW,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;AACjC,KAAC,CAAC;AAEF,IAAA,MAAM,cAAc,GAAG,CAAC,SAAoB,KAAI;QAC9C,QAAQ,SAAS;AACf,YAAA,KAAK,WAAW;AACd,gBAAA,OAAO,gBAAgB,CAAC;AAC1B,YAAA,KAAK,SAAS;AACZ,gBAAA,OAAO,cAAc,CAAC;AACxB,YAAA,KAAK,YAAY;AACf,gBAAA,OAAO,iBAAiB,CAAC;SAC5B;AACH,KAAC,CAAC;AAEF,IAAA,MAAM,qBAAqB,GAAG,CAAC,SAAoB,KAAU;;;;;AAK3D,QAAA,IAAI,YAAY,CAAC,SAAS,CAAC,CAAC,OAAO,EAAE,QAAQ,CAAC,qCAAqC,CAAC,OAAO,CAAC,EAAE;YAC5FK,6CAA+B,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC,OAAsB,CAAC,CAAC;SACnF;AACH,KAAC,CAAC;;AAGF,IAAA,MAAM,kBAAkB,GAAG,CAAC,SAAoB,KAAI;AAClD,QAAA,MAAM,eAAe,GAAG,iBAAiB,CAAC,SAAS,CAAC,CAAC;AACrD,QAAA,MAAM,MAAM,GAAG,eAAe,CAAC,SAAS,CAAC,CAAC;AAC1C,QAAA,IAAI,4BAA4B,CAAC,SAAS,CAAC,KAAK,YAAY,EAAE;;;YAG5D,IAAI,eAAe,EAAE;;;;;AAKnB,gBAAA,IAAI,MAAM,KAAK,SAAS,EAAE;AACxB,oBAAA,OAAO,kBAAkB,CAAC;iBAC3B;AACD,gBAAA,IAAI,MAAM,KAAK,SAAS,EAAE;AACxB,oBAAA,OAAO,oBAAoB,CAAC;iBAC7B;AACD,gBAAA,OAAO,EAAE,CAAC;aACX;iBAAM;AACL,gBAAA,IAAI,MAAM,KAAK,SAAS,EAAE;AACxB,oBAAA,OAAO,oBAAoB,CAAC;iBAC7B;AACD,gBAAA,IAAI,MAAM,KAAK,SAAS,EAAE;AACxB,oBAAA,OAAO,sBAAsB,CAAC;iBAC/B;AACD,gBAAA,OAAO,EAAE,CAAC;aACX;SACF;aAAM;;;YAGL,IAAI,eAAe,EAAE;AACnB,gBAAA,IAAI,MAAM,KAAK,SAAS,EAAE;AACxB,oBAAA,OAAO,SAAS,CAAC;iBAClB;AACD,gBAAA,IAAI,MAAM,KAAK,SAAS,EAAE;AACxB,oBAAA,OAAO,WAAW,CAAC;iBACpB;AACD,gBAAA,OAAO,EAAE,CAAC;aACX;iBAAM;AACL,gBAAA,IAAI,MAAM,KAAK,SAAS,EAAE;AACxB,oBAAA,OAAO,sBAAsB,CAAC,SAAS,CAAC,KAAK,MAAM,GAAG,eAAe,GAAG,gBAAgB,CAAC;iBAC1F;AACD,gBAAA,IAAI,MAAM,KAAK,SAAS,EAAE;AACxB,oBAAA,OAAO,sBAAsB,CAAC,SAAS,CAAC,KAAK,MAAM;AACjD,0BAAE,gBAAgB;0BAChB,iBAAiB,CAAC;iBACvB;AACD,gBAAA,OAAO,EAAE,CAAC;aACX;SACF;AACH,KAAC,CAAC;;;AAIF,IAAA,SAAS,UAAU,CAAC,SAAoB,EAAE,GAA2B,EAAA;AACnE,QAAA,MAAM,MAAM,GAAY,YAAY,CAAC,SAAS,CAAC,CAAC;AAChD,QAAA,MAAM,MAAM,GAAG,eAAe,CAAC,SAAS,CAAC,CAAC;AAC1C,QAAA,OAAOC,yBAAY,CAAkC,kBAAkB,CAAC,SAAS,CAAC,EAAE;AAClF,YAAA,eAAe,EAAE,kBAAkB,CAAC,GAAG,CAAC;AACxC,YAAA,iBAAiB,EAAE,IAAI;YACvB,cAAc,EAAE,MAAK;AACnB,gBAAA,IAAI,MAAM,KAAK,aAAa,EAAE;AAC5B,oBAAA,IAAI,SAAS,CAAC,SAAS,CAAC,EAAE;wBACxB,eAAe,CAAC,SAAS,CAAC,CAAC;qBAC5B;;oBAED,2BAA2B,CAAC,SAAS,CAAC,CAAC;;;;;;;;;;oBAWvC,oBAAoB,CAAC,SAAS,CAAC,CAAC;AAEhC,oBAAA,eAAe,CAAC,SAAS,EAAE,UAAU,CAAC,CAAC;AACvC,oBAAA,eAAe,GAAG;AAChB,wBAAA,SAAS,EAAE,SAAS;AACpB,wBAAA,KAAK,EAAE,IAAI;AACZ,qBAAA,CAAC,CAAC;iBACJ;qBAAM,IAAI,CAAC,MAAM,EAAE;AAClB,oBAAA,IAAI,SAAS,CAAC,SAAS,CAAC,EAAE;wBACxB,qBAAqB,CAAC,SAAS,CAAC,CAAC;qBAClC;oBACD,oBAAoB,CAAC,SAAS,CAAC,CAAC;AAChC,oBAAA,mBAAmB,CAAC,SAAS,EAAE,YAAY,CAAC,CAAC;AAC7C,oBAAA,eAAe,CAAC,SAAS,EAAE,eAAe,CAAC,CAAC;AAC5C,oBAAA,eAAe,GAAG;AAChB,wBAAA,SAAS,EAAE,SAAS;AACpB,wBAAA,KAAK,EAAE,KAAK;AACb,qBAAA,CAAC,CAAC;iBACJ;aACF;SACF,CAAC,CAAC,OAAO,CAAC;KACZ;;IAGD,MAAM,oBAAoB,GAAG,UAAU,CAAC,WAAW,EAAE,cAAc,CAAC,CAAC;IACrE,MAAM,kBAAkB,GAAG,UAAU,CAAC,SAAS,EAAE,YAAY,CAAC,CAAC;IAC/D,MAAM,qBAAqB,GAAG,UAAU,CAAC,YAAY,EAAE,eAAe,CAAC,CAAC;;AAGxE,IAAA,MAAM,WAAW,GAAGC,mBAAS,CAAC,MAAM,CAAC,CAAC;AAEtC,IAAA,MAAM,cAAc,GAAG,CAAC,SAAoB,KAAI;AAC9C,QAAA,MAAM,aAAa,GAAGX,8BAAgB,EAAiB,CAAC;QACxD,QAAQ,SAAS;AACf,YAAA,KAAK,WAAW;AACd,gBAAA,gBAAgB,CAAC,OAAO,GAAG,aAAa,CAAC;gBACzC,MAAM;AACR,YAAA,KAAK,SAAS;AACZ,gBAAA,cAAc,CAAC,OAAO,GAAG,aAAa,CAAC;gBACvC,MAAM;AACR,YAAA,KAAK,YAAY;AACf,gBAAA,iBAAiB,CAAC,OAAO,GAAG,aAAa,CAAC;gBAC1C,MAAM;SACT;AACH,KAAC,CAAC;;;IAIF,SAAS,eAAe,CAAC,SAAoB,EAAA;AAC3C,QAAA,MAAM,MAAM,GAAG,YAAY,CAAC,SAAS,CAAC,CAAC;AACvC,QAAA,MAAM,YAAY,GAAG,eAAe,CAAC,SAAS,CAAC,CAAC;QAEhDE,eAAS,CAAC,MAAK;;;AAGb,YAAA,IAAI,YAAY,KAAK,eAAe,IAAI,CAAC,MAAM,EAAE;gBAC/C,OAAO;aACR;;;;;;AAOD,YAAA,IAAI,YAAY,KAAK,eAAe,IAAI,MAAM,EAAE;AAC9C,gBAAA,eAAe,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;gBAC1C,OAAO;aACR;;;;;;AAOD,YAAA,IAAI,YAAY,KAAK,aAAa,IAAI,MAAM,EAAE;AAC5C,gBAAA,IAAI,SAAS,CAAC,SAAS,CAAC,EAAE;AACxB,oBAAA,MAAM,SAAS,GAAG,YAAY,CAAC,SAAS,CAAC,CAAC;AAC1C,oBAAA,MAAM,eAAe,GAAG,kBAAkB,CAAC,SAAS,CAAC,CAAC;AACtD,oBAAA,eAAe,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;AACnC,oBAAA,eAAe,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;oBAC1C,OAAO;iBACR;aACF;;;AAID,YAAA,IAAI,YAAY,KAAK,aAAa,IAAI,MAAM,EAAE;AAC5C,gBAAA,IAAI,SAAS,CAAC,SAAS,CAAC,EAAE;AACxB,oBAAA,mBAAmB,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;;oBAE9C,cAAc,CAAC,SAAS,CAAC,CAAC;oBAC1B,OAAO;iBACR;aACF;;;;YAMD,IAAI,CAAC,MAAM,EAAE;;;AAGX,gBAAA,MAAM,SAAS,GAAG,YAAY,CAAC,SAAS,CAAC,CAAC;AAC1C,gBAAA,MAAM,eAAe,GAAG,kBAAkB,CAAC,SAAS,CAAC,CAAC;AACtD,gBAAA,eAAe,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;AAEnC,gBAAA,qCAAqC,CAAC,OAAO,GAAGF,8BAAgB,EAAiB,CAAC;AAClF,gBAAA,eAAe,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;aAC3C;SACF,EAAE,CAAC,MAAM,EAAE,YAAY,EAAE,SAAS,CAAC,CAAC,CAAC;;QAGtCY,qBAAe,CAAC,MAAK;;;;;;AAMnB,YAAA,IAAI,YAAY,KAAK,aAAa,IAAI,MAAM,EAAE;AAC5C,gBAAA,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,EAAE;AACzB,oBAAA,MAAM,SAAS,GAAG,YAAY,CAAC,SAAS,CAAC,CAAC;AAC1C,oBAAA,MAAM,eAAe,GAAG,kBAAkB,CAAC,SAAS,CAAC,CAAC;AACtD,oBAAA,eAAe,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;AACnC,oBAAA,eAAe,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;oBAC1C,OAAO;iBACR;aACF;;;AAID,YAAA,IAAI,YAAY,KAAK,aAAa,IAAI,MAAM,EAAE;AAC5C,gBAAA,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,EAAE;AACzB,oBAAA,mBAAmB,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;;oBAE9C,cAAc,CAAC,SAAS,CAAC,CAAC;oBAC1B,OAAO;iBACR;aACF;SACF,EAAE,CAAC,YAAY,EAAE,MAAM,EAAE,SAAS,CAAC,CAAC,CAAC;KACvC;;IAGD,eAAe,CAAC,WAAW,CAAC,CAAC;IAC7B,eAAe,CAAC,SAAS,CAAC,CAAC;IAC3B,eAAe,CAAC,YAAY,CAAC,CAAC;;AAG9B,IAAA,MAAM,kBAAkB,GAAG,CAAC,KAAY,KAAU;AAChD,QAAA,aAAa,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC;AACpC,KAAC,CAAC;AACF,IAAA,MAAM,gBAAgB,GAAG,CAAC,KAAY,KAAU;AAC9C,QAAA,aAAa,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;AAClC,KAAC,CAAC;AACF,IAAA,MAAM,mBAAmB,GAAG,CAAC,KAAY,KAAU;AACjD,QAAA,aAAa,CAAC,YAAY,EAAE,KAAK,CAAC,CAAC;AACrC,KAAC,CAAC;AAEF,IAAA,MAAM,aAAa,GAAG,CAAC,SAAoB,EAAE,KAAU,KAAU;AAC/D,QAAA,IAAI,KAAK,CAAC,IAAI,KAAK,QAAQ,EAAE;;AAE3B,YAAA,IAAI,SAAS,CAAC,SAAS,CAAC,EAAE;AACxB,gBAAA,OAAO,GAAG;oBACR,SAAS;AACT,oBAAA,MAAM,EAAE,WAAW;AACpB,iBAAA,CAAC,CAAC;aACJ;SACF;AACH,KAAC,CAAC;;IAGF,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,GAAGC,mCAAiB,CAC3CC,6EAAwB,CACzB,CAAC;AAEF,IAAA,MAAM,kBAAkB,GAAG,CAAC,UAAsB,KAAI;AACpD,QAAA,OAAO,UAAU,KAAK,YAAY,GAAG,MAAM,CAAC,gBAAgB,GAAG,MAAM,CAAC,iBAAiB,CAAC;AAC1F,KAAC,CAAC;IAEF,MAAM,WAAW,GAAG,MAAc;QAChC,OAAO,WAAW,KAAK,iBAAiB,CAAC;AAC3C,KAAC,CAAC;AAEF,IAAA,MAAM,SAAS,GAAGf,iBAAW,CAC3B,CAAC,SAAoB,KAAa;AAChC,QAAA,QACE,CAAC,iBAAiB,EAAE,aAAa,CAAC,CAAC,OAAO,CAAC,4BAA4B,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,CAAC,EACxF;AACJ,KAAC,EACD,CAAC,4BAA4B,CAAC,CAC/B,CAAC;AAEF,IAAA,MAAM,aAAa,GAAG,CAAC,SAAoB,KAAa;AACtD,QAAA,OAAO,4BAA4B,CAAC,SAAS,CAAC,KAAK,iBAAiB,CAAC;AACvE,KAAC,CAAC;AAEF,IAAA,MAAM,mBAAmB,GAAG,CAAC,SAAoB,KAAY;;AAE3D,QAAA,MAAM,UAAU,GAAe,mBAAmB,CAAC,SAAS,CAAC,CAAC;QAC9D,MAAM,aAAa,GAAa,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC,CAAC;;AAGjE,QAAA,IAAI,SAAS,CAAC,SAAS,CAAC,EAAE;AACxB,YAAA,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;YACzC,IAAI,eAAe,CAAC,SAAS,CAAC,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,EAAE;AAC3D,gBAAA,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,6BAA6B,CAAC,CAAC;aAC1D;;YAGD,IAAI,WAAW,EAAE,IAAI,eAAe,CAAC,SAAS,CAAC,EAAE;AAC/C,gBAAA,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,0BAA0B,CAAC,CAAC;aACvD;SACF;aAAM;AACL,YAAA,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;SACzC;;AAGD,QAAA,IAAI,wBAAwB,CAAC,SAAS,CAAC,EAAE;AACvC,YAAA,aAAa,CAAC,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC;SAC3C;AAED,QAAA,MAAM,0BAA0B,GAAG,CAAC,SAAoB,KAAY;YAClE,QAAQ,SAAS;AACf,gBAAA,KAAK,WAAW;AACd,oBAAA,IAAI,SAAS,CAAC,WAAW,CAAC,EAAE;AAC1B,wBAAA,OAAO,KAAK,GAAG,MAAM,CAAC,iBAAiB,GAAG,MAAM,CAAC,kBAAkB,CAAC;qBACrE;yBAAM;AACL,wBAAA,OAAO,KAAK,GAAG,MAAM,CAAC,gBAAgB,GAAG,MAAM,CAAC,iBAAiB,CAAC;qBACnE;AACH,gBAAA,KAAK,SAAS;AACZ,oBAAA,IAAI,SAAS,CAAC,SAAS,CAAC,EAAE;AACxB,wBAAA,OAAO,KAAK,GAAG,MAAM,CAAC,kBAAkB,GAAG,MAAM,CAAC,iBAAiB,CAAC;qBACrE;yBAAM;AACL,wBAAA,OAAO,KAAK,GAAG,MAAM,CAAC,iBAAiB,GAAG,MAAM,CAAC,gBAAgB,CAAC;qBACnE;AACH,gBAAA,KAAK,YAAY;AACf,oBAAA,OAAO,SAAS,CAAC,YAAY,CAAC,GAAG,MAAM,CAAC,mBAAmB,GAAG,MAAM,CAAC,kBAAkB,CAAC;aAC3F;AACH,SAAC,CAAC;;QAEF,aAAa,CAAC,IAAI,CAAC,0BAA0B,CAAC,SAAS,CAAC,CAAC,CAAC;AAE1D,QAAA,OAAOgB,qBAAU,CAAC,aAAa,CAAC,CAAC;AACnC,KAAC,CAAC;AAEF,IAAA,MAAM,aAAa,GAAG,CAAC,SAAoB,KAAI;QAC7C,QAAQ,SAAS;AACf,YAAA,KAAK,WAAW;AACd,gBAAA,OAAO,WAAW,CAAC;AACrB,YAAA,KAAK,SAAS;AACZ,gBAAA,OAAO,SAAS,CAAC;AACnB,YAAA,KAAK,YAAY;AACf,gBAAA,OAAO,YAAY,CAAC;SACvB;AACH,KAAC,CAAC;AAEF,IAAA,MAAM,iBAAiB,GAAG,CAAC,SAAoB,KAAI;QACjD,QAAQ,SAAS;AACf,YAAA,KAAK,WAAW;AACd,gBAAA,OAAO,kBAAkB,CAAC;AAC5B,YAAA,KAAK,SAAS;AACZ,gBAAA,OAAO,gBAAgB,CAAC;AAC1B,YAAA,KAAK,YAAY;AACf,gBAAA,OAAO,mBAAmB,CAAC;SAC9B;AACH,KAAC,CAAC;AAEF,IAAA,MAAM,mBAAmB,GAAG,CAAC,SAAoB,KAAI;QACnD,IAAI,WAAW,EAAE,IAAI,eAAe,CAAC,SAAS,CAAC,EAAE;AAC/C,YAAA,MAAM,kBAAkB,GAAG,CAAC,MAAM,CAAC,sCAAsC,CAAC,CAAC;YAC3E,QAAQ,SAAS;AACf,gBAAA,KAAK,WAAW;oBACd,kBAAkB,CAAC,IAAI,CACrB,KAAK;0BACD,MAAM,CAAC,0CAA0C;AACnD,0BAAE,MAAM,CAAC,2CAA2C,CACvD,CAAC;oBACF,MAAM;AACR,gBAAA,KAAK,SAAS;oBACZ,kBAAkB,CAAC,IAAI,CACrB,KAAK;0BACD,MAAM,CAAC,2CAA2C;AACpD,0BAAE,MAAM,CAAC,0CAA0C,CACtD,CAAC;oBACF,MAAM;aACT;;AAGD,YAAA,QACEC,cAAK,CAAA,KAAA,EAAA,EAAA,GAAG,EAAE,2BAA2B,EAAE,SAAS,EAAED,qBAAU,CAAC,kBAAkB,CAAC,YAC7E,YAAY,CAAC,SAAS,CAAC,EAAA,CACpB,EACN;SACH;aAAM;;AAEL,YAAA,OAAO,YAAY,CAAC,SAAS,CAAC,CAAC;SAChC;AACH,KAAC,CAAC;;AAGF,IAAA,MAAM,YAAY,GAAG,CAAC,SAAoB,KAAI;QAC5C,QACEC,wBACE,GAAG,EAAE,YAAY,CAAC,SAAS,CAAC,EAC5B,SAAS,EAAE,mBAAmB,CAAC,SAAS,CAAC,EACzC,QAAQ,EAAE,SAAS,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS,EAC/C,SAAS,EAAE,iBAAiB,CAAC,SAAS,CAAC,EACtC,QAAA,EAAA,aAAa,CAAC,SAAS,CAAC,EACrB,CAAA,EACN;AACJ,KAAC,CAAC;AAEF,IAAA,MAAMC,aAAW,GAAGC,0BAAc,EAAE,CAAC;AAErC,IAAA,MAAM,iBAAiB,GAAGnB,iBAAW,CAAC,MAAa;AACjD,QAAA,IAAIkB,aAAW,CAAC,QAAQ,KAAK,KAAK,EAAE;;AAElC,YAAA,OAAO,QAAQ,CAAC,eAAe,CAAC,YAAY,CAAC;SAC9C;QACD,OAAO,MAAM,CAAC,WAAW,CAAC;AAC5B,KAAC,EAAE,CAACA,aAAW,CAAC,QAAQ,CAAC,CAAC,CAAC;;;;;;;;AAS3B,IAAA,MAAM,yBAAyB,GAAG,CAAC,QAAa,KAAI;QAClD,UAAU,CAAC,MAAK;AACd,YAAA,QAAQ,EAAE,CAAC;SACZ,EAAE,CAAC,CAAC,CAAC;AACR,KAAC,CAAC;AAEF,IAAA,MAAM,+BAA+B,GAAGlB,iBAAW,CAAC,MAAK;AACvD,QAAA,MAAM,cAAc,GAAG,iBAAiB,EAAE,CAAC;AAC3C,QAAA,IAAI,cAAc,IAAI,kBAAkB,EAAE;AACxC,YAAA,IAAI,2BAA2B,IAAI,YAAY,EAAE;AAC/C,gBAAA,4BAA4B,EAAE,CAAC;gBAC/B,8BAA8B,CAAC,YAAY,CAAC,CAAC;aAC9C;SACF;aAAM;AACL,YAAA,IAAI,2BAA2B,IAAI,aAAa,EAAE;AAChD,gBAAA,4BAA4B,EAAE,CAAC;gBAC/B,8BAA8B,CAAC,aAAa,CAAC,CAAC;aAC/C;SACF;KACF,EAAE,CAAC,2BAA2B,EAAE,iBAAiB,EAAE,4BAA4B,CAAC,CAAC,CAAC;AAEnF,IAAA,MAAM,oBAAoB,GAAGA,iBAAW,CAAC,MAAK;QAC5C,yBAAyB,CAAC,+BAA+B,CAAC,CAAC;AAC7D,KAAC,EAAE,CAAC,+BAA+B,CAAC,CAAC,CAAC;;;;;IAMtCG,eAAS,CAAC,MAAK;AACb,QAAA,MAAM,cAAc,GAAG,IAAI,cAAc,CAAC,MAAK;AAC7C,YAAA,oBAAoB,EAAE,CAAC;AACzB,SAAC,CAAC,CAAC;AACH,QAAA,cAAc,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;;AAEtC,QAAA,OAAO,MAAK;AACV,YAAA,cAAc,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;AAC1C,SAAC,CAAC;AACJ,KAAC,EAAE,CAAC,oBAAoB,CAAC,CAAC,CAAC;AAE3B,IAAA,MAAM,aAAa,GAAG,CAAC,SAAoB,KAAY;AACrD,QAAA,MAAM,QAAQ,GAAG,WAAW,CAAC,SAAS,CAAC,CAAC;QACxC,IAAI,QAAQ,EAAE;YACZ,OAAO,eAAe,CAAC,SAAS,CAAC,GAAG,CAAC,eAAe,CAAC,QAAQ,CAAC,GAAG,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;SAC9F;AACD,QAAA,OAAO,CAAC,CAAC;AACX,KAAC,CAAC;AAEF,IAAA,MAAM,cAAc,GAAG,CAAC,SAAoB,KAAI;QAC9C,QAAQ,SAAS;AACf,YAAA,KAAK,WAAW;AACd,gBAAA,OAAO,WAAW,CAAC;AACrB,YAAA,KAAK,SAAS;AACZ,gBAAA,OAAO,SAAS,CAAC;AACnB,YAAA,KAAK,YAAY;AACf,gBAAA,OAAO,YAAY,CAAC;SACvB;AACH,KAAC,CAAC;AAEF,IAAA,MAAM,0BAA0B,GAAGH,iBAAW,CAC5C,CAAC,SAAoB,KAAI;;;;QAIvB,MAAM,mBAAmB,GAAG,kBAAkB,CAAC,SAAS,CAAC,OAAyB,CAAC,CAAC;QAEpF,MAAM,QAAQ,GAAG,YAAY,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC;AACjD,QAAA,IAAI,QAAQ,IAAI,CAAC,WAAW,EAAE,IAAI,YAAY,CAAC,SAAS,CAAC,IAAI,SAAS,CAAC,SAAS,CAAC,EAAE;AACjF,YAAA,QAAQ,CAAC,KAAK,CAAC,MAAM,GAAG,mBAAmB,CAAC;SAC7C;KACF,EACD,CAAC,kBAAkB,EAAE,YAAY,EAAE,SAAS,EAAE,WAAW,CAAC,CAC3D,CAAC;AAEF,IAAA,MAAM,yBAAyB,GAAG,CAAC,SAAoB,KAAI;QACzD,MAAM,QAAQ,GAAG,YAAY,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC;QACjD,IAAI,QAAQ,EAAE;AACZ,YAAA,IAAI,YAAY,CAAC,SAAS,CAAC,EAAE;AAC3B,gBAAA,MAAM,iBAAiB,GAAG,QAAQ,CAAC,KAAK,CAAC;AACzC,gBAAA,IAAI,aAAa,CAAC,SAAS,CAAC,EAAE;oBAC5B,iBAAiB,CAAC,KAAK,GAAG,iBAAiB,CAAC,OAAO,CAAC,OAAyB,CAAC,CAAC;iBAChF;qBAAM;AACL,oBAAA,iBAAiB,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;iBAC3C;aACF;SACF;AACH,KAAC,CAAC;AAEF,IAAA,MAAM,2BAA2B,GAAGA,iBAAW,CAAC,MAAK;AACnD,QAAA,MAAM,mBAAmB,GAAG,eAAe,CAAC,OAAO,CAAC;AACpD,QAAA,IAAI,mBAAmB,IAAI,YAAY,CAAC,YAAY,CAAC,IAAI,SAAS,CAAC,YAAY,CAAC,EAAE;YAChF,MAAM,kBAAkB,GAAG,iBAAiB,CAAC,SAAS,CAAC,OAAyB,CAAC,CAAC;AAClF,YAAA,mBAAmB,CAAC,KAAK,CAAC,KAAK,GAAG,kBAAkB,CAAC;SACtD;KACF,EAAE,CAAC,iBAAiB,EAAE,YAAY,EAAE,SAAS,CAAC,CAAC,CAAC;IAEjDG,eAAS,CAAC,MAAK;;QAEb,MAAM,KAAK,GAAc,OAAO,CAAC;QACjC,MAAM,GAAG,GAAc,KAAK,CAAC;QAC7B,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC,SAAoB,KAAI;YAC5C,IAAI,YAAY,CAAC,SAAS,CAAC,IAAI,WAAW,EAAE,EAAE;;;;;;;gBAQ5C,WAAW,CAAC,SAAS,CAAC,EAAE,KAAK,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;;;gBAIvD,MAAM,YAAY,GAAG,WAAW,CAAC,SAAS,CAAC,EAAE,UAAyB,CAAC;AACvE,gBAAA,YAAY,EAAE,KAAK,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;aAC9C;AACH,SAAC,CAAC,CAAC;KACJ,EAAE,CAAC,YAAY,EAAE,WAAW,EAAE,eAAe,EAAE,WAAW,CAAC,CAAC,CAAC;AAE9D,IAAA,MAAM,aAAa,GAAG,CAAC,SAAoB,KAAI;;AAE7C,QAAA,IAAI,eAAe,CAAC,SAAS,CAAC,EAAE;YAC9B,0BAA0B,CAAC,SAAS,CAAC,CAAC;YACtC,yBAAyB,CAAC,SAAS,CAAC,CAAC;SACtC;AACD,QAAA,IAAI,iBAAiB,CAAC,SAAS,CAAC,EAAE;AAChC,YAAA,2BAA2B,EAAE,CAAC;SAC/B;AACH,KAAC,CAAC;;IAGF,MAAM,wBAAwB,GAAG,MAAK;QACpC,yBAAyB,CAAC,mCAAmC,CAAC,CAAC;AACjE,KAAC,CAAC;AACF,IAAA,MAAM,mCAAmC,GAAGH,iBAAW,CAAC,MAAK;;;;AAI3D,QAAA,IAAI,CAAC,WAAW,EAAE,EAAE;YAClB,0BAA0B,CAAC,WAAW,CAAC,CAAC;YACxC,0BAA0B,CAAC,SAAS,CAAC,CAAC;SACvC;AACD,QAAA,2BAA2B,EAAE,CAAC;KAC/B,EAAE,CAAC,0BAA0B,EAAE,2BAA2B,EAAE,WAAW,CAAC,CAAC,CAAC;AAC3E,IAAAoB,mCAAiB,CAAC,OAAO,EAAE,wBAAwB,CAAC,CAAC;AAErD,IAAA,MAAM,cAAc,GAAG,CAAC,SAAoB,KAAI;;AAE9C,QAAA,IAAI,SAAS,CAAC,SAAS,CAAC,EAAE;AACxB,YAAA,MAAM,MAAM,GAAG,aAAa,CAAC,SAAS,CAAC,CAAC;YACxC,QAAQ,SAAS;AACf,gBAAA,KAAK,WAAW;;;AAGd,oBAAA,cAAc,CAAC,WAAW,EAAE,GAAG,CAAC,GAAG,MAAM,CAAC,CAAC;oBAC3C,MAAM;AACR,gBAAA,KAAK,SAAS;;;AAGZ,oBAAA,YAAY,CAAC,WAAW,EAAE,GAAG,MAAM,GAAG,EAAE,GAAG,MAAM,CAAC,CAAC;oBACnD,MAAM;AACR,gBAAA,KAAK,YAAY;oBACf,eAAe,CAAC,MAAM,CAAC,CAAC;oBACxB,MAAM;aACT;SACF;AACH,KAAC,CAAC;;IAGF,MAAM,uBAAuB,GAAG,MAAK;QACnC,yBAAyB,CAAC,kCAAkC,CAAC,CAAC;AAChE,KAAC,CAAC;IACF,MAAM,kCAAkC,GAAG,MAAK;QAC9C,cAAc,CAAC,WAAW,CAAC,CAAC;AAC5B,QAAA,2BAA2B,EAAE,CAAC;AAChC,KAAC,CAAC;AACF,IAAAA,mCAAiB,CAAC,cAAc,EAAE,uBAAuB,CAAC,CAAC;;IAG3D,MAAM,qBAAqB,GAAG,MAAK;QACjC,yBAAyB,CAAC,gCAAgC,CAAC,CAAC;AAC9D,KAAC,CAAC;IACF,MAAM,gCAAgC,GAAG,MAAK;QAC5C,cAAc,CAAC,SAAS,CAAC,CAAC;AAC1B,QAAA,2BAA2B,EAAE,CAAC;AAChC,KAAC,CAAC;AACF,IAAAA,mCAAiB,CAAC,YAAY,EAAE,qBAAqB,CAAC,CAAC;;IAGvD,MAAM,wBAAwB,GAAG,MAAK;QACpC,yBAAyB,CAAC,mCAAmC,CAAC,CAAC;AACjE,KAAC,CAAC;IACF,MAAM,mCAAmC,GAAG,MAAK;QAC/C,cAAc,CAAC,YAAY,CAAC,CAAC;AAC/B,KAAC,CAAC;AACF,IAAAA,mCAAiB,CAAC,eAAe,EAAE,wBAAwB,CAAC,CAAC;AAE7D,IAAA,MAAM,oCAAoC,GAAG,CAAC,SAAoB,KAAI;QACpE,QAAQ,SAAS;AACf,YAAA,KAAK,WAAW;AACd,gBAAA,OAAO,wBAAwB,CAAC;AAClC,YAAA,KAAK,SAAS;AACZ,gBAAA,OAAO,sBAAsB,CAAC;AAChC,YAAA,KAAK,YAAY;AACf,gBAAA,OAAO,yBAAyB,CAAC;SACpC;AACH,KAAC,CAAC;AAEF,IAAA,MAAM,uBAAuB,GAAG,CAAC,SAAoB,KAAI;AACvD,QAAA,MAAM,0BAA0B,GAAG,4BAA4B,CAAC,SAAS,CAAC,CAAC;AAC3E,QAAA,IAAI,oCAAoC,CAAC,SAAS,CAAC,IAAI,0BAA0B,EAAE;YACjF,QAAQ,SAAS;AACf,gBAAA,KAAK,WAAW;oBACd,2BAA2B,CAAC,0BAA0B,CAAC,CAAC;oBACxD,MAAM;AACR,gBAAA,KAAK,SAAS;oBACZ,yBAAyB,CAAC,0BAA0B,CAAC,CAAC;oBACtD,MAAM;AACR,gBAAA,KAAK,YAAY;oBACf,4BAA4B,CAAC,0BAA0B,CAAC,CAAC;oBACzD,MAAM;aACT;;;;;;;AAQD,YAAA,4BAA4B,EAAE,CAAC;SAChC;AACH,KAAC,CAAC;AAEF,IAAA,MAAM,wBAAwB,GAAG,CAAC,SAAoB,KAAI;AACxD,QAAA,MAAM,YAAY,GAAiB;AACjC,YAAA,QAAQ,EAAE,KAAK;AACf,YAAA,SAAS,EAAE,KAAK;SACjB,CAAC;AAEF,QAAA,MAAM,WAAW,GAAG;AAClB,YAAA,QAAQ,EAAE,KAAK;AACf,YAAA,SAAS,EAAE,KAAK;SACjB,CAAC;;QAGF,uBAAuB,CAAC,SAAS,CAAC,CAAC;;AAGnC,QAAA,IAAI,SAAS,CAAC,SAAS,CAAC,EAAE;YACxB,aAAa,CAAC,SAAS,CAAC,CAAC;;AAGzB,YAAA,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,EAAE;gBAC9B,cAAc,CAAC,SAAS,CAAC,CAAC;aAC3B;YAED;;;AAGE,YAAAH,cAAA,CAAA,KAAA,EAAA,EAAA,QAAA,EACEA,eAACI,WAAK,EAAA,EAAA,QAAA,EACJJ,cAAC,CAAAK,iBAAQ,IACP,SAAS,EAAE,SAAS,KAAK,YAAY,GAAG,SAAS,GAAG,OAAO,EAC3D,SAAS,EAAE,SAAS,EACpB,KAAK,EAAE,wBAAwB,CAAC,SAAS,CAAC,GAAG,MAAM,CAAC,QAAQ,GAAG,EAAE,EACjE,QAAQ,EAAE,WAAW,EAAE,IAAI,eAAe,CAAC,SAAS,CAAC,GAAG,OAAO,GAAG,UAAU,EAC5E,WAAW,EAAE,cAAc,CAAC,SAAS,CAAC,EACtC,WAAW,EAAE,WAAW,EACxB,YAAY,EAAE,YAAY,EACzB,QAAA,EAAA,mBAAmB,CAAC,SAAS,CAAC,GACtB,EACL,CAAA,EAAA,CACJ,EACN;SACH;aAAM;;AAEL,YAAA,OAAO,YAAY,CAAC,SAAS,CAAC,CAAC;SAChC;AACH,KAAC,CAAC;;;;;;;AASF,IAAA,MAAM,SAAS,GAAG,CAAC,SAAoB,KAAS;QAC9C,MAAM,SAAS,GAAG,eAAe,CAAC,SAAS,CAAC,KAAK,eAAe,CAAC;AACjE,QAAA,OAAO,SAAS,GAAG,wBAAwB,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC;AAChE,KAAC,CAAC;IAEF,QACEC,yBAAK,GAAG,EAAE,OAAO,EAAE,SAAS,EAAE,OAAO,EAAM,GAAA,WAAW,aAEnD,SAAS,CAAC,WAAW,CAAC,EAEvBA,eAAA,CAAA,KAAA,EAAA,EAAK,GAAG,EAAE,SAAS,EAAE,SAAS,EAAE,MAAM,CAAC,aAAa,EAAA,QAAA,EAAA,CAClDN,wBAAK,SAAS,EAAE,MAAM,CAAC,WAAW,EAE/B,QAAA,EAAA,QAAQ,EACL,CAAA,EAEL,SAAS,CAAC,YAAY,CAAC,CAAA,EAAA,CACpB,EAEL,SAAS,CAAC,SAAS,CAAC,CACjB,EAAA,CAAA,EACN;AACJ;;;;"}