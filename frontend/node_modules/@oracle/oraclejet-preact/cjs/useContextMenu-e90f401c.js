/* @oracle/oraclejet-preact: undefined */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
var SelectMenuGroupContext = require('./SelectMenuGroupContext-ae5e1373.js');
require('preact');
require('./logger-2b636482.js');
require('./LayerHost-aee0e070.js');
require('preact/compat');


require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js');
require('./tooltipUtils-ae48fed6.js');

require('./UNSAFE_Menu/themes/MenuItemStyles.css.js');
require('./UNSAFE_Separator/themes/SeparatorStyles.css.js');


require('./UNSAFE_Menu/themes/redwood/MenuSeparatorVariants.css.js');

var useContextMenuGesture = require('./useContextMenuGesture-03ba6353.js');

const initialMenuProps = {
    isOpen: false,
    initialFocus: 'menu',
    placement: 'bottom-start',
    offsetValue: 0,
    anchorRef: { current: null }
};

/**
 * The internal component used to render a custom context menu
 */
function ContextMenu({ contextMenuConfig, contextMenuContext, rootRef, setMenuProps, onContextMenuDismissed, gestureRef, ...menuProps }) {
    const handleCloseContextMenu = hooks.useCallback((detail) => {
        /*
        TODO: Focus ring should be visible when context menu was closed because of selecting an item using keyboard,
        but should not be visible when the selection was done using mouse or touch. This would probably means menu
        onClose API is going to be changed a little bit so we can satisfy this requirement. JET-62372
        */
        //Focus has to be set on the current target that was obtained
        //during context menu gesture when menu is dismissed or item is "selected"
        if (detail.reason === 'dismissed' || detail.reason === 'itemAction') {
            rootRef.current?.focus({ preventScroll: true });
            onContextMenuDismissed?.(gestureRef.current);
        }
        // We close the menu.The only prop that matters here is isOpen
        setMenuProps(initialMenuProps);
    }, [rootRef, gestureRef, setMenuProps, onContextMenuDismissed]);
    return (jsxRuntime.jsx(SelectMenuGroupContext.Menu, { ...menuProps, onClose: handleCloseContextMenu, "aria-label": contextMenuConfig.accessibleLabel, children: menuProps.isOpen && contextMenuConfig.itemsRenderer(contextMenuContext) }));
}

const TOUCH_OFFSET_VALUE = 30;
const menuPropGestureStates = {
    mouse: {
        initialFocus: 'menu',
        placement: 'bottom-start',
        offsetValue: 0
    },
    keyboard: {
        initialFocus: 'firstItem',
        placement: 'bottom-start',
        offsetValue: 0
    },
    touch: {
        initialFocus: 'menu',
        placement: 'end',
        offsetValue: TOUCH_OFFSET_VALUE
    }
};
function useContextMenu({ onContextMenuHandler, contextMenuOptions, rootRef, contextMenuConfig, onContextMenuDismissed }) {
    const [contextMenuContext, setContextMenuContext] = hooks.useState();
    const [menuProps, setMenuProps] = hooks.useState(initialMenuProps);
    const gestureRef = hooks.useRef(null);
    const onVisContextMenuHandler = hooks.useCallback(({ gesture, anchor, target }) => {
        gestureRef.current = gesture;
        const { context, ...launcherInfo } = onContextMenuHandler({
            gesture,
            target
        });
        let menuAnchor;
        switch (launcherInfo.type) {
            case 'offset': {
                const { offsetValue, isRtl, width } = launcherInfo;
                const rootRefDims = rootRef.current?.getBoundingClientRect();
                menuAnchor = {
                    x: isRtl
                        ? width + rootRefDims.x - Math.abs(offsetValue.crossAxis)
                        : rootRefDims.x + Math.abs(offsetValue.crossAxis),
                    y: rootRefDims.y + Math.abs(offsetValue.mainAxis)
                };
                break;
            }
            case 'element':
                menuAnchor = launcherInfo.elem;
                break;
            case 'pointer':
                menuAnchor = anchor;
                break;
        }
        setContextMenuContext(context);
        setMenuProps({
            ...menuPropGestureStates[gesture],
            anchorRef: { current: menuAnchor },
            isOpen: true
        });
    }, [onContextMenuHandler, rootRef]);
    const contextMenuContent = contextMenuConfig && (jsxRuntime.jsx(ContextMenu, { ...menuProps, onContextMenuDismissed: onContextMenuDismissed, gestureRef: gestureRef, setMenuProps: setMenuProps, rootRef: rootRef, contextMenuConfig: contextMenuConfig, contextMenuContext: contextMenuContext }));
    const { triggerProps } = useContextMenuGesture.useContextMenuGesture(onVisContextMenuHandler, {
        ...contextMenuOptions,
        isTouchHoldReleaseGesture: true
    });
    return { contextMenuProps: triggerProps, contextMenuContent };
}

exports.ContextMenu = ContextMenu;
exports.useContextMenu = useContextMenu;
//# sourceMappingURL=useContextMenu-e90f401c.js.map
