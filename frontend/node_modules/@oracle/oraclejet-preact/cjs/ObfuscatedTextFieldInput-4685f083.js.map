{"version":3,"file":"ObfuscatedTextFieldInput-4685f083.js","sources":["../../src/UNSAFE_TextField/HistoryManager.ts","../../src/UNSAFE_TextField/useHistoryManager.ts","../../src/UNSAFE_TextField/ObfuscatedTextFieldInput.tsx"],"sourcesContent":["const DEFAULT_MAX_HISTORY = 100;\n\n/**\n * Options for instantiating the HistoryManager class\n */\ntype HistoryManagerOptions = {\n  /**\n   * Maximum allowed states in the history. If a new state is pushed\n   * when the manager is at the limit, the oldest state is removed from\n   * the history.\n   */\n  maxHistory?: number;\n};\n\n/**\n * This class creates an instance that can be used to manage history.\n * One can use the push method to store any history state and can call\n * undo/redo method to get a previous/next state in the history.\n * @template State The type of the state stored in the history\n */\nexport class HistoryManager<State = any> {\n  private currentIndex: number;\n  private maxHistory: number;\n  private states: State[];\n\n  constructor({ maxHistory = DEFAULT_MAX_HISTORY }: HistoryManagerOptions) {\n    this.currentIndex = 0;\n    this.maxHistory = maxHistory;\n    this.states = [];\n  }\n\n  get currentState() {\n    return this.states[this.currentIndex];\n  }\n\n  get isEmpty() {\n    return this.states.length === 0;\n  }\n\n  get hasUndo() {\n    return !this.isEmpty && this.currentIndex > 0;\n  }\n\n  get hasRedo() {\n    return !this.isEmpty && this.currentIndex < this.states.length - 1;\n  }\n\n  /**\n   * Pushes a state to the history\n   * @param state the state to be pushed into the history\n   */\n  push(state: State) {\n    // if the current position is not the end of the array, clear all the\n    // items after the current position\n    if (this.currentIndex < this.states.length - 1) this.states.length = this.currentIndex + 1;\n    // add the new state\n    this.states.push(state);\n    // if the states' size exceeded the allowed limit, remove the oldest state\n    if (this.states.length > this.maxHistory) this.states.shift();\n    this.currentIndex = this.states.length - 1;\n  }\n\n  /**\n   * Retrieves the state from the history after walking the provided steps.\n   * @param steps number of steps to travel in the history\n   * @returns the state after walking the steps in the history\n   */\n  go(steps: number) {\n    this.currentIndex = Math.min(Math.max(this.currentIndex + steps, 0), this.states.length - 1);\n    return this.currentState;\n  }\n\n  /**\n   * Go back in history by 1 step\n   * @returns The previous state\n   */\n  undo() {\n    return this.go(-1);\n  }\n\n  /**\n   * Go forward in history by 1 step\n   * @returns The previous state\n   */\n  redo() {\n    return this.go(1);\n  }\n\n  /**\n   * Clears the history\n   */\n  clear() {\n    this.states.length = 0;\n    this.currentIndex = 0;\n  }\n}\n","import { useEffect, useMemo, useRef } from 'preact/compat';\nimport { HistoryManager } from './HistoryManager';\n\ntype Props<T> = {\n  /**\n   * The state that needs to be pushed to the history.\n   */\n  state: T;\n\n  /**\n   * Compares two states\n   * @param a State A\n   * @param b State B\n   * @returns equality of the two states\n   */\n  comparator: (a?: T, b?: T) => boolean;\n\n  /**\n   * Whether history management is disabled. When it is disabled\n   * the states will not be pushed to the history. Additionally, when it\n   * changes from enabled to disabled, the history will be cleared.\n   */\n  isDisabled: boolean;\n\n  /**\n   * Maximum states that need to be stored in the history. This can only be set\n   * during the initialization. Changing the value after the initialization will\n   * not have any effect.\n   */\n  maxHistory?: number;\n};\n\nexport type HistoryController<T> = Pick<\n  HistoryManager<T>,\n  'hasRedo' | 'hasUndo' | 'redo' | 'undo'\n> & {\n  /**\n   * A method that can be called to toggle the history manager to\n   * save or ignore states.\n   * This is different from `isDisabled`; ignoring will not clear the history\n   * while disabling clears the history.\n   * @param doIgnore flag to indicate if this should ignore state updates\n   */\n  ignore: (doIgnore?: boolean) => void;\n};\n\n/**\n * A custom hook that provides history management. Using this hook, one can push\n * consecutive states to the stack. Then they can go to any point in the history\n * by performing undo/redo operations.\n * @param param0 The hook's props\n * @returns The history manager controller that can be used to manage the history.\n *\n * @template State A Generic representing the shape of the state.\n *\n * @example\n * function MyComponent(props) {\n *   const historyManager = useHistoryManager<MyValue>({\n *     state: props.value,\n *     comparator: (value1, value2) => value1 === value2\n *   });\n *\n *   return (\n *     <SomeComponent\n *       value={props.value}\n *       onValueChange={props.onValueChange}\n *       onUndo={() => {\n *         const undoValue = historyManager.undo();\n *         props.onValueChange(historyManager.undo());\n *       }}\n *       onRedo={() => {\n *         const redoValue = historyManager.redo();\n *         props.onValueChange(redoValue);\n *       }}  />\n *   );\n * }\n */\nexport function useHistoryManager<State>({\n  state,\n  comparator,\n  isDisabled,\n  maxHistory\n}: Props<State>) {\n  // We do not want to recreate history manager and only have a single version.\n  const initialMaxHistoryRef = useRef(maxHistory);\n  const historyManager = useMemo(\n    () => new HistoryManager<State>({ maxHistory: initialMaxHistoryRef.current }),\n    []\n  );\n\n  // We use a ref for determining if we should ignore state updates. This is needed\n  // as we may not want to update the history when we are undoing/redoing.\n  const isIgnoredRef = useRef(false);\n\n  // We want to add the state to the history if it changes. But, we should not cause\n  // a rerender as pushing a state to the history does not cause any UI changes. So we\n  // will use refs instead of states.\n  const previousStateRef = useRef<State>();\n  // we only push the new state if\n  // 1. it is different from the old state\n  // 2. the history management is not disabled\n  // 3. the states are not ignored\n  if (!comparator(previousStateRef.current, state) && !isDisabled && !isIgnoredRef.current) {\n    previousStateRef.current = state;\n    historyManager.push(state);\n  }\n\n  // when the history management becomes disabled, we clear the history created so far\n  if (isDisabled) {\n    historyManager.clear();\n  }\n\n  // clear the history when the component is unmounted\n  // we only want to clear history on unmount.\n  // TODO: Disable eslint exhaustive-deps rule when it is enabled\n  // doing it now results in eslint error, saying the rule is not found.\n  useEffect(() => () => historyManager.clear(), [historyManager]);\n\n  return useMemo<HistoryController<State>>(\n    () => ({\n      get hasRedo() {\n        return historyManager.hasRedo;\n      },\n      get hasUndo() {\n        return historyManager.hasUndo;\n      },\n      redo: () => historyManager.redo(),\n      undo: () => historyManager.undo(),\n      ignore(doIgnore = true) {\n        isIgnoredRef.current = !!doIgnore;\n      }\n    }),\n    [historyManager]\n  );\n}\n","import { useEffectEvent } from '#hooks/PRIVATE_useEffectEvent';\nimport { isUndoEvent, isRedoEvent } from '#utils/PRIVATE_keyboardUtils';\nimport { mergeRefs } from '#utils/PRIVATE_refUtils';\nimport { ComponentProps, Ref, useCallback, useLayoutEffect, useMemo, useRef } from 'preact/compat';\nimport { TextFieldInput } from './TextFieldInput';\nimport { containerStyles } from './themes/ObfuscatedTextFieldInputStyles.css';\nimport { useHistoryManager } from './useHistoryManager';\n\ntype TextFieldInputProps = ComponentProps<typeof TextFieldInput>;\ntype PickedPropsFromTextFieldInput = Pick<\n  TextFieldInputProps,\n  | 'aria-describedby'\n  | 'aria-invalid'\n  | 'aria-label'\n  | 'aria-labelledby'\n  | 'autoFocus'\n  | 'currentCommitValue'\n  | 'hasEmptyLabel'\n  | 'hasEndContent'\n  | 'hasInsideLabel'\n  | 'hasStartContent'\n  | 'id'\n  | 'isRequired'\n  | 'onBlur'\n  | 'onCommit'\n  | 'onFocus'\n  | 'onInput'\n  | 'placeholder'\n  | 'textAlign'\n  | 'type'\n  | 'value'\n  | 'variant'\n>;\ntype Props = PickedPropsFromTextFieldInput & {\n  /**\n   * The character used for obfuscation\n   */\n  character?: string;\n  /**\n   * The ref for the input element\n   */\n  inputRef?: Ref<HTMLInputElement>;\n  /**\n   * Flag to indicate if the text is to be revealed\n   */\n  isRevealed?: boolean;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// Various delete interactions. While this covers all platforms, the examples //\n// are only provided for MacOS. This will work the same for similar behavior  //\n// from other platforms achieved from platform specific keystrokes.           //\n////////////////////////////////////////////////////////////////////////////////\n\n// Some of the deletion types exist in the spec, but unable to trigger for input:\n// 1. deleteSoftLineForward\n// 2. deleteEntireSoftLine\n// 3. deleteHardLineBackward (triggered only in Safari instead of deleteSoftLineBackward)\n// 4. deleteHardLineForward\n// 5. deleteByDrag\n// 6. deleteContent\n//\n// Some we do not want to support:\n// 1. deleteByCut - we want to disable cutting/copying value when obfuscated\n\n/**\n * Deletes the whole selection.\n * @param content the current content\n * @param selectionStart the selection start index\n * @param selectionEnd the selection end index\n * @returns the content with deletion performed and the new cursor position\n */\nconst deleteSelection = (content: string, selectionStart: number, selectionEnd: number) => ({\n  content: content.slice(0, selectionStart) + content.slice(selectionEnd),\n  // when a selection is deleted, the new cursor position will always be the\n  //  selectionStart\n  selectionStart,\n  selectionEnd: selectionStart\n});\n\n/**\n * Deletes the whole content before the cursor.\n * @param content the current content\n * @param selectionStart the selection start index\n * @param selectionEnd the selection end index\n * @returns the content with deletion performed and the new cursor position\n */\nconst deleteEverythingBackward = (content: string, selectionStart: number, selectionEnd: number) =>\n  // if there is a selection, remove the selection to form the new word\n  selectionEnd > selectionStart\n    ? deleteSelection(content, selectionStart, selectionEnd)\n    : // if the cursor is at the start, then noop\n    selectionStart === 0\n    ? { content, selectionStart, selectionEnd }\n    : // if there is no selection, then delete everything before the cursor\n      // we don't delete word by word when we are showing obfuscated text\n      {\n        content: content.slice(selectionEnd),\n        // the new selection range will be at the beginning of the text\n        selectionStart: 0,\n        selectionEnd: 0\n      };\n\n/**\n * Deletes the whole content after the cursor.\n * @param content the current content\n * @param selectionStart the selection start index\n * @param selectionEnd the selection end index\n * @returns the content with deletion performed and the new cursor position\n */\nconst deleteEverythingForward = (content: string, selectionStart: number, selectionEnd: number) =>\n  // if there is a selection, remove the selection to form the new word\n  selectionEnd > selectionStart\n    ? deleteSelection(content, selectionStart, selectionEnd)\n    : // if the cursor is at the end, then noop\n    selectionStart === content.length\n    ? { content, selectionStart, selectionEnd }\n    : // if there is no selection, then delete everything after the cursor and the selection range\n      // stays the same\n      // we don't delete word by word when we are showing obfuscated text\n      { content: content.slice(0, selectionStart), selectionStart, selectionEnd };\n\nconst deletionOperations = {\n  /**\n   * Deletes the current selection or a character before the cursor if there is no selection.\n   * Key Combinations (MacOS) - delete\n   * @param content the current content\n   * @param selectionStart the selection start index\n   * @param selectionEnd the selection end index\n   * @returns the content with deletion performed and the new cursor position\n   */\n  deleteContentBackward(content: string, selectionStart: number, selectionEnd: number) {\n    // if there is a selection, remove the selection to form the new word\n    if (selectionEnd > selectionStart) {\n      return deleteSelection(content, selectionStart, selectionEnd);\n    }\n    // if the cursor is at the start, then noop\n    if (selectionStart === 0) {\n      return { content, selectionStart, selectionEnd };\n    }\n    // if no selection, then remove one char before the cursor\n    return {\n      content: content.slice(0, selectionStart - 1) + content.slice(selectionEnd),\n      // new selectionStart & selectionEnd will be one position before\n      selectionStart: selectionStart - 1,\n      selectionEnd: selectionStart - 1\n    };\n  },\n\n  /**\n   * Deletes the current selection or a character after the cursor if there is no selection.\n   * Key Combinations (MacOS) - fn + delete\n   * @param content the current content\n   * @param selectionStart the selection start index\n   * @param selectionEnd the selection end index\n   * @returns the content with deletion performed\n   */\n  deleteContentForward(content: string, selectionStart: number, selectionEnd: number) {\n    // if there is a selection, remove the selection to form the new word\n    if (selectionEnd > selectionStart) {\n      return deleteSelection(content, selectionStart, selectionEnd);\n    }\n    // if the cursor is at the end, then noop\n    if (selectionStart === content.length) {\n      return { content, selectionStart, selectionEnd };\n    }\n    // if no selection, then remove one char after the cursor\n    return {\n      content: content.slice(0, selectionStart) + content.slice(selectionEnd + 1),\n      // the new selection range will stay the same\n      selectionStart,\n      selectionEnd\n    };\n  },\n\n  /**\n   * Deletes the current selection or a word before the cursor if there is no selection.\n   * Key Combinations (MacOS) - option + delete\n   * @param content the current content\n   * @param selectionStart the selection start index\n   * @param selectionEnd the selection end index\n   * @returns the content with deletion performed\n   */\n  deleteWordBackward(content: string, selectionStart: number, selectionEnd: number) {\n    // In input's case, when obfuscated there will not be any spaces\n    // So, we delete everything before the cursor\n    return deleteEverythingBackward(content, selectionStart, selectionEnd);\n  },\n\n  /**\n   * Deletes the current selection or a word after the cursor if there is no selection.\n   * Key Combinations (MacOS) - option + fn + delete\n   * @param content the current content\n   * @param selectionStart the selection start index\n   * @param selectionEnd the selection end index\n   * @returns the content with deletion performed\n   */\n  deleteWordForward(content: string, selectionStart: number, selectionEnd: number) {\n    // In input's case, when obfuscated there will not be any spaces\n    // So, we delete everything after the cursor\n    return deleteEverythingForward(content, selectionStart, selectionEnd);\n  },\n\n  /**\n   * Deletes the current selection or everything before the cursor if there is no selection.\n   * Key Combinations (MacOS) - command + delete\n   * @param content the current content\n   * @param selectionStart the selection start index\n   * @param selectionEnd the selection end index\n   * @returns the content with deletion performed\n   */\n  deleteSoftLineBackward(content: string, selectionStart: number, selectionEnd: number) {\n    // delete everything before the cursor\n    return deleteEverythingBackward(content, selectionStart, selectionEnd);\n  },\n\n  /**\n   * Deletes the current selection or everything after the cursor if there is no selection.\n   * Key Combinations (MacOS) - unable to trigger\n   * @param content the current content\n   * @param selectionStart the selection start index\n   * @param selectionEnd the selection end index\n   * @returns the content with deletion performed\n   */\n  deleteSoftLineForward(content: string, selectionStart: number, selectionEnd: number) {\n    // delete everything after the cursor\n    return deleteEverythingForward(content, selectionStart, selectionEnd);\n  },\n\n  /**\n   * Deletes the current selection or everything before the cursor if there is no selection.\n   * Key Combinations (MacOS) - command + delete in Safari only\n   * @param content the current content\n   * @param selectionStart the selection start index\n   * @param selectionEnd the selection end index\n   * @returns the content with deletion performed\n   */\n  deleteHardLineBackward(content: string, selectionStart: number, selectionEnd: number) {\n    // in input, everything is single line. So, this is similar to soft line\n    // delete everything before the cursor\n    return deleteEverythingBackward(content, selectionStart, selectionEnd);\n  },\n\n  /**\n   * Deletes the current selection or everything after the cursor if there is no selection.\n   * Key Combinations (MacOS) - unable to trigger\n   * @param content the current content\n   * @param selectionStart the selection start index\n   * @param selectionEnd the selection end index\n   * @returns the content with deletion performed\n   */\n  deleteHardLineForward(content: string, selectionStart: number, selectionEnd: number) {\n    // in input, everything is single line. So, this is similar to soft line\n    // delete everything after the cursor\n    return deleteEverythingForward(content, selectionStart, selectionEnd);\n  },\n\n  /**\n   * Deletes the current selection without any direction. Noop if there is no\n   * selection.\n   * @param content the current content\n   * @param selectionStart the selection start index\n   * @param selectionEnd the selection end index\n   */\n  deleteContent(content: string, selectionStart: number, selectionEnd: number) {\n    // this should always have a selection\n    if (selectionEnd > selectionStart) {\n      return deleteSelection(content, selectionStart, selectionEnd);\n    }\n    // return the original content if there is no selection.\n    return { content, selectionStart, selectionEnd };\n  }\n} as const;\n\n/**\n * Checks if the provided deletion operation is supported\n * @param op The operation name\n * @returns whether the deletion operation is supported\n */\nconst isSupportedDeletionOperation = (op: string): op is keyof typeof deletionOperations =>\n  Object.keys(deletionOperations).includes(op);\n\n//////////////////////////////////////////////////////////////////////////////\n// Various insertions interactions. Insertions are those interactions which //\n// include text to the field one way or another (like pasting and such).    //\n//////////////////////////////////////////////////////////////////////////////\n\n// Since we will be using input element and not contenteditable div or textarea\n// we will only support a few and rest we will simply not handle.\n// 1. insertText - when one normally types\n// 2. insertFromPaste - when one pastes content or autofill\n// The way we handle the event is same for these supported types.\n// See other inputTypes and what they do here -\n// https://w3c.github.io/input-events/#interface-InputEvent-Attributes\nconst supportedInputOperations = ['insertText', 'insertFromPaste'];\n/**\n * Checks if the provided insertion operation is supported\n * @param op The operation name\n * @returns whether the insertion operation is supported\n */\nconst isSupportedInsertionOperation = (op: string) => supportedInputOperations.includes(op);\n\n/////////////////////////////////////////////////////////////////////\n// Since we are obfuscating the text, we need to implement our own //\n// Undo / Redo implementation. This is achieved by using the       //\n// HistoryManager. And this type represents the structure of the   //\n// state in the HistoryManager.                                    //\n/////////////////////////////////////////////////////////////////////\ntype InputHistoryState = {\n  value: string;\n  selection: {\n    start: number;\n    end: number;\n  };\n};\n\n/**\n * Compares two states to see if they are equal.\n * @param a a state to be compared\n * @param b another state to be compared\n * @returns result of equality\n */\nconst compareInputHistoryState = (a?: InputHistoryState, b?: InputHistoryState) => {\n  if (a === b) return true;\n  if (!a || !b) return false;\n\n  return (\n    a.value === b.value &&\n    a.selection.start === b.selection.start &&\n    a.selection.end === b.selection.end\n  );\n};\n\n/**\n * Renders an input field (similar to TextFieldInput) that obfuscates the text\n * entered in it.\n */\nexport const ObfuscatedTextFieldInput = ({\n  character = 'â€¢',\n  currentCommitValue,\n  inputRef,\n  isRevealed = false,\n  onCommit,\n  onInput,\n  type = 'text',\n  value,\n  ...passThroughProps\n}: Props) => {\n  // Even though TextFieldInput handles retaining the cursor position on rerender\n  // it will not work for us here as we preventDefault in the onbeforeinput event\n  // which will prevent the input event from getting called. Since TextFieldInput\n  // component relies on the input event to be called for restoring cursor position\n  // things will not work as expected. So, we have to reimplement this logic here\n  // again.\n  const selectionRangeRef = useRef({\n    selectionStart: value?.length ?? 0,\n    selectionEnd: value?.length ?? 0\n  });\n  const internalInputRef = useRef<HTMLInputElement>(null);\n  const mergedInputRef = useMemo(\n    () => mergeRefs(inputRef, internalInputRef),\n    [inputRef, internalInputRef]\n  );\n\n  // this component manually handles history when it is obfuscated, so we will be\n  // using the history manager\n  const historyManager = useHistoryManager<InputHistoryState>({\n    comparator: compareInputHistoryState,\n    // We do not want to maintain history when we are revealing the text.\n    // Disabling will reset the history.\n    isDisabled: isRevealed,\n    // We push the new value along with the current selectionRange to the history.\n    // Notice that we memoize the state based on the value. This is because a new\n    // state should be created only when the value changes and not when the selection\n    // changes.\n    state: useMemo<InputHistoryState>(\n      () => ({\n        value: value ?? '',\n        selection: {\n          start: selectionRangeRef.current.selectionStart,\n          end: selectionRangeRef.current.selectionEnd\n        }\n      }),\n      [value]\n    )\n  });\n\n  const onInputPayloadRef = useRef<Parameters<NonNullable<typeof onInput>>[0]>();\n\n  /**\n   * Restores selection range using the ref.\n   * @param _ we don't need this param, but this is just for making the\n   *            useLayoutEffect hook and its dependency array to match.\n   */\n  const STABLE_restoreSelectionRange = useEffectEvent((_?: any) => {\n    // only update the selectionRange of the component if it is focused\n    if (internalInputRef.current !== document.activeElement) return;\n\n    const { selectionStart, selectionEnd } = selectionRangeRef.current;\n    internalInputRef.current?.setSelectionRange(selectionStart, selectionEnd);\n  });\n\n  // when the value changes, we need to update the selection range\n  useLayoutEffect(() => {\n    // restore selection on value change\n    STABLE_restoreSelectionRange(value);\n  }, [STABLE_restoreSelectionRange, value]);\n\n  const computeNextInput = useCallback<NonNullable<GlobalEventHandlers['onbeforeinput']>>(\n    (event) => {\n      // if the component is revealing the current value, then let it\n      // go through the onInput event\n      if (isRevealed) return;\n\n      // otherwise handle it here\n      const target = event.target as HTMLInputElement;\n      const { selectionStart, selectionEnd } = target;\n      const previousValue = value ?? '';\n      const operation = event.inputType;\n\n      // stop ignoring history state updates as user initiated an action\n      historyManager.ignore(false);\n      // reset the next input state\n      onInputPayloadRef.current = undefined;\n\n      // There are different insertion inputTypes, but we only care about some\n      // see isSupportedInsertionOperation for what we support and\n      // https://w3c.github.io/input-events/#interface-InputEvent-Attributes\n      // for all the available inputTypes.\n      // And per spec, event.data will exist for insertion events, but we check for\n      // it anyway.\n      if (isSupportedInsertionOperation(operation) && event.data) {\n        // now, we determine what is the current value based on the\n        // current position of the cursor, previous value and the current\n        // entered key\n        const newValue =\n          previousValue.slice(0, selectionStart ?? previousValue.length) +\n          event.data +\n          previousValue.slice(selectionEnd ?? previousValue.length);\n\n        // new cursor position will be number of chars in event.data from\n        // the selectionStart\n        const cursorPosition = (selectionStart ?? previousValue.length) + event.data.length;\n        selectionRangeRef.current = {\n          selectionStart: cursorPosition,\n          selectionEnd: cursorPosition\n        };\n\n        // store the next input state which will be used to trigger onInput\n        // during the input event\n        onInputPayloadRef.current = { previousValue, value: newValue };\n        return;\n      }\n\n      // there are various different types of deletion events (e.g., delete vs backspace)\n      // and we need to handle it accordingly\n      // See https://w3c.github.io/input-events/#interface-InputEvent-Attributes\n      if (isSupportedDeletionOperation(operation)) {\n        const deletionOperation = deletionOperations[operation];\n        const {\n          content: newValue,\n          selectionStart: newSelectionStart,\n          selectionEnd: newSelectionEnd\n        } = deletionOperation(\n          previousValue,\n          selectionStart ?? previousValue.length,\n          selectionEnd ?? previousValue.length\n        );\n\n        // new cursor position will always be the selection start\n        selectionRangeRef.current = {\n          selectionStart: newSelectionStart,\n          selectionEnd: newSelectionEnd\n        };\n\n        // with this, trigger the onInput (only if the data is changed)\n        if (previousValue !== newValue) {\n          // store the next input state which will be used to trigger onInput\n          // during the input event\n          onInputPayloadRef.current = { previousValue, value: newValue };\n        }\n        return;\n      }\n\n      // handling history actions - undo/redo\n      if (['historyUndo', 'historyRedo'].includes(event.inputType)) {\n        const isUndo = event.inputType === 'historyUndo';\n\n        // if we don't have an undo/redo state, do nothing and return\n        if ((isUndo && !historyManager.hasUndo) || (!isUndo && !historyManager.hasRedo)) return;\n\n        // since we are restoring from history, we do not want to push this state back to history\n        // so we ignore the history updates until the next normal input happens\n        historyManager.ignore();\n        const { value: newValue, selection } = isUndo\n          ? historyManager.undo()\n          : historyManager.redo();\n\n        // with this trigger the onInput and the selection range\n        selectionRangeRef.current = {\n          selectionStart: selection.start,\n          selectionEnd: selection.end\n        };\n        // store the next input state which will be used to trigger onInput\n        // during the input event\n        onInputPayloadRef.current = { previousValue, value: newValue };\n        return;\n      }\n\n      // Unsupported action, so we prevent the input event from triggering\n      event.preventDefault();\n    },\n    [historyManager, isRevealed, value]\n  );\n\n  const triggerOnInputCallback = useCallback(() => {\n    // if the component is revealing the current value, then let it\n    // go through the onInput event from the TextFieldInput component.\n    if (isRevealed) return;\n\n    // if there is a stored next input state, then call the\n    // onInput callback\n    if (onInputPayloadRef.current) {\n      onInput?.(onInputPayloadRef.current);\n    }\n  }, [isRevealed, onInput]);\n\n  const selectAllWhenObfuscated = useCallback(() => {\n    // do not do anything when the value is revealed\n    if (isRevealed) return;\n\n    // Since we are using special char, double clicking will not select all the text\n    // and so we do it manually.\n    internalInputRef.current?.select();\n  }, [isRevealed]);\n\n  const killEventWhenObfuscated = useCallback<EventListener>(\n    (event) => {\n      if (isRevealed) return;\n\n      // prevent the default action when we are obfuscating the text.\n      // usually for events like cut and copy as we do not want to allow that.\n      event.preventDefault();\n    },\n    [isRevealed]\n  );\n\n  // the onInputHandler, onCommitHandler, onKeyDown are wired to TextFieldInput component\n  const onInputHandler = useCallback<NonNullable<TextFieldInputProps['onInput']>>(\n    (details) => {\n      // do not handle the onInput events, if the component is not in\n      // revealed state as we are handling things in onBeforeInput\n      if (!isRevealed) return;\n\n      // otherwise simply pass through to the onInput handler from the\n      // props and update the selectionRange\n      selectionRangeRef.current = {\n        selectionStart: internalInputRef.current?.selectionStart ?? details.value?.length ?? 0,\n        selectionEnd: internalInputRef.current?.selectionEnd ?? details.value?.length ?? 0\n      };\n      onInput?.(details);\n    },\n    [isRevealed, onInput]\n  );\n  const onCommitHandler = useCallback<NonNullable<TextFieldInputProps['onCommit']>>(() => {\n    // trigger onCommit only if the current value is different from the previous commit value\n    if (currentCommitValue === value) return;\n    onCommit?.({ previousValue: currentCommitValue, value });\n  }, [currentCommitValue, value, onCommit]);\n  const onKeyDownHandler = useCallback<NonNullable<TextFieldInputProps['onKeyDown']>>(\n    (event) => {\n      // if the component is revealing the current value, then let it naturally\n      // go through the onInput event\n      if (isRevealed) return;\n\n      // We handle undo/redo in both beforeinput and keydown as firefox does not\n      // seem to trigger beforeinput for undo/redo in our implementation. So, we handle it\n      // using keydown event.\n      const _isUndoEvent = isUndoEvent(event);\n      const _isRedoEvent = isRedoEvent(event);\n      if (_isUndoEvent || _isRedoEvent) {\n        // if we don't have an undo/redo state, do nothing and return\n        if ((_isUndoEvent && !historyManager.hasUndo) || (_isRedoEvent && !historyManager.hasRedo))\n          return;\n\n        // prevent the default here\n        event.preventDefault();\n        // since we are restoring from history, we do not want to push this state back to history\n        // so we ignore the history updates until the next normal input happens\n        historyManager.ignore();\n        const { value: newValue, selection } = _isUndoEvent\n          ? historyManager.undo()\n          : historyManager.redo();\n\n        // with this trigger the onInput and the selection range\n        selectionRangeRef.current = {\n          selectionStart: selection.start,\n          selectionEnd: selection.end\n        };\n        onInput?.({ previousValue: value, value: newValue });\n        return;\n      }\n    },\n    [historyManager, isRevealed, onInput, value]\n  );\n\n  return (\n    <div\n      class={containerStyles}\n      // Note: We are capturing events bubbling from the input element in the bubbling phase\n      // We are doing this approach because we do not want to add APIs to the TextFieldInput\n      // component exposing these event callbacks.\n      // This is for obfuscating the characters typed in the input\n      // Note: onBeforeInput is typed as a GenericEventHandler in preact\n      // so the event argument is of generic Event type. But as per the mdn\n      // docs (https://developer.mozilla.org/en-US/docs/Web/API/Element/beforeinput_event#event_type)\n      // it will receive an InputEvent. Hence, the explicit any casting here.\n      onBeforeInput={computeNextInput as any}\n      onInput={triggerOnInputCallback}\n      // This is for preventing cut action when obfuscated\n      onCut={killEventWhenObfuscated}\n      // This is for preventing copy action when obfuscated\n      onCopy={killEventWhenObfuscated}\n      // This is for selecting all the chars when double-clicked\n      onDblClick={selectAllWhenObfuscated}\n      // This is for selecting all the chars when right-clicked\n      onContextMenu={selectAllWhenObfuscated}>\n      <TextFieldInput\n        {...passThroughProps}\n        // override properties\n        as=\"input\"\n        autoComplete=\"off\"\n        // this is not really needed as we don't rely on the information from\n        // onCommit callback\n        currentCommitValue={currentCommitValue}\n        type={type}\n        spellcheck={false}\n        inputRef={mergedInputRef}\n        // We handle our own Input and Commit events and may not\n        // be relying on the data that the TextFieldInput provides us\n        onInput={onInputHandler}\n        onCommit={onCommitHandler}\n        onKeyDown={onKeyDownHandler}\n        value={isRevealed ? value : character.repeat(value?.length ?? 0)}\n      />\n    </div>\n  );\n};\n"],"names":["useRef","useMemo","useEffect","mergeRefs","useEffectEvent","useLayoutEffect","useCallback","isUndoEvent","isRedoEvent","_jsx","containerStyles","TextFieldInput"],"mappings":"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"}