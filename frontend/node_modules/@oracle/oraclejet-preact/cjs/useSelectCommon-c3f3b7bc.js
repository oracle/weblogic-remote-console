/* @oracle/oraclejet-preact: undefined */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var Flex = require('./Flex-6ca216a7.js');
var HighlightText = require('./HighlightText-e622ae4f.js');
require('./Grid-57fb11dc.js');

var ListItemText = require('./ListItemText-6e975c5b.js');
var Skeleton = require('./Skeleton-e746e396.js');
var hooks = require('preact/hooks');
var logger = require('./logger-2b636482.js');
var PRIVATE_SelectCommon_themes_dropdownStyles_css = require('./PRIVATE_SelectCommon/themes/dropdownStyles.css.js');
var List = require('./List-d4904e56.js');
var usePress = require('./usePress-886180e4.js');
var CaretDown = require('./CaretDown-a6f0314b.js');
var classNames = require('./classNames-c14c6ef3.js');
var useComponentTheme = require('./useComponentTheme-082fc8e4.js');
var UNSAFE_ButtonLabelLayout_themes_redwood_ButtonLabelLayoutTheme = require('./UNSAFE_ButtonLabelLayout/themes/redwood/ButtonLabelLayoutTheme.js');
var useTestId = require('./useTestId-9093a54b.js');
var UNSAFE_BaseButton_themes_redwood_BaseButtonTheme = require('./UNSAFE_BaseButton/themes/redwood/BaseButtonTheme.js');
var CollectionInteractionContext = require('./CollectionInteractionContext-f84ff7a1.js');
var useTranslationBundle = require('./useTranslationBundle-18b7bf8b.js');
var clientHints = require('./clientHints-c40c5250.js');
var compat = require('preact/compat');
var keyboardUtils = require('./keyboardUtils-b42fe7d5.js');
var tabbableUtils = require('./tabbableUtils-7e41d383.js');

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
function renderItemText(item, itemText) {
    // if item-text is a string and the data has the specified field, return it;
    // otherwise log an error
    if (typeof itemText === 'string') {
        if (item.data?.hasOwnProperty(itemText)) {
            const retData = item.data[itemText];
            return String(retData);
        }
        logger.error('SelectMultiple: itemText specifies field that does not exist: ' + itemText);
        // return undefined if the field doesn't exist
        return undefined;
    }
    // if item-text is a function, call it to create a display label
    return itemText(item);
}

const noOp = () => { };
function DefaultList({ 'aria-label': ariaLabel, currentItemVariant, currentKey, data, itemRenderer, itemText, onCurrentKeyChange, onItemAction, onLoadRange = noOp, onSelectionChange, searchText, selectedKeys, selectionMode }) {
    const listItemRenderer = hooks.useCallback((listItemContext) => {
        // specify the listItemContext props that we want to expose individually instead of
        // spreading the whole object so that we don't automatically include any new props that
        // may be added to it
        const itemRendererProps = {
            data: listItemContext.data,
            index: listItemContext.index,
            metadata: listItemContext.metadata,
            selector: listItemContext.selector,
            searchText,
            selectedKeys,
            onSelectionChange: ({ value }) => {
                onSelectionChange?.({ value });
            }
        };
        const itemContext = {
            data: listItemContext.data,
            key: listItemContext.metadata.key,
            metadata: listItemContext.metadata
        };
        return itemRenderer ? (itemRenderer(itemRendererProps)) : (jsxRuntime.jsxs(Flex.Flex, { align: "center", children: [listItemContext.selector && (jsxRuntime.jsx("div", { class: PRIVATE_SelectCommon_themes_dropdownStyles_css.dropdownStyles.selectorWrapper, children: listItemContext.selector() })), jsxRuntime.jsx("div", { class: selectionMode === 'single'
                        ? PRIVATE_SelectCommon_themes_dropdownStyles_css.dropdownStyles.singleSelectItem
                        : PRIVATE_SelectCommon_themes_dropdownStyles_css.dropdownStyles.multiSelectItem, children: jsxRuntime.jsx(ListItemText.ListItemText, { variant: "primary", children: jsxRuntime.jsx(HighlightText.HighlightText, { matchText: searchText, children: renderItemText(itemContext, itemText) }) }) })] }));
    }, [itemRenderer, itemText, onSelectionChange, searchText, selectedKeys, selectionMode]);
    const keys = hooks.useMemo(() => {
        return { all: false, keys: selectedKeys ?? new Set() };
    }, [selectedKeys]);
    const currentItemOverride = hooks.useMemo(() => (currentKey !== undefined ? { rowKey: currentKey } : undefined), [currentKey]);
    const handleItemAction = hooks.useCallback(({ context: { data, metadata } }) => {
        onItemAction?.({ context: { data, key: metadata.key, metadata } });
    }, [onItemAction]);
    const handleSelectionChange = hooks.useCallback(({ value }) => {
        onSelectionChange?.({ value: new Set(value.keys?.values()) });
    }, [onSelectionChange]);
    return (jsxRuntime.jsx(List.List, { "aria-label": ariaLabel, allowTabbableMode: false, currentItemVariant: currentItemVariant, currentItemOverride: currentItemOverride, data: data ?? null, loadingIndicator: loadingIndicator, onPersistCurrentItem: onCurrentKeyChange, onItemAction: handleItemAction, onLoadRange: onLoadRange, onSelectionChange: handleSelectionChange, role: "listbox", selectedKeys: keys, selectionMode: selectionMode, children: (context) => listItemRenderer(context) }));
}
/**
 * Custom 3 Skeleton loader for select multiple
 * TODO: to remove this once  is solved
 */
const loadingIndicator = (jsxRuntime.jsx(List.SkeletonContainer, { minimumCount: 3, children: () => {
        return (jsxRuntime.jsx(Flex.Flex, { height: "12x", align: "center", children: jsxRuntime.jsx(Skeleton.Skeleton, { height: "4x" }) }));
    } }));

const isSimpleClick = (event) => {
    return event.button === 0 && !event.ctrlKey;
};
const preventDefault = (event) => {
    event.preventDefault();
};
const preventDefaultForCurrentTarget = (event) => {
    if (event.currentTarget === event.target) {
        event.preventDefault();
    }
};

const noop = () => { };
function DropdownArrow({ isDisabled = false, onClick, testId }) {
    const { classes } = useComponentTheme.useComponentTheme(UNSAFE_ButtonLabelLayout_themes_redwood_ButtonLabelLayoutTheme.ButtonLabelLayoutRedwoodTheme, { size: 'sm' });
    const { baseTheme } = useComponentTheme.useComponentTheme(UNSAFE_BaseButton_themes_redwood_BaseButtonTheme.BaseButtonRedwoodTheme);
    const preventDefault = hooks.useCallback((event) => {
        event.preventDefault();
    }, []);
    const { pressProps } = usePress.usePress(onClick ?? noop, { isDisabled });
    // TODO: JET-67410 replace this with a icon button
    const styleClasses = classNames.classNames([
        classes,
        baseTheme,
        PRIVATE_SelectCommon_themes_dropdownStyles_css.dropdownStyles.arrow.base,
        isDisabled ? PRIVATE_SelectCommon_themes_dropdownStyles_css.dropdownStyles.arrow.disabled : PRIVATE_SelectCommon_themes_dropdownStyles_css.dropdownStyles.arrow.enabled
    ]);
    const testIdProps = useTestId.useTestId(testId);
    return (jsxRuntime.jsx("span", { "aria-hidden": "true", class: styleClasses, tabIndex: -1, onMouseDown: preventDefault, ...testIdProps, ...pressProps, children: jsxRuntime.jsx(CaretDown.SvgCaretDown, {}) }));
}

function DropdownList({ children, id, dropdownListRef, hasTopGap = true, hasBottomGap = true, isLoading = false, onKeyDown }) {
    const styleClasses = classNames.classNames([
        PRIVATE_SelectCommon_themes_dropdownStyles_css.dropdownStyles.list.base,
        hasTopGap && PRIVATE_SelectCommon_themes_dropdownStyles_css.dropdownStyles.list.topGap,
        hasBottomGap && PRIVATE_SelectCommon_themes_dropdownStyles_css.dropdownStyles.list.bottomGap,
        isLoading && PRIVATE_SelectCommon_themes_dropdownStyles_css.dropdownStyles.list.loading
    ]);
    return (jsxRuntime.jsx(CollectionInteractionContext.CollectionInteractionContext.Provider, { value: 'embedded', children: jsxRuntime.jsx("div", { ref: dropdownListRef, class: styleClasses, id: id, onMouseDown: preventDefaultForCurrentTarget, onKeyDown: onKeyDown, children: children }) }));
}

function EmptyResults() {
    const translations = useTranslationBundle.useTranslationBundle('@oracle/oraclejet-preact');
    // call preventDefault for mousedown on this div so that focus does not transfer from
    // the input
    return (jsxRuntime.jsx("div", { class: PRIVATE_SelectCommon_themes_dropdownStyles_css.dropdownStyles.results.extraItem, onMouseDown: preventDefaultForCurrentTarget, children: translations.select_noMatchesFound() }));
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Helper function to determine whether the current device is a mobile device
 * @returns true if running on a mobile device, false otherwise
 */
function isMobile() {
    const deviceType = clientHints.getClientHints().deviceType;
    return deviceType === 'phone' || deviceType === 'tablet';
}
/**
 * Helper function to determine whether the current device is a phone
 * @returns true if running on a phone, false otherwise
 */
function isPhone() {
    return clientHints.getClientHints().deviceType === 'phone';
}
/**
 * Helper function to determine whether the current device is a tablet
 * @returns true if running on a tablet, false otherwise
 */
function isTablet() {
    return clientHints.getClientHints().deviceType === 'tablet';
}
function isBeforeDataFetch(data) {
    return data.sizePrecision === 'atLeast' && data.totalSize === 0;
}
function isSearchTextEmptyOrUndefined(searchText) {
    return searchText === undefined || searchText.length === 0;
}
/**
 * Extract keys from a value items array.
 *
 * @param valueItems The value items from which the keys are to be extracted
 * @returns The set of keys
 */
function createKeysFromValueItems(valueItems) {
    const keys = valueItems?.reduce((accumKeys, currentItem) => {
        accumKeys.add(currentItem.key);
        return accumKeys;
    }, new Set());
    return keys;
}

/**
 * A custom hook that constructs the context for SelectSingle/SelectMultiple's collectionRenderer.
 * @param param0 Parameters for constructing the collection renderer context
 * @returns the CollectionRendererContext object
 */
function useCollectionRenderer({ currentKey, onCurrentKeyChange, onItemAction, onSelectedKeysChange, searchText, selectedKeys, selectedOnlyData }) {
    return compat.useMemo(() => {
        const common = {
            searchText,
            currentRowKeyOverride: currentKey,
            onPersistCurrentRowKey: onCurrentKeyChange,
            selected: selectedKeys
        };
        // If onItemAction is present, then we are constructing context for SelectSingle. So,
        // return the context satisfying SelectSingleCollectionRendererContext type.
        if (onItemAction !== undefined)
            return {
                ...common,
                onRowAction: onItemAction
            };
        // If onItemAction is not present, then we are constructing context for SelectMultiple. So,
        // return the context satisfying SelectMultipleCollectionRendererContext type.
        return {
            ...common,
            onSelectedChange: onSelectedKeysChange,
            selectedOnlyData
        };
    }, [
        currentKey,
        onCurrentKeyChange,
        onItemAction,
        onSelectedKeysChange,
        searchText,
        selectedKeys,
        selectedOnlyData
    ]);
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Hook that manages state and behavior for a Select* component.  This hook creates state
 * variables and event listeners, returning properties to apply to components internally
 * rendered by a Select* component, as well as state information.
 *
 * @param data Specifies data for the dropdown list.
 * @param inputRef Ref to the input element.
 * @param isFocused Specifies whether the component has focus.
 * @param onFilter Callback function to trigger loading data for the dropdown list,
 * which may or may not be filtered by user entered text.
 *
 * @returns Component state and event listeners.
 */
function useSelectCommon({ data, inputRef, isFocused, onFilter }) {
    const mainFieldRef = hooks.useRef(null);
    const dropdownRef = hooks.useRef(null);
    const [isDropdownOpen, setDropdownOpen] = hooks.useState(false);
    const [isDropdownAbove, setDropdownAbove] = hooks.useState(false);
    // We only need to push currentRow when we need to override the
    // current row, like when the dropdown is opened and we want to set the initial
    // focused row or when filtering and we want to focus the first row.
    const [currentRowOverride, _setCurrentRowOverride] = hooks.useState({
        rowKey: undefined
    });
    // We still need information on what the current row actually is, but we do not need
    // to react to it until certain scenarios like pressing Tab from the dropdown. So, we
    // just store this in a ref.
    const currentRowKeyRef = hooks.useRef();
    // When we want to update the currentRowOverride, we also want to keep the currentRowKeyRef
    // in sync as the collection will not call onChanged for this change.
    const setCurrentRowOverride = hooks.useCallback((currentRow) => {
        currentRowKeyRef.current = currentRow.rowKey;
        _setCurrentRowOverride(currentRow);
    }, []);
    const [isUserFiltering, setUserFiltering] = hooks.useState(false);
    const [userInput, setUserInput] = hooks.useState();
    const [searchText, setSearchText] = hooks.useState();
    const [prevIsDropdownOpen, setPrevIsDropdownOpen] = hooks.useState(isDropdownOpen);
    const [prevIsFocused, setPrevIsFocused] = hooks.useState(isFocused);
    const [prevIsUserFiltering, setPrevIsUserFiltering] = hooks.useState(isUserFiltering);
    const onMouseDown = hooks.useCallback((event) => {
        // const target = event.target as HTMLElement;
        if (event.defaultPrevented || !isSimpleClick(event)) {
            return;
        }
        if (!isDropdownOpen) {
            setDropdownOpen(true);
        }
        // this is needed to focus the input when clicking on the inside label when there is no
        // value;  otherwise the component looks focused but doesn't actually have physical focus
        setTimeout(function () {
            inputRef.current?.focus();
        }, 0);
    }, [inputRef, isDropdownOpen]);
    const handleDropdownArrowClick = hooks.useCallback(() => {
        setDropdownOpen(!isDropdownOpen);
        // focus the input so that if the user Tabs afterwards, it loses focus and the dropdown closes
        inputRef.current?.focus();
    }, [inputRef, isDropdownOpen]);
    const handleDropdownAutoDismiss = hooks.useCallback((event) => {
        if (isDropdownOpen) {
            setDropdownOpen(false);
            switch (event?.type) {
                case 'keydown': {
                    const keyboardEvent = event;
                    switch (keyboardEvent.code) {
                        case keyboardUtils.KEYS.ESC:
                            // focus the input when the user cancels out of the dropdown
                            inputRef.current?.focus();
                            break;
                    }
                    break;
                }
                case 'mousedown':
                    // if focus is in the dropdown, focus the input before the dropdown is hidden so that
                    // focus will transfer correctly when the target is not focusable;
                    // otherwise the text cursor appears in the input again
                    if (dropdownRef.current?.contains(document.activeElement)) {
                        inputRef.current?.focus();
                    }
                    break;
            }
        }
    }, [inputRef, isDropdownOpen]);
    const handleDropdownPosition = hooks.useCallback((data) => {
        setDropdownAbove(data.placement.startsWith('top'));
    }, []);
    const getDropdownTabbableElems = hooks.useCallback(() => {
        return isDropdownOpen && dropdownRef.current
            ? tabbableUtils.allTabbableElements(dropdownRef.current)
            : undefined;
    }, [isDropdownOpen]);
    const handleUpDownArrowKeys = hooks.useCallback((event) => {
        if (!isDropdownOpen) {
            setDropdownOpen(true);
        }
        else {
            // JET-64909 - focus / 'current' dropped when arrow keying during loading
            // Transfer physical focus into the dropdown only if the data is present and the dropdown
            // has rendered the data. Otherwise, keep the focus in the field.
            if (data != null) {
                const tabbableElems = getDropdownTabbableElems();
                tabbableElems?.[0]?.focus();
                // if there is no current item set, make the first item current
                if (currentRowOverride.rowKey === undefined) {
                    setCurrentRowOverride({ rowKey: data.data[0]?.metadata?.key });
                }
            }
        }
        // prevent the page from scrolling
        event.preventDefault();
    }, [currentRowOverride, data, getDropdownTabbableElems, isDropdownOpen, setCurrentRowOverride]);
    const handleMainFieldKeyDown = hooks.useCallback((event) => {
        // const target = event.target as HTMLElement;
        // ignore control key and function key
        if (keyboardUtils.isControlOrFunctionKey(event)) {
            return;
        }
        switch (event.code) {
            case keyboardUtils.KEYS.PAGE_UP:
            case keyboardUtils.KEYS.PAGE_DOWN:
                // prevent the page from scrolling
                event.preventDefault();
                return;
            case keyboardUtils.KEYS.UP:
            case keyboardUtils.KEYS.DOWN:
                // prevent the page from scrolling
                event.preventDefault();
                break;
            case keyboardUtils.KEYS.ESC:
                if (isDropdownOpen) {
                    setDropdownOpen(false);
                    event.preventDefault();
                    // JET-53183 - core pack compat: stop propagation of handled events
                    // we don't want a parent collection component to stop editing the row when we close
                    // the dropdown
                    event.stopPropagation();
                }
                break;
        }
    }, [isDropdownOpen]);
    const handleMainFieldKeyUp = hooks.useCallback((event) => {
        // ignore control key and function key
        if (keyboardUtils.isControlOrFunctionKey(event)) {
            return;
        }
        switch (event.code) {
            case keyboardUtils.KEYS.UP:
            case keyboardUtils.KEYS.DOWN:
                handleUpDownArrowKeys(event);
                break;
        }
    }, [handleUpDownArrowKeys]);
    const handleInput = hooks.useCallback((detail) => {
        if (!isDropdownOpen) {
            setDropdownOpen(true);
        }
        setUserFiltering(true);
        setUserInput(detail.value);
        const str = detail.value;
        setSearchText(str);
        onFilter?.({ searchText: str });
    }, [isDropdownOpen, onFilter]);
    const onCurrentKeyChange = hooks.useCallback((detail) => {
        // when the collection changes the current key, we only want to store the information
        // and not do anything.
        currentRowKeyRef.current = detail.value;
    }, []);
    const stopFiltering = hooks.useCallback(() => {
        setUserFiltering(false);
        setUserInput('');
        setSearchText('');
    }, []);
    const updateFiltering = hooks.useCallback((value) => {
        setUserFiltering(true);
        setUserInput(value);
        setSearchText(value);
    }, []);
    // the user is not actively filtering if the dropdown is closed and the component doesn't
    // have focus
    if (prevIsDropdownOpen !== isDropdownOpen ||
        prevIsFocused !== isFocused ||
        prevIsUserFiltering !== isUserFiltering) {
        if (!isDropdownOpen && !isFocused && isUserFiltering) {
            stopFiltering();
        }
    }
    // need to call onFilter with undefined searchText when the dropdown opens and the
    // user is NOT filtering
    hooks.useEffect(() => {
        if (isDropdownOpen && !isUserFiltering) {
            onFilter?.({ searchText: undefined });
        }
    }, [isDropdownOpen, isUserFiltering, onFilter]);
    // when the dropdown closes, reset the isDropdownAbove flag
    if (prevIsDropdownOpen !== isDropdownOpen) {
        if (!isDropdownOpen) {
            setDropdownAbove(false);
        }
        setPrevIsDropdownOpen(isDropdownOpen);
    }
    if (prevIsFocused !== isFocused) {
        setPrevIsFocused(isFocused);
    }
    if (prevIsUserFiltering !== isUserFiltering) {
        setPrevIsUserFiltering(isUserFiltering);
    }
    return {
        currentRowKeyRef,
        currentRowOverride,
        dropdownRef,
        getDropdownTabbableElems,
        handleDropdownArrowClick,
        handleDropdownAutoDismiss,
        handleDropdownPosition,
        handleInput,
        handleMainFieldKeyDown,
        handleMainFieldKeyUp,
        handleUpDownArrowKeys,
        isDropdownAbove,
        isDropdownOpen,
        // the field should remain to look focused while the dropdown is open,
        // in case physical focus is in the dropdown
        isFocused: isFocused || isDropdownOpen,
        isUserFiltering,
        mainFieldRef,
        onCurrentKeyChange,
        onMouseDown,
        searchText,
        setCurrentRowOverride,
        setDropdownOpen,
        setUserInput,
        stopFiltering,
        updateFiltering,
        userInput
    };
}

exports.DefaultList = DefaultList;
exports.DropdownArrow = DropdownArrow;
exports.DropdownList = DropdownList;
exports.EmptyResults = EmptyResults;
exports.createKeysFromValueItems = createKeysFromValueItems;
exports.isBeforeDataFetch = isBeforeDataFetch;
exports.isMobile = isMobile;
exports.isPhone = isPhone;
exports.isSearchTextEmptyOrUndefined = isSearchTextEmptyOrUndefined;
exports.isSimpleClick = isSimpleClick;
exports.isTablet = isTablet;
exports.preventDefault = preventDefault;
exports.preventDefaultForCurrentTarget = preventDefaultForCurrentTarget;
exports.renderItemText = renderItemText;
exports.useCollectionRenderer = useCollectionRenderer;
exports.useSelectCommon = useSelectCommon;
//# sourceMappingURL=useSelectCommon-c3f3b7bc.js.map
