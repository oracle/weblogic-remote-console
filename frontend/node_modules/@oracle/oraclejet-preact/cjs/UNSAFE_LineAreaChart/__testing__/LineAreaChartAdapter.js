/* @oracle/oraclejet-preact: undefined */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var UNSAFE_TestAdapter = require('@oracle/oraclejet-testing/UNSAFE_TestAdapter');
var UNSAFE_Driver = require('@oracle/oraclejet-testing/UNSAFE_Driver');
var UNSAFE_Locators = require('@oracle/oraclejet-testing/UNSAFE_Locators');

async function panStart(driver, element) {
    await driver.click(element);
    await driver.sendKeys(element, UNSAFE_Driver.Keys['PAGE_UP']);
}
async function panEnd(driver, element) {
    await driver.click(element);
    await driver.sendKeys(element, UNSAFE_Driver.Keys['PAGE_DOWN']);
}
async function clearPreviousSelection(element) {
    const driver = UNSAFE_Driver.getTestDriver();
    await driver.click(element);
}
// Function to find the data point by id
async function findDataPointById(itemId, element) {
    const dataPointElements = await element.waitForElements(UNSAFE_Locators.byCss(`[data-oj-private-item-id="${itemId}"]`));
    // Check if any data points are found
    if (dataPointElements.length === 0) {
        return null;
    }
    return dataPointElements[0];
}
class LineAreaChartAdapter extends UNSAFE_TestAdapter.TestAdapter {
    //TODO : We will need to remove selection mode when we can read attributes.
    /**
     * Triggers selection on the given item
     * @param itemId
     * @param replace
     * @param selectionMode
     */
    async doSelectItem(itemId, replace, selectionMode) {
        const driver = UNSAFE_Driver.getTestDriver();
        const chartElement = await this.getElement();
        if (selectionMode === 'single' || replace) {
            await clearPreviousSelection(chartElement);
        }
        const dataPoint = await findDataPointById(itemId, chartElement);
        if (dataPoint) {
            await driver.click(dataPoint);
        }
        else {
            console.warn(`Data point with itemId ${itemId} not found in the viewport`);
        }
    }
    // TODO: Perform CTRL+Click to implement de-select. 
    // async doDeselectItem(locator: TestIdLocator, itemId: string|number): Promise<void> {
    //   const chartElement = await getElement(locator);
    //   const driver = getTestDriver();
    //   // Find the data point with the given itemId
    //   const dataPoint = await findDataPointById(chartElement,itemId);
    //   // Perform Ctrl + click
    //   if (dataPoint) {
    //     //await driver.sendKeys(dataPoint,Key.CONTROL,'a');
    //   } else {
    //     console.warn(`Data point with itemId ${itemId} not found in the viewport.`);
    //   }
    // }
    /**
     * Triggers item drill on then item with given id.
     * @returns
     */
    async doDrillItem(itemId) {
        const driver = UNSAFE_Driver.getTestDriver();
        const chartElement = await this.getElement();
        const dataPoint = await findDataPointById(itemId, chartElement);
        // Check if a data point was found
        if (dataPoint) {
            // single click to simulate the drill action
            await driver.click(dataPoint);
        }
        else {
            console.warn(`Data point with itemId ${itemId} not found in the viewport.`);
        }
    }
    async doDrillGroup(groupId) {
        const driver = UNSAFE_Driver.getTestDriver();
        const chartElement = await this.getElement();
        // Locate the group elements with the matching data-oj-private-id
        const groupElements = await chartElement.waitForElements(UNSAFE_Locators.byCss(`[data-oj-private-group-id="${groupId}"]`));
        // Check if a group was found
        if (groupElements[0]) {
            // Perform a single click to simulate the drill action
            await driver.click(groupElements[0]);
        }
        else {
            console.warn(`Group with groupId ${groupId} not found in the viewport.`);
        }
    }
    async doZoom(direction) {
        const driver = UNSAFE_Driver.getTestDriver();
        const chartElement = await this.getElement();
        await driver.sendKeys(chartElement, direction === 'in' ? '+' : '-');
    }
    async doPan(direction) {
        const driver = UNSAFE_Driver.getTestDriver();
        const chartElement = await this.getElement();
        if (direction === 'start') {
            await panStart(driver, chartElement);
        }
        else {
            await panEnd(driver, chartElement);
        }
    }
}

exports.LineAreaChartAdapter = LineAreaChartAdapter;
//# sourceMappingURL=LineAreaChartAdapter.js.map
