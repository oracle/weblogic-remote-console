/* @oracle/oraclejet-preact: undefined */
'use strict';

var utils$1 = require('./utils-50db2fcf.js');
var utils = require('./utils-a66430fc.js');
var themeContract_css = require('./themeContract.css-a53fd740.js');

/**
 * Validates the min, max, value and step passed to the meter are in appropriate range.
 * @throws { RangeError }
 * @param min The minimum value of the meter.
 * @param max The maximum value of the meter.
 * @param value The metric value of the meter.
 * @param step The step value of the meter.
 */
function validateRange(min, max, value, step, isReadonly, baseline) {
    if (min > max) {
        throw new RangeError('The min must be lower or equal to max.');
    }
    if (value < min || value > max) {
        throw new RangeError('The value must be between min and max.');
    }
    if (!isReadonly && step > max - min) {
        throw new RangeError('The step value must be less than the difference of max and min.');
    }
    if (baseline !== undefined) {
        if (baseline < min || baseline > max) {
            throw new RangeError('Baseline is outside min and max value.');
        }
    }
}
/**
 * Returns the threshold that the current value belongs to. Returns undefined if the current value does not belong to
 * any threshold or if thresholds is undefined.
 * @param value The value in meter.
 * @param thresholds The list of thresholds.
 * @returns The Threshold that current value belongs to.
 */
function findThreshold(value, thresholds) {
    if (!thresholds) {
        return;
    }
    if (value <= thresholds[0].max) {
        return thresholds[0];
    }
    let minValue = thresholds[0].max;
    for (let i = 1; i < thresholds.length; i++) {
        if (minValue < value && value <= thresholds[i].max) {
            return thresholds[i];
        }
        minValue = thresholds[i].max;
    }
    return;
}
/**
 * Returns the color of track for the meter.
 * @param trackColor The color provided via trackColor prop of the meter.
 * @param thresholdDisplay  Specifies whether current threshold to display in track, indicator or all thresholds in track.
 * @param currentThreshold Current threshold for the meter value.
 * @returns The color of the track for the meter.
 */
function getTrackColor(thresholdDisplay, currentThreshold, trackColor) {
    if (thresholdDisplay === 'track' && currentThreshold?.color) {
        return utils$1.getVisThresholdColor(currentThreshold?.color);
    }
    return trackColor;
}
/**
 * Returns the color of indicator for the meter.
 * @param indicatorColor The color provided via indicatorColor prop of the meter.
 * @param thresholdDisplay  Specifies whether current threshold to display in track, indicator or all thresholds in track.
 * @param currentThreshold Current threshold for the meter value.
 * @returns The color of the indicator of the meter.
 */
function getIndicatorColor(thresholdDisplay, currentThreshold, indicatorColor) {
    if (currentThreshold?.color && thresholdDisplay === 'indicator') {
        return utils$1.getVisThresholdColor(currentThreshold.color);
    }
    return indicatorColor;
}
/**
 * Returns the color of track and indicator of the meter.
 * @param value The value of the meter.
 * @param trackColor The color provided via trackColor prop.
 * @param indicatorColor The color provided via indicatorColor prop.
 * @param thresholdDisplay Specifies whether current threshold to display in track, indicator or all thresholds in track.
 * @param thresholds The thresholds for metric value of the meter.
 * @returns The color of the indicator and track of the meter.
 */
function getTrackAndIndicatorColor(value, thresholdDisplay, trackColor, indicatorColor, thresholds) {
    const currentThreshold = findThreshold(value, thresholds);
    return {
        trackColor: getTrackColor(thresholdDisplay, currentThreshold, trackColor),
        indicatorColor: getIndicatorColor(thresholdDisplay, currentThreshold, indicatorColor)
    };
}
/**
 * Returns the aria properties of the meter bar.
 * @param value The value of the meter bar.
 * @param min The minimum value of the meter bar.
 * @param max The maximum value of the meter bar.
 * @param ariaLabel The aria label of the meter bar.
 * @param ariaLabelledby The ariaLabelledBy of the meter bar.
 * @param thresholds The thresholds values for the meter bar.
 * @param isDisabled The gauge is disabled or not.
 * @param isReadonly the gauge is readonly or not.
 * @param tooltip The tooltip values for the rating gauge.
 * @returns The aria properties of the meter
 */
function getMeterAriaProps(value, min, max, ariaLabel, ariaLabelledby, thresholds, isReadonly, isDisabled, tooltip) {
    const currentThreshold = findThreshold(value, thresholds);
    const ariaValueText = currentThreshold?.accessibleLabel
        ? `${value} ${currentThreshold.accessibleLabel}`
        : `${value}`;
    const ariaLabelText = ariaLabel
        ? ariaLabel
        : tooltip && isReadonly && !isDisabled
            ? tooltip
            : undefined;
    if (isReadonly) {
        return {
            'aria-label': ariaLabelText,
            'aria-labelledby': ariaLabelledby,
            'aria-disabled': isDisabled ? true : undefined,
            role: 'img'
        };
    }
    return {
        'aria-label': ariaLabelText,
        'aria-valuenow': value,
        'aria-valuemin': min,
        'aria-valuetext': ariaValueText,
        'aria-valuemax': max,
        'aria-labelledby': ariaLabelledby,
        'aria-disabled': isDisabled ? true : undefined,
        role: 'slider'
    };
}
/**
 * Returns the threshold color that the current value belongs to. Returns component color if the current value does not belong to
 * any threshold or if thresholds is undefined.
 * @param value The value in meter.
 * @param thresholds The list of thresholds.
 * @returns The threshold color that current value belongs to.
 */
function getThresholdColorFromValue(value, color, thresholds) {
    const currentThreshold = findThreshold(value, thresholds);
    if (currentThreshold?.color) {
        return currentThreshold?.color;
    }
    return color;
}
/**
 * Returns the resolved values for the legend vars.
 */
[
    {
        tokenVar: utils.xUnits(1),
        key: 'unit',
        cssProp: 'padding'
    }
];
/**
 * Returns the default label font size for given breakpoint.
 */
function getDefaultReferenceLineLabelFontSize(breakPoint) {
    if (breakPoint === 'min') {
        return themeContract_css.typographyVars.body.xs.fontSize;
    }
    else if (breakPoint === 'xs' || breakPoint === 'sm') {
        return themeContract_css.typographyVars.body.md.fontSize;
    }
    else {
        return themeContract_css.typographyVars.body.lg.fontSize;
    }
}
/**
 * Returns if the list of reference line has a label.
 * @param lines
 * @returns
 */
function hasLabelledReferenceLine(lines) {
    return !!lines?.reduce((prev, cur) => {
        return !!cur.label || prev;
    }, false);
}
/**
 * Returns the maximum dimensions of reference lines labels.
 */
function getMaxRefLabelDims(fontSize, lineHeight, refLines, getTextDimensions) {
    if (!hasLabelledReferenceLine(refLines) || !getTextDimensions || !refLines) {
        return { dims: [], maxRefLabelDims: { width: 0, height: 0 } };
    }
    const dims = refLines.map((line) => {
        const { label, labelStyle } = line;
        const dims = label
            ? getTextDimensions(label, { fontSize, lineHeight, ...labelStyle })
            : { width: 0, height: 0 };
        return dims;
    });
    const maxRefLabelDims = dims.reduce((acc, cur) => {
        return {
            width: Math.max(cur.width, acc.width),
            height: Math.max(cur.height, acc.height)
        };
    }, { width: 0, height: 0 });
    return { dims, maxRefLabelDims };
}
/**
 * Get step adjusted value.
 * @param {number} value Current value
 * @param {number} step Step value
 * @param {number} min Min value
 * @param {number} max Max value
 * @return {number} Adjusted value
 */
const adjustForStep = (value, step, min, max) => {
    if (step && step > 0) {
        const stepNum = value / step;
        if (stepNum < 0.5) {
            return min;
        }
        const adjustedValue = Math.ceil(stepNum) * step;
        return Math.max(Math.min(max, adjustedValue), min);
    }
    return value;
};

exports.adjustForStep = adjustForStep;
exports.findThreshold = findThreshold;
exports.getDefaultReferenceLineLabelFontSize = getDefaultReferenceLineLabelFontSize;
exports.getMaxRefLabelDims = getMaxRefLabelDims;
exports.getMeterAriaProps = getMeterAriaProps;
exports.getThresholdColorFromValue = getThresholdColorFromValue;
exports.getTrackAndIndicatorColor = getTrackAndIndicatorColor;
exports.hasLabelledReferenceLine = hasLabelledReferenceLine;
exports.validateRange = validateRange;
//# sourceMappingURL=meterUtils-dc96aab8.js.map
