/* @oracle/oraclejet-preact: undefined */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
var mergeProps = require('./mergeProps-e3da7237.js');
var collectionUtils = require('./collectionUtils-fe12edac.js');
var LoadMoreCollection = require('./LoadMoreCollection-3cd7e9a9.js');
var classNames = require('./classNames-c14c6ef3.js');
var TabbableModeContext = require('./TabbableModeContext-e99d527e.js');
var useId = require('./useId-6c0eeb27.js');
var View = require('./View-7d9034a7.js');
var UNSAFE_FlatTreeView_themes_TreeViewStyles_css = require('./UNSAFE_FlatTreeView/themes/TreeViewStyles.css.js');
var UNSAFE_FlatTreeView_themes_TreeViewContract_css = require('./UNSAFE_FlatTreeView/themes/TreeViewContract.css.js');
var Flex = require('./Flex-6ca216a7.js');
var Skeleton = require('./Skeleton-e746e396.js');
var useHover = require('./useHover-49b0430d.js');
var clientHints = require('./clientHints-c40c5250.js');
var Expander = require('./Expander-f3b73052.js');
var UNSAFE_FlatTreeView_themes_redwood_TreeViewTheme_css = require('./UNSAFE_FlatTreeView/themes/redwood/TreeViewTheme.css.js');
var useSelection = require('./useSelection-e11d979f.js');
var useAdditiveSelection = require('./useAdditiveSelection-b8ae3a18.js');
require('./ReorderableContext-16396e17.js');
var keys = require('./keys-25710458.js');
require('./LayerHost-aee0e070.js');
require('preact/compat');
var useExpandCollapse = require('./useExpandCollapse-336b4f0c.js');
var useComponentTheme = require('./useComponentTheme-082fc8e4.js');
var useUser = require('./useUser-f900ddf1.js');
var useNavigation = require('./useNavigation-49344b44.js');
var Selector = require('./Selector-9b72f861.js');
var LiveRegion = require('./LiveRegion-e410e187.js');
var HiddenAccessible = require('./HiddenAccessible-087eb49a.js');
var useTranslationBundle = require('./useTranslationBundle-18b7bf8b.js');
require('preact');
require('./Collection-9880039f.js');
require('./useViewportIntersect-bd8ca23c.js');
require('./vanilla-extract-dynamic.esm-2e1b7c25.js');
require('./borders-4b8488cb.js');
require('./dimensions-2fcc0acf.js');
require('./size-0717c0bd.js');
require('./utils-a66430fc.js');
require('./themeContract.css-a53fd740.js');
require('./colorUtils-01f3caa2.js');
require('./_curry1-e8f0d7ea.js');
require('./flexitem-fee13e26.js');

require('./vanilla-extract-sprinkles-createRuntimeSprinkles.esm-d68f3e0f.js');
require('./colors-2f2afb62.js');
require('./padding-398f986c.js');
require('./arrayUtils-7d8dcfc3.js');
require('./aria-889aedd0.js');
require('./theme-dfd6a9fe.js');
require('./Theme-f06687af.js');
require('./mergeInterpolations-6727b536.js');
require('./mergeDeepWithKey-210b024d.js');
require('./_curry3-18677bca.js');
require('./_curry2-c15d89cd.js');
require('./_isObject-28636267.js');
require('./EnvironmentProvider-8696a5b8.js');
require('./LayerManager-fc4df14f.js');
require('./useDensity-022a8f80.js');
require('./useTestId-9093a54b.js');
require('./equals-098f7781.js');
require('./_isArray-73160ad5.js');
require('./_isString-f4443c9e.js');

require('./boxalignment-6dde2812.js');

require('./flexbox-2cae9a01.js');


require('./UNSAFE_Skeleton/themes/redwood/SkeletonTheme.js');
require('./UNSAFE_Skeleton/themes/SkeletonStyles.css.js');

require('./UNSAFE_Skeleton/themes/redwood/SkeletonBaseTheme.css.js');

require('./UNSAFE_Skeleton/themes/redwood/SkeletonVariants.css.js');
require('./vanilla-extract-recipes-createRuntimeFn.esm-d1301b2d.js');
require('./useToggle-3ebba7d8.js');
require('./EmbeddedIconButton-a5a8938b.js');
require('./BaseButton-f6eb6de1.js');
require('./useActive-6770f917.js');
require('./useColorScheme-23e4aab4.js');
require('./UNSAFE_BaseButton/themes/redwood/BaseButtonTheme.js');
require('./UNSAFE_BaseButton/themes/BaseButtonStyles.css.js');

require('./UNSAFE_BaseButton/themes/redwood/BaseButtonVariants.css.js');

require('./BareButton-814ae4b7.js');
require('./useBareButton-8c4f3b41.js');
require('./usePress-886180e4.js');
require('./usePressClick-421494df.js');
require('./useTabbableMode-a275583f.js');
require('./buttonUtils-dff2ea3e.js');
require('./id-86356250.js');
require('./unsafeDomAccess-c3a492f0.js');
require('./ButtonLabelLayout-8981b39a.js');
require('./Text-436e8b56.js');
require('./UNSAFE_Text/themes/TextStyles.css.js');

require('./useButtonLabelLayoutTheme-b7b3bdb6.js');
require('./UNSAFE_ButtonLabelLayout/themes/redwood/ButtonLabelLayoutTheme.js');
require('./UNSAFE_ButtonLabelLayout/themes/ButtonLabelLayoutStyles.css.js');

require('./UNSAFE_ButtonLabelLayout/themes/redwood/ButtonLabelLayoutBaseTheme.css.js');

require('./UNSAFE_ButtonLabelLayout/themes/redwood/ButtonLabelLayoutVariants.css.js');

require('./ChevronDown-25b749b9.js');
require('./Icon-bc05e7bd.js');
require('./useTooltip-8728f2ff.js');
require('./useTooltipControlled-3c2afa53.js');
require('./useFocus-1b288fb9.js');
require('./useTouch-4dec8729.js');
require('./useAnimation-fb11e4cc.js');
require('./useThemeInterpolations-4faece98.js');
require('./useScale-adc62f41.js');
require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentTheme.js');
require('./hooks/UNSAFE_useTooltip/themes/TooltipContentStyles.css.js');

require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentBaseTheme.css.js');

require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js');

require('./tooltipUtils-ae48fed6.js');
require('./Floating-5a704a27.js');
require('./useFloating-13101293.js');
require('./positionUtils-a780137e.js');
require('./refUtils-a9872e75.js');
require('./useOutsideClick-c3802f86.js');
require('./Layer-28b1afce.js');
require('./UNSAFE_Layer/themes/LayerStyles.css.js');

require('./useModal-0739a528.js');
require('./UNSAFE_Floating/themes/redwood/FloatingTheme.js');
require('./UNSAFE_Floating/themes/FloatingStyles.css.js');

require('./UNSAFE_Floating/themes/redwood/FloatingBaseTheme.css.js');

require('./UNSAFE_Floating/themes/redwood/FloatingVariants.css.js');
require('./UNSAFE_Floating/themes/FloatingContract.css.js');
require('./useUnsafeDomElementRef-f22a2f0c.js');
require('./logger-2b636482.js');
require('./UNSAFE_Icon/themes/IconStyle.css.js');

require('./ChevronRight-2019bb77.js');

require('./textSelectionUtils-432ab66b.js');
require('./index-15e13649.js');
require('./UNSAFE_Layer/themes/LayerHostStyles.css.js');

require('./useCurrentKey-76fed320.js');
require('./useReorderableContext-92514102.js');
require('./useCollectionFocusRing-7fcfe8f7.js');
require('./useTabbableModeSet-029f209c.js');
require('./UNSAFE_Selector/themes/SelectorStyles.css.js');

require('./StyledCheckbox-4476f902.js');
require('./Check-da5641a4.js');
require('./CheckboxOff-511f3203.js');
require('./CheckboxOn-744c0ac1.js');
require('./CheckboxMixed-60adede1.js');
require('./UNSAFE_Checkbox/themes/CheckboxIconContract.css.js');
require('./UNSAFE_Checkbox/themes/redwood/CheckboxIconTheme.js');
require('./UNSAFE_Checkbox/themes/CheckboxIconStyles.css.js');

require('./UNSAFE_Checkbox/themes/redwood/CheckboxIconBaseTheme.css.js');

require('./UNSAFE_Checkbox/themes/redwood/CheckboxIconVariants.css.js');


require('./CollectionInteractionContext-f84ff7a1.js');
require('./useCollectionInteractionContext-6fc0200e.js');



/**
 * Allows to specify the time delay for rendering the component
 **/
const timerValue$1 = 50;
/**
 * Represents the skeleton for a tree item in expanding state
 **/
function NodeSkeletonContainer({ children, indentation = 0 }) {
    const [isVisible, setIsVisible] = hooks.useState(false);
    hooks.useEffect(() => {
        setTimeout(() => {
            setIsVisible(true);
        }, timerValue$1);
    }, []);
    return isVisible && children ? (jsxRuntime.jsx("div", { role: "presentation", children: jsxRuntime.jsx(View.View, { paddingInlineStart: indentation, children: [...Array(1)].map((_element, index) => children(index)) }) })) : null;
}

function TreeItemSkeleton({ indentation = 0, isLeaf = false }) {
    return (jsxRuntime.jsx(View.View, { paddingInlineStart: calcIndentation(indentation, isLeaf ? undefined : true), children: jsxRuntime.jsx(View.View, { padding: [0, '4px'], children: jsxRuntime.jsxs(Flex.Flex, { height: "9x", align: "center", gap: "2x", children: [!isLeaf && jsxRuntime.jsx(Skeleton.Skeleton, { width: "6x", height: "6x", borderRadius: "4px" }), jsxRuntime.jsx(Skeleton.Skeleton, { height: "5x", borderRadius: "4px" })] }) }) }));
}
function TreeItemSkeletons() {
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(TreeItemSkeleton, {}), jsxRuntime.jsx(TreeItemSkeleton, { indentation: 1 }), jsxRuntime.jsx(TreeItemSkeleton, { indentation: 2, isLeaf: true })] }));
}

function TreeItem({ itemKey, depth, context, children, isExpanded, onToggle, selected, isSelectable, isCheckboxless, isTabbable, isLoading, isFocusRingVisible }) {
    const rootRef = hooks.useRef(null);
    const indentation = calcIndentation(depth, isExpanded);
    const skeletonIndentation = calcIndentation(depth + 1, isExpanded);
    const { isHover, hoverProps } = useHover.useHover();
    const classes = classNames.classNames([
        UNSAFE_FlatTreeView_themes_TreeViewStyles_css.styles.treeItemStyles.base,
        isFocusRingVisible && UNSAFE_FlatTreeView_themes_TreeViewStyles_css.styles.treeItemStyles.focused,
        selected === true && UNSAFE_FlatTreeView_themes_TreeViewStyles_css.styles.treeItemStyles.selected,
        selected === true && isCheckboxless && UNSAFE_FlatTreeView_themes_TreeViewStyles_css.styles.treeItemStyles.checkboxlessSelected,
        isSelectable && !selected && isHover && UNSAFE_FlatTreeView_themes_TreeViewStyles_css.styles.treeItemStyles.hovered
    ]);
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("div", { ref: rootRef, id: useId.useId(), tabIndex: isMobile() ? -1 : undefined, "data-oj-key": itemKey, class: classes, role: "treeitem", "aria-level": depth + 1, "aria-selected": selected ? 'true' : 'false', ...(isExpanded !== undefined && { 'aria-expanded': isExpanded }), ...(typeof itemKey === 'number' && { 'data-oj-key-type': 'number' }), ...hoverProps, children: jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [selected === true && isHover && jsxRuntime.jsx("div", { class: UNSAFE_FlatTreeView_themes_TreeViewStyles_css.styles.selectedHoveredOverlay }), jsxRuntime.jsx(TabbableModeContext.TabbableModeContext.Provider, { value: { isTabbable }, children: jsxRuntime.jsx(View.View, { paddingInlineStart: indentation, children: jsxRuntime.jsxs(Flex.Flex, { align: "center", children: [isExpanded !== undefined && (jsxRuntime.jsx(Expander.Expander, { itemKey: itemKey, expanded: isExpanded, onToggle: onToggle })), children(context)] }) }) })] }) }), isLoading ? (jsxRuntime.jsx(NodeSkeletonContainer, { indentation: skeletonIndentation, children: () => {
                    return jsxRuntime.jsx(TreeItemSkeletons, {});
                } })) : null] }));
}
const isMobile = () => {
    const { platform } = clientHints.getClientHints();
    return platform === 'ios' || platform === 'android';
};
const calcIndentation = (depth, isExpanded) => {
    const expanderPlaceholder = isExpanded === undefined ? '40px' : '0px';
    return `calc(${Math.max(0, depth)} * ${UNSAFE_FlatTreeView_themes_TreeViewContract_css.treeViewVars.indentWidth} + ${expanderPlaceholder})`;
};

/**
 * Allows to specify the time delay for rendering the component
 **/
const timerValue = 50;
/**
 * SkeletonContainer renders 'minimumCount' number of skeletons
 * of the variant specified from its child element - Skeleton's prop after
 * 'timerValue' ms delay
 **/
function SkeletonContainer({ children, minimumCount = 1, onSkeletonVisible }) {
    const [isVisible, setIsVisible] = hooks.useState(false);
    hooks.useEffect(() => {
        setTimeout(() => {
            setIsVisible(true);
            onSkeletonVisible?.();
        }, timerValue);
    }, [onSkeletonVisible]);
    const containerClasses = classNames.classNames([UNSAFE_FlatTreeView_themes_TreeViewStyles_css.styles.skeletonStyles.container]);
    return isVisible && children ? (jsxRuntime.jsx("div", { class: containerClasses, role: "presentation", children: [...Array(minimumCount)].map((_element, index) => children(index)) })) : null;
}

/**
 * Component that receives the flattened data and renders the hierarchy betweens items based on the shaped metadata.
 * In order to maximize performance, only items that are visible in the viewport are rendered.
 * This is an internal component that is used by FlatTreeView.
 */
function LoadMoreTreeCollection({ data, children, selectionMode, onToggle = () => { }, viewportConfig, hasMore = false, onLoadMore = () => { }, loadMoreIndicator = defaultLoadMoreIndicator, updateContext }) {
    const createTreeItem = (context) => {
        const key = context.data.metadata.key;
        const treeItemContext = {
            index: context.index,
            data: context.data.data,
            metadata: { key }
        };
        // allow container to inject additional things to context
        if (updateContext) {
            updateContext(treeItemContext);
        }
        const expanded = context.data.metadata.expanded;
        return (jsxRuntime.jsx(TreeItem, { itemKey: treeItemContext.metadata.key, context: treeItemContext, depth: context.data.metadata.treeDepth, isExpanded: expanded === 'ongoing' ? true : expanded, onToggle: onToggle, isSelectable: selectionMode !== 'none', isCheckboxless: selectionMode === 'single', selected: context.data.metadata.selected, isLoading: expanded === 'ongoing', isTabbable: false, isFocusRingVisible: context.data.metadata.hasFocus, children: children }, treeItemContext.metadata.key));
    };
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: data === null ? null : (jsxRuntime.jsx(LoadMoreCollection.LoadMoreCollection, { data: data, viewportConfig: viewportConfig, hasMore: hasMore, onLoadMore: onLoadMore, loadMoreIndicator: loadMoreIndicator, children: createTreeItem })) }));
}
const defaultLoadMoreIndicator = (jsxRuntime.jsx("div", { class: LoadMoreCollection.LOADMORE_STYLE_CLASS, children: jsxRuntime.jsx(SkeletonContainer, { minimumCount: 1, children: () => {
            return jsxRuntime.jsx(TreeItemSkeletons, {});
        } }) }));

function useTreeNavigation(data, rootRef, isExpanded, idExtractor) {
    const { direction } = useUser.useUser();
    const arrowKeyAndHandlers = {
        ArrowUp: (key) => collectionUtils.getPrevNextKey(rootRef.current, key, true, collectionUtils.ITEM_SELECTOR),
        ArrowDown: (key) => collectionUtils.getPrevNextKey(rootRef.current, key, false, collectionUtils.ITEM_SELECTOR)
    };
    const { navigationProps, currentKey, onCurrentKeyChange, showFocusRing } = useNavigation.useNavigation(data, rootRef, idExtractor, arrowKeyAndHandlers, undefined, // currentItemOverride,
    undefined, //onPersistCurrentItem,
    undefined, undefined, true, // should always allow shift key
    false, // TODO: update allowTabbableMode when F2 mode is added
    true, false);
    const itemKeyExtractor = hooks.useCallback((element) => {
        if (element.getAttribute('role') === 'tree') {
            return currentKey === undefined ? null : currentKey;
        }
        return collectionUtils.keyExtractor(element, collectionUtils.ITEM_SELECTOR);
    }, [currentKey, collectionUtils.keyExtractor]);
    const onKeyUp = hooks.useCallback((event) => {
        if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
            const isRtl = direction === 'rtl';
            const isLeftArrow = event.key === 'ArrowLeft' && !isRtl;
            const itemKey = itemKeyExtractor(event.target);
            if (itemKey) {
                const contains = isExpanded(itemKey);
                // arrow left on a collapsed node, go to its parent
                if (isLeftArrow && !contains && rootRef.current) {
                    const item = collectionUtils.findElementByKey(rootRef.current, itemKey, collectionUtils.ITEM_SELECTOR);
                    if (item) {
                        const treeDepth = item.getAttribute('aria-level');
                        const parent = treeDepth !== null &&
                            findParentElementByKey(rootRef.current, itemKey, Number(treeDepth), collectionUtils.ITEM_SELECTOR);
                        const newKey = parent && itemKeyExtractor(parent);
                        if (keys.isKeyDefined(newKey)) {
                            onCurrentKeyChange?.({ value: newKey });
                        }
                    }
                }
                else if (!isLeftArrow && contains) {
                    // arrow right on an expanded node, go to its first child
                    const newKey = collectionUtils.getPrevNextKey(rootRef.current, itemKey, false, collectionUtils.ITEM_SELECTOR)();
                    if (keys.isKeyDefined(newKey)) {
                        onCurrentKeyChange?.({ value: newKey });
                    }
                }
            }
        }
    }, [direction, isExpanded, onCurrentKeyChange, itemKeyExtractor]);
    const treeNavigationProps = mergeProps.mergeProps(navigationProps, { onKeyUp });
    return { treeNavigationProps, currentKey, showFocusRing };
}
const findParentElementByKey = (root, key, treeDepth, itemSelector) => {
    if (root && key !== null) {
        const items = Array.from(root.querySelectorAll(itemSelector));
        const index = items.findIndex((i) => i.dataset['ojKey'] == key);
        for (let i = index; i >= 0; i--) {
            const level = items[i].getAttribute('aria-level');
            if (level !== null && Number(level) == treeDepth - 1) {
                return items[i];
            }
        }
    }
    return null;
};

/**
 * A FlatTreeView displays flattened data as a tree with highly interactive features.
 */
function FlatTreeView({ 'aria-label': ariaLabel, 'aria-labelledby': ariaLabelledBy, 'aria-describedby': ariaDescribedBy, data, selectionMode = 'none', selectedKeys = { all: false, keys: new Set() }, onSelectionChange, onToggle, viewportConfig, ...rest }) {
    const rootRef = hooks.useRef(null);
    const [liveRegion, setLiveRegion] = hooks.useState();
    const { collection_loading, collection_loaded } = useTranslationBundle.useTranslationBundle('@oracle/oraclejet-preact');
    const loadingDescId = useId.useId();
    const isExpanded = hooks.useCallback((key) => {
        if (rootRef.current) {
            const elem = collectionUtils.findElementByKey(rootRef.current, key, collectionUtils.ITEM_SELECTOR);
            return elem?.getAttribute('aria-expanded') === 'true';
        }
        return false;
    }, []);
    const { treeNavigationProps, currentKey, showFocusRing } = useTreeNavigation(data, rootRef, isExpanded, idExtractor);
    const items = hooks.useMemo(() => data?.map((value) => {
        const itemKey = value.metadata.key;
        const newValue = { ...value };
        newValue.metadata.selected = keys.containsKey(selectedKeys, itemKey);
        newValue.metadata.hasFocus = currentKey === itemKey && showFocusRing;
        return newValue;
    }) || [], [data, selectedKeys, currentKey, showFocusRing]);
    const expandCollapseProps = useExpandCollapse.useExpandCollapse((element) => {
        if (element.getAttribute('role') === 'tree') {
            return currentKey === undefined ? null : currentKey;
        }
        return collectionUtils.keyExtractor(element, collectionUtils.ITEM_SELECTOR);
    }, isExpanded, onToggle, true);
    // tracking the anchor key which is used for shift+click selection
    const anchorKey = hooks.useRef();
    const handleSelectionChange = hooks.useCallback((detail) => {
        if (onSelectionChange) {
            if (detail.value.all === false && detail.value.keys.size > 0) {
                // during regular selection, the last key selected by a user gesture is the anchor key
                anchorKey.current = Array.from(detail.value.keys.values()).pop();
            }
            onSelectionChange(detail);
        }
    }, [anchorKey, onSelectionChange]);
    const handleSelectionRangeChange = hooks.useCallback((detail) => {
        if (data && onSelectionChange) {
            const value = handleSelectionRange(detail, data);
            if (Array.isArray(value)) {
                if (detail.eventType === 'shiftSpace') {
                    // during range selection by shift+space, the first key selected by a user gesture is the anchor key
                    anchorKey.current = detail.value.start;
                }
                else {
                    // during range selection by shift+click/arrow keys, the last key selected by a user gesture is the anchor key
                    anchorKey.current = detail.value.end;
                }
                if (selectionMode === 'multipleToggle') {
                    const keys$1 = keys.addKeys(selectedKeys, value);
                    onSelectionChange({ value: keys$1, target: null });
                }
                else {
                    onSelectionChange({ value: { all: false, keys: new Set(value) }, target: null });
                }
            }
        }
    }, [data, selectedKeys, onSelectionChange]);
    // single or multiple selection mode
    const { selectionProps } = useSelection.useSelection((element) => {
        if (element === rootRef.current) {
            return currentKey === undefined ? null : currentKey;
        }
        return collectionUtils.keyExtractor(element, collectionUtils.ITEM_SELECTOR);
    }, selectedKeys, selectionMode === 'multipleToggle' ? 'none' : selectionMode, false, 'replace', handleSelectionChange, anchorKey.current, currentKey, (currentKey, isPrev) => collectionUtils.getPrevNextKey(rootRef.current, currentKey, isPrev, collectionUtils.ITEM_SELECTOR), undefined, (key) => {
        if (rootRef.current) {
            const elem = collectionUtils.findElementByKey(rootRef.current, key, collectionUtils.ITEM_SELECTOR);
            if (elem) {
                elem.scrollIntoView({ block: 'nearest' });
            }
        }
    }, handleSelectionRangeChange);
    // multipleToggle selection mode
    const { eventProps: multipleToggleSelectionProps } = useAdditiveSelection.useAdditiveSelection((element) => {
        if (element === rootRef.current) {
            return currentKey === undefined ? null : currentKey;
        }
        return collectionUtils.keyExtractor(element, collectionUtils.ITEM_SELECTOR);
    }, selectedKeys, selectionMode === 'multipleToggle' ? 'multiple' : 'none', false, (key) => {
        if (data) {
            return data.findIndex((value) => value.metadata.key === key);
        }
        return -1;
    }, (startIndex, endIndex) => {
        if (data) {
            const keys = data.map((value) => value.metadata.key);
            return keys.slice(startIndex, endIndex);
        }
        return [];
    }, (currentKey, isPrev) => collectionUtils.getPrevNextKey(rootRef.current, currentKey, isPrev, collectionUtils.ITEM_SELECTOR), currentKey, handleSelectionChange, handleSelectionRangeChange);
    //Note: onKeyUp doesn't work with the cmd key
    const selectAllWithKeyboard = hooks.useCallback((event) => {
        if (selectionMode === 'multiple' || selectionMode === 'multipleToggle') {
            if (onSelectionChange && (event.metaKey || event.ctrlKey) && event.key === 'a') {
                event.preventDefault();
                onSelectionChange({
                    value: { all: true, deletedKeys: new Set() },
                    target: event.target
                });
            }
        }
    }, [onSelectionChange, selectionMode]);
    const { classes } = useComponentTheme.useComponentTheme(UNSAFE_FlatTreeView_themes_redwood_TreeViewTheme_css.TreeViewRedwoodTheme);
    viewportConfig = collectionUtils.getViewportConfig(rootRef, viewportConfig);
    const updateContextCallback = hooks.useCallback((context) => {
        const key = context.metadata.key;
        context.selector =
            selectionMode === 'none' || selectionMode === 'single'
                ? undefined
                : (ariaLabel) => (jsxRuntime.jsx("div", { "aria-hidden": isMobile() ? undefined : true, children: jsxRuntime.jsx(Selector.Selector, { "aria-label": isMobile() ? ariaLabel : undefined, rowKey: key, selectedKeys: selectedKeys, onChange: onSelectionChange }) }));
    }, [selectionMode, selectedKeys, onSelectionChange]);
    const updateLiveRegion = hooks.useCallback(() => {
        setLiveRegion(collection_loading());
    }, [collection_loading]);
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("div", { "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": data == null
                    ? ariaDescribedBy
                        ? [...new Set(ariaDescribedBy.split(/\s+/).concat(loadingDescId))].join(' ')
                        : loadingDescId
                    : ariaDescribedBy, ref: rootRef, role: "tree", "aria-multiselectable": selectionMode === 'multiple' ? true : false, tabIndex: 0, class: classes, ...mergeProps.mergeProps(treeNavigationProps, selectionProps, multipleToggleSelectionProps, expandCollapseProps, { onKeyDown: selectAllWithKeyboard }), children: data == null ? (defaultLoadingIndicator(updateLiveRegion)) : (jsxRuntime.jsx(LoadMoreTreeCollection, { data: items, selectionMode: selectionMode, onToggle: onToggle, viewportConfig: viewportConfig, updateContext: updateContextCallback, ...rest })) }), jsxRuntime.jsx(HiddenAccessible.HiddenAccessible, { id: loadingDescId, children: collection_loading() }), jsxRuntime.jsx(LiveRegion.LiveRegion, { children: data == null ? liveRegion : liveRegion === collection_loading() ? collection_loaded() : '' })] }));
}
const defaultLoadingIndicator = (callback) => {
    return (jsxRuntime.jsx(SkeletonContainer, { minimumCount: 8, onSkeletonVisible: callback, children: () => {
            return jsxRuntime.jsx(TreeItemSkeletons, {});
        } }));
};
const idExtractor = (elem) => elem.id;
/**
 * A helper function to handle range selection
 */
const handleSelectionRange = (detail, data) => {
    const keys = data.map((value) => {
        return value.metadata.key;
    });
    const startIndex = keys.indexOf(detail.value.start);
    const endIndex = keys.indexOf(detail.value.end);
    const minIndex = Math.min(startIndex, endIndex);
    const maxIndex = Math.max(startIndex, endIndex);
    if (minIndex === -1) {
        // return a range to fetch so we can find all the keys, maxIndex should not be -1
        return { offset: 0, count: -1 };
    }
    else {
        // range of keys are in the current viewport, return them
        return keys.slice(minIndex, maxIndex + 1);
    }
};

exports.FlatTreeView = FlatTreeView;
//# sourceMappingURL=UNSAFE_FlatTreeView.js.map
