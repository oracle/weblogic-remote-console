/* @oracle/oraclejet-preact: undefined */
'use strict';

var hooks = require('preact/hooks');
var layoutUtils = require('./layoutUtils-e52005dc.js');
var eventsUtils = require('./eventsUtils-d34f8647.js');
require('./accUtils-5c7d3255.js');
var useVisHover = require('./useVisHover-ad36112d.js');
var mergeProps = require('./mergeProps-e3da7237.js');
var useVisDrill = require('./useVisDrill-61cccf0f.js');

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const getItemInfo = (event) => {
    const itemIndex = event.target.dataset['ojPrivateItemIndex'];
    if (itemIndex) {
        return {
            itemIndex: parseInt(itemIndex, 10)
        };
    }
    return;
};
/**
 * Hook to handle chart navigation. This can be shared between the pie, funnel and pyramid chart
 * as they follow similar navigation pattern.
 * TODO: rename
 */
function usePieChartNav(touchResponse, getDetailFromInfo, getNextChartItem, drilling, onItemDrill) {
    const [focusedItemInfo, setfocusedItemInfo] = hooks.useState({ itemIndex: 0 });
    const [hoveredItemInfo, setHoveredItemInfo] = hooks.useState();
    const activeId = hooks.useRef();
    const onContextMenuDismissed = (gesture) => {
        if (gesture === 'keyboard') {
            updateFocusedItemInfo({
                ...focusedItemInfo,
                isFocusVisible: true
            });
        }
    };
    const updateFocusedItemInfo = (itemInfo) => {
        if (itemInfo.itemIndex !== focusedItemInfo.itemIndex ||
            itemInfo.isFocusVisible !== focusedItemInfo.isFocusVisible) {
            setfocusedItemInfo(itemInfo);
            setHoveredItemInfo(undefined);
        }
    };
    const onPointerUp = (event) => {
        const info = getItemInfo(event);
        if (info) {
            updateFocusedItemInfo({ ...info, isFocusVisible: false });
        }
    };
    const onHover = (event) => {
        const info = getItemInfo(event);
        if (info?.itemIndex != hoveredItemInfo?.itemIndex) {
            setHoveredItemInfo(info);
            activeId.current = layoutUtils.getRandomId();
        }
        else if (!info) {
            activeId.current = undefined;
        }
    };
    const onHoverLeave = () => {
        setHoveredItemInfo(undefined);
        activeId.current = undefined;
    };
    const hoverHandlers = useVisHover.useVisHover(onHover, undefined, onHoverLeave, touchResponse);
    const processDrill = hooks.useCallback((info) => {
        const { id, data } = getDetailFromInfo(info);
        if (id != null && data) {
            onItemDrill?.({ id, data });
            activeId.current = layoutUtils.getRandomId();
        }
    }, [getDetailFromInfo, onItemDrill]);
    const onDrill = hooks.useCallback((event) => {
        if (drilling == 'on') {
            updateFocusedItemInfo({
                ...focusedItemInfo,
                isFocusVisible: true
            });
            if (event.type === 'keydown') {
                processDrill(focusedItemInfo);
            }
            else {
                processDrill(getItemInfo(event));
            }
        }
    }, [drilling, focusedItemInfo, processDrill, updateFocusedItemInfo]);
    const drillProps = useVisDrill.useVisDrill('none', onDrill);
    const onKeyDown = (event) => {
        const key = event.key;
        switch (key) {
            case 'Tab':
                return;
            case 'ArrowDown': {
                const info = getNextChartItem(focusedItemInfo, 'ArrowDown');
                updateFocusedItemInfo({ ...info, isFocusVisible: true });
                eventsUtils.cancelEvent(event);
                break;
            }
            case 'ArrowUp': {
                const info = getNextChartItem(focusedItemInfo, 'ArrowUp');
                updateFocusedItemInfo({ ...info, isFocusVisible: true });
                eventsUtils.cancelEvent(event);
                break;
            }
            case 'ArrowLeft': {
                const info = getNextChartItem(focusedItemInfo, 'ArrowLeft');
                updateFocusedItemInfo({ ...info, isFocusVisible: true });
                eventsUtils.cancelEvent(event);
                break;
            }
            case 'ArrowRight': {
                const info = getNextChartItem(focusedItemInfo, 'ArrowRight');
                updateFocusedItemInfo({ ...info, isFocusVisible: true });
                eventsUtils.cancelEvent(event);
                break;
            }
        }
        activeId.current = layoutUtils.getRandomId();
    };
    const onKeyUp = (event) => {
        const key = event.key;
        if (key === 'Tab') {
            updateFocusedItemInfo({ ...focusedItemInfo, isFocusVisible: true });
        }
    };
    const onBlur = () => {
        updateFocusedItemInfo({
            ...focusedItemInfo,
            isFocusVisible: false
        });
    };
    return {
        focusedItemInfo,
        hoveredItemInfo,
        activeId: activeId.current,
        eventsProps: mergeProps.mergeProps(drillProps, hoverHandlers, {
            onKeyDown,
            onKeyUp,
            onPointerUp,
            onBlur
        }),
        onContextMenuDismissed
    };
}

exports.usePieChartNav = usePieChartNav;
//# sourceMappingURL=usePieChartNav-d47d78a3.js.map
