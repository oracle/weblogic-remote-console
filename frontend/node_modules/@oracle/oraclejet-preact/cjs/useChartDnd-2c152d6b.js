/* @oracle/oraclejet-preact: undefined */
'use strict';

var eventsUtils = require('./eventsUtils-d34f8647.js');
require('./accUtils-5c7d3255.js');
var utils$1 = require('./utils-6f32ac40.js');
var utils = require('./utils-7c1b4abe.js');
var useDnd = require('./useDnd-a7d9b60c.js');

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
function getChartDragContext(target, levelsArray, rootRef, event, selectedIds, series, getDataItem, groupDraggable, itemsDraggable) {
    //We search for the key using the target of the event
    const info = eventsUtils.getInfo(rootRef, target);
    const seriesIndex = info ? info.seriesIndex : undefined;
    const groupIndex = info ? info.groupIndex : undefined;
    const levelIndex = info ? info.levelIndex : undefined;
    let context;
    if (seriesIndex !== undefined &&
        groupIndex !== undefined &&
        getDataItem?.(seriesIndex, groupIndex, levelsArray[levelsArray.length - 1]?.[groupIndex].path)) {
        const currentData = getDataItem(seriesIndex, groupIndex, levelsArray[levelsArray.length - 1]?.[groupIndex].path);
        if (itemsDraggable && itemsDraggable(currentData, seriesIndex, groupIndex) == 'on') {
            const data = [];
            if (selectedIds.size > 1 && selectedIds.has(currentData.id)) {
                const iterator = selectedIds.values();
                let current = iterator.next().value;
                while (current !== undefined) {
                    const { seriesIndex, groupIndex } = utils.findSeriesGroupIndexFromId(series, current, levelsArray, getDataItem);
                    data.push({
                        data: getDataItem(seriesIndex, groupIndex, levelsArray[levelsArray.length - 1]?.[groupIndex].path),
                        seriesIndex,
                        groupIndex
                    });
                    current = iterator.next().value;
                }
            }
            else {
                data.push({
                    data: getDataItem(seriesIndex, groupIndex, levelsArray[levelsArray.length - 1]?.[groupIndex]?.path),
                    seriesIndex,
                    groupIndex
                });
            }
            context = {
                items: data,
                type: 'items',
                event
            };
        }
    }
    else if (groupIndex !== undefined && levelIndex != undefined) {
        if (groupDraggable && groupDraggable(levelsArray[levelIndex][groupIndex].item)) {
            context = {
                group: levelsArray[levelIndex][groupIndex].item,
                groupIndex: groupIndex,
                type: 'xAxisTickLabel',
                event
            };
        }
    }
    return context;
}
function getChartDropContext(xSpace, ySpace, plotAreaSpace, event) {
    //We search for the key using the target of the event
    const offSetX = event.offsetX;
    const offSetY = event.offsetY;
    let context;
    if (utils$1.inSpace(offSetX, offSetY, xSpace)) {
        context = {
            type: 'xAxis',
            x: offSetX - xSpace.x,
            event
        };
    }
    else if (utils$1.inSpace(offSetX, offSetY, ySpace)) {
        context = {
            type: 'yAxis',
            y: offSetY - ySpace.y,
            event
        };
    }
    else if (utils$1.inSpace(offSetX, offSetY, plotAreaSpace)) {
        context = {
            type: 'plotArea',
            x: offSetX - plotAreaSpace.x,
            y: offSetY - plotAreaSpace.y,
            event
        };
    }
    return context;
}
function isChartDraggable(series, levelsArray, getDataItem, groupDraggable, itemsDraggable) {
    if (groupDraggable) {
        for (let levelIndex = 0; levelIndex < levelsArray.length; levelIndex++) {
            const groupItems = levelsArray[levelIndex];
            for (let groupIndex = 0; groupIndex < groupItems.length; groupIndex++) {
                if (groupDraggable(levelsArray[levelIndex][groupIndex].item) === 'on') {
                    return true;
                }
            }
        }
    }
    if (itemsDraggable && getDataItem) {
        const leafgroups = levelsArray[levelsArray.length - 1];
        for (let i = 0; i < leafgroups.length; i++) {
            for (let j = 0; j < series.length; j++) {
                if (getDataItem(j, i, leafgroups[i].path) &&
                    itemsDraggable(getDataItem(j, i, leafgroups[i].path), j, i) === 'on') {
                    return true;
                }
            }
        }
    }
    return false;
}
function getDragImageElements(rootRef, context, event) {
    const elems = [];
    let elem;
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    const container = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    let width;
    let height;
    if (context?.type === 'items') {
        const items = context.items;
        // only component specific
        for (let i = 0; i < items.length; i++) {
            elem = rootRef.current?.querySelector(`[data-oj-private-series-index="${items[i].seriesIndex}"][data-oj-private-group-index="${items[i].groupIndex}"]`);
            if (elem)
                elems.push(elem);
        }
    }
    else if (context?.type === 'xAxisTickLabel') {
        elem = rootRef.current?.querySelector(`[data-oj-private-group-index="${context?.groupIndex}"]`);
        if (elem)
            elems.push(elem);
    }
    if (elems.length > 0) {
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        for (let i = 0; i < elems.length; i++) {
            const bbox = elems[i].getBBox();
            if (bbox.x < minX) {
                minX = bbox.x;
            }
            if (bbox.x + bbox.width > maxX) {
                maxX = bbox.x + bbox.width;
            }
            if (bbox.y < minY) {
                minY = bbox.y;
            }
            if (bbox.y + bbox.height > maxY) {
                maxY = bbox.y + bbox.height;
            }
        }
        // Call getComputedStyles for font on the rootref
        const styles = window.getComputedStyle(elems[0].parentElement);
        for (let i = 0; i < elems.length; i++) {
            elem = elems[i];
            const clone = elem.cloneNode(true);
            container.appendChild(clone);
        }
        container.setAttribute('transform', `translate(${-minX},${-minY})`);
        container.style.fontSize = styles.getPropertyValue('font-size');
        container.style.fontFamily = styles.getPropertyValue('font-family');
        container.style.textAnchor = styles.getPropertyValue('text-anchor');
        container.style.dominantBaseline = styles.getPropertyValue('dominant-baseline');
        width = maxX - minX;
        height = maxY - minY;
        svg.appendChild(container);
        return {
            image: svg,
            offSetX: event.offsetX - minX,
            offSetY: event.offsetY - minY,
            width,
            height
        };
    }
    return null;
}

const useChartDnd = ({ onDragStart, onDrag, onDragEnd, onDragEnter, onDragLeave, onDragOver, onDrop, rootRef, series, selectedIds, levelsArray, getDataItem, groupDraggable, itemsDraggable, xSpace, ySpace, plotAreaSpace, setDragOver, setDatatipDisabled, onSelectionChange }) => {
    const draggable = isChartDraggable(series, levelsArray, getDataItem, groupDraggable, itemsDraggable);
    const getDragContext = function (target, event) {
        return getChartDragContext(target, levelsArray, rootRef, event, selectedIds, series, getDataItem, groupDraggable, itemsDraggable);
    };
    const getDropContext = function (event) {
        const context = getChartDropContext(xSpace, ySpace, plotAreaSpace, event);
        return context;
    };
    const getChartDragImage = function (props) {
        return getDragImageElements(rootRef, props.context, props.event);
    };
    const onPreDndStart = function (context) {
        if (context?.type === 'items') {
            const items = context.items;
            const ids = items.map((item) => item.data.id);
            const data = items.map((item) => item.data);
            onSelectionChange?.({ ids: [...ids], data: [...data] });
        }
    };
    const showDropEffect = function (context) {
        setDragOver({
            accepted: true,
            type: context.type
        });
    };
    const showRejectedDropEffect = function (context) {
        setDragOver({
            accepted: false,
            type: context.type
        });
    };
    const clearDropEffect = function () {
        setDragOver({
            accepted: undefined,
            type: ''
        });
    };
    const { dragProps, dropProps, content } = useDnd.useDnd({
        onDragStart,
        onDrag,
        onDragEnd,
        onDragEnter,
        onDragLeave,
        onDragOver,
        onDrop,
        getDragContext,
        getDropContext,
        getDragImage: getChartDragImage,
        onPreDndStart,
        setDatatipDisabled,
        showRejectedDropEffect,
        showDropEffect,
        clearDropEffect
    });
    return {
        draggable: draggable,
        dndProps: draggable ? { ...dragProps, ...dropProps } : dropProps,
        dndContent: content
    };
};

exports.useChartDnd = useChartDnd;
//# sourceMappingURL=useChartDnd-2c152d6b.js.map
