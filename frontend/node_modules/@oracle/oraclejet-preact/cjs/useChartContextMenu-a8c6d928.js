/* @oracle/oraclejet-preact: undefined */
'use strict';

var useContextMenu = require('./useContextMenu-e90f401c.js');
require('preact/jsx-runtime');
require('./SelectMenuGroupContext-ae5e1373.js');
require('preact/hooks');
require('preact');
require('./logger-2b636482.js');
require('./LayerHost-aee0e070.js');
require('preact/compat');


require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js');
require('./tooltipUtils-ae48fed6.js');

require('./UNSAFE_Menu/themes/MenuItemStyles.css.js');
require('./UNSAFE_Separator/themes/SeparatorStyles.css.js');


require('./UNSAFE_Menu/themes/redwood/MenuSeparatorVariants.css.js');

var eventsUtils = require('./eventsUtils-d34f8647.js');
require('./accUtils-5c7d3255.js');
var layoutUtils = require('./layoutUtils-e52005dc.js');

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
function getChartContextMenuContext(focusedItemInfo, focusedGroupInfo, gesture, target, series, levelsArray, rootRef, xAxisTitle, yAxisTitle, getDataItem) {
    let seriesIndex;
    let groupIndex;
    let levelIndex;
    if (gesture === 'keyboard') {
        //We find the element where the position of the menu is going to be based of
        groupIndex = focusedItemInfo.groupIndex;
        seriesIndex = focusedItemInfo.seriesIndex;
        levelIndex = focusedGroupInfo.levelIndex;
    }
    else {
        //We search for the key using the target of the event
        const info = eventsUtils.getInfo(rootRef, target);
        seriesIndex = info ? info.seriesIndex : undefined;
        groupIndex = info ? info.groupIndex : undefined;
        levelIndex = info ? info.levelIndex : undefined;
    }
    let context;
    if (seriesIndex !== undefined && groupIndex !== undefined && getDataItem) {
        const groupPath = levelsArray[levelsArray.length - 1]?.[groupIndex]?.path;
        const data = getDataItem(seriesIndex, groupIndex, groupPath);
        context = {
            data,
            groupIndex,
            seriesIndex,
            type: 'item'
        };
    }
    else if (seriesIndex !== undefined) {
        context = {
            data: series[seriesIndex],
            type: 'series'
        };
    }
    else if (groupIndex !== undefined && levelIndex != undefined) {
        context = {
            data: levelsArray[levelIndex]?.[groupIndex],
            type: 'xAxisTickLabel'
        };
    }
    else {
        const target = event?.target;
        const text = target?.textContent;
        if ((text && gesture !== 'keyboard' && text === xAxisTitle) || text === yAxisTitle) {
            context = {
                type: 'axisTitle',
                axis: text === xAxisTitle ? 'x' : 'y'
            };
        }
        else {
            context = {
                type: 'background'
            };
        }
    }
    return {
        context: context
    };
}

const useChartContextMenu = ({ isRtl, width, getDataItemPosition, getDataItem, focusedItemInfo, focusedGroupInfo, series, levelsArray, rootRef, xAxisTitle, yAxisTitle, contextMenuConfig, onContextMenuDismissed }) => {
    const { contextMenuProps, contextMenuContent } = useContextMenu.useContextMenu({
        onContextMenuHandler: ({ gesture, target }) => {
            const { context } = getChartContextMenuContext(focusedItemInfo, focusedGroupInfo, gesture, target, series, levelsArray, rootRef, xAxisTitle, yAxisTitle, getDataItem);
            if (gesture === 'keyboard' && context.type === 'item') {
                const elementBounds = focusedItemInfo?.isCurrent
                    ? getDataItemPosition(focusedItemInfo.seriesIndex, focusedItemInfo.groupIndex)
                    : undefined;
                const offsetValue = layoutUtils.calculateOffset(isRtl, width, elementBounds);
                return {
                    type: 'offset',
                    context,
                    offsetValue,
                    isRtl,
                    width
                };
            }
            return { type: 'pointer', context };
        },
        contextMenuOptions: {
            isDisabled: !contextMenuConfig //If there is not a context menu renderer we disable the hook
        },
        rootRef,
        contextMenuConfig,
        onContextMenuDismissed
    });
    return { contextMenuContent, contextMenuProps };
};

exports.useChartContextMenu = useChartContextMenu;
//# sourceMappingURL=useChartContextMenu-a8c6d928.js.map
