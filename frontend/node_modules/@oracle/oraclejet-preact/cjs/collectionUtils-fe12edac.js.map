{"version":3,"file":"collectionUtils-fe12edac.js","sources":["../../src/utils/PRIVATE_collectionUtils/collectionUtils.ts"],"sourcesContent":["import type { RefObject } from 'preact';\nimport { ViewportConfig } from '../../hooks/UNSAFE_useViewportIntersect';\nimport { SelectionRangeDetail } from '../../hooks/PRIVATE_useSelection';\nimport { ListItemRendererContext } from '../../UNSAFE_Collection';\nimport { isKeyDefined } from '../UNSAFE_keys';\nimport { getClientHints } from '../PRIVATE_clientHints';\nimport { FocusableElement } from '../PRIVATE_tabbableUtils';\n\n/**\n * Item selector for collection components\n */\nexport const ITEM_SELECTOR = '[data-oj-key]';\n\n/**\n * Returns the key from the item element\n */\nexport const getKey = (item: HTMLElement) => {\n  return item.dataset['ojKeyType'] === 'number'\n    ? Number(item.dataset['ojKey'])\n    : item.dataset['ojKey'];\n};\n\n/**\n * A helper function that return the key of the first available item.\n */\nexport const getFirstVisibleKey = (root: HTMLElement, itemSelector: string) => {\n  if (root) {\n    const firstItem = root.querySelector(itemSelector);\n    if (firstItem) {\n      const key = getKey(firstItem as HTMLElement);\n      return key;\n    }\n  }\n  return null;\n};\n\n/**\n * A helper function to find the element with the specified key.\n * Returns null if the element with key is not found.\n */\nexport const findElementByKey = <K extends string | number>(\n  root: HTMLElement,\n  key: K,\n  itemSelector: string\n) => {\n  if (root) {\n    const items = root.querySelectorAll(itemSelector);\n    for (let i = 0; i < items.length; i++) {\n      const thisKey = getKey(items[i] as HTMLElement);\n      if (key == (thisKey as K)) {\n        return items[i];\n      }\n    }\n  }\n  return null;\n};\n\n/**\n * A helper function that returns the key of the previous or the next item\n * given the specified current key by traversing indices instead of sibling elements.\n */\nexport const getPrevNextKey = <K extends string | number>(\n  root: HTMLElement | null,\n  currentKey: K | undefined,\n  isPrev: boolean,\n  itemSelector: string\n) => {\n  return (): K | null => {\n    let currItem, currIndex;\n    if (isKeyDefined(currentKey) && root) {\n      const items = root.querySelectorAll(itemSelector);\n      for (let i = 0; i < items.length; i++) {\n        if (getKey(items[i] as HTMLElement) === currentKey) {\n          currItem = items[i];\n          currIndex = i;\n          break;\n        }\n      }\n      if (currItem) {\n        currIndex = currIndex ? currIndex : 0;\n        const nextItem = isPrev ? items[currIndex - 1] : items[currIndex + 1];\n        if (nextItem) {\n          const key = getKey(nextItem as HTMLElement) as K;\n          if (key != null) {\n            return key;\n          }\n        }\n        // no next item or next item is not a valid item\n        return null;\n      }\n      const firstItem = items[0] as HTMLElement;\n      return getKey(firstItem) as K;\n    }\n    return null;\n  };\n};\n\n/**\n * A helper wrapper function so we use ref as root instead of a HTMLElement for prev/next currentKey behavior.\n * Used in comps that have a initialSelection due to this bug: JET-59240\n */\nexport const getPrevNextKeyUsingRef = <K extends string | number>(\n  root: RefObject<HTMLElement>,\n  currentKey: K | undefined,\n  isPrev: boolean,\n  itemSelector: string\n) => {\n  return (): K | null => {\n    return getPrevNextKey(root.current, currentKey, isPrev, itemSelector)();\n  };\n};\n\n/**\n * A helper function that returns the key of the previous or the next item by count,\n * given the specified current key\n */\nexport const getPrevNextKeyByCount = <K, D>(\n  data: D[] | null,\n  getRowKey: (data: D) => K,\n  currentKey?: K,\n  count = 0\n) => {\n  return (): K | null => {\n    if (data && currentKey != undefined) {\n      const currIndex = data.findIndex((d) => {\n        return getRowKey(d) === currentKey;\n      });\n      const nextIndex = currIndex + count;\n      if (0 <= nextIndex && nextIndex < data.length) {\n        return getRowKey(data[nextIndex]);\n      }\n      return null;\n    }\n    return null;\n  };\n};\n\n/**\n * A helper function to get the key from an element\n */\nexport const keyExtractor = <K extends string | number>(\n  element: HTMLElement,\n  itemSelector: string\n): K | null => {\n  const item = element.closest(itemSelector);\n  if (item) {\n    const key = getKey(item as HTMLElement) as K;\n    return key === undefined ? null : key;\n  }\n  return null;\n};\n\n/**\n * If excludeSelf is true, returns a function that determines if a given element is a descendent\n * of the root element. Otherwise, returns a function that determines if a given element is the\n * root element or is a descendant of the root element.\n */\nexport const getElementContainsFunc = (root?: HTMLElement | null, excludeSelf?: boolean) => {\n  return (elem: Element | null) => {\n    if (root != null) {\n      return excludeSelf ? root !== elem && root.contains(elem) : root.contains(elem);\n    }\n    return false;\n  };\n};\n\n/**\n * A helper function to that return viewPortConfig to collection components\n */\nexport const getViewportConfig = (rootRef: RefObject<HTMLElement>, config?: ViewportConfig) => {\n  return (\n    config ?? {\n      scroller: () => {\n        return rootRef.current;\n      }\n    }\n  );\n};\n\n/**\n * A helper function to handle range selection\n */\nexport const handleSelectionRange = <K, D>(\n  detail: SelectionRangeDetail<K>,\n  data: D[],\n  getRowKey: (data: D) => K\n) => {\n  const keys = data.map((value: D) => {\n    return getRowKey(value);\n  });\n  const startIndex = keys.indexOf(detail.value.start);\n  const endIndex = keys.indexOf(detail.value.end);\n  const minIndex = Math.min(startIndex, endIndex);\n  const maxIndex = Math.max(startIndex, endIndex);\n  if (minIndex === -1) {\n    // return a range to fetch so we can find all the keys, maxIndex should not be -1\n    return { offset: 0, count: -1 };\n  } else {\n    // range of keys are in the current viewport, return them\n    return keys.slice(minIndex, maxIndex + 1);\n  }\n};\n\n/**\n * Helper function to determine whether the current device is a mobile device\n * @returns true if running on a mobile device, false otherwise\n */\nexport function isMobile() {\n  const deviceType = getClientHints().deviceType;\n  return deviceType === 'phone' || deviceType === 'tablet';\n}\n\n/**\n * Handle setting focus where required when entering actionable mode, or exiting actionable mode if\n * no tabbable children are found.\n */\nexport function handleEnterActionableMode<K>(\n  hasFocusWithin: boolean,\n  tabbableElements: FocusableElement[],\n  setCurrentTabbableKey: (key?: K) => void,\n  isPreventScroll?: boolean\n) {\n  if (!hasFocusWithin) {\n    const tabbableCount = tabbableElements.length;\n    if (tabbableCount > 0) {\n      tabbableElements[0].focus({ preventScroll: isPreventScroll ? isPreventScroll : false });\n    } else {\n      // exit actionable mode as there are no tabbable children\n      setCurrentTabbableKey(undefined);\n    }\n  }\n}\n\n/**\n * Handle wrapping focus to the correct tabbable child when either trap edge is focused. Will also\n * exit actionable mode if no tabbable children are found, though that should not happen in practice.\n */\nexport function handleWrapActionableFocus<K>(\n  isStart: boolean,\n  tabbableElements: FocusableElement[],\n  setCurrentTabbableKey: (key?: K) => void\n) {\n  const tabbableCount = tabbableElements.length;\n  if (tabbableCount > 0) {\n    if (isStart) {\n      tabbableElements[tabbableCount - 1].focus();\n    } else {\n      tabbableElements[0].focus();\n    }\n  } else {\n    // exit actionable mode as there are no tabbable children\n    setCurrentTabbableKey(undefined);\n  }\n}\n\n/**\n * Compare the equality between two ListItemRendererContexts, especially useful for memoized items\n */\nexport const compareListItemContext = <K, D>(\n  ctx1: ListItemRendererContext<K, D>,\n  ctx2: ListItemRendererContext<K, D>\n) => {\n  // deliberately leave out index as that would change when an item is inserted/removed/moved\n  return (\n    ctx1.data === ctx2.data &&\n    ctx1.isSelected === ctx2.isSelected &&\n    ctx1.metadata.key === ctx2.metadata.key\n  );\n};\n\n/**\n * A helper function that returns an array of keys for the items.\n */\nexport const getItemKeysArray = (root: HTMLElement, itemSelector: string) => {\n  return Array.from(root.querySelectorAll(itemSelector)).map((elem) => getKey(elem as HTMLElement));\n};\n\n/**\n * A helper function that is used in reorder feature to allow auto scrolling during dragging an item\n */\nexport const dragToScroll = (\n  event: DragEvent,\n  isDragging: boolean,\n  rootElement: HTMLElement | null\n) => {\n  const speed = 10;\n  const threshold = 50;\n  if (rootElement != null && isDragging) {\n    const rootElementTop = rootElement.getBoundingClientRect().top;\n    if (event.clientY < rootElementTop + threshold) {\n      rootElement.scrollBy(0, -speed);\n    } else if (event.clientY > rootElementTop + rootElement.clientHeight - threshold) {\n      rootElement.scrollBy(0, speed);\n    }\n  }\n};\n"],"names":["isKeyDefined","getClientHints"],"mappings":"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"}