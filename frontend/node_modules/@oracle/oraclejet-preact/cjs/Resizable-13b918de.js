/* @oracle/oraclejet-preact: undefined */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
var classNames = require('./classNames-c14c6ef3.js');
var PRIVATE_Resizable_themes_ResizableStyles_css = require('./PRIVATE_Resizable/themes/ResizableStyles.css.js');
var positionUtils = require('./positionUtils-a780137e.js');

var ResizeEdge;
(function (ResizeEdge) {
    ResizeEdge[ResizeEdge["NONE"] = 0] = "NONE";
    ResizeEdge[ResizeEdge["N"] = 1] = "N";
    ResizeEdge[ResizeEdge["NE"] = 2] = "NE";
    ResizeEdge[ResizeEdge["E"] = 3] = "E";
    ResizeEdge[ResizeEdge["SE"] = 4] = "SE";
    ResizeEdge[ResizeEdge["S"] = 5] = "S";
    ResizeEdge[ResizeEdge["SW"] = 6] = "SW";
    ResizeEdge[ResizeEdge["W"] = 7] = "W";
    ResizeEdge[ResizeEdge["NW"] = 8] = "NW";
})(ResizeEdge || (ResizeEdge = {}));
/**
 * A component that adds resize capability to a component. Fires the onResize event whenever
 * a potential resize gesture is detected. It is up to the consuming component to update its
 * position and dimensions when appropriate.
 */
function Resizable({ onResize, onResizeStart, onResizeEnd, containerRef, constraints }) {
    const isResizing = hooks.useRef(false);
    const resizingEdge = hooks.useRef(ResizeEdge.NONE);
    const startPosition = hooks.useRef();
    const initialParentClientRect = hooks.useRef({ x: 0, y: 0, width: 0, height: 0 });
    const initialMousePosition = hooks.useRef({ x: 0, y: 0 });
    const findPos = (element) => {
        let elem = element;
        let curLeft = 0;
        let curTop = 0;
        if (elem.offsetParent) {
            do {
                curLeft += elem.offsetLeft;
                curTop += elem.offsetTop;
            } while ((elem = elem.offsetParent));
        }
        return { left: curLeft, top: curTop };
    };
    /**
     * Constrains rect to the current containing block
     */
    const constrainRect = hooks.useCallback((srcRect) => {
        const elem = containerRef?.current;
        const result = {
            x: srcRect.x,
            y: srcRect.y,
            width: srcRect.width,
            height: srcRect.height
        };
        if (!elem)
            return result;
        const containingBlock = positionUtils.getContainingBlockElem(elem);
        const boundingRect = containingBlock?.getBoundingClientRect();
        const dialogRect = elem.getBoundingClientRect();
        const limitLeft = boundingRect ? boundingRect.left : 0;
        const limitTop = boundingRect ? boundingRect.top : 0;
        const limitRight = boundingRect ? boundingRect.right : window.innerWidth;
        const limitBottom = boundingRect ? boundingRect.bottom : window.innerHeight;
        // make sure the new rectangle fits in the min/max constraints and viewport limits
        if ((constraints?.minHeight && result.height < constraints.minHeight) ||
            (constraints?.maxHeight && result.height > constraints.maxHeight)) {
            result.y = dialogRect.y;
            result.height = dialogRect.height;
        }
        else {
            if (result.y < limitTop) {
                result.y = limitTop;
                result.height = dialogRect.height;
            }
            if (result.y + result.height > limitBottom) {
                result.height = dialogRect.height;
            }
        }
        if ((constraints?.minWidth && result.width < constraints.minWidth) ||
            (constraints?.maxWidth && result.width > constraints.maxWidth)) {
            result.x = dialogRect.x;
            result.width = dialogRect.width;
        }
        else {
            if (result.x < limitLeft) {
                result.x = limitLeft;
                result.width = dialogRect.width;
            }
            if (result.x + result.width > limitRight) {
                result.width = dialogRect.width;
            }
        }
        return result;
    }, [containerRef, constraints]);
    /**
     * Calculates the new rect coordinates for a given mouse event
     */
    const getNewRect = hooks.useCallback((event) => {
        let left = 0;
        let width = 0;
        let top = 0;
        let height = 0;
        switch (resizingEdge.current) {
            case ResizeEdge.N:
                top = event.pageY - initialMousePosition.current.y;
                height = initialMousePosition.current.y - event.pageY;
                break;
            case ResizeEdge.E:
                width = event.pageX - initialMousePosition.current.x;
                break;
            case ResizeEdge.S:
                height = event.pageY - initialMousePosition.current.y;
                break;
            case ResizeEdge.W:
                left = event.pageX - initialMousePosition.current.x;
                width = initialMousePosition.current.x - event.pageX;
                break;
            case ResizeEdge.NE:
                top = event.pageY - initialMousePosition.current.y;
                width = event.pageX - initialMousePosition.current.x;
                height = initialMousePosition.current.y - event.pageY;
                break;
            case ResizeEdge.SE:
                width = event.pageX - initialMousePosition.current.x;
                height = event.pageY - initialMousePosition.current.y;
                break;
            case ResizeEdge.SW:
                left = event.pageX - initialMousePosition.current.x;
                width = initialMousePosition.current.x - event.pageX;
                height = event.pageY - initialMousePosition.current.y;
                break;
            case ResizeEdge.NW:
                left = event.pageX - initialMousePosition.current.x;
                top = event.pageY - initialMousePosition.current.y;
                width = initialMousePosition.current.x - event.pageX;
                height = initialMousePosition.current.y - event.pageY;
                break;
        }
        const newRect = {
            x: initialParentClientRect.current.x + left,
            y: initialParentClientRect.current.y + top,
            width: initialParentClientRect.current.width + width,
            height: initialParentClientRect.current.height + height
        };
        const newConstrainedRect = constrainRect(newRect);
        return newConstrainedRect;
    }, [constrainRect]);
    /**
     * Handles mousedown events while the 'resize' mode is active.
     */
    const handleResize = hooks.useCallback((event) => {
        if (!isResizing.current)
            return;
        if (!startPosition.current)
            return;
        const newRect = getNewRect(event);
        onResize?.(newRect);
        event.stopPropagation();
        event.preventDefault();
    }, [onResize, getNewRect]);
    /**
     * Handles mouseup event to exit the 'resize' mode.
     */
    const endResize = hooks.useCallback((event) => {
        isResizing.current = false;
        document.removeEventListener('mousemove', handleResize, true);
        document.removeEventListener('mouseup', endResize, true);
        const newRect = getNewRect(event);
        onResizeEnd?.(newRect);
        resizingEdge.current = ResizeEdge.NONE;
        event.preventDefault();
        event.stopPropagation();
    }, [getNewRect, onResizeEnd, handleResize]);
    /**
     * Handles mousedown event to enter the 'resize mode.
     */
    const startResize = hooks.useCallback((event) => {
        const elem = event.currentTarget;
        if (!elem || !elem.parentElement)
            return;
        const pos = findPos(elem.parentElement);
        isResizing.current = true;
        document.addEventListener('mousemove', handleResize, true);
        document.addEventListener('mouseup', endResize, true);
        initialParentClientRect.current = elem.parentElement.getBoundingClientRect();
        startPosition.current = { x: pos.left, y: pos.top };
        initialMousePosition.current = { x: event.pageX, y: event.pageY };
        const newRect = getNewRect(event);
        onResizeStart?.(newRect);
    }, [getNewRect, onResizeStart, handleResize, endResize]);
    const startResizeN = (event) => {
        startResize(event);
        if (isResizing.current) {
            resizingEdge.current = ResizeEdge.N;
        }
    };
    const startResizeE = (event) => {
        startResize(event);
        if (isResizing.current) {
            resizingEdge.current = ResizeEdge.E;
        }
    };
    const startResizeS = (event) => {
        startResize(event);
        if (isResizing.current) {
            resizingEdge.current = ResizeEdge.S;
        }
    };
    const startResizeW = (event) => {
        startResize(event);
        if (isResizing.current) {
            resizingEdge.current = ResizeEdge.W;
        }
    };
    const startResizeNE = (event) => {
        startResize(event);
        if (isResizing.current) {
            resizingEdge.current = ResizeEdge.NE;
        }
    };
    const startResizeSE = (event) => {
        startResize(event);
        if (isResizing.current) {
            resizingEdge.current = ResizeEdge.SE;
        }
    };
    const startResizeSW = (event) => {
        startResize(event);
        if (isResizing.current) {
            resizingEdge.current = ResizeEdge.SW;
        }
    };
    const startResizeNW = (event) => {
        startResize(event);
        if (isResizing.current) {
            resizingEdge.current = ResizeEdge.NW;
        }
    };
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("div", { class: classNames.classNames([PRIVATE_Resizable_themes_ResizableStyles_css.baseStyle, PRIVATE_Resizable_themes_ResizableStyles_css.styles.handleN]), onMouseDown: startResizeN }), jsxRuntime.jsx("div", { class: classNames.classNames([PRIVATE_Resizable_themes_ResizableStyles_css.baseStyle, PRIVATE_Resizable_themes_ResizableStyles_css.styles.handleE]), onMouseDown: startResizeE }), jsxRuntime.jsx("div", { class: classNames.classNames([PRIVATE_Resizable_themes_ResizableStyles_css.baseStyle, PRIVATE_Resizable_themes_ResizableStyles_css.styles.handleS]), onMouseDown: startResizeS }), jsxRuntime.jsx("div", { class: classNames.classNames([PRIVATE_Resizable_themes_ResizableStyles_css.baseStyle, PRIVATE_Resizable_themes_ResizableStyles_css.styles.handleW]), onMouseDown: startResizeW }), jsxRuntime.jsx("div", { class: classNames.classNames([PRIVATE_Resizable_themes_ResizableStyles_css.baseStyle, PRIVATE_Resizable_themes_ResizableStyles_css.styles.handleNE]), onMouseDown: startResizeNE }), jsxRuntime.jsx("div", { class: classNames.classNames([PRIVATE_Resizable_themes_ResizableStyles_css.baseStyle, PRIVATE_Resizable_themes_ResizableStyles_css.styles.handleSE]), onMouseDown: startResizeSE }), jsxRuntime.jsx("div", { class: classNames.classNames([PRIVATE_Resizable_themes_ResizableStyles_css.baseStyle, PRIVATE_Resizable_themes_ResizableStyles_css.styles.handleSW]), onMouseDown: startResizeSW }), jsxRuntime.jsx("div", { class: classNames.classNames([PRIVATE_Resizable_themes_ResizableStyles_css.baseStyle, PRIVATE_Resizable_themes_ResizableStyles_css.styles.handleNW]), onMouseDown: startResizeNW })] }));
}

exports.Resizable = Resizable;
//# sourceMappingURL=Resizable-13b918de.js.map
