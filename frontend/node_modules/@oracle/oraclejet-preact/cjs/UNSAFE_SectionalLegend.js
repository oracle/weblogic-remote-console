/* @oracle/oraclejet-preact: undefined */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('preact/jsx-runtime');
var compat = require('preact/compat');
var hooks = require('preact/hooks');
var useVisEvents = require('./useVisEvents-9b21e260.js');
var mergeProps = require('./mergeProps-e3da7237.js');
var layoutUtils = require('./layoutUtils-e52005dc.js');
var useLegendDnd = require('./useLegendDnd-47d9f5ba.js');
var useLegendContextMenu = require('./useLegendContextMenu-2a905d60.js');
var useItemFocus = require('./useItemFocus-0c5fbee7.js');
var Flex = require('./Flex-6ca216a7.js');
var PRIVATE_BaseLegend_themes_LegendStyles_css = require('./PRIVATE_BaseLegend/themes/LegendStyles.css.js');
var useCssVars = require('./useCssVars-cc025013.js');
var classNames = require('./classNames-c14c6ef3.js');
var useTestId = require('./useTestId-9093a54b.js');
var useVisTouchResponse = require('./useVisTouchResponse-376e11d5.js');
var stringUtils = require('./stringUtils-3e19c8af.js');
var useTextDimensions = require('./useTextDimensions-c8b41697.js');
var TrackResizeContainer = require('./TrackResizeContainer-100be103.js');
var hooks_PRIVATE_useVisDnd_themes_VisDndStyles_css = require('./hooks/PRIVATE_useVisDnd/themes/VisDndStyles.css.js');
require('./useUser-f900ddf1.js');
require('./LayerHost-aee0e070.js');
require('./index-15e13649.js');
require('preact');
require('./UNSAFE_Layer/themes/LayerHostStyles.css.js');

require('./eventsUtils-d34f8647.js');
require('./useVisHover-ad36112d.js');
require('./datatipUtils-d1ca81a1.js');
require('./clientUtils-a4619fcd.js');
require('./clientHints-c40c5250.js');
require('./useDnd-a7d9b60c.js');
require('./themeContract.css-a53fd740.js');
require('./utils-a66430fc.js');
require('./colorUtils-01f3caa2.js');
require('./_curry1-e8f0d7ea.js');
require('./SvgSymbol-d6be74d9.js');
require('./Marker-b40392cc.js');
require('./PRIVATE_SvgShapes/themes/SvgShapesStyles.css.js');

require('./Text-436e8b56.js');
require('./mergeInterpolations-6727b536.js');
require('./mergeDeepWithKey-210b024d.js');
require('./_curry3-18677bca.js');
require('./_curry2-c15d89cd.js');
require('./_isObject-28636267.js');
require('./UNSAFE_Text/themes/TextStyles.css.js');

require('./vanilla-extract-recipes-createRuntimeFn.esm-d1301b2d.js');
require('./useDatatip-4f6d3759.js');
require('./Layer-28b1afce.js');
require('./UNSAFE_Layer/themes/LayerStyles.css.js');

require('./useThemeInterpolations-4faece98.js');
require('./useColorScheme-23e4aab4.js');
require('./useScale-adc62f41.js');
require('./theme-dfd6a9fe.js');
require('./Theme-f06687af.js');
require('./useDensity-022a8f80.js');
require('./unsafeDomAccess-c3a492f0.js');
require('./Floating-5a704a27.js');
require('./useFloating-13101293.js');
require('./positionUtils-a780137e.js');
require('./refUtils-a9872e75.js');
require('./useOutsideClick-c3802f86.js');
require('./arrayUtils-7d8dcfc3.js');
require('./useModal-0739a528.js');
require('./useComponentTheme-082fc8e4.js');
require('./logger-2b636482.js');
require('./UNSAFE_Floating/themes/redwood/FloatingTheme.js');
require('./UNSAFE_Floating/themes/FloatingStyles.css.js');

require('./UNSAFE_Floating/themes/redwood/FloatingBaseTheme.css.js');

require('./UNSAFE_Floating/themes/redwood/FloatingVariants.css.js');
require('./vanilla-extract-dynamic.esm-2e1b7c25.js');
require('./UNSAFE_Floating/themes/FloatingContract.css.js');
require('./useUnsafeDomElementRef-f22a2f0c.js');
require('./hooks/PRIVATE_useDatatip/themes/useDatatip.css.js');

require('./useId-6c0eeb27.js');
require('./useContextMenu-e90f401c.js');
require('./SelectMenuGroupContext-ae5e1373.js');
require('./Sheet-44b25f1d.js');
require('./Modal-0cea796e.js');
require('./UNSAFE_Modal/themes/ModalStyles.css.js');

require('./tabbableUtils-7e41d383.js');
require('./head-68d0992f.js');
require('./_arity-c228159c.js');
require('./_isArray-73160ad5.js');
require('./_isString-f4443c9e.js');
require('./popupUtils-488fe8f7.js');
require('./WindowOverlay-a10f995e.js');
require('./UNSAFE_WindowOverlay/themes/WindowOverlayStyles.css.js');

require('./UNSAFE_WindowOverlay/themes/WindowOverlayContract.css.js');
require('./UNSAFE_WindowOverlay/themes/redwood/WindowOverlayTheme.js');
require('./UNSAFE_WindowOverlay/themes/redwood/WindowOverlayBaseTheme.css.js');

require('./UNSAFE_WindowOverlay/themes/redwood/WindowOverlayVariants.css.js');
require('./UNSAFE_Sheet/themes/SheetStyles.css.js');

require('./useAnimationStatus-c0c14bcc.js');
require('./useAnimation-fb11e4cc.js');
require('./animationUtils-54852d03.js');
require('./useTranslationBundle-18b7bf8b.js');
require('./Dropdown-b2579045.js');
require('./keyboardUtils-b42fe7d5.js');
require('./usePopupAnimation-18040396.js');
require('./popupAnimationUtils-dcace427.js');
require('./CollectionInteractionContext-f84ff7a1.js');
require('./UNSAFE_Dropdown/themes/dropdownStyles.css.js');

require('./useOutsideMousedown-8f913d1a.js');
require('./UNSAFE_Menu/themes/MenuStyles.css.js');

require('./UNSAFE_Menu/themes/DropdownMenuStyles.css.js');

require('./Skeleton-e746e396.js');
require('./dimensions-2fcc0acf.js');
require('./size-0717c0bd.js');
require('./borders-4b8488cb.js');
require('./UNSAFE_Skeleton/themes/redwood/SkeletonTheme.js');
require('./UNSAFE_Skeleton/themes/SkeletonStyles.css.js');

require('./UNSAFE_Skeleton/themes/redwood/SkeletonBaseTheme.css.js');

require('./UNSAFE_Skeleton/themes/redwood/SkeletonVariants.css.js');
require('./UNSAFE_Menu/themes/MenuSkeletonStyles.css.js');

require('./LiveRegion-e410e187.js');

require('./UNSAFE_Menu/themes/redwood/MenuItemTheme.js');
require('./UNSAFE_Menu/themes/MenuItemStyles.css.js');

require('./UNSAFE_Menu/themes/redwood/MenuItemBaseTheme.css.js');

require('./UNSAFE_Menu/themes/redwood/MenuItemVariants.css.js');

require('./usePress-886180e4.js');
require('./flexitem-fee13e26.js');

require('./vanilla-extract-sprinkles-createRuntimeSprinkles.esm-d68f3e0f.js');
require('./useInteractionStyle-c203a8a0.js');
require('./useHover-49b0430d.js');
require('./useToggle-3ebba7d8.js');
require('./useActive-6770f917.js');


require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js');

require('./tooltipUtils-ae48fed6.js');
require('./EnvironmentProvider-8696a5b8.js');
require('./LayerManager-fc4df14f.js');

require('./UNSAFE_Separator/themes/SeparatorStyles.css.js');



require('./UNSAFE_Menu/themes/redwood/MenuSeparatorVariants.css.js');
require('./useContextMenuGesture-03ba6353.js');
require('./textSelectionUtils-432ab66b.js');
require('./boxalignment-6dde2812.js');

require('./flexbox-2cae9a01.js');



require('./useTheme-09dfbb78.js');
require('./useAddBusyState-d19ae1fa.js');
require('./BusyStateContext-86f40d3c.js');
require('./useBusyStateContext-362eee2a.js');
require('./useSize-8115eae0.js');
require('./useResizeObserver-a9e97180.js');


/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
function getItem(itemInfo, sections) {
    const { sectionIdx, itemIdx } = itemInfo;
    if (sectionIdx == -1 && itemIdx == -1) {
        const itemsLength = sections[sections.length - 1].items.length;
        return sections[sections.length - 1].items[itemsLength - 1];
    }
    return sections[sectionIdx].items[itemIdx];
}
function getNextItemInfo(itemInfo, sections) {
    let { itemIdx, sectionIdx } = itemInfo;
    if (sectionIdx == -1 && itemIdx == -1) {
        return {
            itemIdx: sections[sections.length - 1].items.length - 1,
            sectionIdx: sections.length - 1
        };
    }
    itemIdx += 1;
    const itemsLength = sections[sectionIdx].items.length;
    if (itemIdx >= itemsLength) {
        if (sectionIdx === sections.length - 1) {
            itemIdx = itemInfo.itemIdx;
        }
        else {
            sectionIdx += 1;
            itemIdx = 0;
        }
    }
    const item = sections[sectionIdx].items[itemIdx]; //TODO : Work for better fix instead of adding 'as LegendItem<D>'
    if (item?.actionable !== 'off') {
        return { itemIdx, sectionIdx };
    }
    return getNextItemInfo({ itemIdx, sectionIdx }, sections);
}
function getPrevItemInfo(itemInfo, sections) {
    let { itemIdx, sectionIdx } = itemInfo;
    if (sectionIdx == -1 && itemIdx == -1) {
        (itemIdx = sections[sections.length - 1].items.length - 1), (sectionIdx = sections.length - 1);
    }
    itemIdx -= 1;
    if (itemIdx < 0) {
        if (sectionIdx === 0) {
            itemIdx = 0;
        }
        else {
            itemIdx = sections[sectionIdx - 1].items.length - 1;
            sectionIdx -= 1;
        }
    }
    const item = sections[sectionIdx].items[itemIdx]; //TODO : Work for better fix instead of adding 'as LegendItem<D>'
    if (item?.actionable !== 'off') {
        return { itemIdx, sectionIdx };
    }
    return getPrevItemInfo({ itemIdx, sectionIdx }, sections);
}
/**
 * Returns utils functions for navigation in simple sectional legend.
 * @param items
 * @returns
 */
function getSectionalNavUtils(sections) {
    return {
        getItem: (itemInfo) => {
            return getItem(itemInfo, sections);
        },
        getDetailFromInfo: (itemInfo) => {
            if (!itemInfo || sections.length === 0) {
                return { itemId: undefined, sectionId: undefined, data: undefined };
            }
            const item = getItem(itemInfo, sections);
            const sectionId = sections[itemInfo.sectionIdx].id;
            return {
                itemId: item.id,
                sectionId: sectionId,
                data: sections[itemInfo.sectionIdx].items[itemInfo.itemIdx]
            };
        },
        getPrevItemInfo: (itemInfo) => {
            return getPrevItemInfo(itemInfo, sections);
        },
        getNextItemInfo: (itemInfo) => {
            return getNextItemInfo(itemInfo, sections);
        }
    };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const getSectionalLegendLayoutInfo = ({ width, getTextDimensions, resolvedVars, rootRef, orientation, legendFontStylesObj = {}, symbolWidth, symbolHeight, sections }) => {
    let maxWidth = 0;
    let maxHeight = 0;
    let totalWidth = 0;
    const containerWidth = width;
    if (!rootRef.current || !Object.keys(resolvedVars).length || !getTextDimensions) {
        return;
    }
    const unitLength = parseFloat(resolvedVars['unit']);
    let currentRowWidth = 0;
    let maxRowWidth = 0;
    const isSectionWrappedArray = [];
    const isLegendWrappedArray = [];
    const itemsPerRowArray = [];
    let legendHeight = 0;
    const paddingTop = 0.75 * unitLength;
    // const paddingBottom = 1.5 * unitLength;
    sections.forEach((section, index) => {
        let isSectionWrapped = false;
        let isLegendWrapped = false;
        let totalSectionalWidth;
        let rowsAndCol;
        // getTextDimensions calculating text height as +6 from orignal size
        const titleDims = getTextDimensions(section.title, { fontWeight: '600' });
        //0.5 is adjustment made as getTextdimensions is not calculating correct height
        const titleHeight = titleDims.height + paddingTop + 0.5;
        const titlePaddingStart = 3;
        const titleWidth = titleDims.width + titlePaddingStart;
        const { maxItemWidth, maxItemHeight, horizontalSectionWidth } = getMaxWidth(section.items, unitLength, getTextDimensions, legendFontStylesObj, symbolWidth, symbolHeight);
        let initialNumberOfItemsPerRow = section.items.length;
        const rowGap = 4 * unitLength;
        if (titleWidth + horizontalSectionWidth < containerWidth) {
            totalSectionalWidth = horizontalSectionWidth + titleWidth;
            if (currentRowWidth !== 0 &&
                currentRowWidth + rowGap + totalSectionalWidth < containerWidth &&
                !isLegendWrappedArray[index - 1]) {
                currentRowWidth = currentRowWidth + totalSectionalWidth + rowGap;
            }
            else {
                currentRowWidth = totalSectionalWidth;
                legendHeight += Math.max(titleHeight, maxItemHeight);
                if (index !== 0) {
                    legendHeight += rowGap;
                }
            }
        }
        else {
            isSectionWrapped = true;
            totalSectionalWidth = horizontalSectionWidth;
            const rowPadding = 0.4 * unitLength;
            if (horizontalSectionWidth > containerWidth) {
                isLegendWrapped = true;
                currentRowWidth = 0;
                initialNumberOfItemsPerRow = Math.floor(containerWidth / maxItemWidth);
                rowsAndCol = useLegendDnd.getSectionGridNums(section.items.length, initialNumberOfItemsPerRow);
                if (rowsAndCol.itemsPerCol && rowsAndCol.itemsPerRow) {
                    legendHeight += titleHeight + 2 * (maxItemHeight + rowPadding) + 2 * paddingTop;
                    currentRowWidth = rowsAndCol.itemsPerRow * maxItemWidth;
                    if (rowsAndCol.itemsPerCol > 2) {
                        //here padding gets added to top and bottom
                        legendHeight += (rowsAndCol.itemsPerCol - 2) * (maxItemHeight + 2 * rowPadding);
                    }
                }
            }
            else {
                currentRowWidth = totalSectionalWidth;
                legendHeight += maxItemHeight + titleHeight + 2 * paddingTop;
                if (index !== 0) {
                    legendHeight += rowGap;
                }
            }
        }
        maxRowWidth = Math.max(currentRowWidth, maxRowWidth);
        totalWidth += horizontalSectionWidth;
        maxWidth = Math.max(maxWidth, maxItemWidth);
        maxHeight = maxItemHeight;
        isSectionWrappedArray.push(isSectionWrapped);
        isLegendWrappedArray.push(isLegendWrapped);
        itemsPerRowArray.push(orientation === 'vertical' ? 1 : Math.max(1, initialNumberOfItemsPerRow));
    });
    const legendLayoutInfo = {
        maxRowWidth: Math.ceil(maxRowWidth),
        legendHeight,
        totalWidth,
        maxItemWidth: Math.min(maxWidth, containerWidth),
        maxItemHeight: Math.ceil(maxHeight),
        itemsPerRowArray,
        isSectionWrappedArray,
        isLegendWrappedArray
    };
    return legendLayoutInfo;
};
/**
 * Returns maximum of the width among the items in a section of legend also return the width of the entire section.
 * @param items Legend items array
 * @param unitLength Base  element
 * @param getTextDimensions Text width measurement function
 * @param legendFontStylesObj Legend text font style properties object
 * @param symbolWidth Width of legend symbol
 *
 * @returns
 */
const getMaxWidth = (items, unitLength, getTextDimensions, legendFontStylesObj, symbolWidth, symbolHeight) => {
    let maxItemWidth = 0;
    let maxItemHeight = 0;
    let horizontalSectionWidth = 0;
    let itemSymbolWidth = 0;
    let itemSymbolHeight = 0;
    const symbolPadding = unitLength * 1.5;
    if (symbolWidth) {
        itemSymbolWidth = symbolPadding + symbolWidth;
    }
    else {
        //below expression is simplified as, itemSymbolWidth = marginLeft + marginRight + width
        itemSymbolWidth = 4 * unitLength;
    }
    const paddingTop = 1.7 * unitLength;
    const defaultSymbolHeight = 2.5 * unitLength;
    if (symbolHeight) {
        // symbolHeight/defaultSymbolHeight + paddingTopBottom
        itemSymbolHeight = symbolHeight + paddingTop;
    }
    else {
        itemSymbolHeight = defaultSymbolHeight + paddingTop;
    }
    const paddingLeftRight = 2.5 * unitLength;
    items?.forEach((item) => {
        const legendItem = item;
        const { width, height } = getTextDimensions(legendItem.text, legendFontStylesObj);
        //itemTextWidth = paddingLeft + paddingRight + width
        const itemTextWidth = paddingLeftRight + width;
        //horizontalSectionWidth = total width of the section
        horizontalSectionWidth += itemSymbolWidth + itemTextWidth;
        maxItemWidth = Math.max(maxItemWidth, itemSymbolWidth + itemTextWidth);
        maxItemHeight = Math.max(maxItemHeight, height, itemSymbolHeight);
    });
    return { maxItemWidth, maxItemHeight, horizontalSectionWidth };
};

/**
 * A Sectional Legend allows grouping of legend items in sections with a specific title.
 */
const SectionalLegend = compat.forwardRef(({ orientation = 'horizontal', sectionTitleHAlign = 'start', sections, isReadOnly = true, onItemAction, onItemHover, onItemFocus, testId, contextMenuConfig, hideAndShowBehavior = 'off', hoverBehavior = 'none', valign = 'top', halign = 'start', ...props }, ref = null) => {
    return (jsxRuntime.jsx(TrackResizeContainer.TrackResizeContainer, { width: '100%', height: '100%', class: classNames.classNames([
            PRIVATE_BaseLegend_themes_LegendStyles_css.styles.flexStyle,
            PRIVATE_BaseLegend_themes_LegendStyles_css.styles[`${halign}HAlign`],
            PRIVATE_BaseLegend_themes_LegendStyles_css.styles[`${valign}VAlign`]
        ]), children: function _(width, _height) {
            const testIdProps = useTestId.useTestId(testId);
            const rootRef = hooks.useRef(null);
            const isTestEnv = testIdProps['data-testid'] !== undefined;
            const rootDimsRef = hooks.useRef();
            const { resolvedVars, cssContent } = useCssVars.useCssVars(useLegendDnd.legendVars);
            const { getItem, getDetailFromInfo, getPrevItemInfo, getNextItemInfo } = getSectionalNavUtils(sections);
            const legendFontStylesObj = useLegendDnd.getLegendTextStyle({
                fontStyle: props.textFontStyle,
                fontSize: props.textFontSize?.toString(),
                fontWeight: props.textFontWeight?.toString(),
                fontFamily: props.textFontFamily
            }, resolvedVars);
            const { textMeasureContent, getTextDimensions } = useTextDimensions.useTextDimensions();
            const isLegendItemActionable = useLegendDnd.getIsLegendItemActionable(sections, isReadOnly, true);
            const hasData = sections.length > 0;
            const layoutInfo = getSectionalLegendLayoutInfo({
                width,
                rootRef,
                getTextDimensions,
                resolvedVars,
                orientation,
                legendFontStylesObj,
                symbolWidth: props.symbolWidth,
                symbolHeight: props.symbolHeight,
                sections
            });
            const { touchResponse, touchResponseStyle } = useVisTouchResponse.useVisTouchResponse({ type: 'touchStart' });
            const { focusedItemInfo, hoveredItemInfo, onContextMenuDismissed, activeId, eventsProps } = useVisEvents.useVisEvent(touchResponse, !isReadOnly, isLegendItemActionable, useLegendDnd.getKeyUpHandler, getDetailFromInfo, getPrevItemInfo, getNextItemInfo, onItemAction, onItemHover, onItemFocus, useLegendDnd.isEqualItem, useLegendDnd.getItemInfo, { itemIdx: 0, sectionIdx: 0 });
            const { focusedItemRef } = useItemFocus.useItemFocus(focusedItemInfo);
            const text = useLegendDnd.getDatatipText(sections, getItem, focusedItemInfo, hoveredItemInfo);
            const [datatipDisabled, setDatatipDisabled] = hooks.useState(false);
            const { datatipContent, datatipProps: { 'aria-describedby': datatipAriaDescribedby, ...datatipProps } } = useLegendContextMenu.useLegendDatatip({
                text,
                rootDimsRef,
                focusedItemInfo,
                focusedItemRef,
                touchResponse,
                isDisabled: datatipDisabled
            });
            const ariaProps = useLegendDnd.getAriaProps(isReadOnly, props['aria-label'], props.hiddenIds, stringUtils.l([props['aria-describedby'], datatipAriaDescribedby]), props['aria-labelledby']);
            const { contextMenuContent, contextMenuProps } = useLegendContextMenu.useSectionalLegendContextMenu({
                rootRef,
                contextMenuConfig: hasData ? contextMenuConfig : undefined,
                focusedItemInfo,
                sections,
                isReadOnly,
                onContextMenuDismissed
            });
            const [dragOver, setDragOver] = hooks.useState();
            const { draggable, dndProps, dndContent } = useLegendDnd.useLegendDnd({
                onDrag: props.onDrag,
                onDragStart: props.onDragStart,
                onDragEnd: props.onDragEnd,
                onDragEnter: props.onDragEnter,
                onDragLeave: props.onDragLeave,
                onDragOver: props.onDragOver,
                onDrop: props.onDrop,
                sections,
                setDragOver,
                setDatatipDisabled,
                itemDraggable: props.itemDraggable
            });
            const mergedProps = mergeProps.mergeProps(eventsProps, datatipProps, contextMenuProps, dndProps);
            const titleStyle = {
                fontFamily: props.sectionTitleFontFamily,
                fontSize: props.sectionTitleFontSize,
                color: props.sectionTitleColor,
                fontStyle: props.sectionTitleFontStyle,
                fontWeight: props.sectionTitleFontWeight,
                textDecoration: props.sectionTitleTextDecoration
            };
            const { sectionalLegendBaseStyles, renderedLegendStyle } = PRIVATE_BaseLegend_themes_LegendStyles_css.styles;
            const isHoriz = orientation === 'horizontal';
            hooks.useImperativeHandle(ref, () => ({
                _getPreferredSize: (_width, _height) => {
                    const legendLayoutInfo = getSectionalLegendLayoutInfo({
                        width: _width,
                        getTextDimensions,
                        resolvedVars,
                        rootRef,
                        orientation,
                        legendFontStylesObj,
                        symbolWidth: props.symbolWidth,
                        symbolHeight: props.symbolHeight,
                        sections
                    });
                    if (legendLayoutInfo) {
                        return {
                            width: legendLayoutInfo?.maxRowWidth,
                            height: legendLayoutInfo?.legendHeight
                        };
                    }
                    else {
                        return;
                    }
                }
            }), [getTextDimensions, legendFontStylesObj, resolvedVars]);
            return (jsxRuntime.jsxs("div", { ref: rootRef, tabIndex: isReadOnly ? undefined : 0, role: "application", class: classNames.classNames([
                    sectionalLegendBaseStyles,
                    renderedLegendStyle,
                    dragOver
                        ? hooks_PRIVATE_useVisDnd_themes_VisDndStyles_css.styles.dndDragOverHTMLStyle
                        : dragOver === false
                            ? hooks_PRIVATE_useVisDnd_themes_VisDndStyles_css.styles.dndRejectedStyle
                            : undefined
                ]), draggable: draggable, style: touchResponseStyle, ...testIdProps, ...ariaProps, ...mergedProps, "aria-activedescendant": activeId, children: [jsxRuntime.jsx(Flex.Flex, { direction: isHoriz ? 'row' : 'column', wrap: 'wrap', gap: '4x', children: sections.map((section, index) => {
                            const labelledById = !isReadOnly ? layoutUtils.getRandomId() : '';
                            const isWrappedSection = layoutInfo
                                ? layoutInfo.isSectionWrappedArray[index]
                                : false;
                            const flexDirection = !isHoriz || isWrappedSection ? 'column' : 'row';
                            const alignItems = !isHoriz || isWrappedSection ? 'start' : 'center';
                            const { itemsPerCol, itemsPerRow } = useLegendDnd.getSectionGridNums(section.items.length, layoutInfo?.itemsPerRowArray[index]);
                            return (jsxRuntime.jsxs(Flex.Flex, { align: alignItems, direction: flexDirection, maxWidth: '100%', justify: 'start', wrap: "wrap", children: [jsxRuntime.jsx(useLegendContextMenu.LegendText, { text: section.title, ...titleStyle, type: "title", id: labelledById, align: sectionTitleHAlign }), jsxRuntime.jsx(useLegendContextMenu.BaseLegend, { ...props, focusedItemRef: focusedItemRef, labelledBy: labelledById, sectionIdx: index, items: section.items, orientation: orientation, itemsPerRow: itemsPerRow, itemsPerCol: itemsPerCol, itemWidth: layoutInfo?.isLegendWrappedArray[index]
                                            ? layoutInfo?.maxItemWidth
                                            : undefined, isReadOnly: isReadOnly, focusedItemInfo: focusedItemInfo, hoveredItemInfo: hoveredItemInfo, activeId: activeId, hideAndShowBehavior: hideAndShowBehavior, hoverBehavior: hoverBehavior, isTestEnv: isTestEnv })] }));
                        }) }), datatipContent, textMeasureContent, cssContent, contextMenuContent, dndContent] }));
        } }));
});

exports.SectionalLegend = SectionalLegend;
//# sourceMappingURL=UNSAFE_SectionalLegend.js.map
