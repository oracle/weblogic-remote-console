/* @oracle/oraclejet-preact: undefined */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('preact/jsx-runtime');
var preact = require('@testing-library/preact');
var matchTranslationBundle = require('../matchTranslationBundle-99625a42.js');
require('../LayerHost-aee0e070.js');
var EnvironmentProvider = require('../EnvironmentProvider-8696a5b8.js');
var TabbableModeContext = require('../TabbableModeContext-e99d527e.js');
require('preact/hooks');
var chai = require('chai');
var userEvent = require('@testing-library/user-event');
require('../index-15e13649.js');
require('preact');
require('preact/compat');
require('../UNSAFE_Layer/themes/LayerHostStyles.css.js');

require('../LayerManager-fc4df14f.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var userEvent__default = /*#__PURE__*/_interopDefaultLegacy(userEvent);

function __variableDynamicImportRuntime0__(path) {
  switch (path) {
    case '../../resources/nls/ar/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/ar/bundle.js'); });
    case '../../resources/nls/ar-XB/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/ar-XB/bundle.js'); });
    case '../../resources/nls/bg/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/bg/bundle.js'); });
    case '../../resources/nls/bs/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/bs/bundle.js'); });
    case '../../resources/nls/bs-Cyrl/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/bs-Cyrl/bundle.js'); });
    case '../../resources/nls/cs/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/cs/bundle.js'); });
    case '../../resources/nls/da/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/da/bundle.js'); });
    case '../../resources/nls/de/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/de/bundle.js'); });
    case '../../resources/nls/el/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/el/bundle.js'); });
    case '../../resources/nls/en/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/en/bundle.js'); });
    case '../../resources/nls/en-XA/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/en-XA/bundle.js'); });
    case '../../resources/nls/en-XC/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/en-XC/bundle.js'); });
    case '../../resources/nls/es/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/es/bundle.js'); });
    case '../../resources/nls/et/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/et/bundle.js'); });
    case '../../resources/nls/fi/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/fi/bundle.js'); });
    case '../../resources/nls/fr/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/fr/bundle.js'); });
    case '../../resources/nls/fr-CA/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/fr-CA/bundle.js'); });
    case '../../resources/nls/he/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/he/bundle.js'); });
    case '../../resources/nls/hr/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/hr/bundle.js'); });
    case '../../resources/nls/hu/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/hu/bundle.js'); });
    case '../../resources/nls/is/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/is/bundle.js'); });
    case '../../resources/nls/it/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/it/bundle.js'); });
    case '../../resources/nls/ja/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/ja/bundle.js'); });
    case '../../resources/nls/ko/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/ko/bundle.js'); });
    case '../../resources/nls/lt/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/lt/bundle.js'); });
    case '../../resources/nls/lv/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/lv/bundle.js'); });
    case '../../resources/nls/ms/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/ms/bundle.js'); });
    case '../../resources/nls/nl/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/nl/bundle.js'); });
    case '../../resources/nls/no/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/no/bundle.js'); });
    case '../../resources/nls/pl/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/pl/bundle.js'); });
    case '../../resources/nls/pt/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/pt/bundle.js'); });
    case '../../resources/nls/pt-PT/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/pt-PT/bundle.js'); });
    case '../../resources/nls/ro/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/ro/bundle.js'); });
    case '../../resources/nls/ru/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/ru/bundle.js'); });
    case '../../resources/nls/sk/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/sk/bundle.js'); });
    case '../../resources/nls/sl/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/sl/bundle.js'); });
    case '../../resources/nls/sr/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/sr/bundle.js'); });
    case '../../resources/nls/sr-Latn/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/sr-Latn/bundle.js'); });
    case '../../resources/nls/sv/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/sv/bundle.js'); });
    case '../../resources/nls/th/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/th/bundle.js'); });
    case '../../resources/nls/tr/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/tr/bundle.js'); });
    case '../../resources/nls/uk/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/uk/bundle.js'); });
    case '../../resources/nls/vi/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/vi/bundle.js'); });
    case '../../resources/nls/zh-Hans/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/zh-Hans/bundle.js'); });
    case '../../resources/nls/zh-Hant/bundle.ts': return Promise.resolve().then(function () { return require('../resources/nls/zh-Hant/bundle.js'); });
    default: return new Promise(function(resolve, reject) {
      (typeof queueMicrotask === 'function' ? queueMicrotask : setTimeout)(
        reject.bind(null, new Error("Unknown variable dynamic import: " + path))
      );
    })
   }
 }
const setupTabbableComponent = async (component, isTabbable) => {
    const locale = matchTranslationBundle.matchTranslationBundle(['en'], new Set(['en-US', 'en']));
    const { default: translations } = await __variableDynamicImportRuntime0__(`../../resources/nls/${locale}/bundle.ts`);
    const env = {
        translations: { '@oracle/oraclejet-preact': translations }
    };
    if (isTabbable !== undefined) {
        return preact.render(jsxRuntime.jsx(EnvironmentProvider.RootEnvironmentProvider, { environment: env, children: jsxRuntime.jsx(TabbableModeContext.TabbableModeContext.Provider, { value: { isTabbable: isTabbable }, children: component }) }));
    }
    else {
        return preact.render(jsxRuntime.jsx(EnvironmentProvider.RootEnvironmentProvider, { environment: env, children: component }));
    }
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const queryById = preact.queryByAttribute.bind(null, 'id');
function queryAllBy(attribute) {
    return preact.queryAllByAttribute.bind(null, attribute);
}
preact.queryByAttribute.bind(null, 'data-oj-private-item-index');
function checkTooltipText(content) {
    const targetElements = document.querySelectorAll('[role="tooltip"]');
    const targetElementItem = targetElements.item(0);
    const tooltipContainer = targetElementItem?.firstElementChild;
    chai.expect(tooltipContainer?.style.opacity).not.equals('');
    chai.expect(tooltipContainer?.style.opacity).not.equals('0');
    chai.expect(tooltipContainer?.style.maxHeight).not.equals('');
    chai.expect(tooltipContainer?.style.maxHeight).not.equals('0');
    const innerHTML = tooltipContainer?.firstElementChild?.innerHTML;
    chai.expect(innerHTML).equals(content);
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Mocks the `pageX`, `pageY`, `offsetX`, and `offsetY` properties on the `MouseEvent.prototype`
 * for testing purposes (e.g. for when using userEvent.pointer)
 * See workaround in https://github.com/testing-library/user-event/issues/1037#issuecomment-1576780336
 * that this is based on.
 *
 * This function saves the original property descriptors, then redefines `pageX`, `pageY`, `offsetX`, and `offsetY`
 * to return the values of `clientX` and `clientY`. This allows tests to interact with these properties.
 * This function should be called in beforeEach of tests.
 *
 * @returns An object containing the original property descriptors, which should
 *          be used later to restore the original behavior.
 */
function mockMouseEventPageXYOffsetXY() {
    const originalPageXDescriptor = Object.getOwnPropertyDescriptor(MouseEvent.prototype, 'pageX');
    const originalPageYDescriptor = Object.getOwnPropertyDescriptor(MouseEvent.prototype, 'pageY');
    const originalOffsetXDescriptor = Object.getOwnPropertyDescriptor(MouseEvent.prototype, 'offsetX');
    const originalOffsetYDescriptor = Object.getOwnPropertyDescriptor(MouseEvent.prototype, 'offsetY');
    Object.defineProperties(MouseEvent.prototype, {
        pageX: {
            configurable: true,
            get() {
                return this.clientX;
            }
        },
        pageY: {
            configurable: true,
            get() {
                return this.clientY;
            }
        },
        offsetX: {
            configurable: true,
            get() {
                return this.clientX;
            }
        },
        offsetY: {
            configurable: true,
            get() {
                return this.clientY;
            }
        }
    });
    return {
        originalPageXDescriptor,
        originalPageYDescriptor,
        originalOffsetXDescriptor,
        originalOffsetYDescriptor
    };
}
/**
 * Restores the original `pageX`, `pageY`, `offsetX`, and `offsetY` property descriptors on the `MouseEvent.prototype`.
 *
 * This function should be called afterEach of tests to ensure that the `MouseEvent.prototype` is returned to its
 * original state.
 *
 * @param descriptors The output of mockMouseEventPageXYOffsetXY
 */
function restoreMouseEventPageXYOffsetXY(descriptors) {
    const { originalPageXDescriptor, originalPageYDescriptor, originalOffsetXDescriptor, originalOffsetYDescriptor } = descriptors;
    if (originalPageXDescriptor) {
        Object.defineProperty(MouseEvent.prototype, 'pageX', originalPageXDescriptor);
    }
    if (originalPageYDescriptor) {
        Object.defineProperty(MouseEvent.prototype, 'pageY', originalPageYDescriptor);
    }
    if (originalOffsetXDescriptor) {
        Object.defineProperty(MouseEvent.prototype, 'offsetX', originalOffsetXDescriptor);
    }
    if (originalOffsetYDescriptor) {
        Object.defineProperty(MouseEvent.prototype, 'offsetY', originalOffsetYDescriptor);
    }
}

function getAllMenuItemsByRole(role, hidden = true) {
    return preact.screen.getAllByRole(role, { hidden });
}
function getMenuItemByRole(role, hidden = true) {
    return preact.screen.getByRole(role, { hidden });
}
function getLabel(label) {
    return preact.screen.getByText(label);
}

const getTestContextMenuForNoData = (renderedElement) => async () => {
    await userEvent__default["default"].tab();
    await userEvent__default["default"].keyboard('[ENTER]');
    preact.fireEvent.keyDown(renderedElement, { key: 'F10', shiftKey: true });
    const menu = preact.screen.queryByRole('menu');
    chai.expect(menu).to.be.null;
};
const getTestContextMenuViaKeyboard = (renderedElement, menuContext, type) => async () => {
    chai.expect(renderedElement).not.null;
    await userEvent__default["default"].tab();
    await userEvent__default["default"].keyboard('[ENTER]');
    preact.fireEvent.keyDown(renderedElement, { key: 'F10', shiftKey: true });
    const menu = getMenuItemByRole('menu');
    const menuItems = getAllMenuItemsByRole('menuitem');
    //With this we check context menu context was set correctly
    const menuItemGotByLabel = getLabel('MenuItem1');
    chai.expect(menu).not.null;
    chai.expect(menuItems.length).equals(3);
    chai.expect(menuItemGotByLabel).not.null;
    await preact.waitFor(() => {
        chai.expect(menuContext).not.null;
    });
    await preact.waitFor(() => {
        chai.expect(type).equals('item');
    });
    if (menuContext.type === 'item') {
        await preact.waitFor(() => {
            chai.expect(menuContext?.data).not.null;
        });
    }
};
const getTestContextMenuViaMouse = (renderedElement) => async () => {
    const firstElement = renderedElement;
    preact.fireEvent.contextMenu(firstElement, {
        clientX: 50,
        clientY: 50,
        currentTarget: firstElement
    });
    const menu = getMenuItemByRole('menu');
    const menuItems = getAllMenuItemsByRole('menuitem');
    //With this we check context menu context was set correctly
    const menuItemGotByLabel = getLabel('MenuItem1');
    chai.expect(menu).not.null;
    chai.expect(menuItems.length).equals(3);
    chai.expect(menuItemGotByLabel).not.null;
};

exports.checkTooltipText = checkTooltipText;
exports["default"] = setupTabbableComponent;
exports.getTestContextMenuForNoData = getTestContextMenuForNoData;
exports.getTestContextMenuViaKeyboard = getTestContextMenuViaKeyboard;
exports.getTestContextMenuViaMouse = getTestContextMenuViaMouse;
exports.mockMouseEventPageXYOffsetXY = mockMouseEventPageXYOffsetXY;
exports.queryAllBy = queryAllBy;
exports.queryById = queryById;
exports.restoreMouseEventPageXYOffsetXY = restoreMouseEventPageXYOffsetXY;
//# sourceMappingURL=PRIVATE_visTestUtils.js.map
