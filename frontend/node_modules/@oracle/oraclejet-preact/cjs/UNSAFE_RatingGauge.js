/* @oracle/oraclejet-preact: undefined */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('preact/jsx-runtime');
var preact = require('preact');
var hooks = require('preact/hooks');
var classNames = require('./classNames-c14c6ef3.js');
var UNSAFE_RatingGauge_themes_RatingGaugeContract_css = require('./UNSAFE_RatingGauge/themes/RatingGaugeContract.css.js');
var useComponentTheme = require('./useComponentTheme-082fc8e4.js');
var useUser = require('./useUser-f900ddf1.js');
var vanillaExtractDynamic_esm = require('./vanilla-extract-dynamic.esm-2e1b7c25.js');
var UNSAFE_RatingGauge_themes_redwood_RatingGaugeTheme = require('./UNSAFE_RatingGauge/themes/redwood/RatingGaugeTheme.js');
var useKeyboardEvents = require('./useKeyboardEvents-caa4eb2d.js');
require('preact/compat');
require('./LayerHost-aee0e070.js');

require('./Floating-5a704a27.js');

require('./datatipUtils-d1ca81a1.js');
var meterUtils = require('./meterUtils-dc96aab8.js');
var useDatatip = require('./useDatatip-4f6d3759.js');
var useTooltip = require('./useTooltip-8728f2ff.js');
require('./logger-2b636482.js');


require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js');
require('./tooltipUtils-ae48fed6.js');
var mergeProps = require('./mergeProps-e3da7237.js');
require('./TabbableModeContext-e99d527e.js');
var useTabbableMode = require('./useTabbableMode-a275583f.js');
var useTestId = require('./useTestId-9093a54b.js');
require('./UNSAFE_RatingGauge/themes/RatingGaugeStyles.css.js');

require('./UNSAFE_RatingGauge/themes/redwood/RatingGaugeBaseTheme.css.js');

require('./UNSAFE_RatingGauge/themes/redwood/RatingGaugeVariants.css.js');

require('./vanilla-extract-recipes-createRuntimeFn.esm-d1301b2d.js');
require('./index-15e13649.js');
require('./UNSAFE_Layer/themes/LayerHostStyles.css.js');

require('./useFloating-13101293.js');
require('./positionUtils-a780137e.js');
require('./refUtils-a9872e75.js');
require('./useOutsideClick-c3802f86.js');
require('./arrayUtils-7d8dcfc3.js');
require('./Layer-28b1afce.js');
require('./UNSAFE_Layer/themes/LayerStyles.css.js');
require('./useThemeInterpolations-4faece98.js');
require('./useColorScheme-23e4aab4.js');
require('./useScale-adc62f41.js');
require('./theme-dfd6a9fe.js');
require('./Theme-f06687af.js');
require('./mergeInterpolations-6727b536.js');
require('./mergeDeepWithKey-210b024d.js');
require('./_curry3-18677bca.js');
require('./_curry1-e8f0d7ea.js');
require('./_curry2-c15d89cd.js');
require('./_isObject-28636267.js');
require('./useDensity-022a8f80.js');
require('./unsafeDomAccess-c3a492f0.js');
require('./useModal-0739a528.js');
require('./utils-a66430fc.js');
require('./themeContract.css-a53fd740.js');
require('./colorUtils-01f3caa2.js');
require('./UNSAFE_Floating/themes/redwood/FloatingTheme.js');
require('./UNSAFE_Floating/themes/FloatingStyles.css.js');

require('./UNSAFE_Floating/themes/redwood/FloatingBaseTheme.css.js');

require('./UNSAFE_Floating/themes/redwood/FloatingVariants.css.js');
require('./UNSAFE_Floating/themes/FloatingContract.css.js');
require('./useUnsafeDomElementRef-f22a2f0c.js');
require('./clientUtils-a4619fcd.js');
require('./clientHints-c40c5250.js');
require('./utils-50db2fcf.js');
require('./hooks/PRIVATE_useDatatip/themes/useDatatip.css.js');
require('./useId-6c0eeb27.js');
require('./useVisHover-ad36112d.js');
require('./useTooltipControlled-3c2afa53.js');
require('./useHover-49b0430d.js');
require('./useToggle-3ebba7d8.js');
require('./useFocus-1b288fb9.js');
require('./useTouch-4dec8729.js');
require('./useAnimation-fb11e4cc.js');
require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentTheme.js');
require('./hooks/UNSAFE_useTooltip/themes/TooltipContentStyles.css.js');
require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentBaseTheme.css.js');

require('./EnvironmentProvider-8696a5b8.js');
require('./LayerManager-fc4df14f.js');

function getValue(pageX, max, step, dimensionsRef, isRtl) {
    const dimensions = dimensionsRef.current;
    if (!dimensions || dimensions.width === 0) {
        return -1;
    }
    const width = pageX - dimensions.x;
    const val = (max * (isRtl ? dimensions.width - width : width)) / dimensions.width;
    const numSteps = val / step;
    return numSteps < 0.5 ? 0 : Math.min(max, Math.ceil(numSteps) * step);
}
function getDimensions(element) {
    if (!element) {
        return {
            width: 0,
            x: 0
        };
    }
    const rect = element.getBoundingClientRect();
    return {
        width: rect.width,
        x: rect.x + window.scrollX
    };
}
/**
 * Returns The color in rating gauge, if the color enum is supported. undefined otherwise.
 * @param color The color in rating gauge.
 * @returns The color in rating gauge, if the color enum is supported. undefined otherwise.
 */
function getColorEnum(color) {
    return color === 'neutral' ||
        color === 'gold' ||
        color === 'danger' ||
        color === 'warning' ||
        color === 'success'
        ? color
        : undefined;
}

const RatingStar = ({ isSelected, isDisabled, isReadOnly, color = 'neutral' }) => {
    const { forcedColors } = useUser.useUser();
    const isHighContrast = forcedColors === 'active';
    const needsHighContrastStyle = isHighContrast && isDisabled;
    const enumColor = getColorEnum(color);
    const customColors = vanillaExtractDynamic_esm.assignInlineVars({
        [UNSAFE_RatingGauge_themes_RatingGaugeContract_css.ratingGaugeVars.colorSelected]: color,
        [UNSAFE_RatingGauge_themes_RatingGaugeContract_css.ratingGaugeVars.borderColorSelected]: color,
        [UNSAFE_RatingGauge_themes_RatingGaugeContract_css.ratingGaugeVars.colorSelectedReadonly]: color
    });
    const { variantClasses, styles: { ratingStarBaseStyle, innerRatingStarColor, outerRatingStarColor, outerDisabledHighContrastBaseStyle, outerDisabledHighContrastSelectedStyle, outerDisabledHighContrastUnselectedStyle } } = useComponentTheme.useComponentTheme(UNSAFE_RatingGauge_themes_redwood_RatingGaugeTheme.RatingGaugeRedwoodTheme, {
        color: enumColor,
        selectionState: isSelected ? 'isSelected' : 'isNotSelected',
        disabledState: isDisabled ? 'isDisabled' : 'isNotDisabled',
        readonlyState: isReadOnly ? 'isReadonly' : 'isNotReadonly',
        highContrastState: isHighContrast ? 'isHighContrast' : 'isNotHighContrast'
    });
    return (jsxRuntime.jsx("svg", { viewBox: "0 0 36 36", height: "100%", width: "100%", style: !enumColor ? customColors : undefined, class: classNames.classNames([ratingStarBaseStyle, enumColor ? variantClasses : '']), children: jsxRuntime.jsxs("g", { children: [jsxRuntime.jsx("path", { class: innerRatingStarColor, d: "m18 1 5.0061 11.9524 12.9939 1.0344-9.9 8.4215 3.0246 12.5917-11.1246-6.7476-11.12461 6.7476 3.02461-12.5917-9.9-8.4215 12.9939-1.0344z" }), jsxRuntime.jsx("path", { class: classNames.classNames([
                        outerRatingStarColor,
                        needsHighContrastStyle ? outerDisabledHighContrastBaseStyle : '',
                        needsHighContrastStyle
                            ? isSelected
                                ? outerDisabledHighContrastSelectedStyle
                                : outerDisabledHighContrastUnselectedStyle
                            : ''
                    ]), d: "m23.0061 12.9524-5.0061-11.9524-5.0061 11.9524-12.9939 1.0344 9.9 8.4215-3.02461 12.5917 11.12461-6.7476 11.1246 6.7476-3.0246-12.5917 9.9-8.4215zm10.5043 1.8394-8.5262 7.2528 2.6077 10.8562-9.5919-5.818-9.59192 5.818 2.60772-10.8562-8.52615-7.2528 11.19115-.891 4.3192-10.31227 4.3192 10.31227z" })] }) }));
};

const RatingGaugeItem = ({ fillRatio, isDisabled, isReadonly, color }) => {
    const { direction } = useUser.useUser();
    const isRtl = direction === 'rtl';
    const { styles: { fractionalStarBaseStyle } } = useComponentTheme.useComponentTheme(UNSAFE_RatingGauge_themes_redwood_RatingGaugeTheme.RatingGaugeRedwoodTheme);
    if (fillRatio === 1 || fillRatio === 0) {
        return (jsxRuntime.jsx(RatingStar, { isSelected: fillRatio === 1, isDisabled: isDisabled, isReadOnly: isReadonly, color: color }));
    }
    // if fillRatio is not 1 or zero, absolutely position selected star above the
    // unselected star and clip both to form partially selected star.
    return (jsxRuntime.jsxs(preact.Fragment, { children: [jsxRuntime.jsx("div", { class: fractionalStarBaseStyle, style: {
                    clipPath: `inset(0% ${isRtl ? (1 - fillRatio) * 100 : 0}% 0% ${isRtl ? 0 : fillRatio * 100}%)`
                }, children: jsxRuntime.jsx(RatingStar, { isSelected: false, isDisabled: isDisabled, isReadOnly: isReadonly, color: color }) }), jsxRuntime.jsx("div", { class: fractionalStarBaseStyle, style: {
                    clipPath: `inset(0% ${isRtl ? 0 : (1 - fillRatio) * 100}% 0% ${isRtl ? (1 - fillRatio) * 100 : 0}%)`
                }, children: jsxRuntime.jsx(RatingStar, { isSelected: true, isDisabled: isDisabled, isReadOnly: isReadonly, color: color }) })] }));
};

const useEvents = (max, step, value, rootRef, dimensionsRef, isInteractive, onCommit, onInput) => {
    const currentInputRef = hooks.useRef();
    const { direction } = useUser.useUser();
    const isRtl = direction === 'rtl';
    const handleInput = (inputValue) => {
        onInput?.({ value: inputValue });
        currentInputRef.current = inputValue;
    };
    const pointerUpHandler = (event) => {
        const val = getValue(event.pageX, max, step, dimensionsRef, isRtl);
        if (val !== -1) {
            onCommit?.({ value: val });
        }
    };
    // When the document or rating gauge parent scrolls, we need to update the dimensionRef.current.x.
    // Instead of updating it for every scroll event, recalculate the dims the first time mouse enters
    // so we get fresh dimension value.
    const pointerEnterHandler = () => {
        dimensionsRef.current = getDimensions(rootRef.current);
    };
    const hoverHandler = (event) => {
        const val = getValue(event.pageX, max, step, dimensionsRef, isRtl);
        if (val !== -1 && val != currentInputRef.current) {
            handleInput(val);
        }
    };
    const blurHandler = () => {
        onCommit?.({ value: value });
    };
    const pointerLeaveHandler = () => {
        handleInput(undefined);
    };
    const keyboardEventsProps = useKeyboardEvents.useKeyboardEvents(value, 0, max, step, currentInputRef, onCommit, onInput);
    return isInteractive
        ? {
            onPointerUp: pointerUpHandler,
            onBlur: blurHandler,
            onPointerMove: hoverHandler,
            onKeyUp: keyboardEventsProps.onKeyUp,
            onKeyDown: keyboardEventsProps.onKeyDown,
            onPointerLeave: pointerLeaveHandler,
            onPointerEnter: pointerEnterHandler
        }
        : {};
};

function useRatingDatatip({ max, value, isDisabled, isReadonly, datatip, thresholds, width }) {
    const datatipIndex = Math.max(1, Math.ceil(value));
    const offset = ((datatipIndex - Math.ceil(max / 2)) * width) / max;
    const datatipText = !datatip && thresholds && !isDisabled
        ? meterUtils.findThreshold(value, thresholds)?.accessibleLabel
        : datatip;
    const { datatipContent, datatipProps } = useDatatip.useDatatip({
        content: isDisabled || isReadonly ? null : datatipText,
        anchor: 'element',
        offset: {
            mainAxis: 8, // redwood datatip design spec
            crossAxis: offset
        },
        placement: 'bottom',
        touchResponse: 'touchStart'
    });
    return {
        datatipContent,
        datatipProps: isReadonly && !isDisabled
            ? {
                'aria-describedby': undefined
            }
            : datatipProps
    };
}

function useRatingTooltip({ isReadonly, isDisabled, tooltip }) {
    const text = isReadonly && !isDisabled ? tooltip : '';
    const { tooltipContent, tooltipProps } = useTooltip.useTooltip({ text, isDisabled });
    return {
        tooltipContent,
        tooltipProps: !isDisabled && isReadonly
            ? tooltipProps
            : {
                'aria-describedby': undefined
            }
    };
}

/**
 * A rating gauge displays information graphically, typically displaying or accepting user feedback on a product or service.
 */
function RatingGauge({ max = 5, value = 0, size, color = 'neutral', step = 1, isReadonly, isDisabled, testId, ...props }) {
    const testIdProps = useTestId.useTestId(testId);
    meterUtils.validateRange(0, max, value, step);
    const rootRef = hooks.useRef(null);
    const dimensionsRef = hooks.useRef(getDimensions(null));
    const isInteractive = !isReadonly && !isDisabled;
    // Since the dimension are compute lazily after render, store width and x in ref
    // This is used to identify hovered and clicked star.
    // width of the rating gauge depends on size and max so passing them as dependencies for useEffect
    hooks.useEffect(() => {
        dimensionsRef.current = getDimensions(rootRef.current);
    }, [size, max]);
    const eventProps = useEvents(max, step, value, rootRef, dimensionsRef, isInteractive, props.onCommit, props.onInput);
    const { datatipContent, datatipProps } = useRatingDatatip({
        max,
        value,
        isDisabled,
        isReadonly,
        datatip: props.datatip,
        thresholds: props.thresholds,
        width: dimensionsRef.current.width
    });
    const { tooltipContent, tooltipProps } = useRatingTooltip({
        isReadonly,
        isDisabled,
        tooltip: props.tooltip
    });
    const ariaProps = meterUtils.getMeterAriaProps(value, 0, max, props['aria-label'], props['aria-labelledby'], props.thresholds, isReadonly, isDisabled, props.tooltip);
    const { 'aria-describedby': datatipAriaDescribedBy, ...restDatatipProps } = datatipProps;
    const { 'aria-describedby': tooltipAriaDescribedBy, ...restTooltipProps } = tooltipProps;
    const mergedEventProps = mergeProps.mergeProps(eventProps, restDatatipProps, restTooltipProps);
    const ariaDescribedBy = [datatipAriaDescribedBy, tooltipAriaDescribedBy, props['aria-describedby']]
        .filter(Boolean)
        .join(' ') || undefined;
    const itemColor = meterUtils.getThresholdColorFromValue(value, color, props.thresholds);
    const { isTabbable } = useTabbableMode.useTabbableMode();
    const { classes, styles: { baseStyle, interactiveStyle, itemStyle, sizeStyle } } = useComponentTheme.useComponentTheme(UNSAFE_RatingGauge_themes_redwood_RatingGaugeTheme.RatingGaugeRedwoodTheme, {
        size
    });
    return (jsxRuntime.jsxs(preact.Fragment, { children: [jsxRuntime.jsx("div", { ...testIdProps, ...ariaProps, ref: rootRef, class: classNames.classNames([classes, baseStyle, isInteractive ? interactiveStyle : undefined]), tabIndex: isTabbable && !isDisabled ? 0 : -1, ...mergedEventProps, "aria-describedby": ariaDescribedBy, children: [...Array(max)].map((_, index) => {
                    const fillRatio = Math.min(Math.max(0, value - index), 1);
                    return (jsxRuntime.jsx("div", { className: classNames.classNames([sizeStyle, itemStyle]), children: jsxRuntime.jsx(RatingGaugeItem, { fillRatio: fillRatio, isDisabled: isDisabled, isReadonly: isReadonly, color: itemColor }) }));
                }) }), datatipContent, tooltipContent] }));
}

exports.RatingGauge = RatingGauge;
//# sourceMappingURL=UNSAFE_RatingGauge.js.map
