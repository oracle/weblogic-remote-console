/* @oracle/oraclejet-preact: undefined */
'use strict';

var getFormatParse = require('./getFormatParse-88bacc78.js');
require('./logger-2b636482.js');
var calendarDateUtils = require('./calendarDateUtils-32adc676.js');

// For locales that start with 'en', we use these placeholders.
const EN_LOCALE_PLACEHOLDER_HOUR = 'hh';
const EN_LOCALE_PLACEHOLDER_MINUTE = 'mm';
const EN_LOCALE_PLACEHOLDER_SECOND = 'ss';
const EN_LOCALE_PLACEHOLDER_MILLISECOND = 'sss';
// For locales that do not start with 'en', we use these placeholders.
const NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER = '--';
const NON_EN_LOCALE_THREE_DIGIT_PLACEHOLDER = '---';
const AM_VALUE = 0;
const PM_VALUE = 12;
/**
 * Given an ISO 8601 time-only string without zulu or offset e.g., 'T01:00:00.000' or 'T01:00', this method returns a Time object
 * containing 'hour' and 'minute', with optional 'second' and 'millisecond'.
 *
 * If the input is invalid (empty, null, undefined, or incorrectly formatted), this function returns undefined.
 * @param {TimeISOStr} isoTime - The ISO 8601 time string that starts with 'T'. (e.g., "T12:30:45.123")
 * @returns  (TimeWithValidIsoStrParts | undefined)
 * Returns a Time object with hour and minute, and optionally second and millisecond if they are in the input ISO string.
 * If the input is invalid, return undefined.
 */
const getTimeObjFromTimeOnlyISOStr = (isoTime) => {
    // Ensure the input is defined and properly formatted.
    if (isoTime === undefined || isoTime === null || !getFormatParse.isTimeOnlyIsoString(isoTime)) {
        return undefined;
    }
    // Remove 'T' prefix and split into time and optional millisecond parts.
    // A valid time-only ISO string must have hour and minute, and may optionally have second and millisecond.
    const timePart = isoTime.substring(1);
    const [fullTime, milliPart] = timePart.split('.');
    const [hour, minute, second] = fullTime.split(':').map((num) => parseInt(num, 10));
    let result;
    if (milliPart !== undefined) {
        const millisecond = parseInt(milliPart, 10);
        if (second === undefined) {
            throw new Error('millisecond is set, but second is missing. This is an invalid iso string');
        }
        result = {
            hour: hour,
            minute: minute,
            second: second,
            millisecond: millisecond
        };
    }
    else if (second !== undefined) {
        result = {
            hour: hour,
            minute: minute,
            second: second
        };
    }
    else {
        result = {
            hour: hour,
            minute: minute
        };
    }
    return result;
};
/**
 * Given a Time object with hour, minute, and optionally second and millisecond, return a time-only ISO string that starts with 'T'.
 * @param {Time | undefined} Time object or undefined. The hour and minute must be defined, otherwise this function returns undefined.
 * @returns {TimeISOStr | undefined} Time-only ISO string that starts with 'T'. If the time is undefined, or the hour or minute are undefined, returns undefined.
 * @throws {Error} throws an error if milliseconds is defined but its value is out of the valid range of 0-999. The allowed range is too large to express in Typescript.
 */
const getTimeOnlyISOStrFromTimeObj = (time) => {
    if (time === undefined) {
        return undefined;
    }
    const { hour, minute, second, millisecond } = time;
    if (hour === undefined || minute === undefined) {
        return undefined;
    }
    if (millisecond !== undefined && !checkIsValidIsoMillisecond(millisecond)) {
        throw new Error('milliseconds is defined but it is out of range to be a valid iso string value. Must be 0-999.');
    }
    // Hour and minute must be 2 digits to be a valid ISO 8601 string.
    const parts = [hour.toString().padStart(2, '0'), minute.toString().padStart(2, '0')];
    let isoTime = parts.join(':');
    if (second !== undefined) {
        const secondPart = second.toString().padStart(2, '0');
        isoTime += ':' + secondPart;
        if (millisecond !== undefined) {
            const msPart = millisecond.toString().padStart(3, '0');
            if (msPart) {
                isoTime += '.' + msPart;
            }
        }
    }
    return `T${isoTime}`;
};
/**
 * Returns a new array where the value in the masks array of type/value objects is replaced
 * with the string placeholders based on the locale.
 * For example, [{type='hour', value='hh'}, {type='minute', value='mm'} for 'en' locales,
 * or value='--' for non-'en' locales.
 * @param {BCP47Locale} locale - The locale.
 * @param {TimePlaceholders} masks - The TimePlaceholder masks
 * @returns A new array where the value in the masks array of type/value objects is replaced with
 * the string placeholders based on the locale.
 */
const replaceCustomMasksValuesWithPlaceholders = (locale, masks) => {
    const { hourPlaceholder, minutePlaceholder, secondPlaceholder, millisecondPlaceholder, dayPeriodPlaceholder } = getTimePlaceholderValuesFromLocale(locale);
    return masks.map((p) => {
        switch (p.type) {
            case 'hour':
                return { ...p, value: hourPlaceholder };
            case 'minute':
                return { ...p, value: minutePlaceholder };
            case 'second':
                return { ...p, value: secondPlaceholder };
            case 'millisecond':
                return { ...p, value: millisecondPlaceholder };
            case 'dayPeriod':
                return { ...p, value: dayPeriodPlaceholder };
            default:
                return { ...p };
        }
    });
};
/**
 * Retrieves the TimePlaceholders masks where value has the placeholder (e.g., 'hh' or '--')
 * by using a new instance of Intl.DateTimeFormat with the locale, granularity, and hour12.
 *
 * @param {BCP47Locale} locale - The locale
 * @param {TimeGranularity} granularity - The granularity of the desired time mask.
 * @param hour12 - passes through to Intl.DateTimeFormat's hour12, which indicates
 * if the hour is a 12-hour (as opposed to 24-hour) clock.
 * E.g., new Intl.DateTimeFormat('en-GB', {timeStyle: 'short', hour12: true}).format(date)
 * @returns Returns the TimePlaceholder masks where value has the placeholders (e.g., 'hh' or '--').
 */
const getTimeMasksFromLocaleAndOptions = (locale = 'en-US', granularity, hour12) => {
    calendarDateUtils.checkNoCalendarExtension(locale);
    // Filter out anything not related to a time mask.
    // This does not filter out spaces, e.g., the literal space between the time and the dayPeriod.
    const filterByTimeType = (parts) => {
        return parts.filter((p) => p.type === 'minute' ||
            p.type === 'hour' ||
            p.type === 'second' ||
            p.type === 'dayPeriod' ||
            p.type === 'literal');
    };
    const testDateWithTime = new Date('2022-11-30T00:00:00');
    // If granularity is milliseconds, we use timeStyle: 'medium'. Later we stitch in the literal and millisecond part to medium since
    // there is not a timeStyle for milliseconds, and you cannot use fractionalSecond: 3 with timeStyle in Intl.DateTimeFormat.
    const timeStyle = granularity === 'minute' ? 'short' : 'medium';
    const formatter = getTimeFormatterShortMedium(locale, timeStyle, hour12);
    const parts = formatter.formatToParts(testDateWithTime);
    const timeParts = filterByTimeType(parts);
    // If granularity is millisecond, then add a separator and fractionalSecond to the array after seconds.
    let allTimeParts;
    if (granularity === 'millisecond') {
        allTimeParts = insertFractionalSecond(locale, timeParts);
    }
    else {
        allTimeParts = timeParts;
    }
    // map it so that it has the same type as InputTimeMask's masks type of TimePlaceholders
    const masks = allTimeParts.map((part) => {
        switch (part.type) {
            case 'fractionalSecond':
                return { type: 'millisecond', value: part.value };
            case 'hour':
            case 'minute':
            case 'second':
            case 'dayPeriod':
            case 'literal':
                return { ...part };
        }
    });
    // replace part value with placeholder
    return replaceCustomMasksValuesWithPlaceholders(locale, masks);
};
const cachedFractionalSecondsDigitFormatter = new Map();
/**
 * Returns a new array with the fractionalSecond part
 * and its preceding separator part merged into the parts array after the seconds part.
 *
 * There is not an Intl.DateTimeFormat timeStyle option that displays milliseconds,
 * and you cannot use fractionalSecond: 3 with a timeStyle option at the same time in Intl.DateTimeFormat.
 * Therefore to get the parts for granularity: 'millisecond',
 * get parts from timeStyle: 'medium' and call this function with those parts. This function will stitch in
 * the separator and fractionalSecond parts after the 'second' part.
 *
 * @param {BCP47Locale} locale
 * @param {FilteredDateTimeFormatPart[]} parts - The parts from calling Intl.DateTimeFormat with timeStyle: 'medium'.
 * @returns a new parts array with the fractionalSecond and its preceding separator stitched into the parts array
 * after the 'second' part.
 */
const insertFractionalSecond = (locale, parts) => {
    const index = parts.findIndex((part) => part.type === 'second');
    if (index === -1) {
        // 'second' not found, return the array as is
        return parts;
    }
    const cacheKey = `${locale}`;
    let formatter = cachedFractionalSecondsDigitFormatter.get(cacheKey);
    if (!formatter) {
        formatter = new Intl.DateTimeFormat(locale, {
            hour: 'numeric',
            minute: 'numeric',
            second: '2-digit',
            fractionalSecondDigits: 3,
            numberingSystem: 'latn'
        });
        cachedFractionalSecondsDigitFormatter.set(cacheKey, formatter);
    }
    // get separatorValue that comes before the fractionalSecond part.
    const partsWithFractionalSeconds = formatter.formatToParts(new Date());
    const separatorPart = getLiteralBeforeFractionalSecond(partsWithFractionalSeconds);
    if (separatorPart === null) {
        return parts;
    }
    const newParts = [
        { type: 'literal', value: separatorPart.value },
        { type: 'fractionalSecond', value: 'sss' }
    ];
    return [...parts.slice(0, index + 1), ...newParts, ...parts.slice(index + 1)];
};
/**
 * Finds and returns the 'literal' part immediately before the first 'fractionalSecond' part in an
 * array of Intl.DateTimeFormatPart objects. If not found, returns null.
 * @param {Intl.DateTimeFormatPart[]} parts
 * @returns {Intl.DateTimeFormatPart[]|null} - The literal part before the 'fractionalSecond' part.
 */
const getLiteralBeforeFractionalSecond = (parts) => {
    const index = parts.findIndex((part) => part.type === 'fractionalSecond');
    if (index > 0 && parts[index - 1].type === 'literal') {
        return parts[index - 1];
    }
    return null;
};
/**
 * Creates an object with the time segment placeholders based on the locale.
 * For locales that start with 'en', we use 'hh', 'mm', 'ss', 'sss', for
 * other locales we use '--' or '---' if millisecond.
 *
 * @param {BCP47Locale} locale
 * @returns An object with the time segment placeholders.
 */
const getTimePlaceholderValuesFromLocale = (locale) => {
    const { am } = getAmPmStringsForLocale(locale);
    if (locale.startsWith('en')) {
        return {
            hourPlaceholder: EN_LOCALE_PLACEHOLDER_HOUR,
            minutePlaceholder: EN_LOCALE_PLACEHOLDER_MINUTE,
            secondPlaceholder: EN_LOCALE_PLACEHOLDER_SECOND,
            millisecondPlaceholder: EN_LOCALE_PLACEHOLDER_MILLISECOND,
            dayPeriodPlaceholder: am
        };
    }
    return {
        hourPlaceholder: NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER,
        minutePlaceholder: NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER,
        secondPlaceholder: NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER,
        millisecondPlaceholder: NON_EN_LOCALE_THREE_DIGIT_PLACEHOLDER,
        dayPeriodPlaceholder: am
    };
};
/**
 * Creates a time formatter using new Intl.DateTimeFormat for the locale.
 * @param {BCP47Locale} locale - The locale to format the time.
 * @param {'short'|'medium'} timeStyle - The timeStyle formatting option.
 * @param {boolean} hour12 - Whether to use 12-hour time format.
 * @returns A new formatter instance for the specified locale and options.
 */
const getTimeFormatterShortMedium = (locale, timeStyle, hour12) => {
    const options = hour12 === undefined
        ? { timeStyle, numberingSystem: 'latn' }
        : { timeStyle, hour12, numberingSystem: 'latn' };
    return new Intl.DateTimeFormat(locale, options);
};
/**
 * Gets the day period value strings for AM and PM.
 *
 * @param {BCP47Locale} locale - The locale to format the time.
 * @returns An object containing the AM and PM strings for the locale.
 */
const getAmPmStringsForLocale = (locale) => {
    const am = getDayPeriodValueStr(locale, 0); // 0 is 12 AM
    const pm = getDayPeriodValueStr(locale, 13); // 13 is 1 PM
    return { am, pm };
};
const cachedDayPeriodString = new Map();
/**
 * Retrieves the day period string for a specific locale and hour.
 * This uses a cache so a new instance of Intl.DateTimeFormat with hour12: true so even if the locale
 * does not have a 1-12 hour time by default, the hour12: true parameter will force it.
 * For example, for 'en-US' if the hour is 0, this returns 'AM'. If the hour is 13, this returns 'PM'.
 * For 'ms', if the hour is 0, this returns 'PG'.
 *
 * @param {BCP47Locale} locale - The locale to format the time.
 * @param {Hour} hour - The hour for which to get the day period (0-23).
 * @returns {string} The locale's day period value for the hour. All locales have a dayPeriod string, but
 * just in case we default to 'AM' and 'PM'.
 */
const getDayPeriodValueStr = (locale = 'en-US', hour) => {
    const morningIsoHourStr = '00';
    const eveningIsoHourStr = '23';
    const isoHourStr = hour < 12 ? morningIsoHourStr : eveningIsoHourStr;
    // is locale + isoHourStr in the cache? If so, return it.
    const dayPeriod = cachedDayPeriodString.get(`${locale}-${isoHourStr}`);
    if (!dayPeriod) {
        // This sets hour12 to true.
        const formatter = getTimeFormatterShortMedium(locale, 'short', true);
        // Cache both am and pm values at the same time in order to use the same formatter for performance sake.
        [morningIsoHourStr, eveningIsoHourStr].forEach((hourToCache) => {
            const isoStr = `2022-11-30T${hourToCache}:00:00`;
            const date = new Date(isoStr);
            const parts = formatter.formatToParts(date);
            const dayPeriodPart = parts.find((p) => p.type === 'dayPeriod');
            // All locales I tested have a dayPeriod string when hour12: true,
            // but just in case there is a locale for Intl.DateTimeFormat with no dayPeriod string, we default to one.
            const defaultDayPeriodToCache = hourToCache === morningIsoHourStr ? 'AM' : 'PM';
            const dayPeriodToCache = dayPeriodPart ? dayPeriodPart.value : defaultDayPeriodToCache;
            cachedDayPeriodString.set(`${locale}-${hourToCache}`, dayPeriodToCache);
        });
        // return the dayPeriod for the hour requested that we just cached.
        return cachedDayPeriodString.get(`${locale}-${isoHourStr}`);
    }
    return dayPeriod;
};
const getDayPeriodValueFromHour = (hour) => {
    return hour > 11 ? PM_VALUE : AM_VALUE;
};
/**
 * Formats a Time object into a string based on the provided masks.
 * Handles hour conversion (12-hour/24-hour) since the Time object is in 24-hour format,
 * and the mask, if it has the dayPeriod, is in 12-hour format. Applies leading
 * zeros to hour if leadingZeroForHour is true. Pads zeros to minute, second, and millisecond so
 * that the digits equal two for minute/second and three for millisecond.
 * The timeMasks must have the correct segments to match the granularity before calling this function.
 * @param locale
 * @param time
 * @param granularity
 * @param timeMasks
 * @param leadingZeroForHour
 * @returns a formatted time string
 */
const formatTimeFromMasks = (locale, time, granularity, timeMasks, leadingZeroForHour) => {
    calendarDateUtils.checkNoCalendarExtension(locale);
    // First, the time must be complete.
    if (time.hour === undefined ||
        time.minute === undefined ||
        (granularity === 'second' && time.second === undefined) ||
        (granularity === 'millisecond' && time.millisecond === undefined)) {
        return '';
    }
    const hasDayPeriod = timeMasks.some((part) => part.type === 'dayPeriod');
    const dayPeriodToDisplay = hasDayPeriod ? getDayPeriodValueStr(locale, time.hour) : ''; // e.g., 'AM' or 'PM' for 'en-US'
    // Format hour with optional leading zero
    const timeHour = hasDayPeriod ? to12Hour(time.hour) : time.hour;
    const hourToDisplay = leadingZeroForHour ? padWithZero(timeHour, 2) : timeHour.toString();
    // Format minute, second, and millisecond with necessary padding
    const minuteToDisplay = padWithZero(time.minute, 2);
    const secondToDisplay = padWithZero(time.second, 2);
    const millisecondToDisplay = padWithZero(time.millisecond, 3);
    // Map timeMasks to their corresponding values and join them into a formatted time string.
    const timeValues = timeMasks.map(({ type, value }) => type === 'hour'
        ? hourToDisplay
        : type === 'minute'
            ? minuteToDisplay
            : type === 'second'
                ? secondToDisplay
                : type === 'millisecond'
                    ? millisecondToDisplay
                    : type === 'dayPeriod'
                        ? dayPeriodToDisplay
                        : value);
    return timeValues.join('');
};
/**
 * Retrieves the hour string. If the display has a day period, then the hour string
 * will be 1-12, otherwise it will be 0-23.
 * @param hour
 * @param hasDayPeriod true if the time to display has a day period segment (e.g., a segment that shows AM or PM).
 * This means the time field has a 1-12 hour time.
 * @param leadingZeroForHour If true, the hour string will have length of 2, with leading zeros if necessary to pad it out.
 * @returns
 */
const getHourValueStr = (hour, hasDayPeriod, leadingZeroForHour) => {
    // If hasDayPeriod, the hour to display is in the range of 1-12. E.g., 1:00 AM.
    // Since the hour parameter is 0-23, the hour to display needs to be converted to a 1-12 hour string.
    // If hasDayPeriod is false, the hour to display is in the range of 0-23. E.g., 01:00.
    const timeHour = hasDayPeriod ? to12Hour(hour) : hour;
    return leadingZeroForHour ? padWithZero(timeHour, 2) : timeHour.toString();
};
const cachedTimeStyleShortHasLeadingZero = new Map();
/**
 * Returns true if the locale's hour has a leading zero by default.
 *
 * This method uses a cached new Intl.DateTimeFormat(locale),
 * and uses formatToParts for hour
 * to figure out if the hour has a leading zero.
 *
 * @param {BCP47Locale} locale - the locale
 * @returns true if hour starts with 0 for the specific locale.
 */
const getLeadingZeroForHour = (locale) => {
    // check timeStyle short for the locale
    // and see if the hour starts with 0.
    // if so, return true;
    const value = new Date('1995-12-17T09:30:00');
    const cacheKey = `${locale}`;
    let isLeadingZero = cachedTimeStyleShortHasLeadingZero.get(cacheKey);
    if (isLeadingZero === undefined) {
        const formatter = new Intl.DateTimeFormat(locale, {
            timeStyle: 'short',
            numberingSystem: 'latn'
        });
        const parts = formatter.formatToParts(value);
        const hourPart = parts.find((part) => part.type === 'hour');
        const hourValue = hourPart?.value;
        isLeadingZero = hourValue.startsWith('0');
        cachedTimeStyleShortHasLeadingZero.set(cacheKey, isLeadingZero);
    }
    return isLeadingZero;
};
/**
 * Converts the 24-hour hour to a 12-hour hour.
 * @param {Hour} hour24
 * @returns
 */
const to12Hour = (hour24) => {
    const hour12 = hour24 % 12 === 0 ? 12 : hour24 % 12;
    return hour12;
};
const padWithZero = (num, length) => {
    return num !== undefined ? num.toString().padStart(length, '0') : '';
};
/**
 * Returns true if the time params represent two different times.
 * This is useful to call before we call onInput or onCommit.
 * @param t1
 * @param t2
 * @returns true if the time params represent two different times.
 */
const timesAreDifferent = (t1, t2) => {
    const isEmpty = (time) => {
        return (!time || // if time is undefined
            (time.hour === undefined &&
                time.minute === undefined &&
                time.second === undefined &&
                time.millisecond === undefined));
    };
    // Both are empty/undefined, return false (same)
    if (isEmpty(t1) && isEmpty(t2))
        return false;
    // If one is empty/undefined and the other isn't, return true (different)
    if (isEmpty(t1) !== isEmpty(t2))
        return true;
    // Return true if any of the segment values don't match.
    if (t1?.hour !== t2?.hour ||
        t1?.minute !== t2?.minute ||
        t1?.second !== t2?.second ||
        t1?.millisecond !== t2?.millisecond) {
        return true;
    }
    return false;
};
/**
 * Compares two TimeWithValidIsoStrParts objects and returns a number indicating their relative order.
 * @param {TimeWithValidIsoStrParts} time1 The first time to compare.
 * @param {TimeWithValidIsoStrParts} time2 The second time to compare.
 * @returns {number} A negative number if time1 is before time2, a positive number if time1 is after time2, or 0 if they are the same.
 */
const compareTimes = (time1, time2) => {
    if (time1.hour !== time2.hour) {
        return time1.hour - time2.hour;
    }
    if (time1.minute !== time2.minute) {
        return time1.minute - time2.minute;
    }
    // fill second and millisecond to 0 if it isn't filled in.
    const time1Second = time1.second ?? 0;
    const time2Second = time2.second ?? 0;
    if (time1Second !== time2Second) {
        return time1Second - time2Second;
    }
    const time1Millisecond = time1.millisecond ?? 0;
    const time2Millisecond = time2.millisecond ?? 0;
    return time1Millisecond - time2Millisecond;
};
/**
 * Determines whether the input string matches the start of the 'am' and/or 'pm' strings in the given am/pm object.
 *
 * The match is case-insensitive and ignores leading and trailing whitespace.
 *
 * If the input matches with only the start of the 'am' string, 'am' is returned.
 * If the input matches with only the start of the 'pm' string, 'pm' is returned.
 * If the input matches the start of both the 'am' and 'pm strings (e.g., the 'am'/'pm' strings have the same starting letter(s) and the input is too short to disambiguate),
 * 'both is returned.
 * If the input does not match the start of either string, 'none' is returned.
 * @param {AmPmLocalizedValues} amPmObj - An object containing the am and pm strings for the current locale.
 * @param {string} input - The user provided string to match against the am an pm strings.
 * @returns {('am' | 'pm' | 'none' | 'both')}
 */
const getAmPmMatchType = (amPmObj, input) => {
    const trimmedInput = input.trim().toLowerCase();
    // If input is empty after trimming, return 'none'
    if (trimmedInput === '') {
        return 'none';
    }
    // Check if the input matches as a prefix in either property (am or pm)
    const matchesAM = amPmObj.am.toLowerCase().startsWith(trimmedInput);
    const matchesPM = amPmObj.pm.toLowerCase().startsWith(trimmedInput);
    // If both match, return 'both'
    if (matchesAM && matchesPM) {
        return 'both';
    }
    // If only one matches, return that
    if (matchesAM) {
        return 'am';
    }
    if (matchesPM) {
        return 'pm';
    }
    // If neither matches
    return 'none';
};
/**
 * Check if the value has segments in it that are not displayed to the user.
 * E.g., originalValue: {hour: 1, minute: 30, second: 59, millisecond: 599}, and the segments are: ['hour', 'minute'], returns true.
 * originalValue: {millisecond: 599}, and the segments are: ['hour', 'minute'], returns true.
 * originalValue: {second: 599}, and the segments are: ['hour', 'minute'], returns true.
 * originalValue: {second: 599}, and the segments are: ['hour', 'minute'], returns true.
 * originalValue: {hour: 1, minute: 30, second: 599}, and the segments are: ['hour', 'minute', 'second'], returns false.
 * @param orderedSegments {OrderedTimeSegmentsArray} - The segments that are displayed to the user
 * @param originalValue {Time|undefined} - The original Time value.
 * @returns {boolean} returns true if the originalValue has segments that are not displayed to the user.
 */
const hasSegmentsNotDisplayed = (orderedSegments, originalValue) => {
    if (originalValue === undefined) {
        return false;
    }
    // orderedSegments are the segments that are displayed to the user.
    // filter out the 'dayPeriod' since that is not part of the Time object.
    const filteredSegments = orderedSegments.filter((item) => item !== 'dayPeriod');
    // loop through each key in the original value and see if it exists in the filteredSegments
    const hasExtraSegmentsCondition = (key) => (key === 'hour' || key === 'minute' || key === 'second' || key === 'millisecond') &&
        !filteredSegments.includes(key);
    return Object.keys(originalValue).some(hasExtraSegmentsCondition);
};
/**
 * Returns true if any one of the displayed time segments has a different value in initialTime vs updatedTime.
 * @param orderedSegments {OrderedTimeSegmentsArray} the time segments that are displayed to the user
 * @param initialTime {Time} The initial time.
 * @param updatedTime {Time} The updated time.
 * @returns true if the displayed time segments have different values
 */
const displayedTimeSegmentsAreDifferent = (orderedSegments, initialTime, updatedTime) => {
    // orderedSegments are the segments that are displayed to the user.
    // filter out the 'dayPeriod' since that is not part of the Time object.
    const filteredSegments = orderedSegments.filter((item) => item !== 'dayPeriod');
    for (const key of filteredSegments) {
        const value1 = initialTime[key]; // might be undefined. In which case, this will return true if value2 also has undefined for this key.
        const value2 = updatedTime[key];
        if (value1 !== value2) {
            return true;
        }
    }
    return false;
};
/**
 * Returns true if millisecond is a valid ISO value (0-999).
 * The allowed range is too large to express using Typescript.
 */
const checkIsValidIsoMillisecond = (millisecond) => {
    return millisecond >= 0 && millisecond <= 999;
};
/**
 * Format an example TimeISOStr to show in an error message.
 */
const formatIsoTimeStrAsExample = (str, locale, granularity, leadingZeroForHour, masks) => {
    const timeObj = getTimeObjFromTimeOnlyISOStr(str);
    return timeObj === undefined
        ? ''
        : formatTimeFromMasks(locale, timeObj, granularity, masks, leadingZeroForHour);
};
// Given a pattern, return a TimePlaceholder array.
const getTimePlaceholdersFromPattern = (pattern) => {
    const arr = getTimeMaskArrayFromPattern(pattern);
    const timePlaceholders = convertMaskArrayToTimePlaceholders(arr);
    return timePlaceholders;
};
// Given a pattern, like 'h:ss a', return an array like ['h', ':', 'ss', ' ', 'a'].
// We only support pattern for FA User Preferences, and none of the FA time patterns have milliseconds.
const getTimeMaskArrayFromPattern = (pattern) => {
    const result = [];
    let currentSegmentStr = '';
    let currentLiteral = '';
    const addSegment = () => {
        if (currentSegmentStr !== '') {
            result.push(currentSegmentStr);
            currentSegmentStr = '';
        }
    };
    const addLiteral = () => {
        if (currentLiteral !== '') {
            // InputTimeMask wants spaces in its literals, like the space between the time and dayPeriod.
            result.push(currentLiteral);
            currentLiteral = '';
        }
    };
    for (let i = 0; i < pattern.length; i++) {
        const char = pattern[i];
        // if we get a character that is not a literal, then push the literal, if any.
        // This also handles the case where the pattern does not have a space between the 'a' (dayPeriod)
        // and the hour, minute, or second, like 'ahh:mm:ss' or 'hh:mma' or 'hh:mm:ssa'; These dayPeriod
        // and hour, minute, second are different segments even though there is no space.
        // Currently there are no user preference patterns with 'a' at the end with no space before it,
        // but we handle it just the same.
        // None of the FA User Preference patterns have milliseconds, so we do not support that here.
        if (char.toLowerCase() === 'h' ||
            char.toLowerCase() === 'm' ||
            char.toLowerCase() === 's' ||
            char.toLowerCase() === 'a') {
            addLiteral();
            if (currentSegmentStr[0] === char) {
                currentSegmentStr += char;
            }
            else {
                addSegment();
                currentSegmentStr = char;
            }
        }
        else {
            addSegment();
            currentLiteral += char;
        }
    }
    // Add the last components
    addSegment();
    addLiteral();
    return result;
};
// converts an array into the object that is needed to set on the InputTimeMask's masks property, TimePlaceholders type;
// This is used when converting a pattern into a masks property.
// None of the FA User Preference patterns have milliseconds, so we do not support that here.
const convertMaskArrayToTimePlaceholders = (array) => {
    return array.map((item) => {
        if (item.toLowerCase()[0] === 'h') {
            return { type: 'hour', value: EN_LOCALE_PLACEHOLDER_HOUR };
        }
        else if (item.toLowerCase()[0] === 'm') {
            return { type: 'minute', value: EN_LOCALE_PLACEHOLDER_MINUTE };
        }
        else if (item.toLowerCase()[0] === 's') {
            return { type: 'second', value: EN_LOCALE_PLACEHOLDER_SECOND };
        }
        else if (item.toLowerCase()[0] === 'a') {
            return { type: 'dayPeriod', value: 'am/pm' };
        }
        else {
            // Default to literal for anything else
            return { type: 'literal', value: item };
        }
    });
};

exports.AM_VALUE = AM_VALUE;
exports.PM_VALUE = PM_VALUE;
exports.compareTimes = compareTimes;
exports.displayedTimeSegmentsAreDifferent = displayedTimeSegmentsAreDifferent;
exports.formatIsoTimeStrAsExample = formatIsoTimeStrAsExample;
exports.formatTimeFromMasks = formatTimeFromMasks;
exports.getAmPmMatchType = getAmPmMatchType;
exports.getAmPmStringsForLocale = getAmPmStringsForLocale;
exports.getDayPeriodValueFromHour = getDayPeriodValueFromHour;
exports.getDayPeriodValueStr = getDayPeriodValueStr;
exports.getHourValueStr = getHourValueStr;
exports.getLeadingZeroForHour = getLeadingZeroForHour;
exports.getTimeMasksFromLocaleAndOptions = getTimeMasksFromLocaleAndOptions;
exports.getTimeObjFromTimeOnlyISOStr = getTimeObjFromTimeOnlyISOStr;
exports.getTimeOnlyISOStrFromTimeObj = getTimeOnlyISOStrFromTimeObj;
exports.getTimePlaceholdersFromPattern = getTimePlaceholdersFromPattern;
exports.hasSegmentsNotDisplayed = hasSegmentsNotDisplayed;
exports.padWithZero = padWithZero;
exports.replaceCustomMasksValuesWithPlaceholders = replaceCustomMasksValuesWithPlaceholders;
exports.timesAreDifferent = timesAreDifferent;
//# sourceMappingURL=timeUtils-ce57624b.js.map
