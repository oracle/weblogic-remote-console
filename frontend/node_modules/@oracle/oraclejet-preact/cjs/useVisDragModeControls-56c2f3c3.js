/* @oracle/oraclejet-preact: undefined */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
var Button = require('./Button-51364b4d.js');
var Move = require('./Move-7e3d4692.js');
var hooks_PRIVATE_useVisDragModeControls_themes_useVisDragModeControls_css = require('./hooks/PRIVATE_useVisDragModeControls/themes/useVisDragModeControls.css.js');
var useTranslationBundle = require('./useTranslationBundle-18b7bf8b.js');
var ZoomAlt = require('./ZoomAlt-fc9f2cd5.js');
var ButtonSetSingle = require('./ButtonSetSingle-885ce1b6.js');
var ButtonSetItem = require('./ButtonSetItem-7c81cf63.js');
var IconToggleButton = require('./IconToggleButton-52c12187.js');

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Returns the dragMode during initial render or when dragMode props
 * change (i.e when user hasn't selected yet) based on available dragModes.
 */
function getInitialDragMode(dragMode, showPanButton, showZoomButton, showSelectButton) {
    return showPanButton && (dragMode === 'pan' || dragMode === 'user')
        ? 'pan'
        : showZoomButton && dragMode === 'zoom'
            ? 'zoom'
            : showSelectButton && dragMode === 'select'
                ? 'select'
                : undefined;
}

function VisDragModeControls({ position, divRef, dragMode, onDragModeChange, showZoomButton, showPanButton, showSelectButton }) {
    const { right, left, top, bottom } = position;
    const onButtonAction = ({ value }) => {
        onDragModeChange(value === dragMode ? undefined : value);
    };
    const showOnlyOne = (showPanButton && !showSelectButton && !showZoomButton) ||
        (!showPanButton && !showSelectButton && showZoomButton) ||
        (!showPanButton && showSelectButton && !showZoomButton);
    const translations = useTranslationBundle.useTranslationBundle('@oracle/oraclejet-preact');
    const zoomAriaLabel = translations.vis_marqueeZoomTooltip();
    const panAriaLabel = translations.vis_panTooltip();
    const selectAriaLabel = translations.vis_marqueeSelectTooltip();
    return showZoomButton || showPanButton || showSelectButton ? (jsxRuntime.jsx("div", { ref: divRef, class: hooks_PRIVATE_useVisDragModeControls_themes_useVisDragModeControls_css.styles.background, "data-oj-private-object": "dragModeControls", style: {
            right,
            left,
            top,
            bottom
        }, children: !showOnlyOne ? (jsxRuntime.jsxs(ButtonSetSingle.ButtonSetSingle, { size: "sm", value: dragMode, onCommit: onButtonAction, display: "icons", variant: "outlined", children: [showPanButton && (jsxRuntime.jsx(ButtonSetItem.ButtonSetItem, { value: "pan", label: panAriaLabel, startIcon: jsxRuntime.jsx(Move.SvgMove, {}) })), showZoomButton && (jsxRuntime.jsx(ButtonSetItem.ButtonSetItem, { value: "zoom", label: zoomAriaLabel, startIcon: jsxRuntime.jsx(ZoomAlt.SvgZoomAlt, {}) })), showSelectButton && (jsxRuntime.jsx(ButtonSetItem.ButtonSetItem, { value: "select", label: selectAriaLabel, startIcon: jsxRuntime.jsx(Button.SvgButton, {}) }))] })) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [showPanButton && (jsxRuntime.jsx(IconToggleButton.IconToggleButton, { accessibleLabel: panAriaLabel, isSelected: dragMode === 'pan', onToggle: () => {
                        onDragModeChange(dragMode === 'pan' ? undefined : 'pan');
                    }, variant: "outlined", size: "sm", children: jsxRuntime.jsx(Move.SvgMove, {}) })), showZoomButton && (jsxRuntime.jsx(IconToggleButton.IconToggleButton, { accessibleLabel: zoomAriaLabel, isSelected: dragMode === 'zoom', onToggle: () => {
                        onDragModeChange(dragMode === 'zoom' ? undefined : 'zoom');
                    }, variant: "outlined", size: "sm", children: jsxRuntime.jsx(ZoomAlt.SvgZoomAlt, {}) })), showSelectButton && (jsxRuntime.jsx(IconToggleButton.IconToggleButton, { accessibleLabel: selectAriaLabel, isSelected: dragMode === 'select', onToggle: () => {
                        onDragModeChange(dragMode === 'select' ? undefined : 'select');
                    }, variant: "outlined", size: "sm", children: jsxRuntime.jsx(Button.SvgButton, {}) }))] })) })) : null;
}

function useVisDragModeControls({ componentWidth, plotAreaSpace, isRtl, showPanButton, showZoomButton, showSelectButton, isDisabled = false, dragMode }) {
    const dragButtonDivRef = hooks.useRef(null);
    const originalDragModeRef = hooks.useRef(dragMode);
    const isInitialRenderRef = hooks.useRef(true);
    hooks.useEffect(() => {
        isInitialRenderRef.current = false;
    }, []);
    const [userDragMode, setUserDragMode] = hooks.useState();
    const initialSelection = getInitialDragMode(dragMode, showPanButton, showZoomButton, showSelectButton);
    const dragModeChanged = originalDragModeRef.current != dragMode;
    if (dragModeChanged || isInitialRenderRef.current) {
        originalDragModeRef.current = dragMode;
        setUserDragMode(initialSelection);
    }
    const toggleButtonContent = isDisabled ? undefined : (jsxRuntime.jsx(VisDragModeControls, { position: {
            top: `${plotAreaSpace.y}px`,
            right: isRtl ? undefined : `${componentWidth - plotAreaSpace.x - plotAreaSpace.width}px`,
            left: isRtl ? `${plotAreaSpace.x}px` : undefined
        }, divRef: dragButtonDivRef, showSelectButton: showSelectButton, showZoomButton: showZoomButton, showPanButton: showPanButton, dragMode: userDragMode, onDragModeChange: setUserDragMode }));
    return {
        dragButtonDivRef: dragButtonDivRef,
        toggleButtonContent: toggleButtonContent,
        userDragMode
    };
}

exports.useVisDragModeControls = useVisDragModeControls;
//# sourceMappingURL=useVisDragModeControls-56c2f3c3.js.map
