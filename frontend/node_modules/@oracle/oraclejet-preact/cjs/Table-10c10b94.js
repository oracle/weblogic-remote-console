/* @oracle/oraclejet-preact: undefined */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var preact = require('preact');
var hooks = require('preact/hooks');
var compat = require('preact/compat');
var classNames = require('./classNames-c14c6ef3.js');
var useId = require('./useId-6c0eeb27.js');
var TabbableModeContext = require('./TabbableModeContext-e99d527e.js');
var useUser = require('./useUser-f900ddf1.js');
var LoadMoreCollection = require('./LoadMoreCollection-3cd7e9a9.js');
var useTranslationBundle = require('./useTranslationBundle-18b7bf8b.js');
var PRIVATE_Table_themes_TableSkeletonStyles_css = require('./PRIVATE_Table/themes/TableSkeletonStyles.css.js');
var dimensions$1 = require('./dimensions-2fcc0acf.js');
var mergeInterpolations = require('./mergeInterpolations-6727b536.js');
var Selector = require('./Selector-9b72f861.js');
var PRIVATE_Table_themes_TableRowStyles_css = require('./PRIVATE_Table/themes/TableRowStyles.css.js');
var keys = require('./keys-25710458.js');
var FormContext = require('./FormContext-d1d05967.js');
var clientHints = require('./clientHints-c40c5250.js');
var PRIVATE_Table_themes_Table_css = require('./PRIVATE_Table/themes/Table.css.js');
var PRIVATE_Table_themes_TableCellStyles_css = require('./PRIVATE_Table/themes/TableCellStyles.css.js');
var PRIVATE_Table_themes_TableFooterCellStyles_css = require('./PRIVATE_Table/themes/TableFooterCellStyles.css.js');
var PRIVATE_Table_themes_TableHeaderCellStyles_css = require('./PRIVATE_Table/themes/TableHeaderCellStyles.css.js');
var collectionUtils = require('./collectionUtils-fe12edac.js');
var useInteractionStyle = require('./useInteractionStyle-c203a8a0.js');
var PRIVATE_Table_themes_redwood_TableNoDataTheme = require('./PRIVATE_Table/themes/redwood/TableNoDataTheme.js');
var useComponentTheme = require('./useComponentTheme-082fc8e4.js');
var SelectorAll = require('./SelectorAll-c7d87dc7.js');
var SortControl = require('./SortControl-b4dff875.js');
var useSortableContext = require('./useSortableContext-0510fd8e.js');
var Button = require('./Button-3908334e.js');
var Dialog = require('./Dialog-89e1b1c3.js');
var Flex = require('./Flex-6ca216a7.js');
var SelectMenuGroupContext = require('./SelectMenuGroupContext-ae5e1373.js');
var Submenu = require('./Submenu-416179ad.js');
require('./logger-2b636482.js');
require('./UNSAFE_Separator/themes/SeparatorStyles.css.js');


require('./UNSAFE_Menu/themes/redwood/MenuSeparatorVariants.css.js');
var NumberInputText = require('./NumberInputText-d187704a.js');
var FocusTracker = require('./FocusTracker-946ba8d8.js');
require('./CollectionInteractionContext-f84ff7a1.js');
var useCollectionInteractionContext = require('./useCollectionInteractionContext-6fc0200e.js');
var mergeProps = require('./mergeProps-e3da7237.js');
var useContextMenuGesture = require('./useContextMenuGesture-03ba6353.js');
var useColorScheme = require('./useColorScheme-23e4aab4.js');
var useScale = require('./useScale-adc62f41.js');
var useTooltipControlled = require('./useTooltipControlled-3c2afa53.js');
var tooltipUtils = require('./tooltipUtils-ae48fed6.js');
var tabbableUtils = require('./tabbableUtils-7e41d383.js');
var textSelectionUtils = require('./textSelectionUtils-432ab66b.js');
var useAddBusyState = require('./useAddBusyState-d19ae1fa.js');
var useResizeObserver = require('./useResizeObserver-a9e97180.js');
var unsafeDomAccess = require('./unsafeDomAccess-c3a492f0.js');
var PRIVATE_Table_themes_redwood_TableTheme = require('./PRIVATE_Table/themes/redwood/TableTheme.js');
var useTestId = require('./useTestId-9093a54b.js');

/**
 * The internal component used to render a single colgroup in Table.
 */
function TableColGroup({ tableId, isRendered, columnWidthsArray }) {
    const getColStyle = (columnWidth) => {
        return columnWidth == null ? '' : `width:${columnWidth}px;`;
    };
    return isRendered ? (jsxRuntime.jsx("colgroup", { children: columnWidthsArray.map((columnWidth) => {
            return jsxRuntime.jsx("col", { style: getColStyle(columnWidth), "data-oj-table-col": tableId });
        }) })) : null;
}

const dimensions = ['height', 'width'];
// Create an array [dimensionInterpolations['height'], dimensionInterpolations['width']]
const skeletonDimensionInterpolation = Array.from(dimensions, (x) => dimensions$1.dimensionInterpolations[x]);
const interpolations = [...Object.values(skeletonDimensionInterpolation)];
const SkeletonInterpolations = mergeInterpolations.mergeInterpolations(interpolations);
/**
 * TableSkeleton component allows the appropriate skeleton to be rendered based on the
 * property values
 **/
function TableSkeleton({ ...props }) {
    const skeletonStyles = props.isHighContrast ? PRIVATE_Table_themes_TableSkeletonStyles_css.tableSkeletonStylesHC : PRIVATE_Table_themes_TableSkeletonStyles_css.tableSkeletonStyles;
    const classes = classNames.classNames([skeletonStyles.bar]);
    const skeletonDimensions = SkeletonInterpolations({ width: '100%', ...props });
    return jsxRuntime.jsx("div", { style: skeletonDimensions, class: classes });
}

/**
 * TableSkeletonRow renders a set of 'loading' skeletons.
 **/
function TableSkeletonRow({ tableId, colspan, hasTabIndex, isShowFocusRing, isPendingLayout = false, isLoadMore = false, isHighContrast }) {
    const translations = useTranslationBundle.useTranslationBundle('@oracle/oraclejet-preact');
    const skeletonStyles = isHighContrast ? PRIVATE_Table_themes_TableSkeletonStyles_css.tableSkeletonStylesHC : PRIVATE_Table_themes_TableSkeletonStyles_css.tableSkeletonStyles;
    const cellClassArray = [skeletonStyles.cell];
    if (isShowFocusRing) {
        cellClassArray.push(skeletonStyles.focus);
    }
    const cellClasses = classNames.classNames(cellClassArray);
    const innerCellClasses = classNames.classNames([skeletonStyles.innerCell]);
    const rowClasses = classNames.classNames([skeletonStyles.row, skeletonStyles.rowHeight]);
    const firstRowClasses = isPendingLayout
        ? classNames.classNames([skeletonStyles.row, skeletonStyles.headerHeight])
        : rowClasses;
    const accCellContent = (jsxRuntime.jsx("div", { style: 'width:1px;height:0px;overflow:hidden;', children: translations.collection_loading() }));
    return (jsxRuntime.jsx("tr", { class: LoadMoreCollection.LOADMORE_STYLE_CLASS, role: 'row', children: jsxRuntime.jsx("td", { class: cellClasses, colSpan: colspan, role: 'gridcell', tabIndex: hasTabIndex ? 0 : -1, "data-oj-cell-type": isPendingLayout ? 'pending' : isLoadMore ? 'loadMore' : 'loading', ...(isPendingLayout
                ? { 'data-oj-table-pending-cell': tableId }
                : isLoadMore
                    ? { 'data-oj-table-load-more-cell': tableId }
                    : { 'data-oj-table-loading-cell': tableId }), "data-oj-table-focusable": tableId, children: jsxRuntime.jsxs("div", { class: innerCellClasses, children: [accCellContent, [...Array(isLoadMore ? 3 : 25)].map((_element, index) => (jsxRuntime.jsx("div", { class: index === 0 ? firstRowClasses : rowClasses, children: jsxRuntime.jsx(TableSkeleton, { height: "4x", isHighContrast: isHighContrast }) })))] }) }) }));
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Helper function to generate the class array for a data cell.
 */
const getDataCellClassArray = ({ isFirstColumnIndex, isFinalColumnIndex, isFirstRowIndex, isFinalRowIndex, hasVerticalGridlines, hasHorizontalGridlines, hasLastHorizontalGridline, isRowSelected, isPreviousRowSelected, isColumnSelected, isNextColumnSelected, isPreviousColumnSelected, isShowFocusRing, isSticky, isRowSelectionEnabled, isRowSingleSelection, isActive, isHover, isPseudoHover, isStickyStartEdge, isStickyEndEdge, hasStartEdge, hasEndEdge, isRtl, isHighContrast, horizontalAlignment, verticalAlignment, variant, padding }) => {
    const cellStyles = isHighContrast ? PRIVATE_Table_themes_TableCellStyles_css.tableCellStylesHC : PRIVATE_Table_themes_TableCellStyles_css.tableCellStyles;
    const classArray = [cellStyles.base];
    // Padding styling logic
    const { isTopPadding, isBottomPadding, isStartPadding, isEndPadding } = _getPaddingInfo(padding);
    // Horizontal and vertical alignment styling logic
    _applyAlignmentStyling(classArray, horizontalAlignment, verticalAlignment);
    // Sticky styling logic
    _applyStickyStyling(classArray, cellStyles, isSticky, isStickyStartEdge, isStickyEndEdge, isRtl);
    // Interaction styling logic
    if (isRowSelectionEnabled) {
        if (isActive) {
            classArray.push(cellStyles.active);
        }
        else if (isHover) {
            classArray.push(cellStyles.hover);
        }
        else if (isPseudoHover) {
            classArray.push(cellStyles.pseudoHover);
        }
    }
    if (variant === 'highlight') {
        classArray.push(cellStyles.rowHighlight);
    }
    _applyFocusStyling(classArray, cellStyles, isShowFocusRing);
    // Selected Rows and Horizontal Gridline styling logic
    let hasBackground = false;
    if (isRowSelected) {
        hasBackground = true;
        classArray.push(cellStyles.selectedBackground);
    }
    if (isRowSingleSelection && (isRowSelected || isPreviousRowSelected)) {
        classArray.push(cellStyles.horizontalSelectedGridTop);
        classArray.push(isTopPadding ? cellStyles.selectedBorderTopPadding : cellStyles.selectedBorderTopNoPadding);
    }
    else if (!isFirstRowIndex && hasHorizontalGridlines) {
        classArray.push(cellStyles.horizontalGridTop);
        classArray.push(isTopPadding ? cellStyles.borderTopPadding : cellStyles.borderTopNoPadding);
    }
    else {
        classArray.push(isTopPadding ? cellStyles.topSpacerPadding : cellStyles.topSpacerNoPadding);
    }
    if (isFinalRowIndex) {
        classArray.push(cellStyles.lastRow);
        if (isRowSingleSelection && isRowSelected) {
            classArray.push(cellStyles.horizontalSelectedGridBottom);
            classArray.push(isBottomPadding
                ? cellStyles.selectedBorderBottomPadding
                : cellStyles.selectedBorderBottomNoPadding);
        }
        else if (hasLastHorizontalGridline) {
            classArray.push(cellStyles.horizontalGridBottom);
            classArray.push(isBottomPadding ? cellStyles.borderBottomPadding : cellStyles.borderBottomNoPadding);
        }
        else {
            classArray.push(isBottomPadding ? cellStyles.bottomSpacerPadding : cellStyles.bottomSpacerNoPadding);
        }
    }
    else {
        classArray.push(cellStyles.notLastRow);
        classArray.push(isBottomPadding ? cellStyles.bottomPadding : cellStyles.bottomNoPadding);
    }
    // Selected Columns and Vertical Gridline styling logic
    if (isColumnSelected) {
        if (!hasBackground) {
            classArray.push(cellStyles.selectedBackground);
            hasBackground = true;
        }
        _applySelectedColumnStyling(classArray, cellStyles, isStartPadding, isEndPadding, hasStartEdge, hasEndEdge);
    }
    else {
        if (!hasBackground) {
            classArray.push(cellStyles.background);
        }
        _applyColumnStyling(classArray, cellStyles, isStartPadding, isEndPadding, isFirstColumnIndex, isFinalColumnIndex, hasStartEdge, hasEndEdge, isNextColumnSelected, isPreviousColumnSelected, hasVerticalGridlines);
    }
    return classArray;
};
/**
 * Helper function to generate the class array for a header or footer cell.
 */
const getHeaderFooterCellClassArray = ({ isHeader, isActiveStyle, isHoverStyle, isPreviousCellActiveStyle, isPreviousCellHoverStyle, isFirstColumnIndex, isFinalColumnIndex, hasVerticalGridlines, isSelected, isNextColumnSelected, isPreviousColumnSelected, isSticky, isShowFocusRing, isStickyStartEdge, isStickyEndEdge, hasStartEdge, hasEndEdge, isRtl, horizontalAlignment, verticalAlignment, isHighContrast, padding }) => {
    let cellStyles;
    if (isHeader) {
        cellStyles = isHighContrast ? PRIVATE_Table_themes_TableHeaderCellStyles_css.tableHeaderCellStylesHC : PRIVATE_Table_themes_TableHeaderCellStyles_css.tableHeaderCellStyles;
    }
    else {
        cellStyles = isHighContrast ? PRIVATE_Table_themes_TableFooterCellStyles_css.tableFooterCellStylesHC : PRIVATE_Table_themes_TableFooterCellStyles_css.tableFooterCellStyles;
    }
    const classArray = [cellStyles.base];
    // Padding styling logic
    const { isTopPadding, isBottomPadding, isStartPadding, isEndPadding } = _getPaddingInfo(padding);
    classArray.push(isBottomPadding ? cellStyles.bottomPadding : cellStyles.bottomNoPadding);
    classArray.push(isTopPadding ? cellStyles.topPadding : cellStyles.topNoPadding);
    // Horizontal and vertical alignment styling logic
    _applyAlignmentStyling(classArray, horizontalAlignment, verticalAlignment);
    // Sticky styling logic
    _applyStickyStyling(classArray, cellStyles, isSticky, isStickyStartEdge, isStickyEndEdge, isRtl);
    // Interaction styling logic
    _applyFocusStyling(classArray, cellStyles, isShowFocusRing);
    // Selected and Vertical Gridline styling logic
    if (isSelected) {
        if (isActiveStyle) {
            classArray.push(cellStyles.activeSelected);
        }
        else if (isHoverStyle) {
            classArray.push(cellStyles.hoverSelected);
        }
        classArray.push(cellStyles.selectedBackground);
        _applySelectedColumnStyling(classArray, cellStyles, isStartPadding, isEndPadding, hasStartEdge, hasEndEdge);
    }
    else {
        if (isActiveStyle) {
            classArray.push(cellStyles.active);
        }
        else if (isHoverStyle) {
            classArray.push(cellStyles.hover);
        }
        classArray.push(cellStyles.background);
        _applyColumnStyling(classArray, cellStyles, isStartPadding, isEndPadding, isFirstColumnIndex, isFinalColumnIndex, hasStartEdge, hasEndEdge, isNextColumnSelected, isPreviousColumnSelected, hasVerticalGridlines, isActiveStyle, isHoverStyle, isPreviousCellActiveStyle, isPreviousCellHoverStyle);
    }
    return classArray;
};
const _getPaddingInfo = (padding) => {
    const isPaddingDisabled = padding === 'disabled';
    const isComplexPadding = padding instanceof Object;
    const isBottomPadding = !(isPaddingDisabled ||
        (isComplexPadding && padding?.bottom === 'disabled'));
    const isEndPadding = !(isPaddingDisabled || (isComplexPadding && padding?.end === 'disabled'));
    const isStartPadding = !(isPaddingDisabled ||
        (isComplexPadding && padding?.start === 'disabled'));
    const isTopPadding = !(isPaddingDisabled || (isComplexPadding && padding?.top === 'disabled'));
    return { isTopPadding, isBottomPadding, isStartPadding, isEndPadding };
};
const _applyAlignmentStyling = (classArray, horizontalAlignment, verticalAlignment) => {
    classArray.push(PRIVATE_Table_themes_Table_css.textAlignStyles[horizontalAlignment]);
    classArray.push(PRIVATE_Table_themes_Table_css.verticalAlignStyles[verticalAlignment]);
};
const _applyFocusStyling = (classArray, cellStyles, isShowFocusRing) => {
    if (isShowFocusRing) {
        classArray.push(cellStyles.focused);
    }
};
const _applyStickyStyling = (classArray, cellStyles, isSticky, isStickyStartEdge, isStickyEndEdge, isRtl) => {
    if (isSticky) {
        classArray.push(cellStyles.stickyColumn);
    }
    if (isStickyStartEdge) {
        classArray.push(cellStyles.stickyEdge);
        classArray.push(isRtl ? cellStyles.stickyEdgeLeft : cellStyles.stickyEdgeRight);
    }
    else if (isStickyEndEdge) {
        classArray.push(cellStyles.stickyEdge);
        classArray.push(isRtl ? cellStyles.stickyEdgeRight : cellStyles.stickyEdgeLeft);
    }
};
const _applyColumnStyling = (classArray, cellStyles, isStartPadding, isEndPadding, isFirstColumnIndex, isFinalColumnIndex, hasStartEdge, hasEndEdge, isNextColumnSelected, isPreviousColumnSelected, hasVerticalGridlines, isActiveStyle, isHoverStyle, isPreviousCellActiveStyle, isPreviousCellHoverStyle) => {
    if (hasStartEdge) {
        if (isPreviousColumnSelected) {
            classArray.push(cellStyles.verticalSelectedGridStart);
            classArray.push(isStartPadding
                ? cellStyles.selectedBorderStartPadding
                : cellStyles.selectedBorderStartNoPadding);
        }
        else if (isActiveStyle ||
            isHoverStyle ||
            isPreviousCellActiveStyle ||
            isPreviousCellHoverStyle ||
            (!isFirstColumnIndex && hasVerticalGridlines)) {
            classArray.push(cellStyles.verticalGridStart);
            classArray.push(isStartPadding ? cellStyles.borderStartPadding : cellStyles.borderStartNoPadding);
        }
        else if (isStartPadding) {
            classArray.push(cellStyles.startSpacerPadding);
        }
        else {
            classArray.push(cellStyles.startSpacerNoPadding);
        }
    }
    else if (isStartPadding) {
        classArray.push(cellStyles.startPadding);
    }
    else {
        classArray.push(cellStyles.startNoPadding);
    }
    if (hasEndEdge) {
        if (isNextColumnSelected) {
            classArray.push(cellStyles.verticalSelectedGridEnd);
            classArray.push(isEndPadding ? cellStyles.selectedBorderEndPadding : cellStyles.selectedBorderEndNoPadding);
        }
        else if (isActiveStyle || isHoverStyle || (!isFinalColumnIndex && hasVerticalGridlines)) {
            classArray.push(cellStyles.verticalGridEnd);
            classArray.push(isEndPadding ? cellStyles.borderEndPadding : cellStyles.borderEndNoPadding);
        }
        else if (isEndPadding) {
            classArray.push(cellStyles.endSpacerPadding);
        }
        else {
            classArray.push(cellStyles.endSpacerNoPadding);
        }
    }
    else if (isEndPadding) {
        classArray.push(cellStyles.endPadding);
    }
    else {
        classArray.push(cellStyles.endNoPadding);
    }
};
const _applySelectedColumnStyling = (classArray, cellStyles, isStartPadding, isEndPadding, hasStartEdge, hasEndEdge) => {
    if (hasStartEdge) {
        classArray.push(cellStyles.verticalSelectedGridStart);
        classArray.push(isStartPadding
            ? cellStyles.selectedBorderStartPadding
            : cellStyles.selectedBorderStartNoPadding);
    }
    else {
        classArray.push(isStartPadding ? cellStyles.startPadding : cellStyles.startNoPadding);
    }
    if (hasEndEdge) {
        classArray.push(cellStyles.verticalSelectedGridEnd);
        classArray.push(isEndPadding ? cellStyles.selectedBorderEndPadding : cellStyles.selectedBorderEndNoPadding);
    }
    else {
        classArray.push(isEndPadding ? cellStyles.endPadding : cellStyles.endNoPadding);
    }
};
/**
 * Helper function to convert a column's horizontal alignment value into a form control's value.
 */
const getFormTextAlign = (horizontalAlignment, isRtl) => {
    switch (horizontalAlignment) {
        case 'left':
            return isRtl ? 'end' : 'start';
        case 'center':
            return undefined;
        default:
            return horizontalAlignment;
    }
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Returns the cell type for the given cell element
 */
const getCellType = (element) => {
    return element.dataset['ojCellType'];
};
/**
 * Returns the row key for the given row element
 */
const getRowKey = (element) => {
    return (element.dataset['ojKeyType'] === 'number'
        ? Number(element.dataset['ojKey'])
        : element.dataset['ojKey']);
};
/**
 * Returns whether or not auto focus is enabled on the specified cell
 */
const isAutoFocusCell = (rootElement, tableId, activeCell) => {
    const cellElement = getElementFromCell(rootElement, tableId, activeCell);
    return cellElement != null && cellElement.dataset['ojTableAutoFocus'] === 'enabled';
};
/**
 * Returns the key for the row at the given index
 */
const getRowKeyForRowIndex = (rootElement, tableId, index) => {
    const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);
    if (rowElements.length > index) {
        return getRowKey(rowElements[index]);
    }
    return undefined;
};
/**
 * Returns the index of the given row element
 */
const getRowIndexForRowElement = (rootElement, tableId, rowElement) => {
    const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);
    const index = Array.prototype.indexOf.call(rowElements, rowElement);
    if (index > -1) {
        return index;
    }
    return undefined;
};
/**
 * Returns the index of the row for the given key.
 */
function getRowIndexForRowKey(rootElement, tableId, rowKey) {
    const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);
    for (let i = 0; i < rowElements.length; i++) {
        if (rowKey === getRowKey(rowElements[i])) {
            return i;
        }
    }
    return undefined;
}
/**
 * Returns the column key for the given cell element
 */
const getColumnKey = (element) => {
    return element.dataset['ojColumnKey'];
};
/**
 * Returns the index of the given column header element or footer element
 */
const getColumnIndexForHeaderFooterElement = (rootElement, tableId, cellElement, isHeader) => {
    const columnElements = rootElement.querySelectorAll(isHeader
        ? `[data-oj-table-header-cell='${tableId}']`
        : `[data-oj-table-footer-cell='${tableId}']`);
    const index = Array.prototype.indexOf.call(columnElements, cellElement);
    if (index > -1) {
        return index;
    }
    return undefined;
};
/**
 * Helper method to get the cell key definition from an element
 */
function logicalCellExtractor(element, tableId, columnsArray, cellSelector, onlyAncestors) {
    const selectorString = cellSelector != null ? cellSelector : `[data-oj-table-focusable='${tableId}']`;
    const startingElement = onlyAncestors ? element.parentElement : element;
    if (startingElement != null) {
        const cellElement = startingElement.closest(selectorString);
        if (cellElement != null) {
            const cellType = getCellType(cellElement);
            if (cellType === 'data') {
                return {
                    rowKey: collectionUtils.keyExtractor(cellElement, `[data-oj-table-data-row='${tableId}']`),
                    columnKey: getColumnKey(cellElement),
                    type: cellType
                };
            }
            else if (cellType === 'header' || cellType === 'footer') {
                return { columnKey: getColumnKey(cellElement), type: cellType };
            }
            else if (cellType === 'noData' || cellType === 'pending') {
                return { type: cellType };
            }
            else if (cellType === 'loading' || cellType === 'loadMore') {
                const columnKey = getBoundaryColumnKey(columnsArray, true);
                if (columnKey != null) {
                    return { columnKey: columnKey, type: cellType };
                }
            }
        }
    }
    return undefined;
}
/**
 * Helper method to get an element from a cell descriptor
 */
function getElementFromCell(rootElement, tableId, cell) {
    if (cell.type === 'header') {
        // header case
        const headerElements = rootElement.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);
        for (const headerElement of headerElements) {
            if (cell.columnKey === getColumnKey(headerElement)) {
                return headerElement;
            }
        }
    }
    else if (cell.type === 'footer') {
        // footer case
        const footerElements = rootElement.querySelectorAll(`[data-oj-table-footer-cell='${tableId}']`);
        for (const footerElement of footerElements) {
            if (cell.columnKey === getColumnKey(footerElement)) {
                return footerElement;
            }
        }
    }
    else if (cell.type === 'data') {
        // data body case
        const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);
        for (const rowElement of rowElements) {
            if (cell.rowKey === getRowKey(rowElement)) {
                const cellElements = rowElement.querySelectorAll(`[data-oj-table-focusable='${tableId}']`);
                for (const cellElement of cellElements) {
                    if (cell.columnKey === getColumnKey(cellElement)) {
                        return cellElement;
                    }
                }
            }
        }
    }
    else if (cell.type === 'noData') {
        // no data case
        return rootElement.querySelector(`[data-oj-table-nodata-cell='${tableId}']`);
    }
    else if (cell.type === 'pending') {
        // pending skeletons case
        return rootElement.querySelector(`[data-oj-table-pending-cell='${tableId}']`);
    }
    else if (cell.type === 'loading') {
        // loading skeletons case
        return rootElement.querySelector(`[data-oj-table-loading-cell='${tableId}']`);
    }
    else if (cell.type === 'loadMore') {
        // loadMore skeletons case
        return rootElement.querySelector(`[data-oj-table-load-more-cell='${tableId}']`);
    }
    return undefined;
}
/**
 * Helper method to get the top scroller offset of the Table
 */
const getScrollerTopOffset = (rootElement, tableId) => {
    const headerRowElement = rootElement.querySelector(`[data-oj-table-header-row='${tableId}']`);
    return headerRowElement != null ? headerRowElement.getBoundingClientRect().height : 0;
};
/**
 * Helper method to get the bottom scroller offset of the Table
 */
const getScrollerBottomOffset = (rootElement, tableId) => {
    const footerRowElement = rootElement.querySelector(`[data-oj-table-footer-row='${tableId}']`);
    return footerRowElement != null ? footerRowElement.getBoundingClientRect().height : 0;
};
/**
 * Returns the key of the first focusable row in the Table
 */
const getFirstFocusableRowKey = (rootElement, tableId) => {
    const firstRowElement = rootElement.querySelector(`[data-oj-table-data-row='${tableId}']`);
    if (firstRowElement != null) {
        return getRowKey(firstRowElement);
    }
    return undefined;
};
/**
 * Returns the key of the last focusable row in the Table
 */
const getLastFocusableRowKey = (rootElement, tableId) => {
    const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);
    const rowCount = rowElements.length;
    if (rowCount > 0) {
        return getRowKey(rowElements[rowCount - 1]);
    }
    return undefined;
};
/**
 * Helper function to get the first or last column key.
 */
const getBoundaryColumnKey = (columnsArray, isFirst) => {
    if (columnsArray.length > 0) {
        return isFirst ? columnsArray[0].key : columnsArray[columnsArray.length - 1].key;
    }
    return undefined;
};
/**
 * Helper method to get the 'noData' cell
 */
const getNoDataCellElement = (rootElement, tableId) => {
    return rootElement.querySelector(`[data-oj-table-nodata-cell='${tableId}']`);
};
/**
 * Helper method to determine if the no data cell is present in the Table
 */
const hasNoDataCell = (rootElement, tableId) => {
    return getNoDataCellElement(rootElement, tableId) != null;
};
/**
 * Helper method to determine if footer cells are present in the Table
 */
const hasFooterCells = (rootElement, tableId) => {
    return rootElement.querySelectorAll(`[data-oj-table-footer-row='${tableId}']`).length > 0;
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Browser zoom levels are not handled identically between Range sizes and Element sizes, so this offset
 * should be used when comparing horizontal widths. Using a smaller value (0.01 for example) causes false
 * positives, while using a larger value (0.05 for example) causes actual truncations to be missed.
 */
const HORIZONTAL_TRUNCATION_OFFSET = 0.015;
/**
 * Default Redwood line-height overrides cause false positives as the Range sizes are always for a 'normal'
 * line-height, and none of the default scale fonts have 'normal' line-height values. This causes offsets
 * of between 0.5px and 1.5px. As a true truncation will cause an offset of closer to a full line height
 * (at least 12px for 2xs text), use a larger offset value than the currently observed 1.5px max for safety.
 */
const VERTICAL_TRUNCATION_OFFSET = 5;
/**
 * Helper method to determine if a given cell contains truncated text.
 */
const hasTruncatedText = (cellElement) => {
    if (cellElement.getAttribute('data-oj-table-tooltip') !== 'enabled') {
        return false;
    }
    const innerText = String(cellElement.innerText).trim();
    if (innerText === '') {
        return false;
    }
    const walker = document.createTreeWalker(cellElement, NodeFilter.SHOW_TEXT);
    while (walker.nextNode()) {
        const range = new Range();
        const textNode = walker.currentNode;
        range.selectNodeContents(textNode);
        const untruncatedTextLength = range.getBoundingClientRect().width;
        const untruncatedTextHeight = range.getBoundingClientRect().height;
        let firstParent = true;
        let parentElement = textNode.parentElement;
        while (parentElement != null) {
            const parentStyles = getComputedStyle(parentElement);
            if (firstParent) {
                // only verify truncation status of 'visible' text nodes
                if (untruncatedTextLength === 0 || parentStyles.visibility === 'hidden') {
                    break;
                }
                firstParent = false;
            }
            const horizontalPadding = parseFloat(parentStyles.paddingLeft) + parseFloat(parentStyles.paddingRight);
            const horizontalBorder = parseFloat(parentStyles.borderLeft) + parseFloat(parentStyles.borderRight);
            const renderedTextLength = parentElement.getBoundingClientRect().width - horizontalPadding - horizontalBorder;
            const verticalPadding = parseFloat(parentStyles.paddingTop) + parseFloat(parentStyles.paddingBottom);
            const verticalBorder = parseFloat(parentStyles.borderTop) + parseFloat(parentStyles.borderBottom);
            const renderedTextHeight = parentElement.getBoundingClientRect().height - verticalPadding - verticalBorder;
            if (untruncatedTextLength - renderedTextLength > HORIZONTAL_TRUNCATION_OFFSET ||
                untruncatedTextHeight - renderedTextHeight > VERTICAL_TRUNCATION_OFFSET) {
                return true;
            }
            if (parentElement === cellElement) {
                break;
            }
            parentElement = parentElement.parentElement;
        }
    }
    return false;
};
/**
 * Helper function to handle updating the Table's tooltip due to a focus navigation gesture.
 */
function handleNavigationTooltipGesture(rootElement, tableId, cell, showTooltip, hideTooltip) {
    hideTooltip(true);
    if (cell.type === 'data' || cell.type === 'header' || cell.type === 'footer') {
        const cellElement = getElementFromCell(rootElement, tableId, cell);
        if (cellElement != null) {
            showTooltip(cell);
        }
    }
}
/**
 * Helper function to handle updating the Table's tooltip due to a pointer move gesture.
 */
function handleMoveTooltipGesture(tableId, columnsArray, event, showTooltip, hideTooltip, tooltipId) {
    let tooltipShown = false;
    const targetElement = event.relatedTarget;
    if (targetElement != null && targetElement.closest(`#${tooltipId}`) != null) {
        return;
    }
    const cellElement = event.target.closest(`[data-oj-table-focusable='${tableId}']`);
    if (cellElement != null) {
        const type = getCellType(cellElement);
        if (type === 'data' || type === 'header' || type === 'footer') {
            showTooltip(logicalCellExtractor(cellElement, tableId, columnsArray));
            tooltipShown = true;
        }
    }
    if (!tooltipShown) {
        hideTooltip();
    }
}
/**
 * Helper function to handle updating the Table's tooltip due to a pointer leave gesture.
 */
const handleLeaveTableTooltipGesture = (rootElement, event, hideTooltip, tooltipId) => {
    const targetElement = event.relatedTarget;
    if (targetElement != null && targetElement.closest(`#${tooltipId}`) != null) {
        // the pointer 'left' the table, but is only over a cell tooltip - in most cases, we want
        // to just return here as the pointer is still 'over' the table. however, this can also
        // occur when the pointer is technically outside of the table's bounds, and in that case
        // we don't actually want to return as we should clear out our cell tooltip as expected
        const boundingRect = rootElement.getBoundingClientRect();
        const isOutOfBounds = event.clientX < boundingRect.left ||
            event.clientX > boundingRect.right ||
            event.clientY < boundingRect.top ||
            event.clientY > boundingRect.bottom;
        if (!isOutOfBounds) {
            return;
        }
    }
    hideTooltip();
};
// Pointer Enter handler for elements that need to prevent default browser tooltips
const _pointerEnterHandler = (event) => {
    const targetElement = event.target;
    targetElement.classList.add(PRIVATE_Table_themes_Table_css.preventBrowserTooltipStyle);
};
// Pointer Leave handler for elements that need to prevent default browser tooltips
const _pointerLeaveHandler = (event) => {
    const targetElement = event.target;
    targetElement.classList.remove(PRIVATE_Table_themes_Table_css.preventBrowserTooltipStyle);
};
/*
 * Props that can be spread on elements that need to prevent default browser tooltips
 */
const preventBrowserTooltipProps = {
    onPointerEnter: _pointerEnterHandler,
    onPointerLeave: _pointerLeaveHandler
};

function _defaultCellRenderer({ rowData, field }) {
    return field != null ? String(rowData[field]) : undefined;
}
/**
 * The internal component used to render a single cell in a TableRow.
 */
function TableCell({ tableId, rowData, field, columnKey, columnIndex, rowKey, rowIndex, isFinalRowIndex, isFinalColumnIndex, isFirstLogicalColumnIndex, isFinalLogicalColumnIndex, hasVerticalGridlines, hasHorizontalGridlines, hasFooters, hasVerticalUnderflow, hasMore, isRowSelected, isPreviousRowSelected, isColumnSelected, isNextColumnSelected, isPreviousColumnSelected, isSticky, isShowFocusRing, hasTabIndex, isTabbableMode, isAccRowHeader, focusTarget = 'cell', renderer = _defaultCellRenderer, selectorRenderer, isRowSelectionEnabled, isRowSingleSelection, variant, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle, isStickyStartEdge, isStickyEndEdge, hasStartEdge, hasEndEdge, isRtl, isHighContrast, padding, tooltip, horizontalAlignment = 'start', verticalAlignment = 'center' }) {
    const browser = clientHints.getClientHints().browser;
    const rowContext = { key: rowKey, data: rowData };
    const columnPadding = typeof padding === 'function' ? padding(rowContext) : padding;
    const columnTooltip = typeof tooltip === 'function' ? tooltip(rowContext) : tooltip;
    const supportsDefaultTooltip = columnTooltip !== 'disabled';
    const hasLastHorizontalGridline = hasHorizontalGridlines && (hasMore || hasVerticalUnderflow || !hasFooters);
    const cellClasses = classNames.classNames(getDataCellClassArray({
        isFirstColumnIndex: columnIndex === 0 || isFirstLogicalColumnIndex,
        isFinalColumnIndex: isFinalColumnIndex || isFinalLogicalColumnIndex,
        isFirstRowIndex: rowIndex === 0,
        isFinalRowIndex,
        hasVerticalGridlines,
        hasHorizontalGridlines,
        hasLastHorizontalGridline,
        isRowSelected,
        isPreviousRowSelected,
        isColumnSelected,
        isNextColumnSelected,
        isPreviousColumnSelected,
        isSticky,
        hasStartEdge,
        hasEndEdge,
        isShowFocusRing,
        isRowSelectionEnabled,
        isRowSingleSelection,
        isActive: applyActiveStyle,
        isHover: applyHoverStyle,
        isPseudoHover: applyPseudoHoverStyle,
        isStickyStartEdge,
        isStickyEndEdge,
        isRtl,
        isHighContrast,
        horizontalAlignment,
        verticalAlignment,
        variant,
        padding: columnPadding
    }));
    const cellRendererProps = {
        rowData: rowData,
        rowKey: rowKey,
        field: field,
        columnKey: columnKey,
        selector: selectorRenderer,
        isTabbable: isTabbableMode
    };
    const supportsAutoFocus = typeof focusTarget === 'function'
        ? focusTarget(rowContext) === 'content'
        : focusTarget === 'content';
    return (jsxRuntime.jsx("td", { "aria-colindex": columnIndex + 1, class: cellClasses, tabIndex: hasTabIndex ? 0 : -1, role: isAccRowHeader ? 'rowheader' : 'gridcell', "data-oj-cell-type": 'data', "data-oj-column-key": columnKey, "data-oj-table-focusable": tableId, "data-oj-table-data-cell": tableId, "data-oj-table-tooltip": supportsDefaultTooltip ? 'enabled' : undefined, "data-oj-table-auto-focus": supportsAutoFocus ? 'enabled' : undefined, ...(supportsDefaultTooltip && browser === 'safari' ? preventBrowserTooltipProps : {}), ...(isColumnSelected ? { 'aria-selected': true } : {}), children: jsxRuntime.jsx(FormContext.FormContext.Provider, { value: { textAlign: getFormTextAlign(horizontalAlignment, isRtl) }, children: renderer(cellRendererProps) }) }));
}

/**
 * The internal component used to render a single row in Table.
 */
function TableRow({ tableId, rowKey, rowData, rowIndex, isFinalRow, columnsArray, rowHeaderColumnKeys, hasVerticalGridlines, hasHorizontalGridlines, hasFooters, hasVerticalUnderflow, hasMore, isSelected, isPreviousSelected, isRowSelectionEnabled, isSingleRowSelectionEnabled, selectedRowKeys = { all: false, keys: new Set() }, isShowFocusRing, activeColumnKey, isTabbableMode, selectedColumnKeys = { all: false, keys: new Set() }, variant, disabledInteractionKeys, onSelectionChange, startStickyEdge, endStickyEdge, firstStickyColumnIndex, finalStickyColumnIndex, columnBorderEdges, isRtl, isHighContrast }) {
    const translations = useTranslationBundle.useTranslationBundle('@oracle/oraclejet-preact');
    const { interactionProps, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle } = useInteractionStyle.useInteractionStyle({ disabledKeys: disabledInteractionKeys });
    const rowStyles = isHighContrast ? PRIVATE_Table_themes_TableRowStyles_css.tableRowStylesHC : PRIVATE_Table_themes_TableRowStyles_css.tableRowStyles;
    const classArray = [rowStyles.base, isFinalRow ? rowStyles.lastRowHeight : rowStyles.rowHeight];
    const classes = classNames.classNames(classArray);
    const accessibleRowName = (rowIndex + 2).toString();
    const handleRowSelectorChange = (detail) => {
        if (onSelectionChange != null) {
            onSelectionChange({
                value: {
                    row: detail.value,
                    column: { all: false, keys: new Set() }
                },
                target: detail.target
            }, false);
        }
    };
    const selectorRenderer = isRowSelectionEnabled && !isSingleRowSelectionEnabled
        ? () => {
            // conversion from 0-based index and adding the header row as it is always rendered
            return (jsxRuntime.jsx(Selector.Selector, { "aria-label": translations.collection_selectRow({ ROW_NAME: accessibleRowName }), onChange: handleRowSelectorChange, rowKey: rowKey, selectedKeys: selectedRowKeys }));
        }
        : undefined;
    let isPreviousColumnSelected = false;
    let isPreviousStickyColumnSelected = false;
    return (jsxRuntime.jsx("tr", { "aria-rowindex": rowIndex + 2, class: classes, role: 'row', "data-oj-key": rowKey, "data-oj-table-data-row": tableId, ...(isRowSelectionEnabled
            ? isSelected
                ? { 'aria-selected': true }
                : { 'aria-selected': false }
            : {}), ...(typeof rowKey === 'number' && { 'data-oj-key-type': 'number' }), ...(isRowSelectionEnabled && interactionProps), children: columnsArray.map((column, columnIndex) => {
            const columnKey = column.key;
            const isColumnSelected = keys.containsKey(selectedColumnKeys, columnKey);
            const isActive = columnKey === activeColumnKey;
            const hasTabIndex = isActive && !isTabbableMode;
            const isSticky = column.value.sticky === 'enabled';
            let nextVisibleColumn;
            let isNextVisibleColumnSelected = false;
            let isPreviousVisibleColumnSelected = false;
            let isFirstLogicalColumnIndex = false;
            let isFinalLogicalColumnIndex = false;
            if (isSticky) {
                if (startStickyEdge != null && firstStickyColumnIndex === columnIndex) {
                    isFirstLogicalColumnIndex = true;
                }
                if (endStickyEdge != null && finalStickyColumnIndex === columnIndex) {
                    isFinalLogicalColumnIndex = true;
                }
                if ((startStickyEdge != null && startStickyEdge > columnIndex) ||
                    (endStickyEdge != null && endStickyEdge <= columnIndex)) {
                    for (let i = columnIndex + 1; i < columnsArray.length; i++) {
                        if (columnsArray[i].value.sticky === 'enabled') {
                            nextVisibleColumn = columnsArray[i];
                            break;
                        }
                    }
                }
                else {
                    nextVisibleColumn =
                        columnIndex < columnsArray.length - 1 ? columnsArray[columnIndex + 1] : undefined;
                }
                isNextVisibleColumnSelected =
                    startStickyEdge === columnIndex
                        ? false
                        : nextVisibleColumn != null && keys.containsKey(selectedColumnKeys, nextVisibleColumn.key);
                if ((startStickyEdge != null && startStickyEdge >= columnIndex) ||
                    (endStickyEdge != null && endStickyEdge < columnIndex)) {
                    isPreviousVisibleColumnSelected = isPreviousStickyColumnSelected;
                }
                else if (endStickyEdge !== columnIndex) {
                    isPreviousVisibleColumnSelected = isPreviousColumnSelected;
                }
            }
            else {
                isPreviousVisibleColumnSelected = isPreviousColumnSelected;
            }
            const cellProps = {
                tableId: tableId,
                rowData: rowData,
                field: column.value.field,
                stickyColumn: column.value.sticky,
                columnKey: columnKey,
                columnIndex: columnIndex,
                rowKey: rowKey,
                rowIndex: rowIndex,
                isFinalRowIndex: isFinalRow,
                isFinalColumnIndex: columnIndex === columnsArray.length - 1,
                isFirstLogicalColumnIndex: isFirstLogicalColumnIndex,
                isFinalLogicalColumnIndex: isFinalLogicalColumnIndex,
                hasVerticalGridlines: hasVerticalGridlines,
                hasHorizontalGridlines: hasHorizontalGridlines,
                hasFooters: hasFooters,
                hasVerticalUnderflow: hasVerticalUnderflow,
                hasMore: hasMore,
                isRowSelected: isSelected,
                isPreviousRowSelected: isPreviousSelected,
                isSticky: isSticky,
                isColumnSelected: isColumnSelected,
                isNextColumnSelected: isNextVisibleColumnSelected,
                isPreviousColumnSelected: isPreviousVisibleColumnSelected,
                isShowFocusRing: isShowFocusRing && isActive,
                hasTabIndex: hasTabIndex,
                isTabbableMode: isTabbableMode,
                isAccRowHeader: rowHeaderColumnKeys.has(column.key),
                renderer: column.value.renderer,
                selectorRenderer: selectorRenderer,
                isRowSelectionEnabled: isRowSelectionEnabled,
                variant: variant,
                isRowSingleSelection: isSingleRowSelectionEnabled,
                applyActiveStyle: applyActiveStyle,
                applyHoverStyle: applyHoverStyle,
                applyPseudoHoverStyle: applyPseudoHoverStyle,
                isStickyStartEdge: columnIndex === startStickyEdge,
                isStickyEndEdge: columnIndex === endStickyEdge,
                hasStartEdge: columnBorderEdges[columnIndex].hasStart,
                hasEndEdge: columnBorderEdges[columnIndex].hasEnd,
                isRtl: isRtl,
                isHighContrast: isHighContrast,
                padding: column.value.padding,
                tooltip: column.value.tooltip,
                focusTarget: column.value.focusTarget,
                horizontalAlignment: column.value.alignment?.horizontal != null
                    ? column.value.alignment.horizontal
                    : column.value.horizontalAlignment,
                verticalAlignment: column.value.alignment?.vertical
            };
            isPreviousColumnSelected = isColumnSelected;
            if (isSticky) {
                isPreviousStickyColumnSelected = isColumnSelected;
            }
            return jsxRuntime.jsx(TableCell, { ...cellProps });
        }) }));
}
const _areStringSetsEquivalent = (set1, set2) => {
    if (set1 == null) {
        return set2 == null;
    }
    if (set2 == null) {
        return false;
    }
    return set1.size === set2.size && [...set1].every((x) => set2.has(x));
};
const _areColumnsArraysEquivalent = (columnsArray1, columnsArray2) => {
    if (columnsArray1.length === columnsArray2.length) {
        for (let i = 0; i < columnsArray1.length; i++) {
            if (columnsArray1[i].key !== columnsArray2[i].key ||
                columnsArray1[i].value !== columnsArray2[i].value) {
                return false;
            }
        }
        return true;
    }
    return false;
};
const MemoizeTableRow = compat.memo(TableRow, (prev, next) => {
    if (prev && next) {
        return (prev.tableId === next.tableId &&
            prev.rowKey === next.rowKey &&
            prev.rowData === next.rowData &&
            prev.rowIndex === next.rowIndex &&
            prev.isFinalRow === next.isFinalRow &&
            _areColumnsArraysEquivalent(prev.columnsArray, next.columnsArray) &&
            prev.hasHorizontalGridlines === next.hasHorizontalGridlines &&
            prev.hasVerticalGridlines === next.hasVerticalGridlines &&
            (!next.isFinalRow ||
                (prev.hasFooters === next.hasFooters &&
                    prev.hasVerticalUnderflow === next.hasVerticalUnderflow &&
                    prev.hasMore === next.hasMore)) &&
            _areStringSetsEquivalent(prev.rowHeaderColumnKeys, next.rowHeaderColumnKeys) &&
            prev.isSelected === next.isSelected &&
            prev.isPreviousSelected === next.isPreviousSelected &&
            prev.isRowSelectionEnabled === next.isRowSelectionEnabled &&
            prev.isSingleRowSelectionEnabled === next.isSingleRowSelectionEnabled &&
            (prev.isRowSelectionEnabled && !prev.isSingleRowSelectionEnabled
                ? keys.isSameKey(prev.selectedRowKeys, next.selectedRowKeys)
                : true) &&
            keys.isSameKey(prev.selectedColumnKeys, next.selectedColumnKeys) &&
            prev.isShowFocusRing === next.isShowFocusRing &&
            prev.activeColumnKey === next.activeColumnKey &&
            prev.isTabbableMode === next.isTabbableMode &&
            prev.variant === next.variant &&
            prev.onSelectionChange === next.onSelectionChange &&
            prev.startStickyEdge === next.startStickyEdge &&
            prev.endStickyEdge === next.endStickyEdge &&
            prev.firstStickyColumnIndex === next.firstStickyColumnIndex &&
            prev.finalStickyColumnIndex === next.finalStickyColumnIndex &&
            prev.columnBorderEdges === next.columnBorderEdges &&
            prev.isRtl === next.isRtl &&
            prev.isHighContrast === next.isHighContrast &&
            prev.disabledInteractionKeys === next.disabledInteractionKeys);
    }
    return false;
});

/**
 * The internal component used to render a single cell in a TableRow.
 */
function TableNoData({ rootRef, tableId, columnsCount, isShowFocusRing, hasTabIndex, isTabbableMode, ariaRowIndex, renderer }) {
    const browser = clientHints.getClientHints().browser;
    const translations = useTranslationBundle.useTranslationBundle('@oracle/oraclejet-preact');
    const rowClasses = classNames.classNames([PRIVATE_Table_themes_TableRowStyles_css.tableRowStyles.base]);
    const { classes: themeClasses } = useComponentTheme.useComponentTheme(PRIVATE_Table_themes_redwood_TableNoDataTheme.TableNoDataRedwoodTheme, {
        defaultRenderer: renderer == null ? 'isDefaultRenderer' : 'notDefaultRenderer',
        showFocusRing: isShowFocusRing ? 'isShowFocusRing' : 'notShowFocusRing'
    });
    const cellClasses = classNames.classNames([themeClasses]);
    function defaultContentRenderer() {
        return translations.collection_noData();
    }
    const contentRenderer = renderer != null ? renderer : defaultContentRenderer;
    // in firefox, table element heights are not stretched unless explicitly set in some cases
    hooks.useLayoutEffect(() => {
        if (browser === 'firefox') {
            const rootElement = rootRef.current;
            if (rootElement != null) {
                const tableBodyElement = rootElement.querySelector(`[data-oj-table-body='${tableId}']`);
                const noDataElement = rootElement.querySelector(`[data-oj-table-nodata-cell='${tableId}']`);
                if (tableBodyElement != null && noDataElement != null) {
                    noDataElement.style.height = '';
                    noDataElement.style.height = `${tableBodyElement.getBoundingClientRect().height}px`;
                }
            }
        }
    });
    return (jsxRuntime.jsx("tr", { "aria-rowindex": ariaRowIndex, class: rowClasses, role: 'row', children: jsxRuntime.jsx("td", { "aria-colindex": 1, class: cellClasses, style: browser !== 'firefox' ? 'height: 100%;' : undefined, tabIndex: hasTabIndex ? 0 : -1, role: 'gridcell', colSpan: columnsCount, "data-oj-cell-type": 'noData', "data-oj-table-focusable": tableId, "data-oj-table-nodata-cell": tableId, children: contentRenderer({ isTabbable: isTabbableMode }) }) }));
}

/**
 * The internal component used to render a single cell in a TableRow.
 */
function TableBody({ rootRef, viewportInfo, tableId, isValidRender, getAccessibleRowHeaders, tableData, columnsArray, hasVerticalGridlines, hasHorizontalGridlines, hasFooters, hasVerticalUnderflow, isShowFocusRing, isTabbableMode, hasMore, onLoadMore, activeCell, currentRowKey, currentRowVariant, selected, isRowSelectionEnabled, isSingleRowSelectionEnabled, disabledInteractionKeys, onSelectionChange, noDataRenderer, startStickyEdge, endStickyEdge, firstStickyColumnIndex, finalStickyColumnIndex, columnBorderEdges, isRtl, isHighContrast }) {
    const browser = clientHints.getClientHints().browser;
    // returns a TableRowContext based on ItemContext (added key)
    const getRowContext = hooks.useCallback((context) => {
        return {
            index: context.index,
            data: context.data.data,
            key: context.data.metadata
        };
    }, []);
    let isPreviousSelected = false;
    const collectionChildrenFunc = (context) => {
        const tableRowContext = getRowContext(context);
        const rowKey = tableRowContext.key;
        const containsActiveCell = activeCell?.rowKey === rowKey;
        const activeColumnKey = containsActiveCell ? activeCell.columnKey : undefined;
        const isSelected = keys.containsKey(selected.row, rowKey);
        const rowProps = {
            tableId: tableId,
            columnsArray: columnsArray,
            rowHeaderColumnKeys: getAccessibleRowHeaders(tableRowContext),
            hasVerticalGridlines: hasVerticalGridlines,
            hasHorizontalGridlines: hasHorizontalGridlines,
            hasFooters: hasFooters,
            hasVerticalUnderflow: hasVerticalUnderflow,
            hasMore: hasMore,
            isSelected: isSelected,
            isPreviousSelected: isPreviousSelected,
            disabledInteractionKeys: disabledInteractionKeys,
            onSelectionChange: onSelectionChange,
            isRowSelectionEnabled: isRowSelectionEnabled,
            isSingleRowSelectionEnabled: isSingleRowSelectionEnabled,
            variant: currentRowKey === rowKey ? currentRowVariant : 'none',
            isShowFocusRing: isShowFocusRing && containsActiveCell,
            activeColumnKey: activeColumnKey,
            isTabbableMode: isTabbableMode,
            selectedRowKeys: selected.row,
            selectedColumnKeys: selected.column,
            rowIndex: tableRowContext.index,
            rowKey: rowKey,
            rowData: tableRowContext.data,
            isFinalRow: tableRowContext.index === tableData.length - 1,
            startStickyEdge: startStickyEdge,
            endStickyEdge: endStickyEdge,
            firstStickyColumnIndex: firstStickyColumnIndex,
            finalStickyColumnIndex: finalStickyColumnIndex,
            columnBorderEdges: columnBorderEdges,
            isRtl: isRtl,
            isHighContrast: isHighContrast
        };
        isPreviousSelected = isSelected;
        return jsxRuntime.jsx(MemoizeTableRow, { ...rowProps });
    };
    const getNoDataProps = () => {
        const isActive = activeCell?.type === 'noData';
        const hasTabIndex = isActive && !isTabbableMode;
        return {
            rootRef: rootRef,
            tableId: tableId,
            columnsCount: columnsArray.length,
            isShowFocusRing: isShowFocusRing && isActive,
            hasTabIndex: hasTabIndex,
            isTabbableMode: isTabbableMode,
            ariaRowIndex: isValidRender ? 2 : 1,
            renderer: isValidRender ? noDataRenderer : undefined
        };
    };
    const isShowEmptyLoading = tableData.length === 0 && hasMore;
    const isShowNoData = tableData.length === 0 && !hasMore;
    const loadMoreViewportConfig = {
        scroller: () => viewportInfo.viewportConfig.scroller().current
    };
    return (jsxRuntime.jsx("tbody", { class: PRIVATE_Table_themes_Table_css.backgroundStyles.inherit, role: 'presentation', "data-oj-table-body": tableId, children: isShowNoData || !isValidRender ? (jsxRuntime.jsx(TableNoData, { ...getNoDataProps() })) : (jsxRuntime.jsxs(preact.Fragment, { children: [jsxRuntime.jsx(LoadMoreCollection.LoadMoreCollection, { data: tableData, loadMoreIndicator: jsxRuntime.jsx(TableSkeletonRow, { tableId: tableId, hasTabIndex: isShowEmptyLoading
                            ? activeCell?.type === 'loading'
                            : activeCell?.type === 'loadMore', colspan: columnsArray.length, isLoadMore: !isShowEmptyLoading, isShowFocusRing: isShowFocusRing &&
                            (isShowEmptyLoading
                                ? activeCell?.type === 'loading'
                                : activeCell?.type === 'loadMore'), isHighContrast: isHighContrast }), hasMore: hasMore, onLoadMore: onLoadMore, viewportConfig: loadMoreViewportConfig, children: collectionChildrenFunc }), jsxRuntime.jsx("tr", { style: browser !== 'firefox' ? 'height: 100%;' : undefined, role: 'presentation', "data-oj-table-spacer-row": tableId })] })) }));
}

/**
 * The internal component used to render a single cell in a TableHeaderRow.
 */
function TableHeaderCell({ tableId, columnKey, columnIndex, isFinalColumnIndex, isFirstLogicalColumnIndex, isFinalLogicalColumnIndex, hasVerticalGridlines, isSelected, isNextColumnSelected, isPreviousColumnSelected, isSticky, isColumnSelectable, isRowSelectionEnabled, selectedRowKeys = { all: false, keys: new Set() }, isShowFocusRing, hasTabIndex, isTabbableMode, headerText, stickyTopOffset = 0, focusTarget = 'cell', renderer, onSelectionChange, isShowSortIcon, sortable = 'disabled', sortDirection = 'unsorted', onSortCriterionChange, isStickyStartEdge, isStickyEndEdge, hasStartEdge, hasEndEdge, isActiveStyle, isHoverStyle, isPreviousCellActiveStyle, isPreviousCellHoverStyle, isRtl, isAccColumnHeader, isHighContrast, padding, tooltip, horizontalAlignment = 'start', verticalAlignment = 'center' }) {
    const browser = clientHints.getClientHints().browser;
    const supportsDefaultTooltip = tooltip !== 'disabled';
    const supportsAutoFocus = focusTarget === 'content';
    const translations = useTranslationBundle.useTranslationBundle('@oracle/oraclejet-preact');
    const cellClasses = classNames.classNames(getHeaderFooterCellClassArray({
        isHeader: true,
        isActiveStyle,
        isHoverStyle,
        isPreviousCellActiveStyle,
        isPreviousCellHoverStyle,
        isFirstColumnIndex: columnIndex === 0 || isFirstLogicalColumnIndex,
        isFinalColumnIndex: isFinalColumnIndex || isFinalLogicalColumnIndex,
        hasVerticalGridlines,
        isSelected,
        isNextColumnSelected,
        isPreviousColumnSelected,
        isSticky,
        isShowFocusRing,
        isStickyStartEdge,
        isStickyEndEdge,
        hasStartEdge,
        hasEndEdge,
        isRtl,
        horizontalAlignment,
        verticalAlignment,
        isHighContrast,
        padding
    }));
    let selectorAllState;
    if (keys.isSameKey(selectedRowKeys, { all: true, deletedKeys: new Set() })) {
        selectorAllState = 'all';
    }
    else if (keys.isSameKey(selectedRowKeys, { all: false, keys: new Set() })) {
        selectorAllState = 'none';
    }
    else {
        selectorAllState = 'partial';
    }
    const handleSelectorChange = (detail) => {
        if (onSelectionChange != null) {
            onSelectionChange({
                value: {
                    row: detail.value,
                    column: { all: false, keys: new Set() }
                },
                target: detail.target
            }, false);
        }
    };
    const selectorRenderer = isRowSelectionEnabled
        ? () => (jsxRuntime.jsx(SelectorAll.SelectorAll, { "aria-label": translations.collection_selectAllRows(), onChange: handleSelectorChange, selected: selectorAllState }))
        : undefined;
    const handleSortGesture = hooks.useCallback(() => {
        if (onSortCriterionChange != null) {
            const newDirection = sortDirection === 'ascending' ? 'descending' : 'ascending';
            onSortCriterionChange([{ key: columnKey, sortDirection: newDirection }]);
        }
    }, [columnKey, sortDirection, onSortCriterionChange]);
    const headerCellRendererProps = {
        key: columnKey,
        headerText: headerText,
        sortable: sortable,
        sortDirection: sortDirection,
        selector: selectorRenderer,
        isTabbable: isTabbableMode
    };
    const getHeaderCellRenderer = hooks.useCallback(() => {
        if (renderer != null) {
            return renderer;
        }
        return ({ headerText, sortable, sortDirection }) => {
            const text = headerText != null ? (jsxRuntime.jsx("div", { class: PRIVATE_Table_themes_Table_css.tableHeaderCellTextStyles.base, children: jsxRuntime.jsx("span", { class: PRIVATE_Table_themes_TableHeaderCellStyles_css.tableHeaderCellStyles.defaultRendererSpan, children: headerText }) })) : undefined;
            if (sortable === 'enabled' || sortDirection !== 'unsorted') {
                const isIconFirst = horizontalAlignment === 'end' ||
                    (!isRtl && horizontalAlignment === 'right') ||
                    (isRtl && horizontalAlignment === 'left');
                const containerClasses = classNames.classNames([
                    PRIVATE_Table_themes_Table_css.tableHeaderSortContainerStyles.base,
                    PRIVATE_Table_themes_Table_css.justifyContentStyles[horizontalAlignment]
                ]);
                return (jsxRuntime.jsxs("div", { class: containerClasses, children: [isIconFirst && jsxRuntime.jsx(SortControl.SortControl, {}), text, !isIconFirst && jsxRuntime.jsx(SortControl.SortControl, {})] }));
            }
            return text;
        };
    }, [renderer, horizontalAlignment, isRtl]);
    const getAriaSelected = () => {
        if (isSelected) {
            return { 'aria-selected': true };
        }
        return isColumnSelectable ? { 'aria-selected': false } : undefined;
    };
    const getAriaSort = () => {
        if (sortDirection === 'ascending' || sortDirection === 'descending') {
            return { 'aria-sort': sortDirection };
        }
        return undefined;
    };
    return (jsxRuntime.jsx(useSortableContext.SortableContext.Provider, { value: { isRendered: isShowSortIcon, sortable, sortDirection, onSort: handleSortGesture }, children: jsxRuntime.jsx("th", { "aria-colindex": columnIndex + 1, ...getAriaSelected(), ...getAriaSort(), class: cellClasses, style: `top:${stickyTopOffset}px;`, tabIndex: hasTabIndex ? 0 : -1, role: isAccColumnHeader ? 'columnheader' : 'gridcell', "data-oj-cell-type": 'header', "data-oj-column-key": columnKey, "data-oj-table-focusable": tableId, "data-oj-table-header-cell": tableId, "data-oj-table-tooltip": supportsDefaultTooltip ? 'enabled' : undefined, "data-oj-table-auto-focus": supportsAutoFocus ? 'enabled' : undefined, ...(supportsDefaultTooltip && browser === 'safari' ? preventBrowserTooltipProps : {}), children: jsxRuntime.jsx(FormContext.FormContext.Provider, { value: { textAlign: getFormTextAlign(horizontalAlignment, isRtl) }, children: getHeaderCellRenderer()(headerCellRendererProps) }) }) }));
}

/**
 * The internal component used to render a header region in Table.
 */
function TableHeader({ tableId, isRendered, columnsArray, hasVerticalGridlines, activeKey, isTabbableMode, isShowFocusRing, selectedColumnKeys, selectedRowKeys, isColumnSelectionEnabled, isRowSelectionEnabled, onSelectionChange, isForceSortIcons, activeStyleKey, hoverStyleKey, sortCriterion, onSortCriterionChange, stickyTopOffset, startStickyEdge, endStickyEdge, firstStickyColumnIndex, finalStickyColumnIndex, columnBorderEdges, isResizeHover, isRtl, isHighContrast }) {
    const rowClasses = classNames.classNames([PRIVATE_Table_themes_Table_css.tableHeaderRowStyles.base]);
    const getStyle = () => {
        return isResizeHover ? 'cursor: col-resize;' : '';
    };
    let previousColumnKey;
    let previousStickyColumnKey;
    let isPreviousSelectable = false;
    let isPreviousStickySelectable = false;
    let isPreviousColumnSelected = false;
    let isPreviousStickyColumnSelected = false;
    return isRendered ? (jsxRuntime.jsx("thead", { class: PRIVATE_Table_themes_Table_css.backgroundStyles.inherit, role: 'presentation', children: jsxRuntime.jsx("tr", { "aria-rowindex": 1, class: rowClasses, role: 'row', style: getStyle(), "data-oj-table-header-row": tableId, children: columnsArray.map((column, columnIndex) => {
                const columnKey = column.key;
                let sortDirection;
                if (sortCriterion != null) {
                    for (const criterion of sortCriterion) {
                        if (criterion.key === columnKey) {
                            sortDirection = criterion.sortDirection;
                            break;
                        }
                    }
                }
                const sortable = column.value.sortable;
                const hasSortIcon = sortable === 'enabled' || sortDirection != null;
                const isShowSortIcon = hasSortIcon &&
                    (isForceSortIcons || sortDirection != null || hoverStyleKey === columnKey);
                const isSticky = column.value.sticky === 'enabled';
                const isSelectable = isColumnSelectionEnabled && column.value.selectable !== 'disabled';
                const isSelected = keys.containsKey(selectedColumnKeys, columnKey);
                const isActive = columnKey === activeKey;
                const hasTabIndex = isActive && !isTabbableMode;
                let previousVisibleColumnKey;
                let isPreviousVisibleColumnSelectable = false;
                let isPreviousVisibleColumnSelected = false;
                let nextVisibleColumn;
                let isNextVisibleColumnSelected = false;
                let isFirstLogicalColumnIndex = false;
                let isFinalLogicalColumnIndex = false;
                if (isSticky) {
                    if (startStickyEdge != null && firstStickyColumnIndex === columnIndex) {
                        isFirstLogicalColumnIndex = true;
                    }
                    if (endStickyEdge != null && finalStickyColumnIndex === columnIndex) {
                        isFinalLogicalColumnIndex = true;
                    }
                    if ((startStickyEdge != null && startStickyEdge > columnIndex) ||
                        (endStickyEdge != null && endStickyEdge <= columnIndex)) {
                        for (let i = columnIndex + 1; i < columnsArray.length; i++) {
                            if (columnsArray[i].value.sticky === 'enabled') {
                                nextVisibleColumn = columnsArray[i];
                                break;
                            }
                        }
                    }
                    else {
                        nextVisibleColumn =
                            columnIndex < columnsArray.length - 1 ? columnsArray[columnIndex + 1] : undefined;
                    }
                    isNextVisibleColumnSelected =
                        startStickyEdge === columnIndex
                            ? false
                            : nextVisibleColumn != null &&
                                keys.containsKey(selectedColumnKeys, nextVisibleColumn.key);
                    if ((startStickyEdge != null && startStickyEdge >= columnIndex) ||
                        (endStickyEdge != null && endStickyEdge < columnIndex)) {
                        previousVisibleColumnKey = previousStickyColumnKey;
                        isPreviousVisibleColumnSelectable = isPreviousStickySelectable;
                        isPreviousVisibleColumnSelected = isPreviousStickyColumnSelected;
                    }
                    else if (endStickyEdge !== columnIndex) {
                        previousVisibleColumnKey = previousColumnKey;
                        isPreviousVisibleColumnSelectable = isPreviousSelectable;
                        isPreviousVisibleColumnSelected = isPreviousColumnSelected;
                    }
                }
                else {
                    previousVisibleColumnKey = previousColumnKey;
                    isPreviousVisibleColumnSelectable = isPreviousSelectable;
                    isPreviousVisibleColumnSelected = isPreviousColumnSelected;
                }
                const headerCellProps = {
                    tableId: tableId,
                    hasVerticalGridlines: hasVerticalGridlines,
                    columnKey: columnKey,
                    columnIndex: columnIndex,
                    isFinalColumnIndex: columnIndex === columnsArray.length - 1,
                    isFirstLogicalColumnIndex: isFirstLogicalColumnIndex,
                    isFinalLogicalColumnIndex: isFinalLogicalColumnIndex,
                    stickyTopOffset: stickyTopOffset,
                    isSticky: isSticky,
                    isSelected: isSelected,
                    isNextColumnSelected: isNextVisibleColumnSelected,
                    isPreviousColumnSelected: isPreviousVisibleColumnSelected,
                    hasStartEdge: columnBorderEdges[columnIndex].hasStart,
                    hasEndEdge: columnBorderEdges[columnIndex].hasEnd,
                    selectedRowKeys: selectedRowKeys,
                    isColumnSelectable: isSelectable,
                    isRowSelectionEnabled: isRowSelectionEnabled,
                    isShowFocusRing: isShowFocusRing && isActive,
                    hasTabIndex: hasTabIndex,
                    isTabbableMode: isTabbableMode,
                    headerText: column.value.headerText,
                    renderer: column.value.headerRenderer,
                    onSelectionChange: onSelectionChange,
                    isShowSortIcon: isShowSortIcon,
                    sortable: sortable,
                    sortDirection: sortDirection,
                    onSortCriterionChange: onSortCriterionChange,
                    isStickyStartEdge: columnIndex === startStickyEdge,
                    isStickyEndEdge: columnIndex === endStickyEdge,
                    isActiveStyle: isSelectable && activeStyleKey === columnKey,
                    isHoverStyle: isSelectable && hoverStyleKey === columnKey,
                    isPreviousCellActiveStyle: activeStyleKey != null &&
                        activeStyleKey === previousVisibleColumnKey &&
                        isPreviousVisibleColumnSelectable,
                    isPreviousCellHoverStyle: hoverStyleKey != null &&
                        hoverStyleKey === previousVisibleColumnKey &&
                        isPreviousVisibleColumnSelectable,
                    isRtl: isRtl,
                    isAccColumnHeader: column.value.accessibleColumnHeader !== 'disabled',
                    isHighContrast: isHighContrast,
                    padding: column.value.headerPadding,
                    tooltip: column.value.headerTooltip,
                    focusTarget: column.value.headerFocusTarget,
                    horizontalAlignment: column.value.headerAlignment?.horizontal != null
                        ? column.value.headerAlignment.horizontal
                        : column.value.horizontalAlignment,
                    verticalAlignment: column.value.headerAlignment?.vertical
                };
                previousColumnKey = columnKey;
                isPreviousSelectable = isSelectable;
                isPreviousColumnSelected = isSelected;
                if (isSticky) {
                    previousStickyColumnKey = columnKey;
                    isPreviousStickySelectable = isSelectable;
                    isPreviousStickyColumnSelected = isSelected;
                }
                return jsxRuntime.jsx(TableHeaderCell, { ...headerCellProps });
            }) }) })) : null;
}

function _defaultFooterCellRenderer({ footerText }) {
    return footerText != null ? footerText : undefined;
}
/**
 * The internal component used to render a single cell in a TableFooterRow.
 */
function TableFooterCell({ tableId, columnKey, columnIndex, isFinalColumnIndex, isFirstLogicalColumnIndex, isFinalLogicalColumnIndex, hasVerticalGridlines, isSelected, isNextColumnSelected, isPreviousColumnSelected, isSticky, isColumnSelectable, isShowFocusRing, hasTabIndex, isTabbableMode, stickyBottomOffset = 0, focusTarget = 'cell', footerText, renderer = _defaultFooterCellRenderer, isStickyStartEdge, isStickyEndEdge, hasStartEdge, hasEndEdge, isActiveStyle, isHoverStyle, isPreviousCellActiveStyle, isPreviousCellHoverStyle, isRtl, isHighContrast, padding, tooltip, horizontalAlignment = 'start', verticalAlignment = 'center' }) {
    const browser = clientHints.getClientHints().browser;
    const supportsDefaultTooltip = tooltip !== 'disabled';
    const supportsAutoFocus = focusTarget === 'content';
    const cellClasses = classNames.classNames(getHeaderFooterCellClassArray({
        isHeader: false,
        isActiveStyle,
        isHoverStyle,
        isPreviousCellActiveStyle,
        isPreviousCellHoverStyle,
        isFirstColumnIndex: columnIndex === 0 || isFirstLogicalColumnIndex,
        isFinalColumnIndex: isFinalColumnIndex || isFinalLogicalColumnIndex,
        hasVerticalGridlines,
        isSelected,
        isNextColumnSelected,
        isPreviousColumnSelected,
        isSticky,
        hasStartEdge,
        hasEndEdge,
        isShowFocusRing,
        isStickyStartEdge,
        isStickyEndEdge,
        isRtl,
        horizontalAlignment,
        verticalAlignment,
        isHighContrast,
        padding
    }));
    const footerCellRendererProps = {
        key: columnKey,
        footerText: footerText,
        isTabbable: isTabbableMode
    };
    return (jsxRuntime.jsx("td", { "aria-colindex": columnIndex + 1, ...(isSelected
            ? { 'aria-selected': true }
            : isColumnSelectable
                ? { 'aria-selected': false }
                : {}), class: cellClasses, style: `bottom:${stickyBottomOffset}px;`, tabIndex: hasTabIndex ? 0 : -1, role: 'gridcell', "data-oj-cell-type": 'footer', "data-oj-column-key": columnKey, "data-oj-table-focusable": tableId, "data-oj-table-footer-cell": tableId, "data-oj-table-tooltip": supportsDefaultTooltip ? 'enabled' : undefined, "data-oj-table-auto-focus": supportsAutoFocus ? 'enabled' : undefined, ...(supportsDefaultTooltip && browser === 'safari' ? preventBrowserTooltipProps : {}), children: jsxRuntime.jsx(FormContext.FormContext.Provider, { value: { textAlign: getFormTextAlign(horizontalAlignment, isRtl) }, children: renderer(footerCellRendererProps) }) }));
}

/**
 * The internal component used to render a footer region in Table.
 */
function TableFooter({ tableId, isRendered, columnsArray, hasVerticalGridlines, activeKey, isTabbableMode, isShowFocusRing, selectedColumnKeys, isColumnSelectionEnabled, activeStyleKey, hoverStyleKey, stickyBottomOffset, startStickyEdge, endStickyEdge, firstStickyColumnIndex, finalStickyColumnIndex, columnBorderEdges, dataRowCount, isRtl, isHighContrast }) {
    const rowClasses = classNames.classNames([PRIVATE_Table_themes_Table_css.tableFooterRowStyles.base]);
    let previousColumnKey;
    let previousStickyColumnKey;
    let isPreviousSelectable = false;
    let isPreviousStickySelectable = false;
    let isPreviousColumnSelected = false;
    let isPreviousStickyColumnSelected = false;
    return isRendered ? (jsxRuntime.jsx("tfoot", { class: PRIVATE_Table_themes_Table_css.backgroundStyles.inherit, role: 'presentation', children: jsxRuntime.jsx("tr", { "aria-rowindex": Math.max(dataRowCount, 1) + 2, class: rowClasses, role: 'row', "data-oj-table-footer-row": tableId, children: columnsArray.map((column, columnIndex) => {
                const columnKey = column.key;
                const isSticky = column.value.sticky === 'enabled';
                const isSelectable = isColumnSelectionEnabled && column.value.selectable !== 'disabled';
                const isSelected = keys.containsKey(selectedColumnKeys, columnKey);
                const isActive = columnKey === activeKey;
                const hasTabIndex = isActive && !isTabbableMode;
                let previousVisibleColumnKey;
                let isPreviousVisibleColumnSelectable = false;
                let isPreviousVisibleColumnSelected = false;
                let nextVisibleColumn;
                let isNextVisibleColumnSelected = false;
                let isFirstLogicalColumnIndex = false;
                let isFinalLogicalColumnIndex = false;
                if (isSticky) {
                    if (startStickyEdge != null && firstStickyColumnIndex === columnIndex) {
                        isFirstLogicalColumnIndex = true;
                    }
                    if (endStickyEdge != null && finalStickyColumnIndex === columnIndex) {
                        isFinalLogicalColumnIndex = true;
                    }
                    if ((startStickyEdge != null && startStickyEdge > columnIndex) ||
                        (endStickyEdge != null && endStickyEdge <= columnIndex)) {
                        for (let i = columnIndex + 1; i < columnsArray.length; i++) {
                            if (columnsArray[i].value.sticky === 'enabled') {
                                nextVisibleColumn = columnsArray[i];
                                break;
                            }
                        }
                    }
                    else {
                        nextVisibleColumn =
                            columnIndex < columnsArray.length - 1 ? columnsArray[columnIndex + 1] : undefined;
                    }
                    isNextVisibleColumnSelected =
                        startStickyEdge === columnIndex
                            ? false
                            : nextVisibleColumn != null &&
                                keys.containsKey(selectedColumnKeys, nextVisibleColumn.key);
                    if ((startStickyEdge != null && startStickyEdge >= columnIndex) ||
                        (endStickyEdge != null && endStickyEdge < columnIndex)) {
                        previousVisibleColumnKey = previousStickyColumnKey;
                        isPreviousVisibleColumnSelectable = isPreviousStickySelectable;
                        isPreviousVisibleColumnSelected = isPreviousStickyColumnSelected;
                    }
                    else if (endStickyEdge !== columnIndex) {
                        previousVisibleColumnKey = previousColumnKey;
                        isPreviousVisibleColumnSelectable = isPreviousSelectable;
                        isPreviousVisibleColumnSelected = isPreviousColumnSelected;
                    }
                }
                else {
                    previousVisibleColumnKey = previousColumnKey;
                    isPreviousVisibleColumnSelectable = isPreviousSelectable;
                    isPreviousVisibleColumnSelected = isPreviousColumnSelected;
                }
                const footerCellProps = {
                    tableId: tableId,
                    columnKey: columnKey,
                    columnIndex: columnIndex,
                    isFinalColumnIndex: columnIndex === columnsArray.length - 1,
                    isFirstLogicalColumnIndex: isFirstLogicalColumnIndex,
                    isFinalLogicalColumnIndex: isFinalLogicalColumnIndex,
                    hasVerticalGridlines: hasVerticalGridlines,
                    stickyBottomOffset: stickyBottomOffset,
                    isSticky: isSticky,
                    isSelected: isSelected,
                    isNextColumnSelected: isNextVisibleColumnSelected,
                    isPreviousColumnSelected: isPreviousVisibleColumnSelected,
                    hasStartEdge: columnBorderEdges[columnIndex].hasStart,
                    hasEndEdge: columnBorderEdges[columnIndex].hasEnd,
                    isColumnSelectable: isSelectable,
                    isShowFocusRing: isShowFocusRing && isActive,
                    hasTabIndex: hasTabIndex,
                    isTabbableMode: isTabbableMode,
                    footerText: column.value.footerText,
                    renderer: column.value.footerRenderer,
                    isStickyStartEdge: columnIndex === startStickyEdge,
                    isStickyEndEdge: columnIndex === endStickyEdge,
                    isActiveStyle: isSelectable && activeStyleKey === columnKey,
                    isHoverStyle: isSelectable && hoverStyleKey === columnKey,
                    isPreviousCellActiveStyle: activeStyleKey != null &&
                        activeStyleKey === previousVisibleColumnKey &&
                        isPreviousVisibleColumnSelectable,
                    isPreviousCellHoverStyle: hoverStyleKey != null &&
                        hoverStyleKey === previousVisibleColumnKey &&
                        isPreviousVisibleColumnSelectable,
                    isRtl: isRtl,
                    isHighContrast: isHighContrast,
                    padding: column.value.footerPadding,
                    tooltip: column.value.footerTooltip,
                    focusTarget: column.value.footerFocusTarget,
                    horizontalAlignment: column.value.footerAlignment?.horizontal != null
                        ? column.value.footerAlignment.horizontal
                        : column.value.horizontalAlignment,
                    verticalAlignment: column.value.footerAlignment?.vertical
                };
                previousColumnKey = columnKey;
                isPreviousSelectable = isSelectable;
                isPreviousColumnSelected = isSelected;
                if (isSticky) {
                    previousStickyColumnKey = columnKey;
                    isPreviousStickySelectable = isSelectable;
                    isPreviousStickyColumnSelected = isSelected;
                }
                return jsxRuntime.jsx(TableFooterCell, { ...footerCellProps });
            }) }) })) : null;
}

/**
 * The internal component used to render a drag indicator line in the Table.
 */
function TableDragIndicator({ position, isRtl, height }) {
    const tableDragIndicatorClasses = classNames.classNames([PRIVATE_Table_themes_Table_css.tableDragIndicatorStyles.base]);
    const getDragIndicatorStyle = () => {
        const heightString = height != null ? `height:${height}px;` : '';
        if (position != null) {
            return isRtl
                ? `right:${position}px;cursor:col-resize;${heightString}`
                : `left:${position}px;cursor:col-resize;${heightString}`;
        }
        return `display:none;`;
    };
    return jsxRuntime.jsx("div", { class: tableDragIndicatorClasses, style: getDragIndicatorStyle() });
}

/**
 * The internal component used to render a custom context menu on the Table
 */
function TableContextMenu({ contextMenuConfig, contextMenuContext, ...menuProps }) {
    const translations = useTranslationBundle.useTranslationBundle('@oracle/oraclejet-preact');
    const accessibleLabel = contextMenuConfig.accessibleLabel != null
        ? contextMenuConfig.accessibleLabel
        : translations.accContextMenuLabel();
    return contextMenuConfig.itemsRenderer(contextMenuContext) != null ? (jsxRuntime.jsx(SelectMenuGroupContext.Menu, { "aria-label": accessibleLabel, ...menuProps, children: menuProps.isOpen && contextMenuConfig.itemsRenderer(contextMenuContext) })) : (jsxRuntime.jsx(jsxRuntime.Fragment, {}));
}
/**
 * The internal component used to render the context menu sort item on the Table
 */
function TableContextMenuSort({ columnKey, isDisabled, currentSortDirection, onSortCriterionChange }) {
    const translations = useTranslationBundle.useTranslationBundle('@oracle/oraclejet-preact');
    const _handleSort = ({ value }) => {
        if (onSortCriterionChange != null && value !== currentSortDirection) {
            onSortCriterionChange([
                { key: columnKey, sortDirection: value === 'ascending' ? 'ascending' : 'descending' }
            ]);
        }
    };
    return (jsxRuntime.jsx(Submenu.Submenu, { label: translations.collection_sortColumnMenu(), children: jsxRuntime.jsxs(Submenu.SelectSingleMenuGroup, { value: currentSortDirection, onCommit: _handleSort, children: [jsxRuntime.jsx(Submenu.SelectMenuItem, { isDisabled: isDisabled, value: "ascending", label: translations.collection_sortAscendingSubMenu() }), jsxRuntime.jsx(Submenu.SelectMenuItem, { isDisabled: isDisabled, value: "descending", label: translations.collection_sortDescendingSubMenu() })] }) }));
}
/**
 * The internal component used to render the context menu column resize item on the Table
 */
function TableContextMenuResize({ isDisabled, setIsResizeDialogOpen }) {
    const translations = useTranslationBundle.useTranslationBundle('@oracle/oraclejet-preact');
    const handleResize = () => {
        setIsResizeDialogOpen(true);
    };
    return (jsxRuntime.jsx(SelectMenuGroupContext.MenuItem, { label: translations.collection_resizeColumnMenu(), onAction: handleResize, isDisabled: isDisabled }));
}
/**
 * The internal component used to render the column resize dialog on the Table
 */
function TableResizeColumnDialog({ isOpen, columnKey, onColumnResize, appliedColumnWidths, setIsResizeDialogOpen }) {
    const translations = useTranslationBundle.useTranslationBundle('@oracle/oraclejet-preact');
    const initialWidth = Math.round(appliedColumnWidths.netColumnWidths[columnKey]);
    const initialWidthRef = hooks.useRef(initialWidth);
    const numberInputRef = hooks.useRef(null);
    const [widthValue, setWidthValue] = hooks.useState(String(initialWidth));
    let isDisabled;
    let messages;
    if (widthValue == null ||
        Number.isNaN(parseInt(widthValue)) ||
        String(parseInt(widthValue)) !== widthValue.trim() ||
        parseInt(widthValue) < 16 ||
        parseInt(widthValue) > 100000) {
        messages = [
            {
                severity: 'error',
                detail: translations.collection_resizeMessageDetail({ MIN: '16', MAX: '100000' })
            }
        ];
        isDisabled = true;
    }
    else {
        isDisabled = false;
    }
    const apply = hooks.useCallback(() => {
        if (columnKey != null && onColumnResize != null && widthValue != null) {
            if (parseInt(widthValue) !== initialWidthRef.current) {
                onColumnResize({
                    key: columnKey,
                    newWidth: parseInt(widthValue),
                    allColumnWidths: appliedColumnWidths.netColumnWidths,
                    paddingWidth: appliedColumnWidths.totalBorderOffset,
                    gesture: 'contextMenu',
                    type: 'absolute'
                });
            }
        }
        setIsResizeDialogOpen(false);
    }, [columnKey, onColumnResize, widthValue, appliedColumnWidths, setIsResizeDialogOpen]);
    const handleKeyDown = hooks.useCallback((event) => {
        if (event.key === 'Enter' && !isDisabled) {
            apply();
        }
    }, [apply, isDisabled]);
    const cancel = hooks.useCallback(() => {
        setIsResizeDialogOpen(false);
    }, [setIsResizeDialogOpen]);
    const handleOnInput = hooks.useCallback((detail) => {
        setWidthValue(detail.value);
    }, []);
    const footer = (jsxRuntime.jsxs(Flex.Flex, { gap: "2x", children: [jsxRuntime.jsx(Button.Button, { onAction: cancel, label: translations.collection_cancel() }), jsxRuntime.jsx(Button.Button, { variant: "callToAction", onAction: apply, label: translations.collection_apply(), isDisabled: isDisabled })] }));
    return (jsxRuntime.jsx(Dialog.Dialog, { autoFocusRef: numberInputRef, isOpen: isOpen, modality: 'modal', header: translations.collection_resizeColumnDialog(), footer: footer, children: jsxRuntime.jsx("div", { onKeyDown: handleKeyDown, children: jsxRuntime.jsx(NumberInputText.NumberInputText, { label: translations.collection_width(), onInput: handleOnInput, suffix: translations.collection_pixels(), messages: messages, isRequired: true, isRequiredShown: true, ref: numberInputRef, value: widthValue }) }) }));
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Hook that manages data on the Preact Table
 */
function useDataManager({ data, getRowKey, hasMore, onLoadMore }) {
    const tableData = hooks.useMemo(() => {
        const newDataArray = data != null
            ? data.map((d) => {
                const key = getRowKey(d);
                return { data: d, metadata: key };
            })
            : [];
        return newDataArray;
    }, [data, getRowKey]);
    // debounce loadMore calls to prevent state changes from triggering multiple calls
    const loadMoreDataRef = hooks.useRef();
    if (!hasMore) {
        // clear loadMoreData cache once more data is not available
        loadMoreDataRef.current = undefined;
    }
    const onTableLoadMore = hooks.useCallback(() => {
        if (tableData === loadMoreDataRef.current) {
            return;
        }
        loadMoreDataRef.current = tableData;
        return onLoadMore();
    }, [tableData, onLoadMore]);
    return { tableData, onTableLoadMore };
}

/**
 * A helper function to make sure specified elem is visible in the specified container
 */
function _scrollColumnIntoView(columnElement, scrollerElement, viewportInfo, columnsArray, stickyColumnInfo, scrollbarWidth, isRtl, appliedColumnWidths, location) {
    const columnKey = getColumnKey(columnElement);
    let columnIndex;
    for (let i = 0; i < columnsArray.length; i++) {
        if (columnsArray[i].key === columnKey) {
            columnIndex = i;
            break;
        }
    }
    if (columnIndex != null && appliedColumnWidths != null) {
        let startOffset = 0;
        let endOffset = 0;
        if (viewportInfo.isExternalScroller) {
            const scrollerOffsetStart = viewportInfo.viewportConfig.scrollerOffsetStart;
            if (scrollerOffsetStart != null) {
                startOffset = scrollerOffsetStart;
            }
            const scrollerOffsetEnd = viewportInfo.viewportConfig.scrollerOffsetEnd;
            if (scrollerOffsetEnd != null) {
                endOffset = scrollerOffsetEnd;
            }
        }
        let stickyCount = 0;
        const borderOffset = appliedColumnWidths.borderOffset;
        const stickyColumns = stickyColumnInfo.stickyColumns;
        for (let i = 0; i < stickyColumns.length; i++) {
            const stickyIndex = stickyColumns[i];
            if (stickyIndex < columnIndex) {
                startOffset += appliedColumnWidths.netColumnWidths[columnsArray[stickyIndex].key];
                stickyCount += 1;
            }
            else {
                break;
            }
        }
        startOffset += startOffset > 0 ? stickyCount * borderOffset + borderOffset : 0;
        if (!appliedColumnWidths.borderEdges[columnIndex].hasStart) {
            startOffset += borderOffset;
        }
        stickyCount = 0;
        for (let i = stickyColumns.length - 1; i > -1; i--) {
            const stickyIndex = stickyColumns[i];
            if (stickyIndex > columnIndex) {
                endOffset += appliedColumnWidths.netColumnWidths[columnsArray[stickyIndex].key];
                stickyCount += 1;
            }
            else {
                break;
            }
        }
        endOffset += endOffset > 0 ? stickyCount * borderOffset + borderOffset : 0;
        if (!appliedColumnWidths.borderEdges[columnIndex].hasEnd) {
            endOffset += borderOffset;
        }
        const horizontalOverflowDiff = _getHorizontalOverflowDiff(columnElement, scrollerElement, startOffset, endOffset, scrollbarWidth, isRtl);
        const leftOverflowDiff = horizontalOverflowDiff.left;
        const hasLeftOverflow = leftOverflowDiff >= 0;
        const rightOverflowDiff = horizontalOverflowDiff.right;
        const hasRightOverflow = rightOverflowDiff >= 0;
        // don't adjust scroll position if row has overflow in both directions
        if (hasLeftOverflow && hasRightOverflow) {
            return;
        }
        if (location == null || location === 'inView') {
            // if column fits fully in viewport, scroll overflow side into view
            // otherwise, scroll the shortest amount to fill viewport with column
            if (hasLeftOverflow) {
                if (Math.abs(rightOverflowDiff) > Math.abs(leftOverflowDiff)) {
                    scrollerElement.scrollLeft = _roundScrollValue(scrollerElement.scrollLeft - leftOverflowDiff, false);
                }
                else {
                    scrollerElement.scrollLeft = _roundScrollValue(scrollerElement.scrollLeft + rightOverflowDiff, true);
                }
            }
            else if (hasRightOverflow) {
                if (Math.abs(leftOverflowDiff) > Math.abs(rightOverflowDiff)) {
                    scrollerElement.scrollLeft = _roundScrollValue(scrollerElement.scrollLeft + rightOverflowDiff, true);
                }
                else {
                    scrollerElement.scrollLeft = _roundScrollValue(scrollerElement.scrollLeft - leftOverflowDiff, false);
                }
            }
        }
        else if (location === 'start') {
            scrollerElement.scrollLeft = _roundScrollValue(scrollerElement.scrollLeft - leftOverflowDiff, false);
        }
        else {
            scrollerElement.scrollLeft = _roundScrollValue(scrollerElement.scrollLeft + rightOverflowDiff, true);
        }
    }
}
/**
 * A helper function to make sure specified elem is visible in the specified container
 */
const _scrollRowIntoView = (rootElement, viewportInfo, tableId, rowElement, scrollerElement, scrollbarHeight, location) => {
    let topOffset = 0;
    let bottomOffset = 0;
    if (viewportInfo.isExternalScroller) {
        const scrollerOffsetTop = viewportInfo.viewportConfig.scrollerOffsetTop;
        if (scrollerOffsetTop != null) {
            topOffset = scrollerOffsetTop;
        }
        const scrollerOffsetBottom = viewportInfo.viewportConfig.scrollerOffsetBottom;
        if (scrollerOffsetBottom != null) {
            bottomOffset = scrollerOffsetBottom;
        }
    }
    topOffset += getScrollerTopOffset(rootElement, tableId);
    bottomOffset += getScrollerBottomOffset(rootElement, tableId);
    const verticalOverflowDiff = _getVerticalOverflowDiff(rowElement, scrollerElement, topOffset, bottomOffset, scrollbarHeight);
    const topOverflowDiff = verticalOverflowDiff.top;
    const hasTopOverflow = topOverflowDiff >= 0;
    const bottomOverflowDiff = verticalOverflowDiff.bottom;
    const hasBottomOverflow = bottomOverflowDiff >= 0;
    // don't adjust scroll position if row has overflow in both directions
    if (hasTopOverflow && hasBottomOverflow) {
        return;
    }
    if (location == null || location === 'inView') {
        // if row fits fully in viewport, scroll overflow side into view
        // otherwise, scroll the shortest amount to fill viewport with row
        if (hasBottomOverflow) {
            if (Math.abs(topOverflowDiff) > Math.abs(bottomOverflowDiff)) {
                scrollerElement.scrollTop = _roundScrollValue(scrollerElement.scrollTop + bottomOverflowDiff, true);
            }
            else {
                scrollerElement.scrollTop = _roundScrollValue(scrollerElement.scrollTop - topOverflowDiff, false);
            }
        }
        else if (hasTopOverflow) {
            if (Math.abs(bottomOverflowDiff) > Math.abs(topOverflowDiff)) {
                scrollerElement.scrollTop = _roundScrollValue(scrollerElement.scrollTop - topOverflowDiff, false);
            }
            else {
                scrollerElement.scrollTop = _roundScrollValue(scrollerElement.scrollTop + bottomOverflowDiff, true);
            }
        }
    }
    else if (location === 'top') {
        scrollerElement.scrollTop = _roundScrollValue(scrollerElement.scrollTop - topOverflowDiff, false);
    }
    else {
        scrollerElement.scrollTop = _roundScrollValue(scrollerElement.scrollTop + bottomOverflowDiff, true);
    }
};
/**
 * Helper method to round a desired scrollTop or scrollLeft value to the nearest valid value
 * depending on the client browser.
 */
const _roundScrollValue = (value, isOver) => {
    // use Math.floor() and Math.ceil() to ensure we round to nearest containing valid
    // pixel value in either direction as valid scrollTop values are only integers
    return isOver ? Math.ceil(value) : Math.floor(value);
};
/**
 * A helper to get the horizontal overflow diff of the given element
 */
const _getHorizontalOverflowDiff = (element, scrollerElement, startOffset, endOffset, scrollbarWidth, isRtl) => {
    const elementRect = element.getBoundingClientRect();
    const scrollerRect = scrollerElement.getBoundingClientRect();
    if (isRtl) {
        return {
            left: scrollerRect.left - elementRect.left + endOffset + scrollbarWidth,
            right: elementRect.right - scrollerRect.right + startOffset
        };
    }
    else {
        return {
            left: scrollerRect.left - elementRect.left + startOffset,
            right: elementRect.right - scrollerRect.right + endOffset + scrollbarWidth
        };
    }
};
/**
 * A helper to get the vertical overflow diff of the given element
 */
const _getVerticalOverflowDiff = (element, scrollerElement, topOffset, bottomOffset, scrollbarHeight) => {
    const elementRect = element.getBoundingClientRect();
    const scrollerRect = scrollerElement.getBoundingClientRect();
    return {
        top: scrollerRect.top - elementRect.top + topOffset,
        bottom: elementRect.bottom - scrollerRect.bottom + bottomOffset + scrollbarHeight
    };
};
/**
 * Helper to set the horizontal scroll position on the Table.
 */
function setHorizontalScrollPosition(scrollerElement, columnsArray, fullColumnWidths, isRtl, horizontalScrollPosition) {
    const x = _getScrollLeftFromScrollPosition(scrollerElement, columnsArray, fullColumnWidths, horizontalScrollPosition);
    scrollerElement.scrollLeft = x != null ? (isRtl ? -x : x) : 0;
}
/**
 * Helper to set the vertical scroll position on the Table.
 */
function setVerticalScrollPosition(rootElement, scrollerElement, tableId, verticalScrollPosition) {
    const y = _getScrollTopFromScrollPosition(rootElement, scrollerElement, tableId, verticalScrollPosition);
    scrollerElement.scrollTop = y != null ? y : 0;
}
/**
 * Helper to determine the 'x' value of a given scroll position.
 */
function _getScrollLeftFromScrollPosition(scrollerElement, columnsArray, fullColumnWidths, scrollPosition) {
    if (scrollPosition != null) {
        let columnKey;
        let useColumn = false;
        if (scrollPosition.columnKey != null) {
            // columnKey takes precedence over everything else
            useColumn = true;
            columnKey = scrollPosition.columnKey;
        }
        else if (scrollPosition.offsetX != null && scrollPosition.x == null) {
            // offsetX can be used on its own if it is the only horizontal aspect provided
            useColumn = true;
            const currentHorizontalScrollPosition = getHorizontalScrollPosition(scrollerElement, columnsArray, fullColumnWidths);
            columnKey = currentHorizontalScrollPosition.columnKey;
        }
        if (useColumn) {
            if (columnKey != null) {
                let x = 0;
                for (let i = 0; i < fullColumnWidths.length; i++) {
                    if (columnsArray[i].key === columnKey) {
                        return x + (scrollPosition.offsetX != null ? scrollPosition.offsetX : 0);
                    }
                    if (columnsArray[i].value.sticky !== 'enabled') {
                        x += fullColumnWidths[i];
                    }
                }
            }
        }
        else if (scrollPosition.x != null) {
            return scrollPosition.x;
        }
    }
    // either nothing was provided, or what was provided was invalid
    return undefined;
}
/**
 * Helper to determine the 'y' value of a given scroll position.
 */
function _getScrollTopFromScrollPosition(rootElement, scrollerElement, tableId, scrollPosition) {
    if (scrollPosition != null) {
        let rowKey;
        let useRow = false;
        if (scrollPosition.rowKey != null) {
            // rowKey takes precedence over everything else
            useRow = true;
            rowKey = scrollPosition.rowKey;
        }
        else if (scrollPosition.offsetY != null && scrollPosition.y == null) {
            // offsetY can be used on its own if it is the only vertical aspect provided
            useRow = true;
            rowKey = getVerticalScrollPosition(rootElement, scrollerElement, tableId).rowKey;
        }
        if (useRow) {
            if (rowKey != null) {
                let y = 0;
                const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);
                for (let i = 0; i < rowElements.length; i++) {
                    if (rowKey === getRowKey(rowElements[i])) {
                        return y + (scrollPosition.offsetY != null ? scrollPosition.offsetY : 0);
                    }
                    y += rowElements[i].getBoundingClientRect().height;
                }
            }
        }
        else if (scrollPosition.y != null) {
            return scrollPosition.y;
        }
    }
    // either nothing was provided, or what was provided was invalid
    return undefined;
}
/**
 * Helper to get the logical scroll position for the given scrollLeft value. If no scrollLeft value is given,
 * it will use the current scrollLeft value of the Table.
 */
function getHorizontalScrollPosition(scrollerElement, columnsArray, fullColumnWidths, newScrollLeft) {
    // ensure scroll position x value is initialized
    const scrollLeft = Math.abs(newScrollLeft == null ? scrollerElement.scrollLeft : newScrollLeft);
    const scrollPosition = {
        x: scrollLeft,
        columnKey: undefined,
        offsetX: undefined
    };
    let columnEnd = 0;
    if (columnsArray.length > 0) {
        if (scrollLeft === 0) {
            scrollPosition.columnKey = columnsArray[0].key;
            scrollPosition.offsetX = 0;
            return scrollPosition;
        }
    }
    for (let i = 0; i < columnsArray.length; i++) {
        if (columnsArray[i].value.sticky !== 'enabled') {
            columnEnd += fullColumnWidths[i];
        }
        if (scrollLeft <= columnEnd - 0.5) {
            scrollPosition.columnKey = columnsArray[i].key;
            scrollPosition.offsetX = fullColumnWidths[i] + scrollLeft - columnEnd;
            break;
        }
    }
    return scrollPosition;
}
/**
 * Helper to get the logical scroll position for the given scrollTop value. If no scrollTop value is given,
 * it will use the current scrollTop value of the Table.
 */
function getVerticalScrollPosition(rootElement, scrollerElement, tableId, newScrollTop) {
    // ensure scroll position y value is initialized
    const scrollTop = Math.abs(newScrollTop == null ? scrollerElement.scrollTop : newScrollTop);
    const scrollPosition = {
        y: scrollTop,
        rowKey: undefined,
        offsetY: undefined
    };
    let rowBottom = 0;
    const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);
    if (rowElements.length > 0) {
        if (scrollTop === 0) {
            scrollPosition.rowKey = getRowKeyForRowIndex(rootElement, tableId, 0);
            scrollPosition.offsetY = 0;
            return scrollPosition;
        }
    }
    for (let i = 0; i < rowElements.length; i++) {
        const rowHeight = rowElements[i].getBoundingClientRect().height;
        rowBottom += rowHeight;
        if (scrollTop <= rowBottom - 0.5) {
            scrollPosition.rowKey = getRowKeyForRowIndex(rootElement, tableId, i);
            scrollPosition.offsetY = rowHeight + scrollTop - rowBottom;
            break;
        }
    }
    return scrollPosition;
}
function applyScrollDetail(rootElement, scrollerElement, viewportInfo, tableId, columnsArray, stickyColumnInfo, sizingInfo, scrollDetail, isRtl, appliedColumnWidths) {
    if (scrollDetail.cell.type === 'data') {
        const rowElement = collectionUtils.findElementByKey(rootElement, scrollDetail.cell.rowKey, `[data-oj-table-data-row='${tableId}']`);
        if (rowElement != null && scrollDetail.locationY != null && !sizingInfo.isInitialRender) {
            const scrollbarHeight = sizingInfo.boxHeight - sizingInfo.contentHeight;
            _scrollRowIntoView(rootElement, viewportInfo, tableId, rowElement, scrollerElement, scrollbarHeight, scrollDetail.locationY);
        }
    }
    if (scrollDetail.cell.type === 'data' ||
        scrollDetail.cell.type === 'header' ||
        scrollDetail.cell.type === 'footer') {
        const cellElement = getElementFromCell(rootElement, tableId, scrollDetail.cell);
        if (cellElement != null && scrollDetail.locationX != null && !sizingInfo.isInitialRender) {
            const scrollbarWidth = sizingInfo.boxWidth - sizingInfo.contentWidth;
            _scrollColumnIntoView(cellElement, scrollerElement, viewportInfo, columnsArray, stickyColumnInfo, scrollbarWidth, isRtl, appliedColumnWidths, scrollDetail.locationX);
        }
    }
    if (scrollDetail.cell.type === 'loadMore' || scrollDetail.cell.type === 'loading') {
        const cellElement = getElementFromCell(rootElement, tableId, scrollDetail.cell);
        if (cellElement != null && scrollDetail.locationY != null && !sizingInfo.isInitialRender) {
            const scrollbarHeight = sizingInfo.boxHeight - sizingInfo.contentHeight;
            _scrollRowIntoView(rootElement, viewportInfo, tableId, cellElement, scrollerElement, scrollbarHeight, scrollDetail.cell.type === 'loading' && scrollDetail.locationY === 'inView'
                ? 'top'
                : scrollDetail.locationY);
        }
    }
}
/**
 * Helper function to update the 'left' and 'right' values of all sticky columns to correspond
 * to the given sizing information.
 */
function updateStickyColumns(rootElement, scrollerElement, viewportInfo, tableId, isRtl, columnsArray, stickyColumnInfo, fullColumnWidths, stickyEdgesState, setStickyEdgesState, isHorizontalScroll) {
    let stickyIndex;
    let stickyStartOffset = 0;
    let stickyEndOffset = 0;
    if (viewportInfo.isExternalScroller) {
        const scrollerOffsetStart = viewportInfo.viewportConfig.scrollerOffsetStart;
        if (scrollerOffsetStart != null) {
            stickyStartOffset = scrollerOffsetStart;
        }
        const scrollerOffsetEnd = viewportInfo.viewportConfig.scrollerOffsetEnd;
        if (scrollerOffsetEnd != null) {
            stickyEndOffset = scrollerOffsetEnd;
        }
    }
    const stickyIndicies = stickyColumnInfo.stickyColumns;
    for (let i = 0; i < stickyIndicies.length; i++) {
        stickyIndex = stickyIndicies[i];
        _applyStickyColumnOffset(rootElement, tableId, isRtl, stickyIndex, stickyStartOffset, true);
        stickyStartOffset += fullColumnWidths[stickyIndex];
    }
    for (let i = stickyIndicies.length - 1; i > -1; i--) {
        stickyIndex = stickyIndicies[i];
        _applyStickyColumnOffset(rootElement, tableId, isRtl, stickyIndex, stickyEndOffset, false);
        stickyEndOffset += fullColumnWidths[stickyIndex];
    }
    // only apply sticky edge styling if horizontal overflow is present
    if (isHorizontalScroll) {
        updateStickyEdges(scrollerElement, columnsArray, stickyColumnInfo, fullColumnWidths, stickyEdgesState, setStickyEdgesState);
    }
    else if (stickyEdgesState.start != null || stickyEdgesState.end != null) {
        setStickyEdgesState({});
    }
}
/**
 * Helper function to get the sticky column indicies.
 */
const getStickyColumnIndicies = (columnsArray) => {
    const stickyColumns = [];
    for (let i = 0; i < columnsArray.length; i++) {
        if (columnsArray[i].value.sticky === 'enabled') {
            stickyColumns.push(i);
        }
    }
    return stickyColumns;
};
/**
 * Helper function to update the 'left' and 'right' values of a specific column.
 */
const _applyStickyColumnOffset = (rootElement, tableId, isRtl, columnIndex, stickyOffset, isStart) => {
    const styleProperty = (isStart && !isRtl) || (!isStart && isRtl) ? 'left' : 'right';
    const styleValue = `${stickyOffset}px`;
    const headerElements = rootElement.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);
    const headerElement = headerElements[columnIndex];
    headerElement.style[styleProperty] = styleValue;
    const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);
    for (let j = 0; j < rowElements.length; j++) {
        const rowElement = rowElements[j];
        const cellElements = rowElement.querySelectorAll(`[data-oj-table-data-cell='${tableId}']`);
        const cellElement = cellElements[columnIndex];
        cellElement.style[styleProperty] = styleValue;
    }
    const footerElements = rootElement.querySelectorAll(`[data-oj-table-footer-cell='${tableId}']`);
    if (footerElements.length > 0) {
        const footerElement = footerElements[columnIndex];
        footerElement.style[styleProperty] = styleValue;
    }
};
/**
 * Helper function to update the sticky edges based on the given scrollLeft value.
 */
function updateStickyEdges(scrollerElement, columnsArray, stickyColumnInfo, fullColumnWidths, stickyEdgesState, setStickyEdgesState, scrollLeft) {
    if (columnsArray.length > 0) {
        let i;
        let currentScrollIndex;
        const newScrollPosition = getHorizontalScrollPosition(scrollerElement, columnsArray, fullColumnWidths, scrollLeft);
        for (i = 0; i < columnsArray.length; i++) {
            if (columnsArray[i].key === newScrollPosition.columnKey) {
                currentScrollIndex = i;
                break;
            }
        }
        let startIndex;
        const stickyIndicies = stickyColumnInfo.stickyColumns;
        // browser zoom levels cause rounding issues where the start scroll
        // position may never be reached, but it should always be within 1
        if (newScrollPosition.x >= 1) {
            for (i = 0; i < stickyIndicies.length; i++) {
                const currentIndex = stickyIndicies[i];
                if (currentIndex < currentScrollIndex) {
                    startIndex = currentIndex;
                }
                else {
                    break;
                }
            }
        }
        let endIndex;
        let currentWidth = 0;
        const maxScrollPos = scrollerElement.scrollWidth - scrollerElement.clientWidth;
        const endOverflow = maxScrollPos - newScrollPosition.x;
        // browser zoom levels cause rounding issues where the max scroll
        // position may never be reached, but it should always be within 1
        if (endOverflow >= 1) {
            for (let i = columnsArray.length - 1; i > -1; i--) {
                if (stickyIndicies.indexOf(i) !== -1) {
                    endIndex = i;
                }
                else {
                    currentWidth += fullColumnWidths[i];
                    if (currentWidth > endOverflow) {
                        break;
                    }
                }
            }
        }
        if (stickyEdgesState.start != startIndex || stickyEdgesState.end != endIndex) {
            setStickyEdgesState({ start: startIndex, end: endIndex });
        }
    }
}
/**
 * Helper function to hide a currently shown tooltip once the anchor cell scrolls out of view.
 */
function hideOutOfViewTooltip(rootElement, scrollerElement, tableId, sizingInfo, stickyColumnInfo, fullColumnWidths, tooltipAnchorRef, hideTooltip, isRtl) {
    if (tooltipAnchorRef.current != null) {
        const verticalOverflowDiff = _getVerticalOverflowDiff(tooltipAnchorRef.current, scrollerElement, getScrollerTopOffset(rootElement, tableId), getScrollerBottomOffset(rootElement, tableId), sizingInfo.boxHeight - sizingInfo.contentHeight);
        const topOverflowDiff = verticalOverflowDiff.top;
        const hasTopOverflow = topOverflowDiff >= 0;
        const bottomOverflowDiff = verticalOverflowDiff.bottom;
        const hasBottomOverflow = bottomOverflowDiff >= 0;
        if ((hasTopOverflow && Math.abs(topOverflowDiff) > tooltipAnchorRef.current.offsetHeight) ||
            (hasBottomOverflow && Math.abs(bottomOverflowDiff) > tooltipAnchorRef.current.offsetHeight)) {
            hideTooltip(true);
            return;
        }
        let startOffset = 0;
        let endOffset = 0;
        const stickyColumns = stickyColumnInfo.stickyColumns;
        for (let i = 0; i < stickyColumns.length; i++) {
            const stickyIndex = stickyColumns[i];
            startOffset += fullColumnWidths[stickyIndex];
        }
        for (let i = stickyColumns.length - 1; i > -1; i--) {
            const stickyIndex = stickyColumns[i];
            endOffset += fullColumnWidths[stickyIndex];
        }
        const horizontalOverflowDiff = _getHorizontalOverflowDiff(tooltipAnchorRef.current, scrollerElement, startOffset, endOffset, sizingInfo.boxWidth - sizingInfo.contentWidth, isRtl);
        const leftOverflowDiff = horizontalOverflowDiff.left;
        const hasLeftOverflow = leftOverflowDiff >= 0;
        const rightOverflowDiff = horizontalOverflowDiff.right;
        const hasRightOverflow = rightOverflowDiff >= 0;
        if ((hasLeftOverflow && Math.abs(leftOverflowDiff) > tooltipAnchorRef.current.offsetWidth) ||
            (hasRightOverflow && Math.abs(rightOverflowDiff) > tooltipAnchorRef.current.offsetWidth)) {
            hideTooltip(true);
        }
    }
}
/**
 * Helper function to reset the scroll position of the scroller element
 */
const resetVerticalScrollPosition = (scrollerElement) => {
    scrollerElement.scrollTop = 0;
};
/**
 * Helper function to get the viewport config. TODO: this needs help for table still
 */
const getViewportConfig = (scrollerRef, config) => {
    return (config ?? {
        scroller: () => {
            return scrollerRef;
        }
    });
};
/**
 * Helper function to update the scroller element's styling based on overflow status.
 */
const applyOverflowStatus = (rootElement, scrollerElement, tableId, contentWidth, availableWidth, contentHeight, availableHeight, scrollbarWidth, overflowRef, setHasVerticalUnderflow) => {
    // check for at least 0.5px difference to account for browser rounding issues
    const hasHorizontalOverflow = contentWidth - availableWidth > 0.5;
    const hasVerticalOverflow = contentHeight - availableHeight > 0.5;
    if (hasHorizontalOverflow) {
        scrollerElement.classList.remove(PRIVATE_Table_themes_Table_css.scrollerStyles.noHorizontalScroll);
        scrollerElement.classList.add(PRIVATE_Table_themes_Table_css.scrollerStyles.horizontalScroll);
    }
    else {
        scrollerElement.classList.remove(PRIVATE_Table_themes_Table_css.scrollerStyles.horizontalScroll);
        scrollerElement.classList.add(PRIVATE_Table_themes_Table_css.scrollerStyles.noHorizontalScroll);
    }
    if (hasVerticalOverflow) {
        scrollerElement.classList.remove(PRIVATE_Table_themes_Table_css.scrollerStyles.noVerticalScroll);
        scrollerElement.classList.add(PRIVATE_Table_themes_Table_css.scrollerStyles.verticalScroll);
        scrollerElement.style.paddingInlineEnd = '';
    }
    else {
        scrollerElement.classList.remove(PRIVATE_Table_themes_Table_css.scrollerStyles.verticalScroll);
        scrollerElement.classList.add(PRIVATE_Table_themes_Table_css.scrollerStyles.noVerticalScroll);
        scrollerElement.style.paddingInlineEnd = `${scrollbarWidth}px`;
    }
    overflowRef.current.isHorizontal = hasHorizontalOverflow;
    overflowRef.current.isVertical = hasVerticalOverflow;
    applyUnderflowStatus(rootElement, tableId, setHasVerticalUnderflow);
};
/**
 * Helper function to update the undeflow status of the Table based on the spacer element sizing.
 */
const applyUnderflowStatus = (rootElement, tableId, setHasVerticalUnderflow) => {
    const spacerRowElement = rootElement.querySelector(`[data-oj-table-spacer-row='${tableId}']`);
    if (spacerRowElement != null) {
        setHasVerticalUnderflow(spacerRowElement.offsetHeight > 0);
    }
};

/**
 * Helper function to determine if a given active cell represents a 'transient' state.
 */
function isTransientCell(activeCell) {
    return (activeCell != null &&
        (activeCell.type === 'loadMore' ||
            activeCell.type === 'loading' ||
            activeCell.type === 'pending'));
}
/**
 * Helper function to compare two given cell descriptors.
 */
function cellComparator(cell1, cell2) {
    if (cell1 == null) {
        return cell2 == null;
    }
    if (cell2 == null) {
        return false;
    }
    if (cell1.type === cell2.type && cell1.rowKey === cell2.rowKey) {
        // special case the transient 'loading' cell types as column keys are hints used for when a user
        // navigates back to another region using the keyboard - otherwise we'd go to the first column
        if (cell1.type === 'loading' || cell1.type === 'loadMore' || cell1.type === 'pending') {
            return true;
        }
        return cell1.columnKey === cell2.columnKey;
    }
    return false;
}
function getCellContextMenuContextFromCell(tableData, columnsArray, setIsResizeDialogOpen, cell, sortCriterion, onSortCriterionChange) {
    if (cell?.type === 'data' || cell?.type === 'header' || cell?.type === 'footer') {
        let isSortable = false;
        let isResizable = false;
        for (let i = 0; i < columnsArray.length; i++) {
            const column = columnsArray[i];
            if (column.key === cell.columnKey) {
                isSortable = column.value.sortable === 'enabled';
                isResizable = column.value.resizable === 'enabled';
                break;
            }
        }
        let currentSortDirection;
        if (sortCriterion != null) {
            for (const criterion of sortCriterion) {
                if (criterion.key === cell.columnKey) {
                    currentSortDirection = criterion.sortDirection;
                    break;
                }
            }
        }
        const allMenuItems = {
            resizeColumn: (jsxRuntime.jsx(TableContextMenuResize, { isDisabled: !isResizable, setIsResizeDialogOpen: setIsResizeDialogOpen })),
            sortColumn: (jsxRuntime.jsx(TableContextMenuSort, { columnKey: cell.columnKey, isDisabled: !isSortable, currentSortDirection: currentSortDirection, onSortCriterionChange: onSortCriterionChange }))
        };
        const hasResizableColumns = columnsArray.some((column) => {
            return column.value.resizable === 'enabled';
        });
        const hasSortableColumns = columnsArray.some((column) => {
            return column.value.sortable === 'enabled';
        });
        const defaultMenuItems = hasResizableColumns || hasSortableColumns ? (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [hasResizableColumns ? allMenuItems['resizeColumn'] : undefined, hasSortableColumns ? allMenuItems['sortColumn'] : undefined] })) : undefined;
        if (cell.type === 'data') {
            for (const rowData of tableData) {
                if (rowData.metadata === cell.rowKey) {
                    return {
                        allMenuItems,
                        defaultMenuItems,
                        rowData: rowData.data,
                        rowKey: cell.rowKey,
                        columnKey: cell.columnKey,
                        type: 'data'
                    };
                }
            }
        }
        else {
            return {
                allMenuItems,
                defaultMenuItems,
                columnKey: cell.columnKey,
                type: cell.type
            };
        }
    }
    return undefined;
}
/**
 * Helper function to determine the resulting cell from a cell override.
 */
function _getCellFromCellOverride(tableData, columnsArray, cellOverride, currentCell) {
    let cellType;
    let cellRowKey;
    let cellColumnKey;
    if (cellOverride.rowKey != null) {
        cellType = 'data';
        cellRowKey = cellOverride.rowKey;
        if (cellOverride.columnKey != null) {
            cellColumnKey = cellOverride.columnKey;
        }
        else if (currentCell?.columnKey != null) {
            cellColumnKey = currentCell.columnKey;
        }
        else {
            cellColumnKey = getBoundaryColumnKey(columnsArray, true);
        }
        if (cellColumnKey == null) {
            return undefined;
        }
    }
    else if (cellOverride.columnKey != null) {
        cellColumnKey = cellOverride.columnKey;
        if (cellOverride.type != null) {
            cellType = cellOverride.type;
        }
        else if (currentCell?.type != null && currentCell.type !== 'noData') {
            cellType = currentCell.type;
        }
        else {
            cellType = 'header';
        }
        if (cellType === 'data') {
            if (currentCell?.rowKey != null) {
                cellRowKey = currentCell.rowKey;
            }
            else if (tableData.length > 0) {
                cellRowKey = tableData[0].metadata;
            }
            if (cellRowKey == null) {
                return undefined;
            }
        }
    }
    else if (cellOverride.type != null) {
        cellType = cellOverride.type;
        if (cellType !== 'noData') {
            if (currentCell?.columnKey != null) {
                cellColumnKey = currentCell.columnKey;
            }
            else {
                cellColumnKey = getBoundaryColumnKey(columnsArray, true);
            }
            if (cellColumnKey == null) {
                return undefined;
            }
            if (cellType === 'data') {
                if (currentCell?.rowKey != null) {
                    cellRowKey = currentCell.rowKey;
                }
                else if (tableData.length > 0) {
                    cellRowKey = tableData[0].metadata;
                }
                if (cellRowKey == null) {
                    return undefined;
                }
            }
        }
    }
    else {
        return undefined;
    }
    return { type: cellType, rowKey: cellRowKey, columnKey: cellColumnKey };
}
/**
 * Helper function to determine the resulting cell type from a cell override.
 */
function _getCellTypeFromCellOverride(cellOverride, currentCell) {
    if (cellOverride.type != null) {
        return cellOverride.type;
    }
    if (cellOverride.rowKey != null) {
        return 'data';
    }
    // if no type or rowKey was given, a columnKey must have been given
    if (currentCell?.type != null && currentCell.type !== 'noData') {
        return currentCell.type;
    }
    return 'header';
}
/**
 * Helper function to apply a current cell override if necessary.
 */
function applyCurrentCellOverride(rootElement, scrollerElement, viewportInfo, tableId, tableData, columnsArray, stickyColumnInfo, sizingInfoRef, currencyStatusRef, onActiveCellChanged, isEmbeddedSelect, isPendingLayout, isDataLoaded, isRtl, currentCellOverride, appliedColumnWidths) {
    // when embedded select, use most recent non-null current cell value as override base
    const currentCell = isEmbeddedSelect
        ? currencyStatusRef.current.previousEmbeddedSelectCurrentCell
        : currencyStatusRef.current.currentCell;
    // ensure any new currentCellOverride settings are applied if necessary
    if (currencyStatusRef.current.hasPendingCurrentCellOverride ||
        currencyStatusRef.current.currentCellOverride !== currentCellOverride) {
        if (currentCellOverride != null) {
            // attempt to find the cell the override specifies
            const realizedCell = _getCellFromCellOverride(tableData, columnsArray, currentCellOverride, currentCell);
            if (realizedCell != null) {
                // override cell was determined - apply the override immediately
                onActiveCellChanged({ value: realizedCell }, isAutoFocusCell(rootElement, tableId, realizedCell));
                currencyStatusRef.current.currentCellOverride = currentCellOverride;
                currencyStatusRef.current.hasPendingCurrentCellOverride = false;
                if (isEmbeddedSelect) {
                    // scroll 'current-cell-override' vertically into view immediately for embedded select
                    // otherwise, cell will be scrolled into view once the component or cell receives focus
                    if (!isPendingLayout && getElementFromCell(rootElement, tableId, realizedCell) != null) {
                        applyScrollDetail(rootElement, scrollerElement, viewportInfo, tableId, columnsArray, stickyColumnInfo, sizingInfoRef.current, { cell: realizedCell, locationY: 'inView' }, isRtl, appliedColumnWidths);
                        currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;
                    }
                    else if (isPendingLayout || !isDataLoaded) {
                        // corresponding element was not found - data is not ready for scrolling
                        currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = true;
                    }
                    else {
                        // corresponding element was not found - value was garbage
                        currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;
                    }
                }
                else {
                    // not in an embedded select, so no scrolling should be performed
                    currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;
                }
            }
            else if (!isDataLoaded) {
                // override cell could not be determined - data is still fetching
                currencyStatusRef.current.hasPendingCurrentCellOverride = true;
            }
            else {
                // override cell could not be determined - value was garbage
                currencyStatusRef.current.currentCellOverride = currentCellOverride;
                currencyStatusRef.current.hasPendingCurrentCellOverride = false;
                currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;
            }
        }
        else {
            // override is set to clear the current cell
            onActiveCellChanged({ value: currentCellOverride });
            currencyStatusRef.current.currentCellOverride = currentCellOverride;
            currencyStatusRef.current.hasPendingCurrentCellOverride = false;
            if (isEmbeddedSelect) {
                // scroll back to the top for embedded select
                resetVerticalScrollPosition(scrollerElement);
            }
            currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;
        }
    }
    else if (currencyStatusRef.current.hasPendingCurrentCellOverrideScroll) {
        // try and apply any pending scroll from a previous cell override at this time
        if (currencyStatusRef.current.currentCell != null) {
            if (!isPendingLayout &&
                getElementFromCell(rootElement, tableId, currencyStatusRef.current.currentCell) != null) {
                applyScrollDetail(rootElement, scrollerElement, viewportInfo, tableId, columnsArray, stickyColumnInfo, sizingInfoRef.current, { cell: currencyStatusRef.current.currentCell, locationY: 'inView' }, isRtl, appliedColumnWidths);
                currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;
            }
            else if (!isPendingLayout && isDataLoaded) {
                // corresponding element was not found - value was garbage
                currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;
            }
        }
        else {
            // there is no longer a current cell to try and scroll to
            currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;
        }
    }
}
/**
 * Helper to determine if the given render state includes the cell specified.
 */
function _renderIncludesCell(cell, columnsArray, tableData, hasMore, isPendingLayout, hasFooters) {
    // pending layout is special as other regions exist, but are not yet navigable
    if (isPendingLayout) {
        return cell.type === 'pending';
    }
    if (cell.type === 'header' || (hasFooters && cell.type === 'footer')) {
        for (let i = 0; i < columnsArray.length; i++) {
            if (columnsArray[i].key === cell.columnKey) {
                return true;
            }
        }
    }
    else if (tableData.length > 0) {
        if (cell.type === 'loadMore') {
            return hasMore;
        }
        if (cell.type === 'data') {
            let isColumnValid = false;
            for (let i = 0; i < columnsArray.length; i++) {
                if (columnsArray[i].key === cell.columnKey) {
                    isColumnValid = true;
                    break;
                }
            }
            if (isColumnValid) {
                for (let i = 0; i < tableData.length; i++) {
                    if (tableData[i].metadata === cell.rowKey) {
                        return true;
                    }
                }
            }
        }
    }
    else {
        return (cell.type === 'loading' && hasMore) || (cell.type === 'noData' && !hasMore);
    }
    return false;
}
/**
 * Helper to get the cell that should currently be a tab stop for the given render state.
 */
function determineActiveCell(columnsArray, currencyStatusRef, tableData, hasMore, isPendingLayout, isEmbeddedSelect, hasFooters, currentCellOverride) {
    if (isPendingLayout) {
        return { type: 'pending' };
    }
    // if no columns are specified, it is a special case 'noData' display
    const firstColumnKey = getBoundaryColumnKey(columnsArray, true);
    if (firstColumnKey == null) {
        return { type: 'noData' };
    }
    // if nothing specifies where focus should go, use the first header cell
    const defaultFirstCell = {
        type: 'header',
        columnKey: firstColumnKey
    };
    // when embedded select, use most recent non-null current cell value as override base
    const currentCell = isEmbeddedSelect
        ? currencyStatusRef.current.previousEmbeddedSelectCurrentCell
        : currencyStatusRef.current.currentCell;
    if (currencyStatusRef.current.hasPendingCurrentCellOverride ||
        currencyStatusRef.current.currentCellOverride !== currentCellOverride) {
        if (currentCellOverride != null) {
            // attempt to find the cell the override specifies
            const realizedCell = _getCellFromCellOverride(tableData, columnsArray, currentCellOverride, currentCell);
            if (realizedCell != null &&
                _renderIncludesCell(realizedCell, columnsArray, tableData, hasMore, isPendingLayout, hasFooters)) {
                return realizedCell;
            }
            // if here, the resulting cell from the override could not be determined or was not valid
            const overrideCellType = _getCellTypeFromCellOverride(currentCellOverride, currentCell);
            if (overrideCellType === 'data') {
                if (tableData.length === 0 && hasMore) {
                    // pending 'data' override when 'loading' skeletons are shown
                    return { type: 'loading', columnKey: currentCell?.columnKey };
                }
            }
            else if (overrideCellType === 'noData' && tableData.length === 0 && hasMore) {
                // pending 'noData' override when 'loading' skeletons are shown
                return { type: 'loading', columnKey: currentCell?.columnKey };
            }
        }
        else if (_renderIncludesCell(defaultFirstCell, columnsArray, tableData, hasMore, isPendingLayout, hasFooters)) {
            return defaultFirstCell;
        }
        else {
            return undefined;
        }
    }
    // if here, there is no current cell override that can be applied during this render
    const activeCell = currencyStatusRef.current.activeCell;
    if (activeCell != null) {
        if (activeCell.type === 'loadMore') {
            const initialData = currencyStatusRef.current.loadMoreInitialData;
            // if loadMore skeletons are no longer shown, or the data has changed, shift to
            // the next row in the data set if possible - otherwise just the closest row
            if (tableData.length > 0 && tableData !== initialData) {
                const rowKey = initialData != null && tableData.length > initialData.length
                    ? tableData[initialData.length].metadata
                    : tableData[tableData.length - 1].metadata;
                const columnKey = currentCell?.columnKey != null ? currentCell.columnKey : firstColumnKey;
                const cell = { type: 'data', rowKey: rowKey, columnKey: columnKey };
                if (_renderIncludesCell(cell, columnsArray, tableData, hasMore, isPendingLayout, hasFooters)) {
                    return cell;
                }
            }
            else if (tableData.length === 0) {
                if (hasMore) {
                    return { type: 'loading', columnKey: currentCell?.columnKey };
                }
                else {
                    return { type: 'noData' };
                }
            }
        }
        if (_renderIncludesCell(activeCell, columnsArray, tableData, hasMore, isPendingLayout, hasFooters)) {
            return activeCell;
        }
        else if (activeCell.type === 'loading') {
            if (currentCell != null && (currentCell.type === 'data' || currentCell.type === 'noData')) {
                // if the current cell is already set to 'data' or 'noData', and is now available, return it
                if (_renderIncludesCell(currentCell, columnsArray, tableData, hasMore, isPendingLayout, hasFooters)) {
                    return currentCell;
                }
            }
            // otherwise, find the first row if available, and try and maintain the columnKey
            if (tableData.length > 0) {
                const rowKey = tableData[0].metadata;
                const columnKey = currentCell?.columnKey != null ? currentCell.columnKey : firstColumnKey;
                const cell = { type: 'data', rowKey: rowKey, columnKey: columnKey };
                if (_renderIncludesCell(cell, columnsArray, tableData, hasMore, isPendingLayout, hasFooters)) {
                    return cell;
                }
            }
            else {
                return { type: 'noData' };
            }
        }
    }
    // if here, there is no active cell, or the active cell is no longer valid
    if (currentCell != null) {
        if (_renderIncludesCell(currentCell, columnsArray, tableData, hasMore, isPendingLayout, hasFooters)) {
            return currentCell;
        }
        if (currentCell.type === 'data') {
            if (tableData.length === 0 && hasMore) {
                // pending 'data' override when 'loading' skeletons are shown
                return { type: 'loading', columnKey: currentCell.columnKey };
            }
        }
        else if (currentCell.type === 'noData' && tableData.length === 0 && hasMore) {
            // pending 'noData' override when 'loading' skeletons are shown
            return { type: 'loading', columnKey: firstColumnKey };
        }
    }
    if (_renderIncludesCell(defaultFirstCell, columnsArray, tableData, hasMore, isPendingLayout, hasFooters)) {
        return defaultFirstCell;
    }
    return undefined;
}

const TOUCH_OFFSET_VALUE = 40;
const menuPropGestureStates = {
    mouse: {
        initialFocus: 'menu',
        placement: 'bottom-start',
        offsetValue: 2
    },
    keyboard: {
        initialFocus: 'firstItem',
        placement: 'bottom-start',
        offsetValue: 0
    },
    touch: {
        initialFocus: 'menu',
        placement: 'end',
        offsetValue: TOUCH_OFFSET_VALUE
    }
};
const _initialMenuProps = {
    isOpen: false,
    initialFocus: 'menu',
    placement: 'bottom-start',
    offsetValue: 0,
    anchorRef: { current: null }
};
const useContextMenu = (tableId, tableData, columnsArray, activeCell, contextMenuConfig, sortCriterion, onSortCriterionChange) => {
    const [contextMenuContext, setContextMenuContext] = hooks.useState();
    const [menuProps, setMenuProps] = hooks.useState(_initialMenuProps);
    const currentCellElementRef = hooks.useRef();
    const [isResizeDialogOpen, setIsResizeDialogOpen] = hooks.useState(false);
    const { triggerProps } = useContextMenuGesture.useContextMenuGesture(({ gesture, anchor, target }) => {
        if (activeCell != null) {
            const cellContextMenuContext = getCellContextMenuContextFromCell(tableData, columnsArray, setIsResizeDialogOpen, activeCell, sortCriterion, onSortCriterionChange);
            if (cellContextMenuContext != null) {
                // find the cell element the menu is being launched from
                const cellElement = target.closest(`[data-oj-table-focusable='${tableId}']`);
                if (cellElement != null) {
                    currentCellElementRef.current = cellElement;
                    const anchorBasedOnGesture = gesture === 'keyboard' ? cellElement : anchor;
                    setContextMenuContext(cellContextMenuContext);
                    setMenuProps({
                        ...menuPropGestureStates[gesture],
                        anchorRef: { current: anchorBasedOnGesture },
                        isOpen: true
                    });
                }
            }
        }
    }, {
        isDisabled: !contextMenuConfig
    });
    const handleCloseContextMenu = hooks.useCallback((detail) => {
        // set focus back on the cell that was determined as the initial target
        if (detail.reason === 'dismissed' || detail.reason === 'itemAction') {
            currentCellElementRef.current?.focus({ preventScroll: true });
        }
        // close the menu
        setMenuProps({ ..._initialMenuProps });
    }, []);
    return {
        menuProps: { ...menuProps, onClose: handleCloseContextMenu },
        onClose: handleCloseContextMenu,
        contextMenuContext: contextMenuContext,
        contextMenuTriggerProps: triggerProps,
        isResizeDialogOpen: isResizeDialogOpen,
        setIsResizeDialogOpen: setIsResizeDialogOpen
    };
};

// delay small interaction times concerning a tooltip
const SMALL_INTERACTION_DELAY = 50;
const TABLE_HIDE_TOOLTIP_DELAY = Math.max(Math.min(tooltipUtils.SHOW_TOOLTIP_DELAY - SMALL_INTERACTION_DELAY, tooltipUtils.HIDE_TOOLTIP_DELAY), 0);
/**
 * Hook that manages cell template tooltip interactions on the Table when truncation is present.
 */
function useTruncationTooltip({ rootRef, tableId, resizeInfoRef }) {
    const globalTooltipManager = tooltipUtils.getGlobalTooltipManager();
    const tooltipId = useId.useId();
    const tooltipCellRef = hooks.useRef();
    const pendingShowTooltipCellRef = hooks.useRef();
    const tooltipAnchorRef = hooks.useRef();
    const tooltipTextRef = hooks.useRef();
    const [tooltipText, setTooltipText] = hooks.useState();
    const pointerDownRef = hooks.useRef(false);
    const pointerDownTimeoutRef = hooks.useRef();
    const showTooltipTimeoutRef = hooks.useRef();
    const hideTooltipTimeoutRef = hooks.useRef();
    // helper method for clearing the hide tooltip timeout
    const _clearHideTooltipTimeout = hooks.useCallback(() => {
        clearTimeout(hideTooltipTimeoutRef.current);
        hideTooltipTimeoutRef.current = undefined;
    }, []);
    // helper method for clearing the show tooltip timeout
    const _clearShowTooltipTimeout = hooks.useCallback(() => {
        clearTimeout(showTooltipTimeoutRef.current);
        showTooltipTimeoutRef.current = undefined;
        pendingShowTooltipCellRef.current = undefined;
    }, []);
    // helper method for setting up the show tooltip timeout
    const _setupShowTooltipTimeout = hooks.useCallback(() => {
        showTooltipTimeoutRef.current = setTimeout(function () {
            // when showing a tooltip, clear any pending 'clear tooltip timeouts'
            if (hideTooltipTimeoutRef.current != null) {
                _clearHideTooltipTimeout();
            }
            // only show a tooltip if not currently performing a column resize gesture
            if (!resizeInfoRef.current.isResizing) {
                showTooltipTimeoutRef.current = undefined;
                const cell = pendingShowTooltipCellRef.current;
                const rootElement = rootRef.current;
                if (rootElement != null && cell != null) {
                    const cellElement = getElementFromCell(rootElement, tableId, cell);
                    if (cellElement != null && hasTruncatedText(cellElement)) {
                        setTooltipText(String(cellElement.innerText).trim());
                        tooltipAnchorRef.current = cellElement;
                        tooltipCellRef.current = cell;
                    }
                }
            }
            pendingShowTooltipCellRef.current = undefined;
        }, tooltipUtils.SHOW_TOOLTIP_DELAY);
    }, [rootRef, tableId, resizeInfoRef, _clearHideTooltipTimeout]);
    // helper method for setting up the hide tooltip timeout
    const _setupHideTooltipTimeout = hooks.useCallback(() => {
        hideTooltipTimeoutRef.current = setTimeout(function () {
            // unlike in the showtooltip timeout logic, we do not want to clear
            // pending show tooltip timeouts when clearing a tooltip as it could
            // still be waiting to be shown in another location at this time
            hideTooltipTimeoutRef.current = undefined;
            setTooltipText(undefined);
            tooltipAnchorRef.current = undefined;
            tooltipCellRef.current = undefined;
        }, TABLE_HIDE_TOOLTIP_DELAY);
    }, []);
    // callback method to signal a tooltip is desired on the given cell
    const showTooltip = hooks.useCallback((anchorCell) => {
        if (cellComparator(tooltipCellRef.current, anchorCell)) {
            // if the tooltip is already showing in the right cell, clear all timeouts
            if (showTooltipTimeoutRef.current != null) {
                _clearShowTooltipTimeout();
            }
            if (hideTooltipTimeoutRef.current != null) {
                _clearHideTooltipTimeout();
            }
            return;
        }
        if (showTooltipTimeoutRef.current == null) {
            // if no tooltip is already pending, start a new tooltip timeout
            pendingShowTooltipCellRef.current = anchorCell;
            _setupShowTooltipTimeout();
        }
        else if (!cellComparator(pendingShowTooltipCellRef.current, anchorCell)) {
            // if a different tooltip is already pending, start a new tooltip timeout
            _clearShowTooltipTimeout();
            pendingShowTooltipCellRef.current = anchorCell;
            _setupShowTooltipTimeout();
        }
        if (tooltipCellRef.current != null && hideTooltipTimeoutRef.current == null) {
            // if the tooltip is showing on a different cell, ensure a hide timeout is setup
            _setupHideTooltipTimeout();
        }
    }, [
        _setupShowTooltipTimeout,
        _setupHideTooltipTimeout,
        _clearShowTooltipTimeout,
        _clearHideTooltipTimeout
    ]);
    // callback method to signal the current tooltip is no longer desired
    const hideTooltip = hooks.useCallback((isImmediate) => {
        // ignore hide tooltip calls if due to focus loss from a pointer down on the tooltip itself
        if (pointerDownRef.current) {
            return;
        }
        if (showTooltipTimeoutRef.current != null) {
            _clearShowTooltipTimeout();
        }
        if (isImmediate) {
            if (hideTooltipTimeoutRef.current != null) {
                _clearHideTooltipTimeout();
            }
            setTooltipText(undefined);
            tooltipAnchorRef.current = undefined;
            tooltipCellRef.current = undefined;
        }
        else if (hideTooltipTimeoutRef.current == null) {
            _setupHideTooltipTimeout();
        }
    }, [_setupHideTooltipTimeout, _clearShowTooltipTimeout, _clearHideTooltipTimeout]);
    // Pointer move handler for the tooltip.
    const _pointerMoveHandler = hooks.useCallback((_event) => {
        if (showTooltipTimeoutRef.current != null) {
            clearTimeout(showTooltipTimeoutRef.current);
            showTooltipTimeoutRef.current = undefined;
            pendingShowTooltipCellRef.current = undefined;
        }
        if (hideTooltipTimeoutRef.current != null) {
            clearTimeout(hideTooltipTimeoutRef.current);
            hideTooltipTimeoutRef.current = undefined;
        }
    }, []);
    // Pointer leave handler for the tooltip.
    const _pointerLeaveHandler = hooks.useCallback((event) => {
        const targetElement = event.relatedTarget;
        if (targetElement != null && targetElement.closest(`#${tableId}`) != null) {
            return;
        }
        hideTooltip();
    }, [tableId, hideTooltip]);
    // Pointer down handler for the tooltip.
    const _pointerDownHandler = hooks.useCallback((_event) => {
        pointerDownRef.current = true;
        if (pointerDownTimeoutRef.current != null) {
            clearTimeout(pointerDownTimeoutRef.current);
        }
        pointerDownTimeoutRef.current = setTimeout(function () {
            pointerDownRef.current = false;
            pointerDownTimeoutRef.current = undefined;
        }, SMALL_INTERACTION_DELAY);
    }, []);
    // handles logic involving competing tooltips managed outside of the TableView.
    // make sure this check runs BEFORE the rendered content is created below
    const isOpenOverrideRef = hooks.useRef(true);
    if (tooltipText != null && tooltipText !== tooltipTextRef.current) {
        isOpenOverrideRef.current = true;
    }
    const tooltipPointerProps = {
        onPointerLeave: _pointerLeaveHandler,
        onPointerMove: _pointerMoveHandler,
        onPointerDown: _pointerDownHandler
    };
    // avoid applying undefined text after initial render completes as it can appear
    // while the tooltip is going through its closing animation and looks broken
    const renderRawContent = (jsxRuntime.jsx(useTooltipControlled.TooltipContent, { ...tooltipPointerProps, id: tooltipId, isOpen: isOpenOverrideRef.current, isDatatip: false, children: tooltipText != null ? tooltipText : tooltipTextRef.current }));
    // make sure these are in sync AFTER the rendered content is created above - this helps ensure
    // that empty text does not show up while the tooltip is going through a closing animation.
    tooltipTextRef.current = tooltipText;
    // offsets attempt to show the tooltip without overlapping content of nearby cells
    const scale = useScale.useScale();
    let mainAxisOffset = -8;
    let crossAxisOffset = -14;
    if (scale === 'md') {
        mainAxisOffset = -7;
        crossAxisOffset = -12;
    }
    else if (scale === 'sm') {
        mainAxisOffset = -6;
        crossAxisOffset = -11;
    }
    const currentColorScheme = useColorScheme.useColorScheme();
    const tooltipContent = tooltipAnchorRef.current != null
        ? tooltipUtils.getWrappedTooltipContent(renderRawContent, 'tooltip', currentColorScheme, tooltipAnchorRef, 'end-top', { mainAxis: mainAxisOffset, crossAxis: crossAxisOffset })
        : undefined;
    const destroyCallback = hooks.useCallback(() => {
        hideTooltip(true);
    }, [hideTooltip]);
    hooks.useEffect(() => {
        if (isOpenOverrideRef.current && tooltipAnchorRef.current != null) {
            globalTooltipManager.register(destroyCallback);
        }
        else {
            globalTooltipManager.unregister(destroyCallback);
        }
    }, [tooltipAnchorRef, destroyCallback, tooltipText, globalTooltipManager]);
    return { tooltipContent, tooltipId, showTooltip, hideTooltip, tooltipAnchorRef };
}

// constant timeout values for delays following a input gesture until enabling focus rings
const MOUSE_FOCUS_SHIFT_TIMEOUT = 100;
const TOUCH_FOCUS_SHIFT_TIMEOUT = 200;
// constant event.key values that trigger focus ring logic
const NAVIGATION_KEYS = [
    ' ',
    'F2',
    'Enter',
    'Esc', // Firefox 36 and earlier uses 'Esc' instead of 'Escape'
    'Escape',
    'ArrowLeft',
    'ArrowUp',
    'ArrowRight',
    'ArrowDown',
    'Home',
    'End',
    'PageUp',
    'PageDown'
];
// constant event.key values that trigger 'scroll to current' logic
const SCROLL_KEYS = [
    ' ',
    'F2',
    'Enter',
    'Esc', // Firefox 36 and earlier uses 'Esc' instead of 'Escape'
    'Escape'
];
/**
 * Hook that manages focus interactions on the Preact Table
 */
function useFocusHandling({ rootRef, viewportInfo, tableId, isRtl, tableData, hasMore, hasFooters, columnsArray, stickyColumnInfo, sizingInfoRef, selectionExtensionElementRef, cellSupportsTabbable, appliedColumnWidths, currentCellOverride, onPersistCurrentCell, showTooltip, hideTooltip, isPendingLayout, isEmbeddedSelect, isDataLoaded }) {
    // tracks whether the most recent 'blur' was caused by focus being lost by the browser window (or iframe)
    const blurFromWindowRef = hooks.useRef(false);
    // tracks focus loss during render cycle for potential focus recapture cases
    const isRenderCycle = hooks.useRef(true);
    isRenderCycle.current = true;
    const blurredRenderCycleElementRef = hooks.useRef(null);
    const isPendingLayoutFocusRef = hooks.useRef(false);
    // track current 'focus info' state
    const hasFocusRef = hooks.useRef(false);
    const [isTabbableMode, setIsTabbableMode] = hooks.useState(false);
    const [isShowFocusRing, setIsShowFocusRing] = hooks.useState(false);
    // track pointer down information
    const recentPointerRef = hooks.useRef(false);
    const pointerTimerRef = hooks.useRef(null);
    const isShowFocusRingOverrideRef = hooks.useRef(null);
    // track the active and current cell information
    const [activeCell, setActiveCell] = hooks.useState(undefined);
    const currencyStatusRef = hooks.useRef({
        hasPendingCurrentCellOverride: false,
        hasPendingCurrentCellOverrideScroll: false
    });
    // track pending scrolls to minimize 'flash' of focus rings when scrolling
    const [deferredScrollDetail, setDeferredScrollDetail] = hooks.useState(undefined);
    const deferredScrollDetailRef = hooks.useRef();
    // keep state and ref in-sync to avoid edge cases where a gesture updating the scroll detail is handled
    // inbetween a render cycle that changes the scroll detail and the useEffect that applies the detail
    const updateDeferredScrollDetail = hooks.useCallback((scrollDetail) => {
        setDeferredScrollDetail(scrollDetail);
        deferredScrollDetailRef.current = scrollDetail;
    }, []);
    const wasTransient = isTransientCell(currencyStatusRef.current.activeCell);
    const currentActiveCell = determineActiveCell(columnsArray, currencyStatusRef, tableData, hasMore, isPendingLayout, isEmbeddedSelect, hasFooters, currentCellOverride);
    // intercept onPersistCurrentCell calls to ensure internal state is updated appropriately
    const onActiveCellChanged = hooks.useMemo(() => {
        return (detail, isAutoFocus, isSelectionExtension, skipScrollCellIntoView) => {
            const newActiveCell = detail.value;
            if (!cellComparator(currencyStatusRef.current.activeCell, newActiveCell)) {
                setActiveCell(newActiveCell);
                currencyStatusRef.current.activeCell = newActiveCell;
                if (!isTransientCell(newActiveCell)) {
                    const newCurrentCell = newActiveCell;
                    // only update current cell when 'active' is not one of the transient 'skeleton' regions
                    if (onPersistCurrentCell != null) {
                        onPersistCurrentCell({ value: newCurrentCell });
                    }
                    currencyStatusRef.current.currentCell = newCurrentCell;
                    // make sure pending current cell override states are updated on current changed
                    if (newCurrentCell != null) {
                        currencyStatusRef.current.previousEmbeddedSelectCurrentCell = newCurrentCell;
                    }
                    currencyStatusRef.current.currentCellOverride = currentCellOverride;
                    currencyStatusRef.current.hasPendingCurrentCellOverride = false;
                    currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;
                }
                else if (newActiveCell?.type === 'loadMore') {
                    currencyStatusRef.current.loadMoreInitialData = tableData;
                }
                if (!isSelectionExtension) {
                    selectionExtensionElementRef.current = undefined;
                    if (isAutoFocus && newActiveCell != null && cellSupportsTabbable(newActiveCell)) {
                        // attempt to auto-focus cell contents
                        setIsTabbableMode(true);
                        setIsShowFocusRing(false);
                    }
                    else if (isTabbableMode) {
                        // exit tabbable mode when navigating away from auto-focus cell
                        setIsTabbableMode(false);
                    }
                }
            }
            if (newActiveCell != null && !recentPointerRef.current && !skipScrollCellIntoView) {
                updateDeferredScrollDetail({
                    cell: newActiveCell,
                    locationX: 'inView',
                    locationY: 'inView'
                });
            }
        };
    }, [
        currentCellOverride,
        isTabbableMode,
        cellSupportsTabbable,
        tableData,
        onPersistCurrentCell,
        selectionExtensionElementRef,
        updateDeferredScrollDetail
    ]);
    // Helper function to set the Table's focus tracking state to reflect that it is inactive.
    const _setAsInactive = hooks.useCallback(() => {
        hasFocusRef.current = false;
        isPendingLayoutFocusRef.current = false;
        setIsTabbableMode(false);
        setIsShowFocusRing(false);
        hideTooltip();
    }, [hideTooltip]);
    // Helper function to set the Table's focus tracking state to reflect that one of its cells has focus.
    const _enableNavigationMode = hooks.useCallback((cell, skipScrollCellIntoView) => {
        const rootElement = rootRef.current;
        const scrollerElement = viewportInfo.viewportConfig.scroller().current;
        if (rootElement != null && scrollerElement != null) {
            setIsTabbableMode(false);
            const focusRingState = isShowFocusRingOverrideRef.current !== null
                ? isShowFocusRingOverrideRef.current
                : !recentPointerRef.current;
            setIsShowFocusRing(focusRingState);
            if (focusRingState) {
                handleNavigationTooltipGesture(rootElement, tableId, cell, showTooltip, hideTooltip);
            }
            onActiveCellChanged({ value: cell }, false, false, skipScrollCellIntoView);
        }
    }, [rootRef, viewportInfo, tableId, onActiveCellChanged, showTooltip, hideTooltip]);
    // Helper function to set the Table's focus tracking state to reflect that it is tabbable.
    const _enableTabbableMode = hooks.useCallback((cell, isKeyboard, skipScrollCellIntoView) => {
        const rootElement = rootRef.current;
        const scrollerElement = viewportInfo.viewportConfig.scroller().current;
        if (rootElement != null && scrollerElement != null) {
            setIsTabbableMode(true);
            if (!isKeyboard) {
                setIsShowFocusRing(false);
                onActiveCellChanged({ value: cell }, true, false, skipScrollCellIntoView);
            }
        }
    }, [rootRef, viewportInfo, onActiveCellChanged]);
    // Helper function to set the Table's focus tracking state to reflect that a user has
    // exited tabbable mode via the keyboard (esc or 'F2')
    const _disableTabbableMode = hooks.useCallback((cell) => {
        const rootElement = rootRef.current;
        if (rootElement != null) {
            setIsTabbableMode(false);
            const cellElement = getElementFromCell(rootElement, tableId, cell);
            if (cellElement != null) {
                cellElement.focus({ preventScroll: true });
            }
            else {
                rootElement.focus({ preventScroll: true });
            }
        }
    }, [rootRef, tableId]);
    const notifyFocusFromPointer = hooks.useCallback((isTouch) => {
        if (pointerTimerRef.current != null) {
            clearTimeout(pointerTimerRef.current);
        }
        recentPointerRef.current = true;
        pointerTimerRef.current = setTimeout(() => {
            recentPointerRef.current = false;
        }, isTouch ? TOUCH_FOCUS_SHIFT_TIMEOUT : MOUSE_FOCUS_SHIFT_TIMEOUT);
    }, []);
    // PointerDown handler for the outer Table. Focus transfers that occur following a pointerdown
    // on desktop devices should not result in a focus ring being shown on the focused element
    const _pointerDownHandler = hooks.useCallback((event) => {
        if (isShowFocusRing) {
            setIsShowFocusRing(false);
        }
        if (event.pointerType !== 'touch') {
            notifyFocusFromPointer(false);
        }
    }, [isShowFocusRing, notifyFocusFromPointer]);
    // PointerUp handler for the outer Table. Focus transfers that occur following a pointerup
    // on any type of device should not result in a focus ring being shown on the focused element
    const _pointerUpHandler = hooks.useCallback((event) => {
        notifyFocusFromPointer(event.pointerType === 'touch');
    }, [notifyFocusFromPointer]);
    // Focus handler for the outer Table. On focus, a focusable area needs to be 'active'.
    // If an 'active' area already exists, nothing further is needed. Otherwise, the first
    // focusable element should be made 'active'.
    const _onFocusHandler = (event) => {
        hasFocusRef.current = true;
        const rootElement = rootRef.current;
        const scrollerElement = viewportInfo.viewportConfig.scroller().current;
        if (rootElement != null) {
            // don't scroll active into view if previous blur was due to window focus loss
            const skipScrollCellIntoView = blurFromWindowRef.current || isPendingLayout;
            blurFromWindowRef.current = false;
            const targetElement = event.target;
            if (targetElement === rootElement || targetElement === scrollerElement) {
                if (currentActiveCell != null) {
                    _enableNavigationMode(currentActiveCell, skipScrollCellIntoView);
                }
            }
            else {
                const cell = logicalCellExtractor(targetElement, tableId, columnsArray);
                if (cell != null) {
                    if (getCellType(targetElement) != null) {
                        // handle individual focusable regions receiving focus
                        _enableNavigationMode(cell, skipScrollCellIntoView);
                    }
                    else {
                        _enableTabbableMode(cell, false, skipScrollCellIntoView);
                    }
                }
            }
        }
        isShowFocusRingOverrideRef.current = null;
    };
    // Blur handler for the outer Table. When a blur is caused by the browser window itself
    // losing focus (changing tabs or leaving an iframe for example), an eventual re-focus due
    // to the window re-gaining focus needs to be handled differently (no auto-scroll mostly).
    const _onBlurHandler = hooks.useCallback((event) => {
        const rootElement = rootRef.current;
        if (rootElement != null) {
            if (event.target === document.activeElement) {
                // save focus ring state so it's set once focus comes back
                isShowFocusRingOverrideRef.current = isShowFocusRing;
            }
            const relatedTarget = event.relatedTarget;
            const isUnknownRelatedTarget = relatedTarget == null;
            blurFromWindowRef.current = isUnknownRelatedTarget;
            if (isUnknownRelatedTarget || !collectionUtils.getElementContainsFunc(rootElement, true)(relatedTarget)) {
                _setAsInactive();
                if (isRenderCycle.current) {
                    // store element that loses focus during a render cycle for recapturing focus logic
                    blurredRenderCycleElementRef.current = event.target;
                }
            }
        }
    }, [rootRef, isShowFocusRing, _setAsInactive]);
    // KeyDown handler for the outer Table. This specific handler tracks 'focus' transfer keys
    // Esc, F2, Enter, and Tab. It also ensures the active cell is scrolled into view on any key
    const _onKeyDownHandler = hooks.useCallback((event) => {
        const rootElement = rootRef.current;
        const scrollerElement = viewportInfo.viewportConfig.scroller().current;
        if (rootElement != null && scrollerElement != null) {
            const isNavigationKey = NAVIGATION_KEYS.indexOf(event.key) > -1;
            if (isNavigationKey) {
                if (pointerTimerRef.current != null) {
                    clearTimeout(pointerTimerRef.current);
                }
                pointerTimerRef.current = null;
                recentPointerRef.current = false;
            }
            if (isPendingLayout) {
                if (isNavigationKey) {
                    setIsShowFocusRing(true);
                }
            }
            else if (activeCell != null) {
                if (cellSupportsTabbable(activeCell)) {
                    if (event.key === 'F2') {
                        if (isTabbableMode) {
                            _disableTabbableMode(activeCell);
                        }
                        else {
                            _enableTabbableMode(activeCell, true);
                        }
                    }
                    else if (event.key === 'Esc' || event.key === 'Escape') {
                        // Firefox 36 and earlier uses 'Esc' instead of 'Escape'
                        _disableTabbableMode(activeCell);
                    }
                    else if (event.key === 'Enter' && !isTabbableMode) {
                        _enableTabbableMode(activeCell, true);
                    }
                }
                if (!isTabbableMode) {
                    if (isNavigationKey) {
                        setIsShowFocusRing(true);
                    }
                    if (SCROLL_KEYS.indexOf(event.key) > -1) {
                        updateDeferredScrollDetail({
                            cell: activeCell,
                            locationX: 'inView',
                            locationY: 'inView'
                        });
                    }
                }
            }
        }
    }, [
        rootRef,
        viewportInfo,
        isTabbableMode,
        activeCell,
        cellSupportsTabbable,
        isPendingLayout,
        _enableTabbableMode,
        _disableTabbableMode,
        updateDeferredScrollDetail
    ]);
    // Callback for the outer Table's FocusTracker usage.
    const onStartFocusTracking = hooks.useCallback((detail) => {
        const rootElement = rootRef.current;
        if (rootElement != null && activeCell != null) {
            collectionUtils.handleEnterActionableMode(detail.hasFocusWithin && getCellType(detail.activeElement) == null, tabbableUtils.allTabbableElements(getElementFromCell(rootElement, tableId, activeCell)), (value) => {
                setIsTabbableMode(value != undefined);
            });
        }
    }, [rootRef, activeCell, tableId]);
    // Callback for the outer Table's FocusTracker usage.
    const onFocusStartEdge = hooks.useCallback((detail) => {
        collectionUtils.handleWrapActionableFocus(true, detail.tabbableElements, (value) => {
            setIsTabbableMode(value != undefined);
        });
    }, []);
    // Callback for the outer Table's FocusTracker usage.
    const onFocusEndEdge = hooks.useCallback((detail) => {
        collectionUtils.handleWrapActionableFocus(false, detail.tabbableElements, (value) => {
            setIsTabbableMode(value != undefined);
        });
    }, []);
    // Ensure focus is properly set at the completion of every render cycle
    // NO DEPENDENCY ARRAY HERE TO ENSURE THIS RUNS ON EVERY RENDER CYCLE
    hooks.useEffect(() => {
        const rootElement = rootRef.current;
        const scrollerElement = viewportInfo.viewportConfig.scroller().current;
        if (rootElement != null && scrollerElement != null) {
            // internal method responsible for ensuring focus is applied to the appropriate cells or contents
            const _applyInternalFocus = (rootElement, activeElement, isCaptureFocus) => {
                if (currentActiveCell != null) {
                    // ensure real browser focus is on the correct cell element
                    const cellElement = getElementFromCell(rootElement, tableId, currentActiveCell);
                    if (cellElement != null) {
                        // cell is valid, so set focus on it if needed
                        if (!isTabbableMode && activeElement !== cellElement) {
                            if (wasTransient &&
                                !isTransientCell(currentActiveCell) &&
                                isAutoFocusCell(rootElement, tableId, currentActiveCell) &&
                                cellSupportsTabbable(currentActiveCell)) {
                                _enableTabbableMode(currentActiveCell);
                            }
                            else {
                                cellElement.focus({ preventScroll: true });
                            }
                            return;
                        }
                        else if (isTabbableMode &&
                            !collectionUtils.getElementContainsFunc(cellElement, true)(activeElement)) {
                            collectionUtils.handleEnterActionableMode(false, tabbableUtils.allTabbableElements(cellElement), (value) => {
                                setIsTabbableMode(value != undefined);
                                if (isCaptureFocus) {
                                    rootElement.focus({ preventScroll: true });
                                }
                            }, true);
                            return;
                        }
                    }
                }
                if (isCaptureFocus) {
                    rootElement.focus({ preventScroll: true });
                }
            };
            // ensure the current cell is scrolled into view when necessary
            // only run if the state and ref match - otherwise another render cycle may be pending
            if (deferredScrollDetail != null &&
                deferredScrollDetail === deferredScrollDetailRef.current) {
                applyScrollDetail(rootElement, scrollerElement, viewportInfo, tableId, columnsArray, stickyColumnInfo, sizingInfoRef.current, deferredScrollDetail, isRtl, appliedColumnWidths);
                deferredScrollDetailRef.current = undefined;
            }
            // ensure current-cell-override is up to date on each render
            applyCurrentCellOverride(rootElement, scrollerElement, viewportInfo, tableId, tableData, columnsArray, stickyColumnInfo, sizingInfoRef, currencyStatusRef, onActiveCellChanged, isEmbeddedSelect, isPendingLayout, isDataLoaded, isRtl, currentCellOverride, appliedColumnWidths);
            const blurredRenderCycleElement = blurredRenderCycleElementRef.current;
            blurredRenderCycleElementRef.current = null;
            isRenderCycle.current = false;
            const activeElement = tabbableUtils.getActiveElement(rootElement);
            // if we were tracking focus during the render cycle, ensure we recapture focus if needed
            if (blurredRenderCycleElement != null &&
                activeElement === tabbableUtils.getBodyElement(rootElement) &&
                (!collectionUtils.getElementContainsFunc(rootElement, true)(blurredRenderCycleElement) ||
                    !tabbableUtils.isTabbableElement(blurredRenderCycleElement, true))) {
                _applyInternalFocus(rootElement, activeElement, true);
            }
            else if (hasFocusRef.current &&
                cellComparator(activeCell, currencyStatusRef.current.activeCell)) {
                _applyInternalFocus(rootElement, activeElement);
            }
        }
    });
    return {
        focusHandlingProps: {
            onPointerDown: _pointerDownHandler,
            onPointerUp: _pointerUpHandler,
            onFocus: _onFocusHandler,
            onBlur: _onBlurHandler,
            onKeyDown: _onKeyDownHandler
        },
        activeCell,
        onActiveCellChanged,
        currentCell: currencyStatusRef.current.currentCell,
        currentActiveCell,
        isShowFocusRing,
        isTabbableMode,
        onStartFocusTracking,
        onFocusStartEdge,
        onFocusEndEdge,
        updateDeferredScrollDetail
    };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Helper function to get the row action context from a pointer or keyboard event
 */
function _getRowActionGestureContext(rootElement, tableId, tableData, targetElement, targetCell) {
    let rowKey;
    let rowElement;
    if (targetCell?.type === 'data') {
        rowKey = targetCell.rowKey;
        const targetCellElement = getElementFromCell(rootElement, tableId, targetCell);
        if (targetCellElement != null) {
            rowElement = targetCellElement.parentElement;
        }
    }
    else {
        rowKey = collectionUtils.keyExtractor(targetElement, `[data-oj-table-data-row='${tableId}']`);
        if (rowKey != null) {
            rowElement = targetElement.closest(`[data-oj-table-data-row='${tableId}']`);
        }
    }
    if (rowKey != null && rowElement != null) {
        const rowIndex = getRowIndexForRowElement(rootElement, tableId, rowElement);
        if (rowIndex != null) {
            return {
                key: rowKey,
                data: tableData[rowIndex].data
            };
        }
    }
    return undefined;
}
/**
 * Helper function to handle a row action gesture from a pointer or keyboard event
 */
function handleRowActionGesture(rootElement, tableId, tableData, onRowAction, targetElement, targetCell) {
    const rowActionContext = _getRowActionGestureContext(rootElement, tableId, tableData, targetElement, targetCell);
    if (rowActionContext != null) {
        onRowAction({ context: rowActionContext, target: targetElement });
        return true;
    }
    return false;
}
/**
 * Helper function to determine if a pointer or keyboard event should trigger a sort action gesture
 */
function _isSortActionGesture(columnsArray, columnKey) {
    for (const column of columnsArray) {
        if (column.key === columnKey) {
            return column.value.sortable === 'enabled';
        }
    }
    return false;
}
/**
 * Helper function to handle a sort action gesture
 */
function handleSortActionGesture(columnsArray, columnKey, onSortCriterionChange, sortCriterion) {
    if (_isSortActionGesture(columnsArray, columnKey)) {
        let sortDirection;
        if (sortCriterion != null) {
            for (const criterion of sortCriterion) {
                if (criterion.key === columnKey) {
                    sortDirection = criterion.sortDirection;
                    break;
                }
            }
        }
        const newDirection = sortDirection === 'ascending' ? 'descending' : 'ascending';
        onSortCriterionChange([{ key: columnKey, sortDirection: newDirection }]);
        return true;
    }
    return false;
}

/**
 * Helper function to handle a hover gesture over a column header or footer region.
 */
function handleOverColumnHeaderFooterGesture(tableId, event, setHoverStyleColumnInfo, hoverStyleColumnInfo) {
    // only track 'hover' information for mouse events
    if (event.pointerType === 'mouse') {
        const cellElement = event.target.closest(`[data-oj-table-focusable='${tableId}']`);
        if (cellElement != null) {
            const cellType = getCellType(cellElement);
            if (cellType === 'header' || cellType === 'footer') {
                const isHeader = cellType === 'header';
                const columnKey = getColumnKey(cellElement);
                if (columnKey !== hoverStyleColumnInfo?.key ||
                    !hoverStyleColumnInfo?.isHeader !== isHeader) {
                    setHoverStyleColumnInfo({ key: columnKey, isHeader: cellType === 'header' });
                    return;
                }
            }
        }
    }
    handleEndInteractionColumnHeaderFooterGesture(setHoverStyleColumnInfo, hoverStyleColumnInfo);
}
/**
 * Helper function to handle an active gesture over a column header or footer region.
 */
function handleActiveColumnHeaderFooterGesture(tableId, event, setActiveStyleColumnInfo, activeStyleColumnInfo, activeCell) {
    let cellType;
    let columnKey;
    if (activeCell != null) {
        cellType = activeCell.type;
        columnKey = activeCell.columnKey;
    }
    else if (event instanceof PointerEvent && event.pointerType === 'touch') {
        // only handle touch events since hover events have the same treatment
        const cellElement = event.target.closest(`[data-oj-table-focusable='${tableId}']`);
        if (cellElement != null) {
            cellType = getCellType(cellElement);
            columnKey = getColumnKey(cellElement);
        }
    }
    if (columnKey != null && (cellType === 'header' || cellType === 'footer')) {
        const isHeader = cellType === 'header';
        if (columnKey !== activeStyleColumnInfo?.key || !activeStyleColumnInfo?.isHeader !== isHeader) {
            setActiveStyleColumnInfo({ key: columnKey, isHeader: cellType === 'header' });
            return;
        }
    }
    handleEndInteractionColumnHeaderFooterGesture(setActiveStyleColumnInfo, activeStyleColumnInfo);
}
/**
 * Helper function to handle the end of an interaction style gesture for the table region.
 */
function handleEndInteractionColumnHeaderFooterGesture(setInteractionStyleColumnInfo, interactionStyleColumnInfo) {
    if (interactionStyleColumnInfo != null) {
        setInteractionStyleColumnInfo(undefined);
    }
}

/**
 * Helper function to handle an 'Up' or 'Down' arrow key press.
 * Up - Moves to the same cell in the previous row (including headers and footers). No op if already on the first row.
 * Down - Moves to the same cell in the next row (including headers and footers). No op if already on the last row.
 */
function handleAdjacentRowGesture(rootElement, tableId, columnsArray, initialCell, onActiveCellChanged, isPrevious, isExtendSelectionGesture, hideTooltip, updateDeferredScrollDetail) {
    const firstColumnKey = getBoundaryColumnKey(columnsArray, true);
    if (firstColumnKey == null) {
        return;
    }
    let newCell = initialCell;
    const cellType = initialCell.type;
    if (cellType === 'noData') {
        const newColumnKey = firstColumnKey;
        if (isPrevious) {
            newCell = { columnKey: newColumnKey, type: 'header' };
            onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
        }
        else if (hasFooterCells(rootElement, tableId)) {
            newCell = { columnKey: newColumnKey, type: 'footer' };
            onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
        }
    }
    else if (cellType === 'loading') {
        if (isPrevious) {
            newCell = { columnKey: initialCell.columnKey, type: 'header' };
            onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
        }
        else if (hasFooterCells(rootElement, tableId)) {
            newCell = { columnKey: initialCell.columnKey, type: 'footer' };
            onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
        }
    }
    else if (cellType === 'loadMore') {
        if (isPrevious) {
            const rowKey = getLastFocusableRowKey(rootElement, tableId);
            if (rowKey != null) {
                newCell = { rowKey: rowKey, columnKey: initialCell.columnKey, type: 'data' };
                onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
            }
        }
        else if (hasFooterCells(rootElement, tableId)) {
            newCell = { columnKey: initialCell.columnKey, type: 'footer' };
            onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
        }
    }
    else if (cellType !== 'pending') {
        if (cellType === 'data') {
            const currentRowKey = initialCell.rowKey;
            const currentRowElement = collectionUtils.findElementByKey(rootElement, currentRowKey, `[data-oj-table-data-row='${tableId}']`);
            if (currentRowElement != null) {
                const adjacentRowElement = isPrevious
                    ? currentRowElement.previousElementSibling
                    : currentRowElement.nextElementSibling;
                // if adjacent row has no children, it is the 'buffer' row used for height sizing
                if (adjacentRowElement != null && adjacentRowElement.children.length > 0) {
                    const rowKey = getRowKey(adjacentRowElement);
                    if (rowKey != null) {
                        newCell = { rowKey: rowKey, columnKey: initialCell.columnKey, type: 'data' };
                        onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell), isExtendSelectionGesture);
                    }
                    else if (!isExtendSelectionGesture) {
                        newCell = { columnKey: initialCell.columnKey, type: 'loadMore' };
                        if (getElementFromCell(rootElement, tableId, newCell) != null) {
                            onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
                        }
                    }
                }
                else if (!isExtendSelectionGesture && isPrevious) {
                    newCell = { columnKey: initialCell.columnKey, type: 'header' };
                    onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
                }
                else if (!isExtendSelectionGesture && hasFooterCells(rootElement, tableId)) {
                    newCell = { columnKey: initialCell.columnKey, type: 'footer' };
                    onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
                }
            }
        }
        else if (cellType === 'header' && !isPrevious) {
            const rowKey = getFirstFocusableRowKey(rootElement, tableId);
            if (rowKey != null) {
                newCell = { rowKey: rowKey, columnKey: initialCell.columnKey, type: 'data' };
                onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
            }
            else if (hasNoDataCell(rootElement, tableId)) {
                newCell = { type: 'noData' };
                onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
            }
            else {
                newCell = { columnKey: initialCell.columnKey, type: 'loading' };
                if (getElementFromCell(rootElement, tableId, newCell) != null) {
                    onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
                }
                else if (hasFooterCells(rootElement, tableId)) {
                    newCell = { columnKey: initialCell.columnKey, type: 'footer' };
                    onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
                }
            }
        }
        else if (cellType === 'footer' && isPrevious) {
            if (hasNoDataCell(rootElement, tableId)) {
                newCell = { type: 'noData' };
                onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
            }
            else {
                newCell = { columnKey: initialCell.columnKey, type: 'loading' };
                if (getElementFromCell(rootElement, tableId, newCell) != null) {
                    onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
                }
                else {
                    newCell = { columnKey: initialCell.columnKey, type: 'loadMore' };
                    if (getElementFromCell(rootElement, tableId, newCell) != null) {
                        onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
                    }
                    else {
                        const rowKey = getLastFocusableRowKey(rootElement, tableId);
                        if (rowKey != null) {
                            newCell = { rowKey: rowKey, columnKey: initialCell.columnKey, type: 'data' };
                            onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
                        }
                        else {
                            newCell = { columnKey: initialCell.columnKey, type: 'header' };
                            onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
                        }
                    }
                }
            }
        }
    }
    if (!cellComparator(initialCell, newCell)) {
        hideTooltip(true);
    }
    else {
        updateDeferredScrollDetail({ cell: newCell, locationX: 'inView', locationY: 'inView' });
    }
}
/**
 * Helper function to handle a 'PageUp' or 'PageDown' arrow key press.
 * PageUp - Moves to the same cell in the first visible row in the current viewport,
 * and scrolls the Table so it becomes the last visible row in the viewport when able.
 * PageDown - Moves to the same cell in the last visible row in the current viewport,
 * and scrolls the Table so it becomes the first visible row in the viewport when able.
 */
function handlePageRowGesture(rootElement, scrollerElement, tableId, sizingInfoRef, initialCell, onActiveCellChanged, isPrevious, hideTooltip, updateDeferredScrollDetail) {
    if (initialCell.type !== 'noData' && initialCell.type !== 'pending') {
        const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);
        if (rowElements.length > 0) {
            const verticalScrollPosition = getVerticalScrollPosition(rootElement, scrollerElement, tableId);
            const verticalRowIndex = getRowIndexForRowKey(rootElement, tableId, verticalScrollPosition.rowKey);
            let targetRowIndex;
            if (isPrevious) {
                if (verticalScrollPosition.offsetY === 0) {
                    targetRowIndex = Math.max(verticalRowIndex - 1, 0);
                }
                else {
                    targetRowIndex = verticalRowIndex;
                }
            }
            else {
                const scrollerRect = scrollerElement.getBoundingClientRect();
                const scrollbarHeight = sizingInfoRef.current.boxHeight - sizingInfoRef.current.contentHeight;
                const scrollerBottom = scrollerRect.bottom + getScrollerBottomOffset(rootElement, tableId) + scrollbarHeight;
                targetRowIndex = verticalRowIndex;
                while (rowElements.length > targetRowIndex + 1) {
                    targetRowIndex += 1;
                    const elementBottom = rowElements[targetRowIndex].getBoundingClientRect().bottom;
                    if (elementBottom > scrollerBottom) {
                        break;
                    }
                }
            }
            const newRowKey = getRowKeyForRowIndex(rootElement, tableId, targetRowIndex);
            if (newRowKey != null) {
                const newCell = {
                    rowKey: newRowKey,
                    columnKey: initialCell.columnKey,
                    type: 'data'
                };
                if (newRowKey !== initialCell.rowKey) {
                    onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell), false, true);
                }
                if (!cellComparator(initialCell, newCell)) {
                    hideTooltip(true);
                }
                updateDeferredScrollDetail({
                    cell: newCell,
                    locationX: 'inView',
                    locationY: isPrevious ? 'bottom' : 'top'
                });
            }
        }
    }
}
/**
 * Helper function to get the column key next to the given column key in the specified direction. Returns
 * null if there is no adjacent column in the direction specified.
 */
function _getAdjacentColumnKey(initialKey, columnsArray, isPrevious) {
    let currentIndex = -1;
    const columnsCount = columnsArray.length;
    for (let i = 0; i < columnsCount; i++) {
        if (columnsArray[i].key === initialKey) {
            currentIndex = i;
            break;
        }
    }
    if (isPrevious && currentIndex !== 0) {
        return columnsArray[currentIndex - 1].key;
    }
    else if (!isPrevious && currentIndex !== columnsCount - 1) {
        return columnsArray[currentIndex + 1].key;
    }
    return undefined;
}
/**
 * Helper function to handle a 'Previous' or 'Next' arrow key press.
 * Previous - Moves to the previous cell in the current row. No op if already on the first cell in that row.
 * Next - Moves to the next cell in the current row. No op if already on the last cell in that row.
 */
function handleAdjacentColumnGesture(rootElement, tableId, columnsArray, initialCell, onActiveCellChanged, isPrevious, hideTooltip, updateDeferredScrollDetail) {
    let newCell = initialCell;
    const cellType = initialCell.type;
    if (cellType === 'data' || cellType === 'header' || cellType === 'footer') {
        const initialKey = initialCell.columnKey;
        const newKey = _getAdjacentColumnKey(initialKey, columnsArray, isPrevious);
        if (newKey != null) {
            if (cellType === 'data') {
                newCell = { rowKey: initialCell.rowKey, columnKey: newKey, type: cellType };
                onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
            }
            else {
                newCell = { columnKey: newKey, type: cellType };
                onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
            }
        }
    }
    if (!cellComparator(initialCell, newCell)) {
        hideTooltip(true);
    }
    else {
        updateDeferredScrollDetail({ cell: newCell, locationX: 'inView', locationY: 'inView' });
    }
}
/**
 * Helper function to handle a 'Home' or 'End' key press.
 * Home - Jumps to the first cell in the current row. No op if already on the first cell in that row.
 * Ctrl/Cmd + Home - Jumps to the first cell in the first data row. If no data rows are present,
 * jumps to the first cell in the current region (header or footer). No op if already on that cell.
 * End - Jumps to the last cell in the current row. No op if already on the last cell in that row.
 * Ctrl/Cmd + End - Jumps to the last cell in the last data row. If no data rows are present,
 * jumps to the last cell in the current region (header or footer). No op if already on that cell.
 */
function handleJumpColumnGesture(rootElement, tableId, columnsArray, initialCell, onActiveCellChanged, isPrevious, includeRows, hideTooltip, updateDeferredScrollDetail) {
    const newKey = getBoundaryColumnKey(columnsArray, isPrevious);
    if (newKey == null) {
        return;
    }
    let newCell = initialCell;
    const cellType = initialCell.type;
    if (cellType === 'data' || cellType === 'header' || cellType === 'footer') {
        const initialKey = initialCell.columnKey;
        if (includeRows) {
            if (hasNoDataCell(rootElement, tableId)) {
                newCell = { type: 'noData' };
                onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
            }
            else {
                const newRowKey = isPrevious
                    ? getFirstFocusableRowKey(rootElement, tableId)
                    : getLastFocusableRowKey(rootElement, tableId);
                if (newRowKey != null) {
                    newCell = { rowKey: newRowKey, columnKey: newKey, type: 'data' };
                    onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
                }
            }
        }
        else if (newKey !== initialKey) {
            if (cellType === 'data') {
                newCell = { rowKey: initialCell.rowKey, columnKey: newKey, type: cellType };
                onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
            }
            else {
                newCell = { columnKey: newKey, type: cellType };
                onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));
            }
        }
    }
    if (!cellComparator(initialCell, newCell)) {
        hideTooltip(true);
    }
    else {
        updateDeferredScrollDetail({ cell: newCell, locationX: 'inView', locationY: 'inView' });
    }
}

/**
 * Helper function to handle a selection gesture (click, spacebar, etc...)
 */
function handleSelectionGesture(rootElement, tableId, columnsArray, targetElement, isModifierKey, onSelectionChange, isDropDownSelection, selectionMode, selected) {
    const emptyKeys = { all: false, keys: new Set() };
    let selectedRows = selected?.row != null ? selected.row : emptyKeys;
    let selectedColumns = selected?.column != null ? selected.column : emptyKeys;
    const newRowKey = collectionUtils.keyExtractor(targetElement, `[data-oj-table-data-row='${tableId}']`);
    if (newRowKey != null) {
        if (selectionMode?.row === 'single' ||
            selectionMode?.row === 'multiple' ||
            selectionMode?.row === 'multipleToggle') {
            const isToggleSelectionMode = isDropDownSelection || selectionMode.row === 'multipleToggle';
            const isMultiSelectRowGesture = isModifierKey || isToggleSelectionMode;
            if (selectedRows == null) {
                selectedRows = { all: false, keys: new Set([newRowKey]) };
            }
            else if (!keys.containsKey(selectedRows, newRowKey)) {
                if (isMultiSelectRowGesture && selectionMode.row !== 'single') {
                    selectedRows = keys.addKey(selectedRows, newRowKey);
                }
                else {
                    selectedRows = { all: false, keys: new Set([newRowKey]) };
                }
            }
            else if (isMultiSelectRowGesture) {
                selectedRows = keys.removeKey(selectedRows, newRowKey, false);
            }
            else {
                selectedRows = { all: false, keys: new Set([newRowKey]) };
            }
            selectedColumns = emptyKeys;
        }
    }
    else if (selectionMode?.column === 'single' || selectionMode?.column === 'multiple') {
        const cellElement = targetElement.closest(`[data-oj-table-focusable='${tableId}']`);
        if (cellElement != null) {
            const cellType = getCellType(cellElement);
            if (cellType === 'header' || cellType === 'footer') {
                const index = getColumnIndexForHeaderFooterElement(rootElement, tableId, cellElement, cellType === 'header');
                if (index != null) {
                    const column = columnsArray[index];
                    if (column.value.selectable !== 'disabled') {
                        if (selectedColumns == null) {
                            selectedColumns = { all: false, keys: new Set([column.key]) };
                        }
                        else if (!keys.containsKey(selectedColumns, column.key)) {
                            if (isModifierKey && selectionMode.column === 'multiple') {
                                selectedColumns = keys.addKey(selectedColumns, column.key);
                            }
                            else {
                                selectedColumns = { all: false, keys: new Set([column.key]) };
                            }
                        }
                        else if (isModifierKey) {
                            selectedColumns = keys.removeKey(selectedColumns, column.key, false);
                        }
                        else {
                            selectedColumns = { all: false, keys: new Set([column.key]) };
                        }
                        selectedRows = emptyKeys;
                    }
                }
            }
        }
    }
    if (!keys.isSameKey(selectedRows, selected?.row) || !keys.isSameKey(selectedColumns, selected?.column)) {
        onSelectionChange({ value: { row: selectedRows, column: selectedColumns }, target: targetElement }, false);
    }
}
/**
 * Helper function to calculate and apply a new selection state corresponding to the range provided
 */
function _applyRangeSelection(rootElement, tableId, columnsArray, targetElement, startIndex, endIndex, isRowGesture, onSelectionChange, isDropDownSelection, selectionMode, selected, previousEndIndex) {
    const emptyKeys = { all: false, keys: new Set() };
    let selectedRows = selected?.row != null ? selected.row : emptyKeys;
    let selectedColumns = selected?.column != null ? selected.column : emptyKeys;
    if (isRowGesture) {
        selectedColumns = emptyKeys;
        if (selectionMode?.row === 'multiple' || selectionMode?.row === 'multipleToggle') {
            const isToggleSelectionMode = isDropDownSelection || selectionMode.row === 'multipleToggle';
            selectedRows = isToggleSelectionMode ? selectedRows : emptyKeys;
            // selected rows should be added in the order that they are selected
            if (startIndex <= endIndex) {
                for (let i = startIndex; i <= endIndex; i++) {
                    const key = getRowKeyForRowIndex(rootElement, tableId, i);
                    selectedRows = keys.addKey(selectedRows, key);
                }
                // toggle selection gesture is additive except for rows added from previous gesture
                if (isToggleSelectionMode && previousEndIndex != null) {
                    if (previousEndIndex > endIndex) {
                        for (let i = previousEndIndex; i > endIndex; i--) {
                            const key = getRowKeyForRowIndex(rootElement, tableId, i);
                            selectedRows = keys.removeKey(selectedRows, key, false);
                        }
                    }
                    else if (previousEndIndex < startIndex) {
                        for (let i = previousEndIndex; i < startIndex; i++) {
                            const key = getRowKeyForRowIndex(rootElement, tableId, i);
                            selectedRows = keys.removeKey(selectedRows, key, false);
                        }
                    }
                }
            }
            else {
                for (let i = startIndex; i >= endIndex; i--) {
                    const key = getRowKeyForRowIndex(rootElement, tableId, i);
                    selectedRows = keys.addKey(selectedRows, key);
                }
                // toggle selection gesture is additive except for rows added from previous gesture
                if (isToggleSelectionMode && previousEndIndex != null) {
                    if (previousEndIndex < endIndex) {
                        for (let i = previousEndIndex; i < endIndex; i++) {
                            const key = getRowKeyForRowIndex(rootElement, tableId, i);
                            selectedRows = keys.removeKey(selectedRows, key, false);
                        }
                    }
                    else if (previousEndIndex > startIndex) {
                        for (let i = previousEndIndex; i > startIndex; i--) {
                            const key = getRowKeyForRowIndex(rootElement, tableId, i);
                            selectedRows = keys.removeKey(selectedRows, key, false);
                        }
                    }
                }
            }
        }
    }
    else {
        selectedRows = emptyKeys;
        if (selectionMode?.column === 'multiple') {
            selectedColumns = emptyKeys;
            // selected columns should be added in the order that they are selected
            if (startIndex <= endIndex) {
                for (let i = startIndex; i <= endIndex; i++) {
                    const column = columnsArray[i];
                    if (column.value.selectable !== 'disabled') {
                        selectedColumns = keys.addKey(selectedColumns, column.key);
                    }
                }
            }
            else {
                for (let i = startIndex; i >= endIndex; i--) {
                    const column = columnsArray[i];
                    if (column.value.selectable !== 'disabled') {
                        selectedColumns = keys.addKey(selectedColumns, column.key);
                    }
                }
            }
        }
    }
    if (!keys.isSameKey(selectedRows, selected?.row) || !keys.isSameKey(selectedColumns, selected?.column)) {
        onSelectionChange({ value: { row: selectedRows, column: selectedColumns }, target: targetElement }, true);
    }
}
/**
 * Determines whether a potential range selection gesture is valid based on the given target
 */
function isRangeSelectionGesture(rootElement, tableId, columnsArray, targetElement, activeCell, selectionMode) {
    const targetCell = logicalCellExtractor(targetElement, tableId, columnsArray);
    if ((((selectionMode?.row === 'multiple' || selectionMode?.row === 'multipleToggle') &&
        activeCell.type === 'data') ||
        (selectionMode?.column === 'multiple' &&
            (activeCell.type === 'header' || activeCell.type === 'footer'))) &&
        targetCell?.type === activeCell.type) {
        const activeCellElement = getElementFromCell(rootElement, tableId, activeCell);
        const targetCellElement = getElementFromCell(rootElement, tableId, targetCell);
        if (activeCellElement != null && targetCellElement != null) {
            const isRow = targetCell.type === 'data';
            if (isRow) {
                return (getRowIndexForRowElement(rootElement, tableId, activeCellElement.parentElement) != null &&
                    getRowIndexForRowElement(rootElement, tableId, targetCellElement.parentElement) != null);
            }
            else if (targetCell.type === 'header' || targetCell.type === 'footer') {
                const isHeader = targetCell.type === 'header';
                return (getColumnIndexForHeaderFooterElement(rootElement, tableId, activeCellElement, isHeader) !=
                    null &&
                    getColumnIndexForHeaderFooterElement(rootElement, tableId, targetCellElement, isHeader) !=
                        null);
            }
        }
    }
    return false;
}
/**
 * Helper function to handle a range selection gesture (shift+click)
 */
function handleRangeSelectionGesture(rootElement, tableId, columnsArray, targetElement, activeCell, onActiveCellChanged, selectionExtensionElementRef, onSelectionChange, isDropDownSelection, selectionMode, selected) {
    const targetCell = logicalCellExtractor(targetElement, tableId, columnsArray);
    if (targetCell != null) {
        const activeCellElement = getElementFromCell(rootElement, tableId, activeCell);
        const targetCellElement = getElementFromCell(rootElement, tableId, targetCell);
        if (activeCellElement != null && targetCellElement != null) {
            if ((((selectionMode?.row === 'multiple' || selectionMode?.row === 'multipleToggle') &&
                targetCell.type === 'data') ||
                (selectionMode?.column === 'multiple' &&
                    (targetCell.type === 'header' || targetCell.type === 'footer'))) &&
                targetCell.type === activeCell.type) {
                let startIndex;
                let endIndex;
                let previousEndIndex;
                let endElement;
                const isToggleSelectionMode = isDropDownSelection || selectionMode.row === 'multipleToggle';
                const isRow = targetCell.type === 'data';
                if (isRow) {
                    endElement = targetCellElement.parentElement;
                    const startElement = isToggleSelectionMode && selectionExtensionElementRef.current != null
                        ? selectionExtensionElementRef.current
                        : activeCellElement.parentElement;
                    startIndex = getRowIndexForRowElement(rootElement, tableId, startElement);
                    endIndex = getRowIndexForRowElement(rootElement, tableId, endElement);
                    const previousElement = isToggleSelectionMode
                        ? activeCellElement.parentElement
                        : selectionExtensionElementRef.current;
                    if (previousElement != null) {
                        previousEndIndex = getRowIndexForRowElement(rootElement, tableId, previousElement);
                    }
                }
                else if (targetCell.type === 'header' || targetCell.type === 'footer') {
                    const isHeader = targetCell.type === 'header';
                    endElement = targetCellElement;
                    startIndex = getColumnIndexForHeaderFooterElement(rootElement, tableId, activeCellElement, isHeader);
                    endIndex = getColumnIndexForHeaderFooterElement(rootElement, tableId, targetCellElement, isHeader);
                }
                if (startIndex != null && endIndex != null) {
                    if (!isRow || !isToggleSelectionMode) {
                        selectionExtensionElementRef.current = endElement;
                    }
                    else {
                        if (selectionExtensionElementRef.current == null) {
                            selectionExtensionElementRef.current = activeCellElement.parentElement;
                        }
                        onActiveCellChanged({ value: targetCell }, false, true);
                        targetCellElement.focus({ preventScroll: true });
                    }
                    _applyRangeSelection(rootElement, tableId, columnsArray, targetElement, startIndex, endIndex, isRow, onSelectionChange, isDropDownSelection, selectionMode, selected, previousEndIndex);
                    return true;
                }
            }
        }
    }
    return false;
}
/**
 * Helper function to handle a selection extension gesture (shift+arrow key)
 */
function handleExtendSelectionGesture(rootElement, tableId, columnsArray, targetElement, isPrevious, activeCell, selectionExtensionElementRef, onSelectionChange, isDropDownSelection, updateDeferredScrollDetail, selectionMode, selected) {
    const activeCellElement = getElementFromCell(rootElement, tableId, activeCell);
    if (activeCellElement != null) {
        let startIndex;
        let startElement;
        const isToggleSelectionMode = isDropDownSelection || selectionMode?.row === 'multipleToggle';
        const isRow = activeCell.type === 'data';
        const isHeader = activeCell.type === 'header';
        if (isRow) {
            startElement =
                isToggleSelectionMode && selectionExtensionElementRef.current != null
                    ? selectionExtensionElementRef.current
                    : activeCellElement.parentElement;
            startIndex = getRowIndexForRowElement(rootElement, tableId, startElement);
        }
        else {
            startElement = activeCellElement;
            startIndex = getColumnIndexForHeaderFooterElement(rootElement, tableId, startElement, isHeader);
        }
        if (startIndex != null) {
            let endIndex;
            let previousEndIndex;
            let extendedElement;
            const cursorElement = isToggleSelectionMode && isRow
                ? activeCellElement.parentElement
                : selectionExtensionElementRef.current;
            if (cursorElement != null) {
                previousEndIndex = isRow
                    ? getRowIndexForRowElement(rootElement, tableId, cursorElement)
                    : getColumnIndexForHeaderFooterElement(rootElement, tableId, cursorElement, isHeader);
                extendedElement = isPrevious
                    ? cursorElement.previousElementSibling
                    : cursorElement.nextElementSibling;
                if (extendedElement != null && (!isRow || (isRow && getRowKey(extendedElement) != null))) {
                    if (!isToggleSelectionMode || !isRow) {
                        selectionExtensionElementRef.current = extendedElement;
                    }
                    else if (selectionExtensionElementRef.current == null) {
                        selectionExtensionElementRef.current = activeCellElement.parentElement;
                    }
                    endIndex = isRow
                        ? getRowIndexForRowElement(rootElement, tableId, extendedElement)
                        : getColumnIndexForHeaderFooterElement(rootElement, tableId, extendedElement, isHeader);
                }
                else {
                    endIndex = isRow
                        ? getRowIndexForRowElement(rootElement, tableId, cursorElement)
                        : getColumnIndexForHeaderFooterElement(rootElement, tableId, cursorElement, isHeader);
                }
            }
            else {
                extendedElement = isPrevious
                    ? startElement.previousElementSibling
                    : startElement.nextElementSibling;
                if (extendedElement != null && (!isRow || (isRow && getRowKey(extendedElement) != null))) {
                    selectionExtensionElementRef.current = extendedElement;
                    endIndex = isRow
                        ? getRowIndexForRowElement(rootElement, tableId, extendedElement)
                        : getColumnIndexForHeaderFooterElement(rootElement, tableId, extendedElement, isHeader);
                }
                else {
                    endIndex = startIndex;
                }
            }
            if (endIndex != null) {
                _applyRangeSelection(rootElement, tableId, columnsArray, targetElement, startIndex, endIndex, isRow, onSelectionChange, isDropDownSelection, selectionMode, selected, previousEndIndex);
            }
            // scroll 'extensionElement' into view if focus is not shifted
            if (!isRow || !isToggleSelectionMode) {
                const extensionElement = selectionExtensionElementRef.current != null
                    ? selectionExtensionElementRef.current
                    : activeCellElement;
                let extensionCell;
                if (isRow) {
                    const rowKey = collectionUtils.keyExtractor(extensionElement, `[data-oj-table-data-row='${tableId}']`);
                    if (rowKey != null) {
                        extensionCell = {
                            type: activeCell.type,
                            rowKey: rowKey,
                            columnKey: activeCell.columnKey
                        };
                    }
                }
                else {
                    extensionCell = logicalCellExtractor(extensionElement, tableId, columnsArray);
                }
                if (extensionCell != null) {
                    updateDeferredScrollDetail({
                        cell: extensionCell,
                        locationX: 'inView',
                        locationY: 'inView'
                    });
                }
            }
        }
    }
}

/**
 * Hook that manages keyboard interactions on the Preact Table
 */
function useKeyboardHandling({ rootRef, viewportInfo, tableId, tableData, isRtl, isTabbableMode, columnsArray, sizingInfoRef, selectionExtensionElementRef, activeCell, onActiveCellChanged, isDropDownSelection, selectionMode, selected, onTableSelectionChange, activeStyleColumnInfo, setActiveStyleColumnInfo, onRowAction, sortCriterion, onSortCriterionChange, hideTooltip, updateDeferredScrollDetail }) {
    // Keydown handler for the outer Table. This handles all internal
    // keyboard navigation for the Table.
    const _keyDownHandler = hooks.useCallback((event) => {
        const rootElement = rootRef.current;
        const scrollerElement = viewportInfo.viewportConfig.scroller().current;
        if (rootElement != null && scrollerElement != null) {
            const platform = clientHints.getClientHints().platform;
            const keyHandlers = {
                ' ': function () {
                    if (activeCell != null) {
                        if (!isTabbableMode) {
                            handleActiveColumnHeaderFooterGesture(tableId, event, setActiveStyleColumnInfo, activeStyleColumnInfo, activeCell);
                            if (onTableSelectionChange != null && !event.repeat) {
                                handleSelectionGesture(rootElement, tableId, columnsArray, getElementFromCell(rootElement, tableId, activeCell), true, onTableSelectionChange, isDropDownSelection, selectionMode, selected);
                            }
                            event.preventDefault();
                        }
                        if (onRowAction != null &&
                            !event.repeat &&
                            handleRowActionGesture(rootElement, tableId, tableData, onRowAction, event.target, activeCell)) {
                            event.stopPropagation();
                        }
                    }
                },
                Enter: function () {
                    if (activeCell != null) {
                        if (activeCell.type === 'data') {
                            if (isDropDownSelection && !isTabbableMode) {
                                if (onTableSelectionChange != null && !event.repeat) {
                                    handleSelectionGesture(rootElement, tableId, columnsArray, getElementFromCell(rootElement, tableId, activeCell), true, onTableSelectionChange, isDropDownSelection, selectionMode, selected);
                                }
                                event.preventDefault();
                            }
                            if (onRowAction != null &&
                                !event.repeat &&
                                handleRowActionGesture(rootElement, tableId, tableData, onRowAction, event.target, activeCell)) {
                                event.stopPropagation();
                            }
                        }
                        else if (activeCell.type === 'header' &&
                            !isTabbableMode &&
                            !event.repeat &&
                            onSortCriterionChange != null &&
                            handleSortActionGesture(columnsArray, activeCell.columnKey, onSortCriterionChange, sortCriterion)) {
                            event.stopPropagation();
                        }
                    }
                },
                ArrowUp: function () {
                    if (activeCell != null &&
                        (!isTabbableMode || isAutoFocusCell(rootElement, tableId, activeCell))) {
                        let isExtendSelectionGesture = false;
                        if (!isTabbableMode &&
                            activeCell.type === 'data' &&
                            event.shiftKey &&
                            onTableSelectionChange != null &&
                            (selectionMode?.row === 'multiple' || selectionMode?.row === 'multipleToggle')) {
                            handleExtendSelectionGesture(rootElement, tableId, columnsArray, rootElement, true, activeCell, selectionExtensionElementRef, onTableSelectionChange, isDropDownSelection, updateDeferredScrollDetail, selectionMode, selected);
                            isExtendSelectionGesture = true;
                        }
                        if (!isExtendSelectionGesture ||
                            isDropDownSelection ||
                            selectionMode?.row === 'multipleToggle') {
                            handleAdjacentRowGesture(rootElement, tableId, columnsArray, activeCell, onActiveCellChanged, true, isExtendSelectionGesture, hideTooltip, updateDeferredScrollDetail);
                        }
                        event.preventDefault();
                    }
                },
                ArrowDown: function () {
                    if (activeCell != null &&
                        (!isTabbableMode || isAutoFocusCell(rootElement, tableId, activeCell))) {
                        let isExtendSelectionGesture = false;
                        if (!isTabbableMode &&
                            activeCell.type === 'data' &&
                            event.shiftKey &&
                            onTableSelectionChange != null &&
                            (selectionMode?.row === 'multiple' || selectionMode?.row === 'multipleToggle')) {
                            handleExtendSelectionGesture(rootElement, tableId, columnsArray, rootElement, false, activeCell, selectionExtensionElementRef, onTableSelectionChange, isDropDownSelection, updateDeferredScrollDetail, selectionMode, selected);
                            isExtendSelectionGesture = true;
                        }
                        if (!isExtendSelectionGesture ||
                            isDropDownSelection ||
                            selectionMode?.row === 'multipleToggle') {
                            handleAdjacentRowGesture(rootElement, tableId, columnsArray, activeCell, onActiveCellChanged, false, isExtendSelectionGesture, hideTooltip, updateDeferredScrollDetail);
                        }
                        event.preventDefault();
                    }
                },
                ArrowLeft: function () {
                    if (activeCell != null &&
                        (!isTabbableMode || isAutoFocusCell(rootElement, tableId, activeCell))) {
                        if (!isTabbableMode &&
                            (activeCell.type === 'header' || activeCell.type === 'footer') &&
                            event.shiftKey &&
                            onTableSelectionChange != null &&
                            selectionMode?.column === 'multiple') {
                            handleExtendSelectionGesture(rootElement, tableId, columnsArray, rootElement, true, activeCell, selectionExtensionElementRef, onTableSelectionChange, isDropDownSelection, updateDeferredScrollDetail, selectionMode, selected);
                        }
                        else {
                            handleAdjacentColumnGesture(rootElement, tableId, columnsArray, activeCell, onActiveCellChanged, !isRtl, hideTooltip, updateDeferredScrollDetail);
                        }
                        event.preventDefault();
                    }
                },
                ArrowRight: function () {
                    if (activeCell != null &&
                        (!isTabbableMode || isAutoFocusCell(rootElement, tableId, activeCell))) {
                        if (!isTabbableMode &&
                            (activeCell.type === 'header' || activeCell.type === 'footer') &&
                            event.shiftKey &&
                            onTableSelectionChange != null &&
                            selectionMode?.column === 'multiple') {
                            handleExtendSelectionGesture(rootElement, tableId, columnsArray, rootElement, false, activeCell, selectionExtensionElementRef, onTableSelectionChange, isDropDownSelection, updateDeferredScrollDetail, selectionMode, selected);
                        }
                        else {
                            handleAdjacentColumnGesture(rootElement, tableId, columnsArray, activeCell, onActiveCellChanged, isRtl, hideTooltip, updateDeferredScrollDetail);
                        }
                        event.preventDefault();
                    }
                },
                PageUp: function () {
                    if (activeCell != null &&
                        (!isTabbableMode || isAutoFocusCell(rootElement, tableId, activeCell))) {
                        handlePageRowGesture(rootElement, scrollerElement, tableId, sizingInfoRef, activeCell, onActiveCellChanged, true, hideTooltip, updateDeferredScrollDetail);
                        event.preventDefault();
                    }
                },
                PageDown: function () {
                    if (activeCell != null &&
                        (!isTabbableMode || isAutoFocusCell(rootElement, tableId, activeCell))) {
                        handlePageRowGesture(rootElement, scrollerElement, tableId, sizingInfoRef, activeCell, onActiveCellChanged, false, hideTooltip, updateDeferredScrollDetail);
                        event.preventDefault();
                    }
                },
                Home: function () {
                    if (activeCell != null &&
                        (!isTabbableMode || isAutoFocusCell(rootElement, tableId, activeCell))) {
                        handleJumpColumnGesture(rootElement, tableId, columnsArray, activeCell, onActiveCellChanged, true, platform === 'mac' ? event.metaKey : event.ctrlKey, hideTooltip, updateDeferredScrollDetail);
                        event.preventDefault();
                    }
                },
                End: function () {
                    if (activeCell != null &&
                        (!isTabbableMode || isAutoFocusCell(rootElement, tableId, activeCell))) {
                        handleJumpColumnGesture(rootElement, tableId, columnsArray, activeCell, onActiveCellChanged, false, platform === 'mac' ? event.metaKey : event.ctrlKey, hideTooltip, updateDeferredScrollDetail);
                        event.preventDefault();
                    }
                }
            };
            if (Object.keys(keyHandlers).includes(event.key)) {
                keyHandlers[event.key]();
            }
        }
    }, [
        rootRef,
        viewportInfo,
        tableId,
        tableData,
        isRtl,
        isTabbableMode,
        columnsArray,
        sizingInfoRef,
        selectionExtensionElementRef,
        activeCell,
        onActiveCellChanged,
        isDropDownSelection,
        selectionMode,
        selected,
        onTableSelectionChange,
        activeStyleColumnInfo,
        setActiveStyleColumnInfo,
        onRowAction,
        sortCriterion,
        onSortCriterionChange,
        hideTooltip,
        updateDeferredScrollDetail
    ]);
    // Keyup handler for the outer Table.
    const _keyUpHandler = hooks.useCallback((event) => {
        const keyHandlers = {
            ' ': function () {
                if (activeCell != null) {
                    handleEndInteractionColumnHeaderFooterGesture(setActiveStyleColumnInfo, activeStyleColumnInfo);
                }
            }
        };
        if (Object.keys(keyHandlers).includes(event.key)) {
            keyHandlers[event.key]();
        }
    }, [activeCell, activeStyleColumnInfo, setActiveStyleColumnInfo]);
    return { onKeyDown: _keyDownHandler, onKeyUp: _keyUpHandler };
}

/**
 * Helper function to handle a hover over a resizable column region gesture.
 */
function handleOverResizeRegionGesture(rootElement, tableId, event, columnsArray, resizeInfoRef, isRtl) {
    // handle hover feedback around potentially resizable columns
    _updateResizingState(rootElement, tableId, event, columnsArray, resizeInfoRef, isRtl);
}
/**
 * Helper function to handle a column resize start gesture (pointer down).
 */
function handleColumnResizeStartGesture(rootElement, scrollerElement, tableId, event, columnsArray, appliedColumnWidths, resizeInfoRef, isRtl, hideTooltip, onColumnResizing) {
    if (resizeInfoRef.current.key == null) {
        _updateResizingState(rootElement, tableId, event, columnsArray, resizeInfoRef, isRtl);
    }
    if (resizeInfoRef.current.key != null) {
        const rect = scrollerElement.getBoundingClientRect();
        const pointerX = isRtl ? rect.right - event.clientX : event.clientX - rect.left;
        resizeInfoRef.current = {
            isResizing: true,
            isResizeHover: true,
            key: resizeInfoRef.current.key,
            startX: pointerX,
            delta: 0,
            ignoreClick: resizeInfoRef.current.ignoreClick
        };
        if (onColumnResizing != null) {
            onColumnResizing({
                key: resizeInfoRef.current.key,
                delta: 0,
                allColumnWidths: appliedColumnWidths.netColumnWidths,
                paddingWidth: appliedColumnWidths.totalBorderOffset
            });
        }
        hideTooltip(true);
        return true;
    }
    return false;
}
/**
 * Helper function to ensure the resizing state is updated based on the latest pointer event.
 */
function _updateResizingState(rootElement, tableId, event, columnsArray, resizeInfoRef, isRtl) {
    const headerRowElement = rootElement.querySelector(`[data-oj-table-header-row='${tableId}']`);
    if (headerRowElement != null) {
        const headerElements = headerRowElement.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);
        if (collectionUtils.getElementContainsFunc(headerRowElement)(event.target)) {
            let isResizeHover = false;
            for (let i = 0; i < headerElements.length; i++) {
                const headerElement = headerElements[i];
                const cellRect = headerElement.getBoundingClientRect();
                const endEdge = isRtl ? cellRect.left : cellRect.right;
                if (Math.abs(endEdge - event.pageX) <= 8) {
                    if (columnsArray[i].value.edgeResizable !== 'enabled') {
                        break;
                    }
                    // resize operation on end side of header cell
                    resizeInfoRef.current.key = columnsArray[i].key;
                    headerRowElement.style.cursor = 'col-resize';
                    isResizeHover = true;
                    resizeInfoRef.current.isResizeHover = true;
                }
            }
            if (!isResizeHover) {
                headerRowElement.style.cursor = '';
                resizeInfoRef.current.key = undefined;
                resizeInfoRef.current.isResizeHover = false;
            }
        }
        else {
            if (headerRowElement != null) {
                headerRowElement.style.cursor = '';
            }
            resizeInfoRef.current.key = undefined;
            resizeInfoRef.current.isResizeHover = false;
        }
    }
}
/**
 * Helper function to handle a pointer move gesture during a column resize.
 */
function handleColumnResizingGesture(scrollerElement, event, appliedColumnWidths, resizeInfoRef, isRtl, onColumnResizing) {
    if (resizeInfoRef.current.isResizing) {
        const rect = scrollerElement.getBoundingClientRect();
        const currentX = isRtl ? rect.right - event.clientX : event.clientX - rect.left;
        resizeInfoRef.current.delta = currentX - resizeInfoRef.current.startX;
        // handle resize move operation
        if (onColumnResizing != null) {
            onColumnResizing({
                key: resizeInfoRef.current.key,
                delta: resizeInfoRef.current.delta,
                allColumnWidths: appliedColumnWidths.netColumnWidths,
                paddingWidth: appliedColumnWidths.totalBorderOffset
            });
        }
    }
}
/**
 * Helper function to handle a column resize end gesture (pointer up).
 */
function handleColumnResizeEndGesture(scrollerElement, event, appliedColumnWidths, resizeInfoRef, isRtl, onColumnResize) {
    if (resizeInfoRef.current.isResizing) {
        if (onColumnResize != null) {
            const rect = scrollerElement.getBoundingClientRect();
            const currentX = isRtl ? rect.right - event.clientX : event.clientX - rect.left;
            resizeInfoRef.current.delta = currentX - resizeInfoRef.current.startX;
            onColumnResize({
                key: resizeInfoRef.current.key,
                delta: resizeInfoRef.current.delta,
                allColumnWidths: appliedColumnWidths.netColumnWidths,
                paddingWidth: appliedColumnWidths.totalBorderOffset,
                gesture: 'pointer',
                type: 'delta'
            });
        }
    }
    resizeInfoRef.current = {
        isResizing: false,
        isResizeHover: resizeInfoRef.current.isResizeHover,
        ignoreClick: resizeInfoRef.current.ignoreClick
    };
}
/**
 * Helper function to handle the pointer leaving the entire Table when previously hovering
 * over a column resize region.
 */
function handleLeaveResizingGesture(rootElement, tableId, resizeInfoRef) {
    if (!resizeInfoRef.current.isResizing) {
        const headerRowElement = rootElement.querySelector(`[data-oj-table-header-row='${tableId}']`);
        if (headerRowElement != null) {
            headerRowElement.style.cursor = '';
        }
        resizeInfoRef.current.isResizeHover = false;
    }
}
/**
 * Helper function to handle a pointer entering the Table when it was previously handling
 * a column resize gesture.
 */
function handleEnterResizingGesture(scrollerElement, event, appliedColumnWidths, resizeInfoRef, isRtl, onColumnResize) {
    // handle case where user was resizing, moved pointer out of the Table,
    // released the button, and has now entered the table once again
    if (resizeInfoRef.current.isResizing && event.buttons === 0) {
        handleColumnResizeEndGesture(scrollerElement, event, appliedColumnWidths, resizeInfoRef, isRtl, onColumnResize);
    }
}

/**
 * Hook that manages pointer interactions on the Preact Table
 */
function usePointerHandling({ rootRef, viewportInfo, tableId, tableData, isRtl, columnsArray, appliedColumnWidths, resizeInfoRef, selectionExtensionElementRef, onColumnResizing, onColumnResize, activeCell, onActiveCellChanged, isDropDownSelection, selectionMode, selected, onTableSelectionChange, activeStyleColumnInfo, setActiveStyleColumnInfo, onRowAction, showTooltip, hideTooltip, tooltipId }) {
    // tracks whether the most recent 'pointerdown' event was due to a touch gesture
    const selectionTouchRef = hooks.useRef(false);
    // tracks the column key for any header or footer being hovered over
    const [hoverStyleColumnInfo, setHoverStyleColumnInfo] = hooks.useState();
    // tracks the current 'pointer over' element for comparison during 'click' event handling to
    // prevent screen readers from triggering undesired selection gestures from simulated events
    const pointerInfoRef = hooks.useRef();
    // Pointer move handler for the outer Table.
    const _pointerMoveHandler = hooks.useCallback((event) => {
        const rootElement = rootRef.current;
        const scrollerElement = viewportInfo.viewportConfig.scroller().current;
        if (rootElement != null) {
            pointerInfoRef.current = { target: event.target, x: event.clientX, y: event.clientY };
            handleMoveTooltipGesture(tableId, columnsArray, event, showTooltip, hideTooltip, tooltipId);
            if (onColumnResizing != null) {
                if (!resizeInfoRef.current.isResizing) {
                    handleOverResizeRegionGesture(rootElement, tableId, event, columnsArray, resizeInfoRef, isRtl);
                }
                else if (scrollerElement != null && appliedColumnWidths != null) {
                    handleColumnResizingGesture(scrollerElement, event, appliedColumnWidths, resizeInfoRef, isRtl, onColumnResizing);
                }
            }
        }
    }, [
        rootRef,
        viewportInfo,
        tableId,
        columnsArray,
        appliedColumnWidths,
        resizeInfoRef,
        isRtl,
        onColumnResizing,
        showTooltip,
        hideTooltip,
        tooltipId
    ]);
    // Pointer over handler for the outer Table.
    const _pointerOverHandler = hooks.useCallback((event) => {
        const rootElement = rootRef.current;
        if (rootElement != null) {
            pointerInfoRef.current = { target: event.target, x: event.clientX, y: event.clientY };
            handleOverColumnHeaderFooterGesture(tableId, event, setHoverStyleColumnInfo, hoverStyleColumnInfo);
        }
    }, [rootRef, tableId, hoverStyleColumnInfo]);
    // Pointer down handler for the outer Table. It ensures the area targeted is 'current'.
    // NOTE - This event handling is triggered prior to 'onFocus' handling and ensures the
    // 'pending current' area is set when an initial pointer interaction focuses the Table.
    const _pointerDownHandler = hooks.useCallback((event) => {
        handleActiveColumnHeaderFooterGesture(tableId, event, setActiveStyleColumnInfo, activeStyleColumnInfo);
        const rootElement = rootRef.current;
        const scrollerElement = viewportInfo.viewportConfig.scroller().current;
        if (rootElement != null) {
            selectionTouchRef.current = event.pointerType === 'touch';
            const targetElement = event.target;
            if (onTableSelectionChange != null &&
                activeCell != null &&
                event.shiftKey &&
                isRangeSelectionGesture(rootElement, tableId, columnsArray, targetElement, activeCell, selectionMode)) {
                // prevent focus change on selection extension gesture
                if (!textSelectionUtils.getIsSelectionPending()) {
                    event.preventDefault();
                }
            }
            else if (scrollerElement != null &&
                appliedColumnWidths != null &&
                handleColumnResizeStartGesture(rootElement, scrollerElement, tableId, event, columnsArray, appliedColumnWidths, resizeInfoRef, isRtl, hideTooltip, onColumnResizing)) {
                // prevent focus change on column resize gesture
                event.preventDefault();
                resizeInfoRef.current.ignoreClick = true;
            }
            else if (logicalCellExtractor(targetElement, tableId, columnsArray) == null) {
                // prevent focus shift when interacting with 'non-focusable' regions (ie - scrollbar)
                event.preventDefault();
            }
        }
    }, [
        rootRef,
        viewportInfo,
        tableId,
        columnsArray,
        appliedColumnWidths,
        resizeInfoRef,
        activeStyleColumnInfo,
        setActiveStyleColumnInfo,
        isRtl,
        hideTooltip,
        activeCell,
        selectionMode,
        onTableSelectionChange,
        onColumnResizing
    ]);
    // Pointer up handler for the outer Table.
    const _pointerUpHandler = hooks.useCallback((event) => {
        handleEndInteractionColumnHeaderFooterGesture(setActiveStyleColumnInfo, activeStyleColumnInfo);
        const scrollerElement = viewportInfo.viewportConfig.scroller().current;
        if (scrollerElement != null && appliedColumnWidths != null) {
            handleColumnResizeEndGesture(scrollerElement, event, appliedColumnWidths, resizeInfoRef, isRtl, onColumnResize);
        }
    }, [
        viewportInfo,
        appliedColumnWidths,
        resizeInfoRef,
        activeStyleColumnInfo,
        setActiveStyleColumnInfo,
        isRtl,
        onColumnResize
    ]);
    // Pointer leave handler for the outer Table.
    const _pointerLeaveHandler = hooks.useCallback((event) => {
        handleEndInteractionColumnHeaderFooterGesture(setHoverStyleColumnInfo, hoverStyleColumnInfo);
        handleEndInteractionColumnHeaderFooterGesture(setActiveStyleColumnInfo, activeStyleColumnInfo);
        const rootElement = rootRef.current;
        if (rootElement != null) {
            handleLeaveResizingGesture(rootElement, tableId, resizeInfoRef);
            handleLeaveTableTooltipGesture(rootElement, event, hideTooltip, tooltipId);
        }
        pointerInfoRef.current = undefined;
    }, [
        rootRef,
        tableId,
        resizeInfoRef,
        activeStyleColumnInfo,
        setActiveStyleColumnInfo,
        hoverStyleColumnInfo,
        hideTooltip,
        tooltipId
    ]);
    // Pointer enter handler for the outer Table.
    const _pointerEnterHandler = hooks.useCallback((event) => {
        const scrollerElement = viewportInfo.viewportConfig.scroller().current;
        if (scrollerElement != null && appliedColumnWidths != null) {
            handleEnterResizingGesture(scrollerElement, event, appliedColumnWidths, resizeInfoRef, isRtl, onColumnResize);
        }
    }, [viewportInfo, appliedColumnWidths, resizeInfoRef, isRtl, onColumnResize]);
    // Click handler for the outer Table. It ensures the Table's selection state is
    // updated to reflect the area targeted, and any action events are fired correctly.
    const _clickHandler = hooks.useCallback((event) => {
        const rootElement = rootRef.current;
        if (rootElement != null) {
            // only handle click events that match the latest mouse over/move info to prevent screen readers
            // from triggering undesired selections due to simulated click events when transferring focus
            if (event.pointerType !== 'mouse' ||
                (pointerInfoRef.current != null &&
                    pointerInfoRef.current.target === event.target &&
                    Math.abs(pointerInfoRef.current.x - event.clientX) <= 1 &&
                    Math.abs(pointerInfoRef.current.y - event.clientY) <= 1)) {
                let isSelectionExtension = false;
                const platform = clientHints.getClientHints().platform;
                const target = event.target;
                if (onTableSelectionChange != null &&
                    !resizeInfoRef.current.ignoreClick &&
                    !textSelectionUtils.getIsSelectionPending()) {
                    if (activeCell != null && event.shiftKey) {
                        isSelectionExtension = handleRangeSelectionGesture(rootElement, tableId, columnsArray, target, activeCell, onActiveCellChanged, selectionExtensionElementRef, onTableSelectionChange, isDropDownSelection, selectionMode, selected);
                    }
                    if (!isSelectionExtension) {
                        handleSelectionGesture(rootElement, tableId, columnsArray, target, (platform === 'mac' ? event.metaKey : event.ctrlKey) || selectionTouchRef.current, onTableSelectionChange, isDropDownSelection, selectionMode, selected);
                    }
                }
                if (onRowAction != null &&
                    !textSelectionUtils.getIsSelectionPending() &&
                    handleRowActionGesture(rootElement, tableId, tableData, onRowAction, target)) {
                    event.stopPropagation();
                }
            }
        }
        resizeInfoRef.current.ignoreClick = false;
    }, [
        rootRef,
        tableId,
        columnsArray,
        tableData,
        resizeInfoRef,
        selectionExtensionElementRef,
        activeCell,
        onActiveCellChanged,
        isDropDownSelection,
        selectionMode,
        selected,
        onTableSelectionChange,
        onRowAction
    ]);
    return {
        pointerHandlingProps: {
            onPointerOver: _pointerOverHandler,
            onPointerMove: _pointerMoveHandler,
            onPointerDown: _pointerDownHandler,
            onPointerUp: _pointerUpHandler,
            onPointerLeave: _pointerLeaveHandler,
            onPointerEnter: _pointerEnterHandler,
            onClick: _clickHandler
        },
        hoverStyleColumnInfo
    };
}

/**
 * Hook that manages handling scroll events on the Preact Table
 */
function useScrollHandling({ rootRef, viewportInfo, tableId, isLayoutRequired, sizingInfoRef, columnsArray, stickyColumnInfo, stickyEdgesState, setStickyEdgesState, fullColumnWidths, horizontalScrollPositionOverride, verticalScrollPositionOverride, tooltipAnchorRef, hideTooltip, isPendingLayout, isRtl }) {
    const horizontalScrollPositionOverrideRef = hooks.useRef();
    const verticalScrollPositionOverrideRef = hooks.useRef();
    // update horizontal and/or vertical scroll position if a new value is provided
    // NO DEPENDENCY ARRAY AS THIS SHOULD RUN ON EVERY RENDER
    hooks.useLayoutEffect(() => {
        const rootElement = rootRef.current;
        const scrollerElement = viewportInfo.viewportConfig.scroller().current;
        if (rootElement != null &&
            scrollerElement != null &&
            !isPendingLayout &&
            !isLayoutRequired &&
            fullColumnWidths != null) {
            if (horizontalScrollPositionOverrideRef.current !== horizontalScrollPositionOverride) {
                setHorizontalScrollPosition(scrollerElement, columnsArray, fullColumnWidths, isRtl, horizontalScrollPositionOverride);
                horizontalScrollPositionOverrideRef.current = horizontalScrollPositionOverride;
            }
            if (verticalScrollPositionOverrideRef.current !== verticalScrollPositionOverride) {
                setVerticalScrollPosition(rootElement, scrollerElement, tableId, verticalScrollPositionOverride);
                verticalScrollPositionOverrideRef.current = verticalScrollPositionOverride;
            }
        }
    });
    // Scroll hander for the outer Table. It ensures the Table's sticky edges are updated
    // and any out of view tooltips are hidden.
    const _scrollHandler = hooks.useCallback(() => {
        const rootElement = rootRef.current;
        const scrollerElement = viewportInfo.viewportConfig.scroller().current;
        if (rootElement != null && scrollerElement != null && fullColumnWidths != null) {
            updateStickyEdges(scrollerElement, columnsArray, stickyColumnInfo, fullColumnWidths, stickyEdgesState, setStickyEdgesState, scrollerElement.scrollLeft);
            hideOutOfViewTooltip(rootElement, scrollerElement, tableId, sizingInfoRef.current, stickyColumnInfo, fullColumnWidths, tooltipAnchorRef, hideTooltip, isRtl);
        }
    }, [
        rootRef,
        viewportInfo,
        tableId,
        sizingInfoRef,
        columnsArray,
        stickyColumnInfo,
        stickyEdgesState,
        setStickyEdgesState,
        fullColumnWidths,
        tooltipAnchorRef,
        hideTooltip,
        isRtl
    ]);
    hooks.useLayoutEffect(() => {
        const isExternalScroller = viewportInfo.isExternalScroller;
        const scrollerElement = viewportInfo.viewportConfig.scroller().current;
        let scrollerEventElement;
        if (isExternalScroller && scrollerElement != null) {
            if (scrollerElement === document.body || scrollerElement === document.documentElement) {
                scrollerEventElement = window;
            }
            else {
                scrollerEventElement = scrollerElement;
            }
            scrollerEventElement.addEventListener('scroll', _scrollHandler);
        }
        return () => {
            if (isExternalScroller && scrollerEventElement != null) {
                scrollerEventElement.removeEventListener('scroll', _scrollHandler);
            }
        };
    }, [viewportInfo, _scrollHandler]);
    return viewportInfo.isExternalScroller ? {} : { onScroll: _scrollHandler };
}

const _defaultDisabledRowInteractionKeys = ['enter'];
/**
 * Hook that manages interactions and events on the Preact Table
 */
function useInteractionManager({ rootRef, viewportInfo, ref, tableId, tableData, hasMore, hasFooters, isRtl, columnsArray, stickyColumnInfo, appliedColumnWidths, isLayoutRequired, sizingInfoRef, stickyEdgesState, setStickyEdgesState, cellHasRenderer, horizontalScrollPositionOverride, verticalScrollPositionOverride, onColumnResizing, onColumnResize, currentCellOverride, onPersistCurrentCell, selectionMode, selected, onSelectionChange, onRowAction, sortCriterion, onSortCriterionChange, isPendingLayout, contextMenuConfig }) {
    // tracks the current column resize state
    const resizeInfoRef = hooks.useRef({
        isResizing: false,
        isResizeHover: false,
        ignoreClick: false
    });
    // tracks the column key for any header or footer being hovered over
    const [activeStyleColumnInfo, setActiveStyleColumnInfo] = hooks.useState();
    // handles default tooltip state management
    const { tooltipContent, tooltipId, tooltipAnchorRef, showTooltip, hideTooltip } = useTruncationTooltip({ rootRef, tableId, resizeInfoRef });
    // whether row selection is triggered on 'enter' keypresses in addition to 'spacebar'
    const isEmbeddedSelect = useCollectionInteractionContext.useCollectionInteractionContext() === 'embedded';
    const disabledRowInteractionKeys = isEmbeddedSelect
        ? undefined
        : _defaultDisabledRowInteractionKeys;
    // tracks the current selection extension element (if any)
    const selectionExtensionElementRef = hooks.useRef();
    // intercept onSelectionChange calls to ensure local selectionExtensionElementRef is cleared
    const onTableSelectionChange = hooks.useMemo(() => {
        return onSelectionChange != null
            ? (detail, isExtendableSelection) => {
                if (!isExtendableSelection) {
                    selectionExtensionElementRef.current = undefined;
                }
                onSelectionChange(detail);
            }
            : undefined;
    }, [onSelectionChange]);
    // setup focus tracking using the useFocusHandling hook
    const { focusHandlingProps, activeCell, onActiveCellChanged, currentActiveCell, currentCell, isShowFocusRing, isTabbableMode, onStartFocusTracking, onFocusStartEdge, onFocusEndEdge, updateDeferredScrollDetail } = useFocusHandling({
        rootRef,
        viewportInfo,
        tableId,
        tableData,
        hasMore,
        hasFooters,
        columnsArray,
        stickyColumnInfo,
        sizingInfoRef,
        selectionExtensionElementRef,
        isRtl,
        cellSupportsTabbable: cellHasRenderer,
        appliedColumnWidths,
        currentCellOverride,
        onPersistCurrentCell,
        showTooltip,
        hideTooltip,
        isPendingLayout,
        isEmbeddedSelect,
        isDataLoaded: !hasMore || tableData.length > 0
    });
    const keyboardHandlingProps = useKeyboardHandling({
        rootRef,
        viewportInfo,
        tableId,
        tableData,
        isRtl,
        isTabbableMode,
        columnsArray,
        sizingInfoRef,
        selectionExtensionElementRef,
        activeCell,
        onActiveCellChanged,
        isDropDownSelection: isEmbeddedSelect,
        selectionMode,
        selected,
        onTableSelectionChange,
        activeStyleColumnInfo,
        setActiveStyleColumnInfo,
        onRowAction,
        sortCriterion,
        onSortCriterionChange,
        hideTooltip,
        updateDeferredScrollDetail
    });
    const { hoverStyleColumnInfo, pointerHandlingProps } = usePointerHandling({
        rootRef,
        viewportInfo,
        tableId,
        tableData,
        isRtl,
        columnsArray,
        appliedColumnWidths,
        resizeInfoRef,
        selectionExtensionElementRef,
        onColumnResizing,
        onColumnResize,
        activeCell,
        onActiveCellChanged,
        isDropDownSelection: isEmbeddedSelect,
        selectionMode,
        selected,
        onTableSelectionChange,
        activeStyleColumnInfo,
        setActiveStyleColumnInfo,
        onRowAction,
        showTooltip,
        hideTooltip,
        tooltipId
    });
    const scrollHandlingProps = useScrollHandling({
        rootRef,
        viewportInfo,
        tableId,
        isLayoutRequired,
        sizingInfoRef,
        columnsArray,
        stickyColumnInfo,
        stickyEdgesState,
        setStickyEdgesState,
        fullColumnWidths: appliedColumnWidths?.fullColumnWidths,
        horizontalScrollPositionOverride,
        verticalScrollPositionOverride,
        tooltipAnchorRef,
        hideTooltip,
        isPendingLayout,
        isRtl
    });
    const { contextMenuTriggerProps, menuProps, contextMenuContext, isResizeDialogOpen, setIsResizeDialogOpen } = useContextMenu(tableId, tableData, columnsArray, activeCell, contextMenuConfig, sortCriterion, onSortCriterionChange);
    const interactionManagerProps = !isPendingLayout
        ? mergeProps.mergeProps(focusHandlingProps, keyboardHandlingProps, pointerHandlingProps, contextMenuTriggerProps)
        : focusHandlingProps;
    // setup imperative handle implementation
    hooks.useImperativeHandle(ref, () => {
        const rootElement = rootRef.current;
        const scrollerElement = viewportInfo.viewportConfig.scroller().current;
        return {
            focus: () => {
                if (rootElement != null) {
                    if (currentActiveCell != null) {
                        const cellElement = getElementFromCell(rootElement, tableId, currentActiveCell);
                        if (cellElement != null) {
                            cellElement.focus();
                            return;
                        }
                    }
                    // if no current cell element was found, just focus the root element
                    rootElement.focus();
                }
            },
            getHorizontalScrollPosition: () => {
                if (scrollerElement == null || isLayoutRequired || appliedColumnWidths == null) {
                    return {};
                }
                return getHorizontalScrollPosition(scrollerElement, columnsArray, appliedColumnWidths.fullColumnWidths);
            },
            getVerticalScrollPosition: () => {
                if (rootElement == null || scrollerElement == null || isLayoutRequired) {
                    return {};
                }
                return getVerticalScrollPosition(rootElement, scrollerElement, tableId);
            }
        };
    }, [
        rootRef,
        viewportInfo,
        tableId,
        columnsArray,
        currentActiveCell,
        isLayoutRequired,
        appliedColumnWidths
    ]);
    return {
        interactionManagerProps,
        scrollHandlingProps,
        onTableSelectionChange,
        isShowFocusRing,
        isTabbableMode,
        currentCell,
        currentActiveCell,
        resizeInfoRef,
        onStartFocusTracking,
        onFocusStartEdge,
        onFocusEndEdge,
        activeStyleColumnInfo,
        hoverStyleColumnInfo,
        tooltipContent,
        contextMenuContext,
        menuProps,
        isResizeDialogOpen,
        setIsResizeDialogOpen,
        disabledRowInteractionKeys
    };
}

/**
 * Helper method to extract the individual column widths of the Table
 * depending on its layout. With a 'fixed' layout, an initial 'availableWidth'
 * is required, while with a 'contents' layout, -1 can be provided as the
 * 'availableWidth' initially. This will trigger the layout logic to ensure
 * a non-contstrained Table width is supported, and is needed to match
 * current Redwood behaviors with a 'contents' layout.
 */
function applyLayoutColumnWidths(scrollerElement, viewportInfo, innerTableElement, widthOffset, tableId, isFixed, sampledColumnNetWidthsRef, availableRealWidth, columnsArray, columnBorderEdges, borderOffset, staticColumnWidths) {
    let newNetColumnWidths;
    let totalRealWidth = 0;
    let realWidthsArray = [];
    const tableCols = innerTableElement.querySelectorAll(`[data-oj-table-col='${tableId}']`);
    let totalBorderWidth = 0;
    for (const borderEdge of columnBorderEdges) {
        totalBorderWidth += borderEdge.width;
    }
    const availableNetWidth = availableRealWidth !== -1 ? availableRealWidth - totalBorderWidth : -1;
    if (isFixed) {
        newNetColumnWidths = _getFixedLayoutColumnNetWidths(availableNetWidth, columnsArray, staticColumnWidths);
        for (let i = 0; i < columnsArray.length; i++) {
            const width = newNetColumnWidths[i] + columnBorderEdges[i].width;
            realWidthsArray.push(width);
            totalRealWidth += width;
        }
        _updateTableSizing(innerTableElement, tableCols, realWidthsArray, totalRealWidth);
        return _createColumnWidths(columnsArray, newNetColumnWidths, realWidthsArray, columnBorderEdges, borderOffset, totalBorderWidth);
    }
    const headerElements = innerTableElement.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);
    newNetColumnWidths = _getContentsLayoutColumnNetWidths(innerTableElement, headerElements, sampledColumnNetWidthsRef, availableNetWidth, columnsArray, columnBorderEdges, staticColumnWidths);
    for (let i = 0; i < columnsArray.length; i++) {
        const realWidth = newNetColumnWidths[i] + columnBorderEdges[i].width;
        realWidthsArray.push(realWidth);
        totalRealWidth += realWidth;
    }
    _updateTableSizing(innerTableElement, tableCols, realWidthsArray, totalRealWidth);
    if (availableRealWidth === -1) {
        // for content sizing, check to see if all space is actually utilized
        // this supports no width constraint scenarios
        if (!viewportInfo.isExternalScroller) {
            availableRealWidth = scrollerElement.getBoundingClientRect().width - widthOffset;
        }
        else {
            availableRealWidth = scrollerElement.clientWidth - widthOffset;
        }
        if (Math.abs(totalRealWidth - availableRealWidth) > 0.005) {
            newNetColumnWidths = _getContentsLayoutColumnNetWidths(innerTableElement, headerElements, sampledColumnNetWidthsRef, availableRealWidth - totalBorderWidth, columnsArray, columnBorderEdges, staticColumnWidths);
            totalRealWidth = 0;
            realWidthsArray = [];
            for (let i = 0; i < columnsArray.length; i++) {
                const width = newNetColumnWidths[i] + columnBorderEdges[i].width;
                realWidthsArray.push(width);
                totalRealWidth += width;
            }
            _updateTableSizing(innerTableElement, tableCols, realWidthsArray, totalRealWidth);
        }
    }
    return _createColumnWidths(columnsArray, newNetColumnWidths, realWidthsArray, columnBorderEdges, borderOffset, totalBorderWidth);
}
/**
 * Helper method to extract the individual column widths of the Table
 * for a 'fixed' layout table that already has its root width applied.
 */
function _getFixedLayoutColumnNetWidths(availableNetWidth, columnsArray, staticColumnWidths) {
    const DEFAULT_COLUMN_WEIGHT = 1;
    const DEFAULT_COLUMN_MIN_WIDTH = 100;
    const DEFAULT_COLUMN_MAX_WIDTH = undefined;
    let requiresActiveSizing = false;
    let totalWorkingWeight = 0;
    let forcedTotalNetWidth = 0;
    let pendingTotalNetWidth = 0;
    const columnMaxWidthsArray = [];
    const columnWeightsArray = [];
    const forcedColumnNetWidthsArray = [];
    const newColumnNetWidthsArray = [];
    const appliedColumnNetWidthsArray = [];
    for (let i = 0; i < columnsArray.length; i++) {
        const column = columnsArray[i];
        let columnMinWidth = column.value.minWidth;
        if (columnMinWidth == null || columnMinWidth <= 0) {
            columnMinWidth = DEFAULT_COLUMN_MIN_WIDTH;
        }
        let columnMaxWidth = column.value.maxWidth;
        if (columnMaxWidth == null || columnMaxWidth < columnMinWidth) {
            columnMaxWidth = DEFAULT_COLUMN_MAX_WIDTH;
        }
        columnMaxWidthsArray.push(columnMaxWidth);
        let columnWeight = column.value.weight;
        if (columnWeight == null || columnWeight < 1) {
            columnWeight = DEFAULT_COLUMN_WEIGHT;
        }
        columnWeightsArray.push(columnWeight);
        const columnWidth = staticColumnWidths != null ? staticColumnWidths[column.key] : undefined;
        if (columnWidth != null) {
            forcedTotalNetWidth += columnWidth;
            pendingTotalNetWidth += columnWidth;
            forcedColumnNetWidthsArray.push(columnWidth);
            newColumnNetWidthsArray.push(columnWidth);
            appliedColumnNetWidthsArray.push(columnWidth);
        }
        else {
            requiresActiveSizing = true;
            pendingTotalNetWidth += columnMinWidth;
            totalWorkingWeight += columnWeight;
            forcedColumnNetWidthsArray.push(undefined);
            newColumnNetWidthsArray.push(columnMinWidth);
            appliedColumnNetWidthsArray.push(columnMinWidth);
        }
    }
    // enforce min and max rules if active sizing is required and available space remains
    if (requiresActiveSizing && pendingTotalNetWidth < availableNetWidth) {
        _enforceFixedMinMaxRules(columnsArray, availableNetWidth, totalWorkingWeight, forcedTotalNetWidth, forcedColumnNetWidthsArray, columnWeightsArray, columnMaxWidthsArray, newColumnNetWidthsArray, appliedColumnNetWidthsArray);
    }
    return newColumnNetWidthsArray;
}
/**
 * Helper function to enforce all of the layout sizing rules on the Table's columns.
 */
function _enforceFixedMinMaxRules(columnsArray, availableWidth, totalWorkingWeight, forcedTotalWidth, forcedColumnWidthsArray, columnWeightsArray, columnMaxWidthsArray, newColumnWidthsArray, appliedColumnWidthsArray) {
    // try and honor the weights of each column combined with the min widths, and then check that against
    // any max widths once completed. if the final result doesn't fill the space AND at least 1 max width
    // rule was enforced, repeat the process until no max rules are enforced OR the space is filled.
    let isMaxRuleApplied = true;
    while (isMaxRuleApplied) {
        isMaxRuleApplied = false;
        _enforceWeightedMinRules(columnsArray, availableWidth, totalWorkingWeight, forcedTotalWidth, forcedColumnWidthsArray, columnWeightsArray, newColumnWidthsArray, appliedColumnWidthsArray);
        let pendingTotalWidth = 0;
        for (let i = 0; i < columnsArray.length; i++) {
            if (forcedColumnWidthsArray[i] == null) {
                const maxWidth = columnMaxWidthsArray[i];
                if (maxWidth != null && newColumnWidthsArray[i] > maxWidth) {
                    isMaxRuleApplied = true;
                    forcedColumnWidthsArray[i] = maxWidth;
                    forcedTotalWidth += maxWidth;
                    totalWorkingWeight -= columnWeightsArray[i];
                    newColumnWidthsArray[i] = maxWidth;
                    appliedColumnWidthsArray[i] = maxWidth;
                }
            }
            pendingTotalWidth += newColumnWidthsArray[i];
        }
        isMaxRuleApplied = isMaxRuleApplied && pendingTotalWidth < availableWidth;
    }
}
/**
 * Helper method to extract the individual column widths of the Table
 * for a 'contents' layout table that already has its root width applied.
 */
function _getContentsLayoutColumnNetWidths(innerTableElement, headerElements, sampledColumnNetWidthsRef, availableNetWidth, columnsArray, columnBorderEdges, staticColumnWidths) {
    const DEFAULT_COLUMN_MIN_WIDTH = undefined;
    const DEFAULT_COLUMN_MAX_WIDTH = undefined;
    let requiresActiveSizing = false;
    const columnMinWidthsArray = [];
    const columnMaxWidthsArray = [];
    const forcedColumnNetWidthsArray = [];
    const newColumnNetWidthsArray = [];
    for (let i = 0; i < columnsArray.length; i++) {
        const column = columnsArray[i];
        let columnMinWidth = column.value.minWidth;
        if (columnMinWidth == null || columnMinWidth <= 0) {
            columnMinWidth = DEFAULT_COLUMN_MIN_WIDTH;
        }
        columnMinWidthsArray.push(columnMinWidth);
        let columnMaxWidth = column.value.maxWidth;
        if (columnMaxWidth == null || columnMaxWidth < (columnMinWidth != null ? columnMinWidth : 0)) {
            columnMaxWidth = DEFAULT_COLUMN_MAX_WIDTH;
        }
        columnMaxWidthsArray.push(columnMaxWidth);
        const columnWidth = staticColumnWidths != null ? staticColumnWidths[column.key] : undefined;
        if (columnWidth != null) {
            forcedColumnNetWidthsArray.push(columnWidth);
            newColumnNetWidthsArray[i] = columnWidth;
        }
        else {
            requiresActiveSizing = true;
            forcedColumnNetWidthsArray.push(undefined);
        }
    }
    // short-circuit normal contents sizing if each column specifies a 'width' value
    if (requiresActiveSizing) {
        // if active sizing is required, update min width values to reflect actual widths
        // performance note - this should be the only logic that requires DOM measurements
        let forcedTotalNetWidth = 0;
        let pendingTotalNetWidth = 0;
        let totalPreferredNetWidth = 0;
        let totalWorkingWeight = 0;
        let totalRemainingWeight = 0;
        const sampledNetWidths = sampledColumnNetWidthsRef.current;
        const sampledMinNetWidthsArray = [];
        const sampledWeightNetWidthsArray = [];
        const appliedColumnNetWidthsArray = [];
        if (sampledNetWidths != null) {
            for (let i = 0; i < columnsArray.length; i++) {
                sampledMinNetWidthsArray.push(sampledNetWidths.minWidths[columnsArray[i].key]);
                sampledWeightNetWidthsArray.push(sampledNetWidths.weightWidths[columnsArray[i].key]);
            }
        }
        else {
            sampledColumnNetWidthsRef.current = {
                minWidths: {},
                weightWidths: {}
            };
            // when sampledColumnNetWidths are not populated, table has 'max-content' width applied,
            // which allows for measurements to represent the column weights
            for (let i = 0; i < headerElements.length; i++) {
                const sampledWeightNetWidth = headerElements[i].getBoundingClientRect().width -
                    columnBorderEdges[i].width;
                sampledWeightNetWidthsArray.push(sampledWeightNetWidth);
                sampledColumnNetWidthsRef.current.weightWidths[columnsArray[i].key] = sampledWeightNetWidth;
            }
            // specify 'min-content' width, allowing measurements to represent minimum auto-resizable column widths
            innerTableElement.style.width = 'min-content';
            for (let i = 0; i < headerElements.length; i++) {
                const sampledMinNetWidth = headerElements[i].getBoundingClientRect().width -
                    columnBorderEdges[i].width;
                sampledMinNetWidthsArray.push(sampledMinNetWidth);
                sampledColumnNetWidthsRef.current.minWidths[columnsArray[i].key] = sampledMinNetWidth;
            }
        }
        for (let i = 0; i < sampledMinNetWidthsArray.length; i++) {
            const forcedWidth = forcedColumnNetWidthsArray[i];
            if (forcedWidth == null) {
                let columnNetWidth;
                const sampledMinNetWidth = sampledMinNetWidthsArray[i];
                const minWidth = columnMinWidthsArray[i];
                const maxWidth = columnMaxWidthsArray[i];
                if (minWidth != null && minWidth >= sampledMinNetWidth) {
                    columnNetWidth = minWidth;
                }
                else if (maxWidth != null && sampledMinNetWidth >= maxWidth) {
                    columnNetWidth = maxWidth;
                }
                else {
                    columnNetWidth = sampledMinNetWidth;
                }
                pendingTotalNetWidth += columnNetWidth;
                // replace sampled weight with min width if needed
                const columnWeight = minWidth != null && minWidth >= sampledWeightNetWidthsArray[i]
                    ? minWidth
                    : sampledWeightNetWidthsArray[i];
                sampledWeightNetWidthsArray[i] = columnWeight;
                totalPreferredNetWidth +=
                    maxWidth != null && maxWidth <= columnWeight ? maxWidth : columnWeight;
                totalWorkingWeight += columnWeight;
                totalRemainingWeight += columnWeight - columnNetWidth;
                // newColumnWidthsArray already has content, so update in place rather than 'push'
                newColumnNetWidthsArray[i] = columnNetWidth;
                appliedColumnNetWidthsArray.push(columnNetWidth);
            }
            else {
                forcedTotalNetWidth += forcedWidth;
                pendingTotalNetWidth += forcedWidth;
                totalPreferredNetWidth += forcedWidth;
                appliedColumnNetWidthsArray.push(forcedWidth);
            }
        }
        // special case for initial rendering where we don't know if overall width is constrained
        if (availableNetWidth === -1) {
            availableNetWidth = totalPreferredNetWidth;
        }
        if (pendingTotalNetWidth < availableNetWidth) {
            _enforceContentsMinMaxRules(columnsArray, availableNetWidth, totalPreferredNetWidth, totalRemainingWeight, totalWorkingWeight, pendingTotalNetWidth, forcedTotalNetWidth, forcedColumnNetWidthsArray, sampledWeightNetWidthsArray, columnMaxWidthsArray, newColumnNetWidthsArray, appliedColumnNetWidthsArray);
        }
    }
    return newColumnNetWidthsArray;
}
/**
 * Helper function to enforce all of the layout sizing rules on the Table's columns.
 */
function _enforceContentsMinMaxRules(columnsArray, availableWidth, totalPreferredWidth, totalRemainingWeight, totalWorkingWeight, appliedPendingTotalWidth, forcedTotalWidth, forcedColumnWidthsArray, columnWeightsArray, columnMaxWidthsArray, newColumnWidthsArray, appliedColumnWidthsArray) {
    // try and honor the weights of each column combined with the min widths, and then check that against
    // any max widths once completed. if the final result doesn't fill the space AND at least 1 max width
    // rule was enforced, repeat the process until no max rules are enforced OR the space is filled.
    let isMaxRuleApplied = true;
    while (isMaxRuleApplied) {
        isMaxRuleApplied = false;
        if (totalPreferredWidth > availableWidth) {
            _enforceConstrainedWeightRules(columnsArray, availableWidth - appliedPendingTotalWidth, totalRemainingWeight, columnWeightsArray, forcedColumnWidthsArray, newColumnWidthsArray, appliedColumnWidthsArray);
        }
        else {
            _enforceWeightedMinRules(columnsArray, availableWidth, totalWorkingWeight, forcedTotalWidth, forcedColumnWidthsArray, columnWeightsArray, newColumnWidthsArray, appliedColumnWidthsArray);
        }
        let pendingTotalWidth = 0;
        for (let i = 0; i < columnsArray.length; i++) {
            if (forcedColumnWidthsArray[i] == null) {
                const maxWidth = columnMaxWidthsArray[i];
                if (maxWidth != null && newColumnWidthsArray[i] > maxWidth) {
                    isMaxRuleApplied = true;
                    forcedColumnWidthsArray[i] = maxWidth;
                    forcedTotalWidth += maxWidth;
                    appliedPendingTotalWidth += maxWidth - appliedColumnWidthsArray[i];
                    totalWorkingWeight -= columnWeightsArray[i];
                    newColumnWidthsArray[i] = maxWidth;
                    appliedColumnWidthsArray[i] = maxWidth;
                }
            }
            pendingTotalWidth += newColumnWidthsArray[i];
        }
        isMaxRuleApplied = isMaxRuleApplied && pendingTotalWidth < availableWidth;
    }
}
/**
 * Helper function to enforce constrained weights / min width rules on the Table's columns.
 */
function _enforceConstrainedWeightRules(columnsArray, initialExtraWidth, totalRemainingWeight, columnWeightsArray, forcedColumnWidthsArray, newColumnWidthsArray, appliedColumnWidthsArray) {
    if (initialExtraWidth > 0) {
        let availableWidth = initialExtraWidth;
        let currentWeightTotal = totalRemainingWeight;
        for (let i = 0; i < columnsArray.length; i++) {
            if (currentWeightTotal > 0 && forcedColumnWidthsArray[i] == null) {
                const currentWeight = columnWeightsArray[i] - appliedColumnWidthsArray[i];
                const weightWidth = (currentWeight / currentWeightTotal) * availableWidth;
                newColumnWidthsArray[i] = weightWidth + appliedColumnWidthsArray[i];
                availableWidth -= weightWidth;
                currentWeightTotal -= currentWeight;
            }
        }
    }
}
/**
 * Helper function to enforce the weights / min width rules on the Table's columns.
 */
function _enforceWeightedMinRules(columnsArray, availableWidth, totalWeight, forcedTotalWidth, forcedColumnWidthsArray, columnWeightsArray, newColumnWidthsArray, appliedColumnWidthsArray) {
    const pendingForcedColumnWidths = [];
    let isMinRuleApplied = true;
    while (isMinRuleApplied) {
        isMinRuleApplied = false;
        let currentWeightTotal = totalWeight;
        let widthDiff = availableWidth - forcedTotalWidth;
        if (widthDiff > 0) {
            for (let i = 0; i < columnsArray.length; i++) {
                if (currentWeightTotal > 0 &&
                    forcedColumnWidthsArray[i] == null &&
                    pendingForcedColumnWidths[i] == null) {
                    const currentWeight = columnWeightsArray[i];
                    const newWidth = (currentWeight / currentWeightTotal) * widthDiff;
                    // if calculated width breaks min width requirement, force min width as needed
                    const minWidth = appliedColumnWidthsArray[i];
                    if (newWidth < minWidth) {
                        // the preferred weighted size conflicts with the min size, so set pending to min size
                        pendingForcedColumnWidths[i] = minWidth;
                        forcedTotalWidth += minWidth;
                        newColumnWidthsArray[i] = minWidth;
                        isMinRuleApplied = true;
                        totalWeight -= currentWeight;
                        break;
                    }
                    newColumnWidthsArray[i] = newWidth;
                    widthDiff -= newWidth;
                    currentWeightTotal -= currentWeight;
                }
            }
        }
    }
}
/**
 * Helper function to create a ColumnWidths object from a TableColumn array and a widths array.
 */
function _createColumnWidths(columnsArray, netWidthsArray, realWidthsArray, borderEdges, borderOffset, totalBorderOffset) {
    const logicalWidthsArray = [];
    const columnWidths = {};
    for (let i = 0; i < columnsArray.length; i++) {
        columnWidths[columnsArray[i].key] = netWidthsArray[i];
        logicalWidthsArray.push(netWidthsArray[i] + borderEdges[i].offset);
    }
    return {
        netColumnWidths: columnWidths,
        fullColumnWidths: logicalWidthsArray,
        realColumnWidths: realWidthsArray,
        borderEdges,
        borderOffset,
        totalBorderOffset
    };
}
/**
 * Helper method to apply the given sizing object to the currently rendered Table
 * and column elements.
 */
function _updateTableSizing(innerTableElement, tableCols, realWidthsArray, totalRealWidth) {
    for (let i = 0; i < tableCols.length; i++) {
        const tableCol = tableCols[i];
        tableCol.style.width = `${realWidthsArray[i]}px`;
    }
    innerTableElement.style.width = `${totalRealWidth}px`;
    innerTableElement.style.tableLayout = 'fixed';
}
/**
 * Helper function to compare two ColumnWidths instances for equality.
 */
const columnWidthsComparator = (columnWidths1, columnWidths2) => {
    const keys1 = Object.keys(columnWidths1);
    const keys2 = Object.keys(columnWidths2);
    if (keys1.length === keys2.length) {
        for (const key of keys1) {
            const columnKey = key;
            if (columnWidths1[columnKey] !== columnWidths2[columnKey]) {
                return false;
            }
        }
        return true;
    }
    return false;
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Hook that manages column sizing on the Preact Table
 */
function useSizingManager({ rootRef, innerTableRef, tableId, tableData, viewportConfig, externalScrollerRef, layout, columns, columnOrder, columnWidths, isRtl, isHighContrast }) {
    // scrollerRef is callback-based to meet useResizeObserver hook's state management requirements
    const [scrollerRef, setScrollerRef] = hooks.useState(preact.createRef());
    const scrollerRefCallback = hooks.useCallback((node) => {
        setScrollerRef({ current: node });
    }, []);
    hooks.useImperativeHandle(externalScrollerRef, () => {
        if (viewportConfig?.scroller != null) {
            return { [unsafeDomAccess.UNSAFE_DOM_ACCESS]: viewportConfig.scroller().current };
        }
        return { [unsafeDomAccess.UNSAFE_DOM_ACCESS]: scrollerRef.current };
    }, [scrollerRef, viewportConfig]);
    // setup busy start and busy end callbacks for the 2 resize observer regions
    const { onBusyStart: onResizeScrollerBusyStart, onBusyEnd: onResizeScrollerBusyEnd } = useAddBusyState.useAddBusyState('handling scroller resize');
    const { onBusyStart: onResizeTableBusyStart, onBusyEnd: onResizeTableBusyEnd } = useAddBusyState.useAddBusyState('handling table resize');
    // state to force a rerender following the initial render where scrollbars are forced
    const [_isScrollbarSizeKnown, setIsScrollbarSizeKnown] = hooks.useState(false);
    // column width state information
    const sampledColumnNetWidthsRef = hooks.useRef();
    const [appliedColumnWidths, setAppliedColumnWidths] = hooks.useState();
    const [innerTableHeight, setInnerTableHeight] = hooks.useState();
    const [hasVerticalUnderflow, setHasVerticalUnderflow] = hooks.useState(false);
    // general table sizing state information
    const sizingInfoRef = hooks.useRef({
        isInitialRender: true,
        isScrollbarSizeKnown: false
    });
    const pendingResizeEntriesRef = hooks.useRef({});
    // scrollbar overflow state
    const overflowRef = hooks.useRef({
        isHorizontal: false,
        isVertical: false
    });
    // sticky edge state management
    const [stickyEdgesState, setStickyEdgesState] = hooks.useState({});
    // current viewport information
    const viewportInfo = hooks.useMemo(() => {
        const tableViewportConfig = getViewportConfig(scrollerRef, viewportConfig);
        return {
            isExternalScroller: viewportConfig?.scroller() != null,
            viewportConfig: tableViewportConfig
        };
    }, [scrollerRef, viewportConfig]);
    // memoize realized columns array on 'columns' and 'columnOrder'
    const columnsArray = hooks.useMemo(() => {
        const newColumnsArray = [];
        if (columnOrder != null) {
            for (const key of columnOrder) {
                if (columns[key] != null) {
                    newColumnsArray.push({
                        key: key,
                        value: columns[key]
                    });
                }
            }
        }
        else {
            for (const [key, value] of Object.entries(columns)) {
                newColumnsArray.push({
                    key: key,
                    value: value
                });
            }
        }
        return newColumnsArray;
    }, [columnOrder, columns]);
    const stickyColumnInfo = hooks.useMemo(() => {
        const stickyColumns = getStickyColumnIndicies(columnsArray);
        let firstStickyColumnIndex;
        let finalStickyColumnIndex;
        const stickyColumnsCount = stickyColumns.length;
        if (stickyColumns.length > 0) {
            firstStickyColumnIndex = stickyColumns[0];
            finalStickyColumnIndex = stickyColumns[stickyColumnsCount - 1];
        }
        return { stickyColumns, firstStickyColumnIndex, finalStickyColumnIndex };
    }, [columnsArray]);
    const borderOffset = isHighContrast ? 3 : 1;
    const columnBorderEdges = hooks.useMemo(() => {
        const newColumnBorderEdges = [];
        let isPreviousColumnHasEnd = false;
        for (let i = 0; i < columnsArray.length; i++) {
            const hasStart = !isPreviousColumnHasEnd;
            const isLastColumn = i === columnsArray.length - 1;
            const isColumnSticky = stickyColumnInfo.stickyColumns.includes(i);
            const isLastStickyColumn = isColumnSticky && stickyColumnInfo.finalStickyColumnIndex === i;
            const hasEnd = isLastColumn || isLastStickyColumn || stickyEdgesState?.start === i;
            const width = (hasStart ? borderOffset : 0) + (hasEnd ? borderOffset : 0);
            let offset;
            if (isLastStickyColumn ||
                (isLastColumn && stickyColumnInfo.finalStickyColumnIndex !== i - 1)) {
                offset = 2 * borderOffset;
            }
            else {
                offset =
                    !isLastColumn && stickyColumnInfo.finalStickyColumnIndex === i - 1 ? 0 : borderOffset;
            }
            newColumnBorderEdges.push({ hasStart, hasEnd, width, offset });
            isPreviousColumnHasEnd = hasEnd;
        }
        return newColumnBorderEdges;
    }, [borderOffset, columnsArray, stickyEdgesState, stickyColumnInfo]);
    // determine if a new layout is required
    let isLayoutRequired = false;
    if (appliedColumnWidths != null) {
        for (let i = 0; i < columnsArray.length; i++) {
            const key = columnsArray[i].key;
            const netWidth = appliedColumnWidths.netColumnWidths[key];
            const staticWidth = columnWidths != null ? columnWidths[key] : undefined;
            if (netWidth == null || (staticWidth != null && staticWidth !== netWidth)) {
                isLayoutRequired = true;
                break;
            }
        }
    }
    else {
        isLayoutRequired = true;
    }
    // ensure sampled column sizes are cleared if 'columns', 'columnOrder', or 'layout' is updated
    hooks.useLayoutEffect(() => {
        sampledColumnNetWidthsRef.current = undefined;
        setAppliedColumnWidths(undefined);
    }, [columns, columnOrder, layout]);
    // ensure applied column widths are cleared if 'columnWidths' is updated
    hooks.useLayoutEffect(() => {
        setAppliedColumnWidths(undefined);
    }, [columnWidths, stickyEdgesState]);
    // setup sizing calculation updates for subsequent renders
    hooks.useLayoutEffect(() => {
        const scrollerElement = viewportInfo.viewportConfig.scroller().current;
        const innerTableElement = innerTableRef.current;
        if (layout !== 'pending' &&
            scrollerElement != null &&
            innerTableElement != null &&
            !sizingInfoRef.current.isInitialRender &&
            (viewportInfo.isExternalScroller || sizingInfoRef.current.isScrollbarSizeKnown) &&
            isLayoutRequired &&
            columnsArray.length > 0) {
            let widthOffset = 0;
            if (viewportInfo.isExternalScroller) {
                const scrollerOffsetStart = viewportInfo.viewportConfig.scrollerOffsetStart;
                if (scrollerOffsetStart != null) {
                    widthOffset += scrollerOffsetStart;
                }
                const scrollerOffsetEnd = viewportInfo.viewportConfig.scrollerOffsetEnd;
                if (scrollerOffsetEnd != null) {
                    widthOffset += scrollerOffsetEnd;
                }
            }
            else if (sizingInfoRef.current.isScrollbarSizeKnown) {
                widthOffset = sizingInfoRef.current.defaultScrollbarWidth;
            }
            const totalWidth = layout === 'fixed' ? sizingInfoRef.current.contentWidth - widthOffset : -1;
            const newColumnWidths = applyLayoutColumnWidths(scrollerElement, viewportInfo, innerTableElement, widthOffset, tableId, layout === 'fixed', sampledColumnNetWidthsRef, totalWidth, columnsArray, columnBorderEdges, borderOffset, columnWidths);
            setAppliedColumnWidths(newColumnWidths);
        }
    }, [
        viewportInfo,
        innerTableRef,
        tableId,
        columnsArray,
        columnBorderEdges,
        borderOffset,
        columnWidths,
        layout,
        isLayoutRequired,
        isHighContrast
    ]);
    hooks.useLayoutEffect(() => {
        const rootElement = rootRef.current;
        const scrollerElement = viewportInfo.viewportConfig.scroller().current;
        if (layout !== 'pending' &&
            rootElement != null &&
            scrollerElement != null &&
            appliedColumnWidths != null) {
            updateStickyColumns(rootElement, scrollerElement, viewportInfo, tableId, isRtl, columnsArray, stickyColumnInfo, appliedColumnWidths.fullColumnWidths, stickyEdgesState, setStickyEdgesState, viewportInfo.isExternalScroller || overflowRef.current.isHorizontal);
        }
    }, [
        tableData,
        rootRef,
        viewportInfo,
        tableId,
        appliedColumnWidths,
        columnsArray,
        stickyColumnInfo,
        layout,
        stickyEdgesState,
        isRtl
    ]);
    // helper method to update the sticky edge styling due to resize events
    const _updateStickyEdgesFromResize = hooks.useCallback((scrollerElement) => {
        if (appliedColumnWidths != null) {
            if (viewportInfo.isExternalScroller || overflowRef.current.isHorizontal) {
                // ensure sticky edges are applied correctly if horizontal overflow is present
                updateStickyEdges(scrollerElement, columnsArray, stickyColumnInfo, appliedColumnWidths.fullColumnWidths, stickyEdgesState, setStickyEdgesState);
            }
            else if (stickyEdgesState.start != null || stickyEdgesState.end != null) {
                // otherwise clear sticky edges if necessary
                setStickyEdgesState({});
            }
        }
    }, [appliedColumnWidths, columnsArray, stickyColumnInfo, stickyEdgesState, viewportInfo]);
    // callback function to handle resizes of the scroller and inner table elements
    const handleResizeCallback = hooks.useCallback(() => {
        let currentEntry = pendingResizeEntriesRef.current.scroller;
        const rootElement = rootRef.current;
        const scrollerElement = viewportInfo.viewportConfig.scroller().current;
        const innerTableElement = innerTableRef.current;
        let isOveralSizeHandled = false;
        // handle scroller element resize notification
        if (currentEntry != null &&
            rootElement != null &&
            scrollerElement != null &&
            innerTableElement != null) {
            const newContentWidth = currentEntry.contentBoxSize[0].inlineSize;
            const newContentHeight = currentEntry.contentBoxSize[0].blockSize;
            const newBoxWidth = currentEntry.borderBoxSize[0].inlineSize;
            const newBoxHeight = currentEntry.borderBoxSize[0].blockSize;
            if (newBoxWidth !== 0 || newBoxHeight !== 0) {
                isOveralSizeHandled = true;
                let availableWidth;
                let availableWidthOffset = 0;
                let defaultScrollbarWidth = 0;
                if (viewportInfo.isExternalScroller) {
                    const scrollerOffsetStart = viewportInfo.viewportConfig.scrollerOffsetStart;
                    if (scrollerOffsetStart != null) {
                        availableWidthOffset += scrollerOffsetStart;
                    }
                    const scrollerOffsetEnd = viewportInfo.viewportConfig.scrollerOffsetEnd;
                    if (scrollerOffsetEnd != null) {
                        availableWidthOffset += scrollerOffsetEnd;
                    }
                    if (sizingInfoRef.current.isScrollbarSizeKnown) {
                        sizingInfoRef.current = {
                            isInitialRender: false,
                            contentWidth: newContentWidth,
                            boxWidth: newBoxWidth,
                            contentHeight: newContentHeight,
                            boxHeight: newBoxHeight,
                            isScrollbarSizeKnown: true,
                            defaultScrollbarWidth: sizingInfoRef.current.defaultScrollbarWidth,
                            defaultScrollbarHeight: sizingInfoRef.current.defaultScrollbarHeight
                        };
                    }
                    else {
                        sizingInfoRef.current = {
                            isInitialRender: false,
                            contentWidth: newContentWidth,
                            boxWidth: newBoxWidth,
                            contentHeight: newContentHeight,
                            boxHeight: newBoxHeight,
                            isScrollbarSizeKnown: false
                        };
                    }
                    availableWidth = newContentWidth - availableWidthOffset;
                }
                else {
                    const isInitialRender = sizingInfoRef.current.isInitialRender;
                    if (sizingInfoRef.current.isScrollbarSizeKnown) {
                        availableWidthOffset = sizingInfoRef.current.defaultScrollbarWidth;
                        sizingInfoRef.current = {
                            isInitialRender: false,
                            contentWidth: newContentWidth,
                            boxWidth: newBoxWidth,
                            contentHeight: newContentHeight,
                            boxHeight: newBoxHeight,
                            isScrollbarSizeKnown: true,
                            defaultScrollbarWidth: sizingInfoRef.current.defaultScrollbarWidth,
                            defaultScrollbarHeight: sizingInfoRef.current.defaultScrollbarHeight
                        };
                    }
                    else {
                        // on the first render that does not specify an external scroller, horizontal and
                        // vertical scrollbars are forced in order to determine default browser sizes
                        availableWidthOffset = newBoxWidth - newContentWidth;
                        sizingInfoRef.current = {
                            isInitialRender: false,
                            contentWidth: newContentWidth,
                            boxWidth: newBoxWidth,
                            contentHeight: newContentHeight,
                            boxHeight: newBoxHeight,
                            isScrollbarSizeKnown: true,
                            defaultScrollbarWidth: availableWidthOffset,
                            defaultScrollbarHeight: newBoxHeight - newContentHeight
                        };
                        setIsScrollbarSizeKnown(true);
                    }
                    defaultScrollbarWidth = sizingInfoRef.current.defaultScrollbarWidth;
                    availableWidth = !isInitialRender || layout === 'fixed' ? newContentWidth : -1;
                }
                if (columnsArray.length > 0) {
                    let newColumnWidths;
                    if (layout !== 'pending') {
                        newColumnWidths = applyLayoutColumnWidths(scrollerElement, viewportInfo, innerTableElement, availableWidthOffset, tableId, layout === 'fixed', sampledColumnNetWidthsRef, availableWidth, columnsArray, columnBorderEdges, borderOffset, columnWidths);
                        if (appliedColumnWidths == null ||
                            !columnWidthsComparator(appliedColumnWidths.netColumnWidths, newColumnWidths.netColumnWidths)) {
                            setAppliedColumnWidths(newColumnWidths);
                        }
                        else {
                            newColumnWidths = undefined;
                        }
                    }
                    // ensure scrollbars are applied correctly - a scrollbar could be needed
                    if (viewportInfo.isExternalScroller) {
                        applyUnderflowStatus(rootElement, tableId, setHasVerticalUnderflow);
                    }
                    else {
                        const innerTableRect = innerTableElement.getBoundingClientRect();
                        applyOverflowStatus(rootElement, scrollerElement, tableId, innerTableRect.width, newContentWidth, innerTableRect.height, newContentHeight, defaultScrollbarWidth, overflowRef, setHasVerticalUnderflow);
                    }
                    if (layout !== 'pending') {
                        if (newColumnWidths != null) {
                            updateStickyColumns(rootElement, scrollerElement, viewportInfo, tableId, isRtl, columnsArray, stickyColumnInfo, newColumnWidths.fullColumnWidths, stickyEdgesState, setStickyEdgesState, viewportInfo.isExternalScroller || overflowRef.current.isHorizontal);
                        }
                        else {
                            _updateStickyEdgesFromResize(scrollerElement);
                        }
                    }
                }
            }
        }
        currentEntry = pendingResizeEntriesRef.current.innerTable;
        if (currentEntry != null) {
            const newBoxWidth = currentEntry.borderBoxSize[0].inlineSize;
            const newBoxHeight = currentEntry.borderBoxSize[0].blockSize;
            // if only an inner table resize occurred, ensure scrollbars are applied correctly
            if (!isOveralSizeHandled &&
                rootElement != null &&
                scrollerElement != null &&
                columnsArray.length > 0 &&
                (newBoxWidth !== 0 || newBoxHeight !== 0)) {
                if (viewportInfo.isExternalScroller) {
                    applyUnderflowStatus(rootElement, tableId, setHasVerticalUnderflow);
                }
                else if (sizingInfoRef.current.isScrollbarSizeKnown) {
                    applyOverflowStatus(rootElement, scrollerElement, tableId, newBoxWidth, sizingInfoRef.current.contentWidth, newBoxHeight, sizingInfoRef.current.contentHeight, sizingInfoRef.current.defaultScrollbarWidth, overflowRef, setHasVerticalUnderflow);
                }
                if (layout !== 'pending') {
                    _updateStickyEdgesFromResize(scrollerElement);
                }
            }
            setInnerTableHeight(newBoxHeight);
        }
        pendingResizeEntriesRef.current = {};
    }, [
        rootRef,
        viewportInfo,
        innerTableRef,
        tableId,
        layout,
        columnsArray,
        stickyColumnInfo,
        columnBorderEdges,
        borderOffset,
        columnWidths,
        appliedColumnWidths,
        stickyEdgesState,
        isRtl,
        _updateStickyEdgesFromResize
    ]);
    // ensure resize observers have access to the latest state information
    const handleResizeCallbackRef = hooks.useRef(handleResizeCallback);
    handleResizeCallbackRef.current = handleResizeCallback;
    // resize observer callback functions are static to avoid hook re-subscribing each render
    const staticHandleScrollerResize = hooks.useCallback((entry) => {
        // only queue up an animation frame if there isn't one already pending
        if (pendingResizeEntriesRef.current.scroller == null ||
            pendingResizeEntriesRef.current.innerTable == null) {
            onResizeScrollerBusyStart();
            window.requestAnimationFrame(() => {
                handleResizeCallbackRef.current();
                onResizeScrollerBusyEnd();
            });
        }
        pendingResizeEntriesRef.current.scroller = entry;
    }, [onResizeScrollerBusyStart, onResizeScrollerBusyEnd]);
    const staticHandleInnerTableResize = hooks.useCallback((entry) => {
        // only queue up an animation frame if there isn't one already pending
        if (pendingResizeEntriesRef.current.scroller == null ||
            pendingResizeEntriesRef.current.innerTable == null) {
            onResizeTableBusyStart();
            window.requestAnimationFrame(() => {
                handleResizeCallbackRef.current();
                onResizeTableBusyEnd();
            });
        }
        pendingResizeEntriesRef.current.innerTable = entry;
    }, [onResizeTableBusyStart, onResizeTableBusyEnd]);
    useResizeObserver.useResizeObserver(viewportInfo.viewportConfig.scroller(), staticHandleScrollerResize);
    useResizeObserver.useResizeObserver(innerTableRef, staticHandleInnerTableResize);
    return {
        columnBorderEdges,
        isLayoutRequired,
        viewportInfo,
        columnsArray,
        appliedColumnWidths,
        sizingInfoRef,
        innerTableHeight,
        hasVerticalUnderflow,
        stickyEdgesState,
        setStickyEdgesState,
        stickyColumnInfo,
        overflowRef,
        scrollerRefCallback
    };
}

const _defaultSelected = {
    row: { all: false, keys: new Set() },
    column: { all: false, keys: new Set() }
};
const _disabledHeaderFooterInteractionKeys = ['enter'];
/**
 * Component that renders data in a flat table.
 */
const Table = compat.forwardRef(function Table({ 'aria-label': ariaLabel, 'aria-labelledby': ariaLabelledBy, getAccessibleRowHeaders, columns, columnOrder, columnWidths, contextMenuConfig, viewportConfig, layout = 'contents', data, getRowKey, hasMore = false, onLoadMore = () => { }, currentCellOverride, onPersistCurrentCell, currentRowVariant = 'none', gridlines, selectionMode, selected = _defaultSelected, onSelectionChange, onRowAction, sortCriterion, onSortCriterionChange, horizontalScrollPositionOverride, verticalScrollPositionOverride, columnResizingIndicator, onColumnResizing, onColumnResize, noDataRenderer, scrollerRef, testId }, ref) {
    const tableId = useId.useId();
    const testIdProps = useTestId.useTestId(testId);
    // rootRef is callback-based to meet useResizeObserver hook's state management requirements
    const [rootRef, setRootRef] = hooks.useState(preact.createRef());
    const rootRefCallback = hooks.useCallback((node) => {
        setRootRef({ current: node });
    }, []);
    const innerTableRef = hooks.useRef(null);
    const { direction, forcedColors } = useUser.useUser();
    const isHighContrast = forcedColors === 'active';
    const isRtl = direction === 'rtl';
    const { tableData, onTableLoadMore } = useDataManager({
        data,
        getRowKey,
        hasMore,
        onLoadMore
    });
    const { columnBorderEdges, isLayoutRequired, viewportInfo, columnsArray, appliedColumnWidths, sizingInfoRef, innerTableHeight, hasVerticalUnderflow, stickyEdgesState, setStickyEdgesState, stickyColumnInfo, overflowRef, scrollerRefCallback } = useSizingManager({
        rootRef,
        innerTableRef,
        tableId,
        tableData,
        viewportConfig,
        externalScrollerRef: scrollerRef,
        layout,
        columns,
        columnOrder,
        columnWidths,
        isRtl,
        isHighContrast
    });
    const cellHasRenderer = hooks.useCallback((cell) => {
        let hasRenderer = false;
        if (cell.type === 'noData') {
            hasRenderer = noDataRenderer != null;
        }
        else if (cell.type !== 'loadMore' && cell.type !== 'loading' && cell.type !== 'pending') {
            for (const column of columnsArray) {
                if (column.key === cell.columnKey) {
                    if (cell.type === 'data') {
                        hasRenderer = column.value.renderer != null;
                    }
                    else if (cell.type === 'header') {
                        hasRenderer = column.value.headerRenderer != null;
                    }
                    else if (cell.type === 'footer') {
                        hasRenderer = column.value.footerRenderer != null;
                    }
                    break;
                }
            }
        }
        return hasRenderer;
    }, [columnsArray, noDataRenderer]);
    const isPendingLayout = layout === 'pending';
    // aria-rowcount includes header and footer rows
    const hasFooters = columnsArray.some((column) => {
        return column.value.footerRenderer != null || column.value.footerText != null;
    });
    const ariaRowCount = hasMore || isPendingLayout ? -1 : tableData.length + (hasFooters ? 2 : 1);
    const ariaColumnCount = Math.max(columnsArray.length, 1);
    const { interactionManagerProps, scrollHandlingProps, onTableSelectionChange, isShowFocusRing, isTabbableMode, currentCell, currentActiveCell, resizeInfoRef, onStartFocusTracking, onFocusStartEdge, onFocusEndEdge, activeStyleColumnInfo, hoverStyleColumnInfo, tooltipContent, contextMenuContext, menuProps, isResizeDialogOpen, setIsResizeDialogOpen, disabledRowInteractionKeys } = useInteractionManager({
        rootRef,
        viewportInfo,
        ref,
        tableId,
        tableData,
        hasMore,
        hasFooters,
        isRtl,
        columnsArray,
        stickyColumnInfo,
        appliedColumnWidths,
        isLayoutRequired,
        sizingInfoRef,
        stickyEdgesState,
        setStickyEdgesState,
        cellHasRenderer,
        horizontalScrollPositionOverride,
        verticalScrollPositionOverride,
        onColumnResizing,
        onColumnResize,
        currentCellOverride,
        onPersistCurrentCell,
        selectionMode,
        selected,
        onSelectionChange,
        onRowAction,
        sortCriterion,
        onSortCriterionChange,
        isPendingLayout,
        contextMenuConfig
    });
    // initialize base Table style classes
    const { classes: themeClasses } = useComponentTheme.useComponentTheme(PRIVATE_Table_themes_redwood_TableTheme.TableRedwoodTheme, {
        pendingLayout: isPendingLayout ? 'isPendingLayout' : 'notPendingLayout',
        showFocusRing: isShowFocusRing ? 'isShowFocusRing' : 'notShowFocusRing',
        externalScroller: viewportInfo.isExternalScroller ? 'isExternalScroller' : 'notExternalScroller'
    });
    let scrollerStyle;
    let scrollerPadding = '';
    const scrollerClassArray = [PRIVATE_Table_themes_Table_css.scrollerStyles.base];
    if (viewportInfo.isExternalScroller) {
        scrollerClassArray.push(PRIVATE_Table_themes_Table_css.scrollerStyles.externalScroller);
    }
    else if (!sizingInfoRef.current.isScrollbarSizeKnown) {
        scrollerClassArray.push(PRIVATE_Table_themes_Table_css.scrollerStyles.forceScroll);
    }
    else {
        if (overflowRef.current.isHorizontal) {
            scrollerClassArray.push(PRIVATE_Table_themes_Table_css.scrollerStyles.horizontalScroll);
        }
        else {
            scrollerClassArray.push(PRIVATE_Table_themes_Table_css.scrollerStyles.noHorizontalScroll);
        }
        if (overflowRef.current.isVertical) {
            scrollerClassArray.push(PRIVATE_Table_themes_Table_css.scrollerStyles.verticalScroll);
        }
        else {
            scrollerClassArray.push(PRIVATE_Table_themes_Table_css.scrollerStyles.noVerticalScroll);
            scrollerPadding = `padding-inline-end: ${sizingInfoRef.current.defaultScrollbarWidth}px;`;
        }
    }
    // hide the table contents when layout is required and otherwise valid
    if (isLayoutRequired && columnsArray.length > 0) {
        scrollerStyle = `${scrollerPadding}opacity:0.001;`;
    }
    else {
        scrollerStyle = scrollerPadding;
    }
    const scrollerClasses = classNames.classNames(scrollerClassArray);
    const classes = classNames.classNames([themeClasses]);
    const tableClasses = classNames.classNames([PRIVATE_Table_themes_Table_css.innerTableStyles.base]);
    const startStickyEdge = stickyEdgesState.start;
    const endStickyEdge = stickyEdgesState.end;
    const hasVerticalGridlines = gridlines?.vertical === 'visible';
    const hasHorizontalGridlines = gridlines?.horizontal !== 'hidden';
    const isRowSelectionEnabled = selectionMode?.row === 'single' ||
        selectionMode?.row === 'multiple' ||
        selectionMode?.row === 'multipleToggle';
    const isColumnSelectionEnabled = selectionMode?.column === 'single' || selectionMode?.column === 'multiple';
    const supportsMultipleSelection = selectionMode?.column === 'multiple' ||
        selectionMode?.row === 'multiple' ||
        selectionMode?.row === 'multipleToggle';
    const getTableBodyProps = () => {
        return {
            rootRef: rootRef,
            viewportInfo: viewportInfo,
            tableId: tableId,
            isValidRender: columnsArray.length > 0,
            tableData: tableData,
            columnsArray: columnsArray,
            getAccessibleRowHeaders: getAccessibleRowHeaders,
            hasVerticalGridlines: hasVerticalGridlines,
            hasHorizontalGridlines: hasHorizontalGridlines,
            hasFooters: hasFooters,
            hasVerticalUnderflow: hasVerticalUnderflow,
            selected: selected,
            isRowSelectionEnabled: isRowSelectionEnabled,
            isSingleRowSelectionEnabled: selectionMode?.row === 'single',
            activeCell: currentActiveCell,
            currentRowKey: currentCell?.type === 'data' ? currentCell.rowKey : undefined,
            currentRowVariant: currentRowVariant,
            isShowFocusRing: isShowFocusRing,
            isTabbableMode: isTabbableMode,
            hasMore: hasMore,
            onLoadMore: onTableLoadMore,
            noDataRenderer: noDataRenderer,
            disabledInteractionKeys: disabledRowInteractionKeys,
            onSelectionChange: onTableSelectionChange,
            startStickyEdge: startStickyEdge,
            endStickyEdge: endStickyEdge,
            firstStickyColumnIndex: stickyColumnInfo.firstStickyColumnIndex,
            finalStickyColumnIndex: stickyColumnInfo.finalStickyColumnIndex,
            columnBorderEdges: columnBorderEdges,
            isRtl: isRtl,
            isHighContrast: isHighContrast
        };
    };
    const getTableColGroupProps = () => {
        let columnWidthsArray;
        if (!isLayoutRequired && appliedColumnWidths?.realColumnWidths != null) {
            columnWidthsArray = appliedColumnWidths.realColumnWidths;
        }
        else if (layout === 'fixed') {
            // default to 100px for each column when layout is not yet available
            columnWidthsArray = [];
            for (let i = 0; i < columnsArray.length; i++) {
                columnWidthsArray[i] = 100;
            }
        }
        else {
            columnWidthsArray = [];
            for (let i = 0; i < columnsArray.length; i++) {
                columnWidthsArray[i] = undefined;
            }
        }
        return {
            tableId: tableId,
            isRendered: columnsArray.length > 0,
            columnWidthsArray: columnWidthsArray
        };
    };
    const getTableHeaderProps = () => {
        return {
            tableId: tableId,
            isRendered: columnsArray.length > 0,
            columnsArray: columnsArray,
            hasVerticalGridlines: hasVerticalGridlines,
            activeKey: currentActiveCell?.type === 'header' ? currentActiveCell.columnKey : undefined,
            isTabbableMode: isTabbableMode,
            selectedColumnKeys: selected.column,
            selectedRowKeys: selected.row,
            isColumnSelectionEnabled: isColumnSelectionEnabled,
            isRowSelectionEnabled: isRowSelectionEnabled,
            disabledInteractionKeys: _disabledHeaderFooterInteractionKeys,
            onSelectionChange: onTableSelectionChange,
            isForceSortIcons: layout === 'contents' && isLayoutRequired,
            activeStyleKey: activeStyleColumnInfo?.isHeader ? activeStyleColumnInfo?.key : undefined,
            hoverStyleKey: hoverStyleColumnInfo?.isHeader ? hoverStyleColumnInfo?.key : undefined,
            sortCriterion: sortCriterion,
            onSortCriterionChange: onSortCriterionChange,
            isShowFocusRing: isShowFocusRing,
            stickyTopOffset: viewportInfo.viewportConfig.scrollerOffsetTop,
            startStickyEdge: startStickyEdge,
            endStickyEdge: endStickyEdge,
            firstStickyColumnIndex: stickyColumnInfo.firstStickyColumnIndex,
            finalStickyColumnIndex: stickyColumnInfo.finalStickyColumnIndex,
            columnBorderEdges: columnBorderEdges,
            isResizeHover: resizeInfoRef.current.isResizeHover,
            isRtl: isRtl,
            isHighContrast: isHighContrast
        };
    };
    const getTableFooterProps = () => {
        return {
            tableId: tableId,
            isRendered: hasFooters,
            columnsArray: columnsArray,
            hasVerticalGridlines: hasVerticalGridlines,
            activeKey: currentActiveCell?.type === 'footer' ? currentActiveCell.columnKey : undefined,
            isTabbableMode: isTabbableMode,
            selectedColumnKeys: selected.column,
            isColumnSelectionEnabled: isColumnSelectionEnabled,
            activeStyleKey: !activeStyleColumnInfo?.isHeader ? activeStyleColumnInfo?.key : undefined,
            hoverStyleKey: !hoverStyleColumnInfo?.isHeader ? hoverStyleColumnInfo?.key : undefined,
            isShowFocusRing: isShowFocusRing,
            disabledInteractionKeys: _disabledHeaderFooterInteractionKeys,
            stickyBottomOffset: viewportInfo.viewportConfig.scrollerOffsetBottom,
            startStickyEdge: startStickyEdge,
            endStickyEdge: endStickyEdge,
            firstStickyColumnIndex: stickyColumnInfo.firstStickyColumnIndex,
            finalStickyColumnIndex: stickyColumnInfo.finalStickyColumnIndex,
            columnBorderEdges: columnBorderEdges,
            dataRowCount: tableData.length,
            isRtl: isRtl,
            isHighContrast: isHighContrast
        };
    };
    const getTableDragIndicator = () => {
        if (columnResizingIndicator != null &&
            !isLayoutRequired &&
            appliedColumnWidths?.fullColumnWidths != null) {
            let position = 0;
            for (let i = 0; i < columnsArray.length; i++) {
                position += appliedColumnWidths.fullColumnWidths[i];
                if (columnsArray[i].key === columnResizingIndicator.key) {
                    if (columnResizingIndicator.delta != null) {
                        position += columnResizingIndicator.delta;
                    }
                    break;
                }
            }
            return jsxRuntime.jsx(TableDragIndicator, { position: position, isRtl: isRtl, height: innerTableHeight });
        }
        return undefined;
    };
    const getTableStyle = () => {
        if (!isLayoutRequired && appliedColumnWidths?.realColumnWidths != null) {
            let totalWidth = 0;
            for (let i = 0; i < appliedColumnWidths.realColumnWidths.length; i++) {
                totalWidth += appliedColumnWidths.realColumnWidths[i];
            }
            return `width:${totalWidth}px;table-layout:fixed;`;
        }
        else if (columnsArray.length > 0) {
            if (layout === 'fixed') {
                // default to 100px for each column when layout is not yet available
                return `width:${columnsArray.length * 100}px;table-layout:fixed;`;
            }
            else {
                // shrink table down as much as possible when a 'contents' layout is required, otherwise
                // the sampled column widths will not reflect the true weight sizes with line-clamping
                return 'width:max-content;will-change:width;';
            }
        }
        // no columns are present
        return 'width:100%;';
    };
    const skeletonStyles = isHighContrast ? PRIVATE_Table_themes_TableSkeletonStyles_css.tableSkeletonStylesHC : PRIVATE_Table_themes_TableSkeletonStyles_css.tableSkeletonStyles;
    const getPendingLayoutSkeletons = () => {
        return isPendingLayout ? (jsxRuntime.jsx("div", { class: skeletonStyles.pendingLayout, children: jsxRuntime.jsx("table", { role: 'presentation', style: 'width:100%;table-layout:fixed;', children: jsxRuntime.jsx("tbody", { role: 'presentation', children: jsxRuntime.jsx(TableSkeletonRow, { tableId: tableId, hasTabIndex: currentActiveCell?.type === 'pending', colspan: ariaColumnCount, isPendingLayout: true, isShowFocusRing: false, isHighContrast: isHighContrast }) }) }) })) : undefined;
    };
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs("div", { ...testIdProps, ref: rootRefCallback, "aria-colcount": ariaColumnCount, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-rowcount": ariaRowCount, ...(supportsMultipleSelection ? { 'aria-multiselectable': true } : {}), class: classes, id: tableId, role: 'grid', tabIndex: currentActiveCell != null ? -1 : 0, ...interactionManagerProps, children: [jsxRuntime.jsxs("div", { ref: scrollerRefCallback, class: scrollerClasses, role: 'rowgroup', style: scrollerStyle, tabIndex: -1, ...scrollHandlingProps, children: [jsxRuntime.jsxs(FocusTracker.FocusTracker, { isDisabled: !isTabbableMode, onFocusStartEdge: onFocusStartEdge, onFocusEndEdge: onFocusEndEdge, onStartTracking: onStartFocusTracking, children: [jsxRuntime.jsx(TabbableModeContext.TabbableModeContext.Provider, { value: { isTabbable: isTabbableMode }, children: jsxRuntime.jsxs("table", { ref: innerTableRef, "aria-hidden": isPendingLayout ? true : undefined, class: tableClasses, role: 'presentation', style: getTableStyle(), "data-oj-table-inner-table": tableId, children: [jsxRuntime.jsx(TableColGroup, { ...getTableColGroupProps() }), jsxRuntime.jsx(TableHeader, { ...getTableHeaderProps() }), jsxRuntime.jsx(TableBody, { ...getTableBodyProps() }), jsxRuntime.jsx(TableFooter, { ...getTableFooterProps() })] }) }), getTableDragIndicator()] }), tooltipContent] }), getPendingLayoutSkeletons()] }), contextMenuConfig != null && contextMenuContext != null && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(TableContextMenu, { ...menuProps, contextMenuConfig: contextMenuConfig, contextMenuContext: contextMenuContext }), isResizeDialogOpen &&
                        currentActiveCell?.columnKey != null &&
                        appliedColumnWidths != null ? (jsxRuntime.jsx(TableResizeColumnDialog, { isOpen: isResizeDialogOpen, columnKey: currentActiveCell.columnKey, appliedColumnWidths: appliedColumnWidths, onColumnResize: onColumnResize, setIsResizeDialogOpen: setIsResizeDialogOpen })) : undefined] }))] }));
});

exports.Table = Table;
//# sourceMappingURL=Table-10c10b94.js.map
