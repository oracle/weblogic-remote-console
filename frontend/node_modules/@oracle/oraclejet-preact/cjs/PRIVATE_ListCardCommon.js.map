{"version":3,"file":"PRIVATE_ListCardCommon.js","sources":["../../src/PRIVATE_ListCardCommon/useCurrentItemOverride.ts"],"sourcesContent":["import { useRef, useMemo, useState, useEffect } from 'preact/hooks';\nimport { CurrentItemProps, CurrentKeyDetail, Item } from '../UNSAFE_Collection';\nimport { useReorderableContext } from '../hooks/PRIVATE_useReorderable/useReorderableContext';\n\n/**\n * This hook converts the new API (i.e. currentItemOverride and onPersistCurrentItem) back to\n * the old API (i.e. currentKey and onCurrentKeyChange), keeps the internal current item, and\n * also triggers an update when a new currentItemOverride is passed by the app\n *\n * @param currentItemOverride\n * @param onPersistCurrentItem\n */\nexport const useCurrentItemOverride = <K extends string | number>(\n  currentItemOverride: CurrentItemProps<K>['currentItemOverride'],\n  onPersistCurrentItem: CurrentItemProps<K>['onPersistCurrentItem']\n) => {\n  // the internal state of current item\n  const [currentItem, setCurrentItem] = useState<Item<K>>();\n  // track the currentItemOverride props\n  const currentItemOverrideRef = useRef<Item<K>>();\n  // whether the current item is overridden by the app\n  const isCurrentItemOverridden = useRef(false);\n\n  // if reorder is enabled, need to update the context here when current item is changed\n  const reorderContext = useReorderableContext();\n\n  // intercept onPersistCurrentItem calls to ensure internal state is updated appropriately\n  const handleCurrentItemChanged = useMemo(() => {\n    return (detail: CurrentKeyDetail<K>) => {\n      const rowKey = detail.value;\n      setCurrentItem({ rowKey });\n      onPersistCurrentItem?.(detail);\n      if (reorderContext?.currentItemKey != null) {\n        reorderContext.currentItemKey.current = rowKey;\n      }\n    };\n  }, [onPersistCurrentItem, reorderContext?.currentItemKey]);\n\n  // ensure any new currentItemOverride settings are applied only on that render\n  // (same as how Table handles the changes)\n  if (currentItemOverrideRef.current !== currentItemOverride) {\n    currentItemOverrideRef.current = currentItemOverride;\n    if (currentItem?.rowKey !== currentItemOverride?.rowKey) {\n      isCurrentItemOverridden.current = true;\n      handleCurrentItemChanged({ value: currentItemOverride?.rowKey as K });\n    }\n  }\n\n  useEffect(() => {\n    isCurrentItemOverridden.current = false;\n  });\n\n  return {\n    currentKey: currentItem?.rowKey,\n    onCurrentKeyChange: handleCurrentItemChanged,\n    isCurrentItemOverridden: isCurrentItemOverridden.current\n  };\n};\n"],"names":["useState","useRef","useReorderableContext","useMemo","useEffect"],"mappings":";;;;;;;;;;AAIA;;;;;;;AAOG;MACU,sBAAsB,GAAG,CACpC,mBAA+D,EAC/D,oBAAiE,KAC/D;;IAEF,MAAM,CAAC,WAAW,EAAE,cAAc,CAAC,GAAGA,cAAQ,EAAW,CAAC;;AAE1D,IAAA,MAAM,sBAAsB,GAAGC,YAAM,EAAW,CAAC;;AAEjD,IAAA,MAAM,uBAAuB,GAAGA,YAAM,CAAC,KAAK,CAAC,CAAC;;AAG9C,IAAA,MAAM,cAAc,GAAGC,2CAAqB,EAAE,CAAC;;AAG/C,IAAA,MAAM,wBAAwB,GAAGC,aAAO,CAAC,MAAK;QAC5C,OAAO,CAAC,MAA2B,KAAI;AACrC,YAAA,MAAM,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC;AAC5B,YAAA,cAAc,CAAC,EAAE,MAAM,EAAE,CAAC,CAAC;AAC3B,YAAA,oBAAoB,GAAG,MAAM,CAAC,CAAC;AAC/B,YAAA,IAAI,cAAc,EAAE,cAAc,IAAI,IAAI,EAAE;AAC1C,gBAAA,cAAc,CAAC,cAAc,CAAC,OAAO,GAAG,MAAM,CAAC;aAChD;AACH,SAAC,CAAC;KACH,EAAE,CAAC,oBAAoB,EAAE,cAAc,EAAE,cAAc,CAAC,CAAC,CAAC;;;AAI3D,IAAA,IAAI,sBAAsB,CAAC,OAAO,KAAK,mBAAmB,EAAE;AAC1D,QAAA,sBAAsB,CAAC,OAAO,GAAG,mBAAmB,CAAC;QACrD,IAAI,WAAW,EAAE,MAAM,KAAK,mBAAmB,EAAE,MAAM,EAAE;AACvD,YAAA,uBAAuB,CAAC,OAAO,GAAG,IAAI,CAAC;YACvC,wBAAwB,CAAC,EAAE,KAAK,EAAE,mBAAmB,EAAE,MAAW,EAAE,CAAC,CAAC;SACvE;KACF;IAEDC,eAAS,CAAC,MAAK;AACb,QAAA,uBAAuB,CAAC,OAAO,GAAG,KAAK,CAAC;AAC1C,KAAC,CAAC,CAAC;IAEH,OAAO;QACL,UAAU,EAAE,WAAW,EAAE,MAAM;AAC/B,QAAA,kBAAkB,EAAE,wBAAwB;QAC5C,uBAAuB,EAAE,uBAAuB,CAAC,OAAO;KACzD,CAAC;AACJ;;;;"}