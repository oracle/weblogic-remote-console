/* @oracle/oraclejet-preact: undefined */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
require('./FormFieldContext-69fe83d2.js');
var useFormFieldContext = require('./useFormFieldContext-4632eb73.js');
var classNames = require('./classNames-c14c6ef3.js');
require('./FormContext-d1d05967.js');
var useFormContext = require('./useFormContext-a794f7b6.js');
var useComponentTheme = require('./useComponentTheme-082fc8e4.js');
require('./TabbableModeContext-e99d527e.js');
require('./LayerHost-aee0e070.js');
require('preact/compat');


require('./UNSAFE_UserAssistance/themes/redwood/UserAssistanceVariants.css.js');
require('./Flex-6ca216a7.js');


require('./UNSAFE_MessageBanner/themes/redwood/MessageBannerVariants.css.js');
require('preact');
var useTooltip = require('./useTooltip-8728f2ff.js');
var useScale = require('./useScale-adc62f41.js');
var useDensity = require('./useDensity-022a8f80.js');


require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js');
require('./tooltipUtils-ae48fed6.js');

var clientHints = require('./clientHints-c40c5250.js');
require('./IconButton-217314e6.js');

require('./MessageFormattingUtils-539d75b0.js');
require('./logger-2b636482.js');
require('./TransitionGroup-b239d98f.js');
require('./MessagesContext-4e939750.js');



require('./UNSAFE_ComponentMessage/themes/redwood/ComponentMessageVariants.css.js');
require('./InputGroupContext-05f2a46f.js');
require('./Popup-080e8f67.js');
require('./UNSAFE_Separator/themes/SeparatorStyles.css.js');
var CompactLabelAssistance = require('./CompactLabelAssistance-d5bbeb5e.js');

require('./UNSAFE_Popup/themes/redwood/PopupVariants.css.js');
var truncationUtils = require('./truncationUtils-2d44b04b.js');
var UNSAFE_TextField_themes_redwood_TextFieldTheme = require('./UNSAFE_TextField/themes/redwood/TextFieldTheme.js');
var UNSAFE_Label_themes_redwood_LabelTheme = require('./UNSAFE_Label/themes/redwood/LabelTheme.js');

/**
 * Hook that detects truncated text when you hover the mouse over a label.
 */
const useDetectLabelTruncation = ({ isDisabled = false, rootRef }) => {
    const [isTextTruncated, setIsTextTruncated] = hooks.useState(false);
    const mouseOverTimerRef = hooks.useRef();
    const handleMouseOver = hooks.useCallback(() => {
        clearTimeout(mouseOverTimerRef.current);
        // Determine if the label is truncated after the user hovers over it.
        mouseOverTimerRef.current = setTimeout(() => {
            const isTruncated = truncationUtils.detectTruncation(rootRef);
            setIsTextTruncated(isTruncated);
        }, 1000);
    }, [rootRef]);
    const handleMouseOut = hooks.useCallback(() => {
        clearTimeout(mouseOverTimerRef.current);
        mouseOverTimerRef.current = undefined;
        setIsTextTruncated(false);
    }, []);
    const detectTruncationProps = !isDisabled
        ? {
            onMouseOver: handleMouseOver,
            onMouseOut: handleMouseOut
        }
        : {};
    return { detectTruncationProps, isTextTruncated };
};

// When you mouse over the label, useDetectLabelTruncation determines if the text is truncated
// and shows a tooltip. When you move the mouse outside of the label, the tooltip goes away.
const TruncatingLabel = ({ children: text, labelRef, hasValue, isFocused, ...labelProps }) => {
    const labelElementRef = hooks.useRef(null);
    const ref = labelRef ?? labelElementRef;
    const { detectTruncationProps, isTextTruncated } = useDetectLabelTruncation({ rootRef: ref });
    // Calculate the tooltip offset so it looks like it's relative to the field instead of the label.
    const scale = useScale.useScale() || 'lg';
    const density = useDensity.useDensity() || 'standard';
    const scaleMap = { sm: 3, md: 3.5, lg: 4 };
    const xUnits = scaleMap[scale];
    const densityUnits = density === 'standard' ? 0 : -xUnits;
    const mainAxisMap = {
        sm: Math.max(xUnits + densityUnits, 3),
        md: Math.max(1.14 * xUnits + densityUnits, 3.5),
        lg: 2 * xUnits + densityUnits
    };
    const mainAxis = hasValue || isFocused ? mainAxisMap[scale] + 5 : Math.max(5.75 * xUnits + densityUnits, 16);
    const { tooltipContent, tooltipProps } = useTooltip.useTooltip({
        offset: {
            mainAxis,
            crossAxis: -4 * xUnits - 1
        },
        position: 'top-start',
        text,
        isDisabled: !isTextTruncated
    });
    const { 'aria-describedby': notNeeded, ...tooltipEventHandlerProps } = tooltipProps;
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("label", { ref: ref, ...detectTruncationProps, ...labelProps, ...tooltipEventHandlerProps, children: text }), tooltipContent] }));
};
const StyledLabel = ({ hasValue, readonly, disabled, isFocused, isRequiredShown, labelRef, helpIconId, helpSourceLink, helpSourceText, userAssistanceDensity = 'reflow', variant = 'inside', parentComponentVariant = 'textField', ...props }) => {
    const { isFormLayout, isReadonly: isReadonlyForm, labelWrapping } = useFormContext.useFormContext();
    const isInside = variant === 'inside';
    const isTextField = parentComponentVariant === 'textField';
    const clientHints$1 = clientHints.getClientHints();
    // JET-73197: Truncated tooltips for core pack.
    // Determine whether to render a TruncatingLabel, which is measured to determine if
    // the label's content exceeds the size of the label itself, i.e. it's truncated.
    // We only want to do this for inside label edge, not disabled, and the textField variant.
    const useTruncatingLabel = isInside && !disabled && parentComponentVariant === 'textField';
    // because variants have to match strings, we have to take any boolean props and convert
    // them to a string value, (ie prefixed with "is" or "non")
    const { classes, styles: { safariAfter, uaDensityCompactLabel, uaDensityCompactLabelStart, uaDensityCompactLabelTopInside } } = useComponentTheme.useComponentTheme(UNSAFE_Label_themes_redwood_LabelTheme.LabelRedwoodTheme, {
        labelWrapping,
        position: variant,
        inside: isInside ? 'isInside' : 'notInside',
        inEnabledForm: isFormLayout && !isReadonlyForm ? 'isInEnabledForm' : 'notInEnabledForm',
        readonly: readonly ? 'isReadonly' : 'notReadonly',
        focused: isFocused ? 'isFocused' : 'nonFocused',
        formLayout: isFormLayout ? 'isFormLayout' : 'nonFormLayout',
        readonlyForm: isReadonlyForm ? 'isReadonlyForm' : 'notReadonlyForm',
        textField: isTextField ? 'isTextField' : 'notTextField',
        value: hasValue ? 'hasValue' : 'noValue',
        valueOrFocus: hasValue || isFocused ? 'hasValueOrFocus' : 'noValueOrFocus',
        animatedWhenInside: isTextField ? 'isAnimated' : 'notAnimated',
        disabled: isTextField && disabled ? 'isDisabled' : 'nonDisabled',
        userAssistanceDensity
    });
    const { baseTheme: textFieldTheme } = useComponentTheme.useComponentTheme(UNSAFE_TextField_themes_redwood_TextFieldTheme.TextFieldRedwoodTheme);
    // JET-74754: Fix dual tooltips on Safari. This prevents safari from putting
    // up its own tooltip for truncated labels.
    const afterClass = clientHints$1.browser === 'safari' ? safariAfter : undefined;
    // TODO: We need to decide whether to standardize on 'class' or 'className'.  Otherwise, we'll
    // run into issues destructuring style interpolations, for example having to concatenate both.
    const compactLabelStyles = classNames.classNames([
        afterClass,
        uaDensityCompactLabel,
        variant === 'start' ? uaDensityCompactLabelStart : uaDensityCompactLabelTopInside
    ]);
    const compactUADLabel = useTruncatingLabel ? (jsxRuntime.jsx(TruncatingLabel, { ...props, class: compactLabelStyles, hasValue: hasValue, isFocused: isFocused, labelRef: labelRef })) : (jsxRuntime.jsx("label", { ...props, class: compactLabelStyles }));
    return userAssistanceDensity === 'compact' ? (jsxRuntime.jsxs("div", { class: classNames.classNames([classes, textFieldTheme]), children: [variant !== 'start' && compactUADLabel, jsxRuntime.jsx(CompactLabelAssistance.CompactLabelAssistance, { isRequiredShown: isRequiredShown, helpIconId: helpIconId, helpSourceLink: helpSourceLink, helpSourceText: helpSourceText, labelEdge: variant === 'top' || variant === 'start' ? variant : 'inside' }), variant === 'start' && compactUADLabel] })) : useTruncatingLabel ? (jsxRuntime.jsx(TruncatingLabel, { ...props, class: classNames.classNames([afterClass, classes, textFieldTheme]), hasValue: hasValue, isFocused: isFocused, labelRef: labelRef })) : (jsxRuntime.jsx("label", { "aria-disabled": disabled ? 'true' : undefined, ...props, class: classNames.classNames([afterClass, classes, textFieldTheme]) }));
};
const Label = ({ forId, ...props }) => {
    const { hasValue, isDisabled, isFocused, isReadonly } = useFormFieldContext.useFormFieldContext();
    return (jsxRuntime.jsx(StyledLabel, { for: forId, hasValue: hasValue, disabled: isDisabled, isFocused: isFocused, readonly: isReadonly, ...props }));
};

exports.Label = Label;
//# sourceMappingURL=Label-afee809f.js.map
