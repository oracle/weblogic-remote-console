/* @oracle/oraclejet-preact: undefined */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
var positionUtils = require('./positionUtils-a780137e.js');
var Floating = require('./Floating-5a704a27.js');
var Layer = require('./Layer-28b1afce.js');
require('preact/compat');
require('./LayerHost-aee0e070.js');
var tabbableUtils = require('./tabbableUtils-7e41d383.js');
var clientHints = require('./clientHints-c40c5250.js');
var useAnimation = require('./useAnimation-fb11e4cc.js');
var animationUtils = require('./animationUtils-54852d03.js');
var useUser = require('./useUser-f900ddf1.js');
var useTestId = require('./useTestId-9093a54b.js');
var useBreakpointValues = require('./useBreakpointValues-77cb15bb.js');
var useResizeObserver = require('./useResizeObserver-a9e97180.js');
var useComponentTheme = require('./useComponentTheme-082fc8e4.js');
var classNames = require('./classNames-c14c6ef3.js');
var UNSAFE_DrawerLayout_themes_redwood_DrawerLayoutTheme = require('./UNSAFE_DrawerLayout/themes/redwood/DrawerLayoutTheme.js');
require('./useFloating-13101293.js');
require('./refUtils-a9872e75.js');
require('./useOutsideClick-c3802f86.js');
require('./arrayUtils-7d8dcfc3.js');
require('./useModal-0739a528.js');
require('./utils-a66430fc.js');
require('./themeContract.css-a53fd740.js');
require('./colorUtils-01f3caa2.js');
require('./_curry1-e8f0d7ea.js');
require('./UNSAFE_Floating/themes/redwood/FloatingTheme.js');
require('./UNSAFE_Floating/themes/FloatingStyles.css.js');

require('./UNSAFE_Floating/themes/redwood/FloatingBaseTheme.css.js');

require('./UNSAFE_Floating/themes/redwood/FloatingVariants.css.js');
require('./vanilla-extract-recipes-createRuntimeFn.esm-d1301b2d.js');
require('./vanilla-extract-dynamic.esm-2e1b7c25.js');
require('./UNSAFE_Floating/themes/FloatingContract.css.js');
require('./useUnsafeDomElementRef-f22a2f0c.js');
require('./unsafeDomAccess-c3a492f0.js');
require('./UNSAFE_Layer/themes/LayerStyles.css.js');

require('./useThemeInterpolations-4faece98.js');
require('./useColorScheme-23e4aab4.js');
require('./useScale-adc62f41.js');
require('./theme-dfd6a9fe.js');
require('./Theme-f06687af.js');
require('./mergeInterpolations-6727b536.js');
require('./mergeDeepWithKey-210b024d.js');
require('./_curry3-18677bca.js');
require('./_curry2-c15d89cd.js');
require('./_isObject-28636267.js');
require('./useDensity-022a8f80.js');
require('./index-15e13649.js');
require('preact');
require('./UNSAFE_Layer/themes/LayerHostStyles.css.js');

require('./head-68d0992f.js');
require('./_arity-c228159c.js');
require('./_isArray-73160ad5.js');
require('./_isString-f4443c9e.js');
require('./useBreakpoints-f5c06998.js');
require('./useAddBusyState-d19ae1fa.js');
require('./BusyStateContext-86f40d3c.js');
require('./useBusyStateContext-362eee2a.js');
require('./logger-2b636482.js');
require('./UNSAFE_DrawerLayout/themes/DrawerLayoutStyles.css.js');

require('./UNSAFE_DrawerLayout/themes/redwood/DrawerLayoutBaseTheme.css.js');

require('./UNSAFE_DrawerLayout/themes/redwood/DrawerLayoutVariants.css.js');

/**
 * A drawer layout adds expandable side contents (drawers) alongside some primary content.
 *
 * These drawers automatically swap 'reflow' and 'overlay' display mode based on width of the page and can be placed at the 'start', 'end' or 'bottom' edge.
 */
const DrawerLayout = ({ children, startDrawer, endDrawer, bottomDrawer, isStartOpen = false, isEndOpen = false, isBottomOpen = false, startDisplay, endDisplay, bottomDisplay, onClose, onTransitionEnd, testId // ...props
 }) => {
    // Constants
    const zeroPx = '0px';
    const verticalBreakpoint = 600;
    const stringStart = 'start';
    const stringEnd = 'end';
    const stringBottom = 'bottom';
    const stringInitial = 'initial';
    const stringOpening = 'opening';
    const stringOpen = 'open';
    const stringClosing = 'closing';
    const stringUnmounted = 'unmounted';
    const stringFullOverlay = 'full-overlay';
    const stringOverlay = 'overlay';
    const stringReflow = 'reflow';
    const stringHidden = 'hidden';
    const stringVisible = 'visible';
    // Initialize states
    const [startDrawerStatus, setStartDrawerStatus] = hooks.useState(isStartOpen ? stringInitial : stringUnmounted);
    const [endDrawerStatus, setEndDrawerStatus] = hooks.useState(isEndOpen ? stringInitial : stringUnmounted);
    const [bottomDrawerStatus, setBottomDrawerStatus] = hooks.useState(isBottomOpen ? stringInitial : stringUnmounted);
    const [startVisibility, setStartVisibility] = hooks.useState(stringHidden);
    const [endVisibility, setEndVisibility] = hooks.useState(stringHidden);
    const [bottomVisibility, setBottomVisibility] = hooks.useState(stringHidden);
    const [startOffset, setStartOffset] = hooks.useState();
    const [endOffset, setEndOffset] = hooks.useState();
    const [bottomOffset, setBottomOffset] = hooks.useState();
    // Breakpoints:
    // sm: 0-600px (full-overlay)
    // md: 600-1024px (overlay)
    // lg: >1024px (reflow)
    const displayMode = useBreakpointValues.useBreakpointValues({
        sm: stringFullOverlay,
        md: stringOverlay,
        lg: stringReflow
    });
    const [viewportDisplayModeHorizontal, setViewportDisplayModeHorizontal] = hooks.useState(displayMode);
    const [viewportDisplayModeVertical, setViewportDisplayModeVertical] = hooks.useState(displayMode);
    // Refs
    const rootRef = hooks.useRef(null);
    const centerRef = hooks.useRef(null);
    const startDrawerRef = hooks.useRef(null);
    const endDrawerRef = hooks.useRef(null);
    const bottomDrawerRef = hooks.useRef(null);
    const placementOfLastlyFocusedRef = hooks.useRef(null);
    const indexOfLastlyFocusedRef = hooks.useRef(null);
    const stretchedOverlayClippingRef = hooks.useRef(null);
    const startLauncherRef = hooks.useRef(null);
    const endLauncherRef = hooks.useRef(null);
    const bottomLauncherRef = hooks.useRef(null);
    const elementWithFocusBeforeDrawerClosesRef = hooks.useRef(null);
    const [startResolvedDisplayMode, setStartResolvedDisplayMode] = hooks.useState(null);
    const [endResolvedDisplayMode, setEndResolvedDisplayMode] = hooks.useState(null);
    const [bottomResolvedDisplayMode, setBottomResolvedDisplayMode] = hooks.useState(null);
    const getDrawerEl = hooks.useCallback((placement) => {
        return getDrawerRef(placement).current;
    }, []);
    const getPlacementOfDrawerWithFocus = hooks.useCallback(() => {
        const startDrawerEl = getDrawerEl(stringStart);
        const endDrawerEl = getDrawerEl(stringEnd);
        const bottomDrawerEl = getDrawerEl(stringBottom);
        const activeElement = tabbableUtils.getActiveElement();
        if (startDrawerEl && startDrawerEl.contains(activeElement)) {
            return stringStart;
        }
        else if (endDrawerEl && endDrawerEl.contains(activeElement)) {
            return stringEnd;
        }
        else if (bottomDrawerEl && bottomDrawerEl.contains(activeElement)) {
            return stringBottom;
        }
        else
            return null;
    }, [getDrawerEl]);
    const triggerFocusTransferStrategy = hooks.useCallback(() => {
        // Focus strategy - find focused element.
        // Save what drawer and what element had focus before it was eventually conditionally re-rendered
        // In 'auto' display mode we swap 'reflow' and 'overlay' automatically
        // When this change happens, conditional rendering mechanism destroys
        // reflow drawer DOM and creates overlay drawer DOM. This, of course,
        // applies vice versa. In such cases focus gets lost.
        // In DOM destroy cases focus is usually moved to <body>.
        // In standard open cases we trigger focus strategy from animationEnd callback.
        // However, in 'reflow' <> 'overlay' cases animation hook is not used/wanted at all.
        // In addition, we should keep focus on the lastly/customly focused elemenet,
        // e.g. the lastly focused element of a form
        // 1. useBreakpoint hook is triggered even there's no drawer present.
        // Handle focus only if there's at least one drawer open
        if (isStartOpen || isEndOpen || isBottomOpen) {
            // 2. Focus might not be in drawers.
            // In modeless cases user can bring the focus out of open drawers by clicking outside them.
            // Check whether focused element lives in a drawer (one of drawers).
            // Do not handle focus at all if it is not within a drawer.
            // Note: returns null if focus is not within a drawer
            const activeElementPlacement = getPlacementOfDrawerWithFocus();
            if (activeElementPlacement) {
                // Save in which drawer focus lives (save its placement).
                placementOfLastlyFocusedRef.current = activeElementPlacement;
                // 3. Focus was detected in a particular drawer
                // Save index of this element
                const allTabbables = tabbableUtils.allTabbableElements(getDrawerRef(placementOfLastlyFocusedRef.current).current, true);
                // Save index of lastly focused element
                indexOfLastlyFocusedRef.current = allTabbables.indexOf(tabbableUtils.getActiveElement());
            }
        }
    }, [getPlacementOfDrawerWithFocus, isStartOpen, isBottomOpen, isEndOpen]);
    const isDrawerOpen = hooks.useCallback((placement) => {
        let isOpen = false;
        switch (placement) {
            case stringStart:
                isOpen = isStartOpen;
                break;
            case stringEnd:
                isOpen = isEndOpen;
                break;
            case stringBottom:
                isOpen = isBottomOpen;
                break;
        }
        return isOpen;
    }, [isStartOpen, isEndOpen, isBottomOpen]);
    hooks.useEffect(() => {
        // Focus strategy - apply focus back
        // Return focus to a drawer if applicable
        // 1a. useBreakpoint hook, which monitors viewport resolution, is triggered even drawer(s) are not open.
        // This hook causes changes to 'viewportDisplayModeHorizontal', a dependency of this effect.
        // 1b. This effect can be also triggered by a change to
        // start-display/end-display/bottom-display properties of the DrawerLayout.
        // Make sure that drawer, in which we previously found focus, is still open.
        const placementOflastlyFocusedDrawer = placementOfLastlyFocusedRef.current;
        if (placementOflastlyFocusedDrawer) {
            const drawerRefReceivingFocus = getDrawerRef(placementOflastlyFocusedDrawer);
            if (drawerRefReceivingFocus.current && isDrawerOpen(placementOflastlyFocusedDrawer)) {
                // 2. Find all tabbables in newly rendered focus receiving focus
                const allTabbables = tabbableUtils.allTabbableElements(drawerRefReceivingFocus.current, true);
                // 3. Try to focus the same element that had focus in previous display mode
                // In theory drawer's content could be modified.
                // Check whether there are more tababble elements than the index value we saved
                if (indexOfLastlyFocusedRef.current != null &&
                    allTabbables.length > indexOfLastlyFocusedRef.current) {
                    // Focus element using the saved index
                    tabbableUtils.focusOn(allTabbables[indexOfLastlyFocusedRef.current]);
                }
                else {
                    // Focus first tabbable
                    tabbableUtils.focusWithin(drawerRefReceivingFocus.current);
                }
                // Reset saved values to avoid possible side effects
                placementOfLastlyFocusedRef.current = null;
                indexOfLastlyFocusedRef.current = null;
            }
        }
    }, [startResolvedDisplayMode, endResolvedDisplayMode, bottomResolvedDisplayMode, isDrawerOpen]);
    hooks.useEffect(() => {
        // Size breakpoint crossed
        triggerFocusTransferStrategy();
        // Reschedules the effect to occur after the ResizeObserver’s loop has completed.
        setTimeout(() => {
            setViewportDisplayModeHorizontal(displayMode);
        }, 0);
    }, [displayMode, triggerFocusTransferStrategy]);
    const getElementHeight = (element) => {
        return element ? Math.round(element.offsetHeight) : 0;
    };
    const getElementHeightPx = hooks.useCallback((element) => {
        return `${getElementHeight(element)}px`;
    }, []);
    const getElementWidth = hooks.useCallback((element) => {
        return element ? Math.round(element.getBoundingClientRect().width) : 0;
    }, []);
    const getElementWidthPx = hooks.useCallback((element) => {
        return `${getElementWidth(element)}px`;
    }, [getElementWidth]);
    // Normalizing position
    const { direction } = useUser.useUser();
    const isLtr = direction === 'ltr';
    const getNormalizedPlacement = hooks.useCallback((placement) => {
        return positionUtils.normalizePosition(placement, direction);
    }, [direction]);
    const isSidePlacement = (placement) => {
        return [stringStart, stringEnd].indexOf(placement) > -1;
    };
    const isBottomPlacement = (placement) => {
        return placement === stringBottom;
    };
    const isAnimationPending = (status) => {
        return [stringOpening, stringClosing].indexOf(status) > -1;
    };
    const isDrawerAnimationPending = (placement) => {
        switch (placement) {
            case stringStart:
                return isAnimationPending(startDrawerStatus);
            case stringEnd:
                return isAnimationPending(endDrawerStatus);
            case stringBottom:
                return isAnimationPending(bottomDrawerStatus);
        }
    };
    const getDrawerVisibility = (placement) => {
        switch (placement) {
            case stringStart:
                return startVisibility;
            case stringEnd:
                return endVisibility;
            case stringBottom:
                return bottomVisibility;
        }
    };
    const setDrawerVisibility = (placement, visibility) => {
        switch (placement) {
            case stringStart:
                return setStartVisibility(visibility);
            case stringEnd:
                return setEndVisibility(visibility);
            case stringBottom:
                return setBottomVisibility(visibility);
        }
    };
    const getDrawerRef = (placement) => {
        switch (placement) {
            case stringStart:
                return startDrawerRef;
            case stringEnd:
                return endDrawerRef;
            case stringBottom:
                return bottomDrawerRef;
        }
    };
    const getAnimatedNodeRef = (placement) => {
        switch (placement) {
            case stringStart:
                return startAnimatedNodeRef;
            case stringEnd:
                return endAnimatedNodeRef;
            case stringBottom:
                return bottomAnimatedNodeRef;
        }
    };
    const getDrawerStatus = (placement) => {
        switch (placement) {
            case stringStart:
                return startDrawerStatus;
            case stringEnd:
                return endDrawerStatus;
            case stringBottom:
                return bottomDrawerStatus;
        }
    };
    const setDrawerStatus = (placement, status) => {
        switch (placement) {
            case stringStart:
                setStartDrawerStatus(status);
                break;
            case stringEnd:
                setEndDrawerStatus(status);
                break;
            case stringBottom:
                setBottomDrawerStatus(status);
                break;
        }
    };
    const resetAnimatedNodeRef = (placement) => {
        switch (placement) {
            case stringStart:
                startAnimatedNodeRef(null);
                break;
            case stringEnd:
                endAnimatedNodeRef(null);
                break;
            case stringBottom:
                bottomAnimatedNodeRef(null);
                break;
        }
    };
    const getDrawerDisplayProp = hooks.useCallback((placement) => {
        switch (placement) {
            case stringStart:
                return startDisplay;
            case stringEnd:
                return endDisplay;
            case stringBottom:
                return bottomDisplay;
        }
    }, [startDisplay, endDisplay, bottomDisplay]);
    const getDrawerResolvedDisplayMode = hooks.useCallback((placement) => {
        const displayProp = getDrawerDisplayProp(placement);
        if (displayProp) {
            return displayProp;
        }
        else {
            if (isSidePlacement(placement)) {
                return viewportDisplayModeHorizontal;
            }
            return viewportDisplayModeVertical;
        }
    }, [getDrawerDisplayProp, viewportDisplayModeHorizontal, viewportDisplayModeVertical]);
    // Animation effects config
    const getAnimationStates = (ref) => {
        return {
            expandVertically: {
                from: {
                    maxHeight: zeroPx
                },
                to: {
                    maxHeight: '100%'
                },
                options: {
                    duration: animationUtils.DURATION_LARGE
                }
            },
            collapseVertically: {
                from: {
                    maxHeight: '100%'
                },
                to: {
                    maxHeight: zeroPx
                },
                options: {
                    duration: animationUtils.DURATION_LARGE
                }
            },
            expandHorizontally: () => {
                return {
                    from: {
                        maxWidth: zeroPx
                    },
                    to: {
                        // We need a function here as the width is dynamic
                        // and percentage can't be used in reflow mode
                        maxWidth: getElementWidthPx(ref.current)
                    },
                    options: {
                        duration: animationUtils.DURATION_LARGE
                    }
                };
            },
            collapseHorizontally: () => {
                return {
                    from: {
                        // We need a function here as the width is dynamic
                        // and percentage can't be used in reflow mode
                        maxWidth: getElementWidthPx(ref.current)
                    },
                    to: {
                        maxWidth: zeroPx
                    },
                    options: {
                        duration: animationUtils.DURATION_LARGE
                    }
                };
            },
            slideUp: {
                from: {
                    // We need a function here as the height is dynamic
                    // and percentage can't be used in reflow mode
                    translateY: '100%'
                },
                to: {
                    translateY: zeroPx
                },
                options: {
                    duration: animationUtils.DURATION_LARGE
                }
            },
            slideDown: {
                from: {
                    translateY: zeroPx
                },
                to: {
                    translateY: '100%'
                },
                options: {
                    duration: animationUtils.DURATION_LARGE
                }
            },
            slideOpenLeft: {
                from: {
                    translateX: '-100%'
                },
                to: {
                    translateX: zeroPx
                },
                options: {
                    duration: animationUtils.DURATION_LARGE
                }
            },
            slideCloseLeft: {
                from: {
                    translateX: '0'
                },
                to: {
                    translateX: '-100%'
                },
                options: {
                    duration: animationUtils.DURATION_LARGE
                }
            },
            slideOpenRight: {
                from: {
                    translateX: '100%'
                },
                to: {
                    translateX: zeroPx
                },
                options: {
                    duration: animationUtils.DURATION_LARGE
                }
            },
            slideCloseRight: {
                from: {
                    translateX: '0'
                },
                to: {
                    translateX: '100%'
                },
                options: {
                    duration: animationUtils.DURATION_LARGE
                }
            }
        };
    };
    const removeAnimationInlineStyles = (placement) => {
        // Remove style attribute left on the element by the Animation util
        const drawerRef = getDrawerRef(placement);
        drawerRef.current.removeAttribute('style');
    };
    const setInitialFocus = (placement) => {
        // Set focus to the first match:
        const drawerRef = getDrawerRef(placement);
        // 1. First element inside the drawer matching [autofocus]
        const autofocusItems = tabbableUtils.getAutofocusFocusables(drawerRef.current);
        if (autofocusItems.length > 0) {
            tabbableUtils.focusOn(autofocusItems[0]);
            return;
        }
        // 2. Tabbable element inside the content element
        // 3. The drawer itself
        tabbableUtils.focusWithin(drawerRef.current);
    };
    const getLauncherRef = (placement) => {
        switch (placement) {
            case stringStart:
                return startLauncherRef;
            case stringEnd:
                return endLauncherRef;
            case stringBottom:
                return bottomLauncherRef;
        }
    };
    const returnFocusToLauncher = (placement) => {
        // Return the focus to the drawer's launcher only if the focus
        // is currently living within a drawer.
        // As we do not apply focus-trap in modeless mode, user is able to
        // get the focus out of the drawer. In this case we do not want to handle it.
        if (getDrawerRef(placement).current?.contains(elementWithFocusBeforeDrawerClosesRef.current)) {
            tabbableUtils.focusOnElementOrNearestAncestor(getLauncherRef(placement).current);
        }
    };
    // Animation effect
    const getAnimationEffect = (placement) => {
        const bottomPlacement = isBottomPlacement(placement);
        const status = getDrawerStatus(placement);
        if (getDrawerResolvedDisplayMode(placement) === stringReflow) {
            // Reflow display mode
            // Effect: Expand/Collapse
            if (bottomPlacement) {
                // useAnimation hook ignores to apply effect if it matches the previous one.
                // if (currentAnimationState.current === animationState) return;
                // That's why we need to pair particular with particualar status and
                // send empty stirng in all other cases
                if (status === 'opening') {
                    return 'expandVertically';
                }
                if (status === 'closing') {
                    return 'collapseVertically';
                }
                return '';
            }
            else {
                if (status === 'opening') {
                    return 'expandHorizontally';
                }
                if (status === 'closing') {
                    return 'collapseHorizontally';
                }
                return '';
            }
        }
        else {
            // Overlay display mode
            // Effect: SlideIn/SlideOut
            if (bottomPlacement) {
                if (status === 'opening') {
                    return 'slideUp';
                }
                if (status === 'closing') {
                    return 'slideDown';
                }
                return '';
            }
            else {
                if (status === 'opening') {
                    return getNormalizedPlacement(placement) === 'left' ? 'slideOpenLeft' : 'slideOpenRight';
                }
                if (status === 'closing') {
                    return getNormalizedPlacement(placement) === 'left'
                        ? 'slideCloseLeft'
                        : 'slideCloseRight';
                }
                return '';
            }
        }
    };
    // Custom hook to be shared for each side
    // It can't be a function as a hook can only be called within a custom hook
    function useNodeRef(placement, ref) {
        const isOpen = isDrawerOpen(placement);
        const status = getDrawerStatus(placement);
        return useAnimation.useAnimation(getAnimationEffect(placement), {
            animationStates: getAnimationStates(ref),
            isAnimatedOnMount: true,
            onAnimationEnd: () => {
                if (status === stringOpening) {
                    if (isOverlay(placement)) {
                        setInitialFocus(placement);
                    }
                    // Remove animation's inline style
                    removeAnimationInlineStyles(placement);
                    // In case drawer display mode changed at runtime (reflow <> overlay)
                    // we need to reset animation node ref otherwise animation state is not refelected.
                    // Case:
                    // <oj-c-drawer-layout> opens on wide screen by default in reflow mode (flex layout).
                    // useAnimation effect was 'expand'
                    // Viewport is shrinked under 1024px, display mode changes to overlay.
                    // This means DOM is reparented.
                    // For overlay mode, closing animation effect should be 'slideout'
                    // If animation nodeRef is not reset, closing effect is neither 'collapse' nor 'slideout'.
                    resetAnimatedNodeRef(placement);
                    setDrawerStatus(placement, stringOpen);
                    onTransitionEnd?.({
                        placement: placement,
                        value: true
                    });
                }
                else if (!isOpen) {
                    if (isOverlay(placement)) {
                        returnFocusToLauncher(placement);
                    }
                    resetAnimatedNodeRef(placement);
                    setDrawerVisibility(placement, stringHidden);
                    setDrawerStatus(placement, stringUnmounted);
                    onTransitionEnd?.({
                        placement: placement,
                        value: false
                    });
                }
            }
        }).nodeRef;
    }
    // Drawer refs
    const startAnimatedNodeRef = useNodeRef(stringStart, startDrawerRef);
    const endAnimatedNodeRef = useNodeRef(stringEnd, endDrawerRef);
    const bottomAnimatedNodeRef = useNodeRef(stringBottom, bottomDrawerRef);
    //testId support
    const testIdProps = useTestId.useTestId(testId);
    const setLauncherRef = (placement) => {
        const activeElement = tabbableUtils.getActiveElement();
        switch (placement) {
            case stringStart:
                startLauncherRef.current = activeElement;
                break;
            case stringEnd:
                endLauncherRef.current = activeElement;
                break;
            case stringBottom:
                bottomLauncherRef.current = activeElement;
                break;
        }
    };
    // Custom hook to be shared for each side
    // It can't be a function as a hook can only be called within a custom hook
    function useDrawerStatus(placement) {
        const isOpen = isDrawerOpen(placement);
        const drawerStatus = getDrawerStatus(placement);
        hooks.useEffect(() => {
            // Ignore initial render
            // 1. Ignore status update on initial render
            if (drawerStatus === stringUnmounted && !isOpen) {
                return;
            }
            // 2. Unmounted
            // Mount visually hidden component.
            // Component gets mounted, but will be visually hidden to avoid flickering.
            // Flickering happens because it gets rendered before animation hook repositions
            // it in next render cycle
            if (drawerStatus === stringUnmounted && isOpen) {
                setDrawerStatus(placement, stringInitial);
                return;
            }
            // 3. Initial
            // Setup animation
            // Component has been mounted.
            // We will kick out animation as node is already present in DOM.
            // To avoid flickering, we still keep it visually hidden until the next render cycle.
            if (drawerStatus === stringInitial && isOpen) {
                if (isOverlay(placement)) {
                    const drawerRef = getDrawerRef(placement);
                    const animatedNodeRef = getAnimatedNodeRef(placement);
                    animatedNodeRef(drawerRef.current);
                    setDrawerStatus(placement, stringOpening);
                    return;
                }
            }
            // 4. Opening
            // Unhide component. It becomes visible.
            if (drawerStatus === stringOpening && isOpen) {
                if (isOverlay(placement)) {
                    setDrawerVisibility(placement, stringVisible);
                    // Remember launcher
                    setLauncherRef(placement);
                    return;
                }
            }
            // 5. Open
            // Status 'open' is set in 'onAnimationEnd' handler
            // 6. Closing
            if (!isOpen) {
                // As animatedNodeRef was reset in onAnimationEnd we need to set it again
                // see useAnimation transition end for details
                const drawerRef = getDrawerRef(placement);
                const animatedNodeRef = getAnimatedNodeRef(placement);
                animatedNodeRef(drawerRef.current);
                elementWithFocusBeforeDrawerClosesRef.current = tabbableUtils.getActiveElement();
                setDrawerStatus(placement, stringClosing);
            }
        }, [isOpen, drawerStatus, placement]);
        // For reflow only
        hooks.useLayoutEffect(() => {
            // 3. Initial
            // Setup animation
            // Component has been mounted.
            // We will kick out animation as node is already present in DOM.
            // To avoid flickering, we still keep it visually hidden until the next render cycle.
            if (drawerStatus === stringInitial && isOpen) {
                if (!isOverlay(placement)) {
                    const drawerRef = getDrawerRef(placement);
                    const animatedNodeRef = getAnimatedNodeRef(placement);
                    animatedNodeRef(drawerRef.current);
                    setDrawerStatus(placement, stringOpening);
                    return;
                }
            }
            // 4. Opening
            // Unhide component. It becomes visible.
            if (drawerStatus === stringOpening && isOpen) {
                if (!isOverlay(placement)) {
                    setDrawerVisibility(placement, stringVisible);
                    // Remember launcher
                    setLauncherRef(placement);
                    return;
                }
            }
        }, [drawerStatus, isOpen, placement]);
    }
    // Drawers' status handler±
    useDrawerStatus(stringStart);
    useDrawerStatus(stringEnd);
    useDrawerStatus(stringBottom);
    // Keydown handlers
    const handleKeyDownStart = (event) => {
        handleKeyDown(stringStart, event);
    };
    const handleKeyDownEnd = (event) => {
        handleKeyDown(stringEnd, event);
    };
    const handleKeyDownBottom = (event) => {
        handleKeyDown(stringBottom, event);
    };
    const handleKeyDown = (placement, event) => {
        if (event.code === 'Escape') {
            // Handle only in overlay mode
            if (isOverlay(placement)) {
                onClose?.({
                    placement,
                    reason: 'escapeKey'
                });
            }
        }
    };
    // Styles
    const { classes, styles } = useComponentTheme.useComponentTheme(UNSAFE_DrawerLayout_themes_redwood_DrawerLayoutTheme.DrawerLayoutRedwoodTheme);
    const getVisibilityClass = (visibility) => {
        return visibility === stringHidden ? styles.visibilityHidden : styles.visibilityVisible;
    };
    const isStretched = () => {
        return displayMode === stringFullOverlay;
    };
    const isOverlay = hooks.useCallback((placement) => {
        return ([stringFullOverlay, stringOverlay].indexOf(getDrawerResolvedDisplayMode(placement)) > -1);
    }, [getDrawerResolvedDisplayMode]);
    const isFullOverlay = (placement) => {
        return getDrawerResolvedDisplayMode(placement) === stringFullOverlay;
    };
    const getDrawerClassNames = (placement) => {
        // Visibility style is always added
        const visibility = getDrawerVisibility(placement);
        const classNamesArr = [getVisibilityClass(visibility)];
        // Styles for overlay vs. full-overlay vs. reflow
        if (isOverlay(placement)) {
            classNamesArr.push(styles.overlayDrawer);
            if (isSidePlacement(placement) && !isFullOverlay(placement)) {
                classNamesArr.push(styles.overlaySideDrawerNonFullWidth);
            }
            // Styles for stretched overlay drawer
            if (isStretched() && isSidePlacement(placement)) {
                classNamesArr.push(styles.stretchedOverlaySideDrawer);
            }
        }
        else {
            classNamesArr.push(styles.reflowDrawer);
        }
        // Styles for animation
        if (isDrawerAnimationPending(placement)) {
            classNamesArr.push(styles.animatedDrawer);
        }
        const getPlacementSpecificStyles = (placement) => {
            switch (placement) {
                case stringStart:
                    if (isOverlay(stringStart)) {
                        return isLtr ? styles.overlayDrawerLeft : styles.overlayDrawerRight;
                    }
                    else {
                        return isLtr ? styles.reflowDrawerLeft : styles.reflowDrawerRight;
                    }
                case stringEnd:
                    if (isOverlay(stringEnd)) {
                        return isLtr ? styles.overlayDrawerRight : styles.overlayDrawerLeft;
                    }
                    else {
                        return isLtr ? styles.reflowDrawerRight : styles.reflowDrawerLeft;
                    }
                case stringBottom:
                    return isOverlay(stringBottom) ? styles.overlayDrawerBottom : styles.reflowDrawerBottom;
            }
        };
        // Placement specific styles
        classNamesArr.push(getPlacementSpecificStyles(placement));
        return classNames.classNames(classNamesArr);
    };
    const getDrawerProp = (placement) => {
        switch (placement) {
            case stringStart:
                return startDrawer;
            case stringEnd:
                return endDrawer;
            case stringBottom:
                return bottomDrawer;
        }
    };
    const getKeyDownHandler = (placement) => {
        switch (placement) {
            case stringStart:
                return handleKeyDownStart;
            case stringEnd:
                return handleKeyDownEnd;
            case stringBottom:
                return handleKeyDownBottom;
        }
    };
    const renderOverlayDrawer = (placement) => {
        if (isStretched() && isSidePlacement(placement)) {
            const clippingAreaStyles = [styles.stretchedOverlaySideDrawerClippingArea];
            switch (placement) {
                case stringStart:
                    clippingAreaStyles.push(isLtr
                        ? styles.stretchedOverlaySideDrawerClippingAreaLeft
                        : styles.stretchedOverlaySideDrawerClippingAreaRight);
                    break;
                case stringEnd:
                    clippingAreaStyles.push(isLtr
                        ? styles.stretchedOverlaySideDrawerClippingAreaRight
                        : styles.stretchedOverlaySideDrawerClippingAreaLeft);
                    break;
            }
            // Add clipping div
            return (jsxRuntime.jsx("div", { ref: stretchedOverlayClippingRef, className: classNames.classNames(clippingAreaStyles), children: renderDrawer(placement) }));
        }
        else {
            // Overlay bottom drawer or not stretched side drawer
            return renderDrawer(placement);
        }
    };
    // Single drawer template
    const renderDrawer = (placement) => {
        return (jsxRuntime.jsx("div", { ref: getDrawerRef(placement), className: getDrawerClassNames(placement), tabIndex: isOverlay(placement) ? -1 : undefined, onKeyDown: getKeyDownHandler(placement), children: getDrawerProp(placement) }));
    };
    const clientHints$1 = clientHints.getClientHints();
    const getViewportHeight = hooks.useCallback(() => {
        if (clientHints$1.platform === 'ios') {
            // On ios window.innerHeight is not recommended way of measuring the viewport
            return document.documentElement.clientHeight;
        }
        return window.innerHeight;
    }, [clientHints$1.platform]);
    // We faced error in KM test environment
    // Error: ResizeObserver loop completed with undelivered notifications.
    // This happens when an observed element is resized again during a notification.
    // Another cause can be rounding values and then setting the rounded value back.
    // If this is in the same loop as the resize notification, it will cause another resize on the element.
    // Wrapping ResizeObserver’s callback in a setTimeout with a delay of 0 milliseconds
    // reschedules the effect to occur after the ResizeObserver’s loop has completed.
    const rescheduleObserverHandler = (callback) => {
        setTimeout(() => {
            callback();
        }, 0);
    };
    const handleRescheduledVerticalResize = hooks.useCallback(() => {
        const viewportHeight = getViewportHeight();
        if (viewportHeight >= verticalBreakpoint) {
            if (viewportDisplayModeVertical != stringReflow) {
                triggerFocusTransferStrategy();
                setViewportDisplayModeVertical(stringReflow);
            }
        }
        else {
            if (viewportDisplayModeVertical != stringOverlay) {
                triggerFocusTransferStrategy();
                setViewportDisplayModeVertical(stringOverlay);
            }
        }
    }, [viewportDisplayModeVertical, getViewportHeight, triggerFocusTransferStrategy]);
    const handleVerticalResize = hooks.useCallback(() => {
        rescheduleObserverHandler(handleRescheduledVerticalResize);
    }, [handleRescheduledVerticalResize]);
    // Window resize listener
    // useBreakpoint hook is designed for horizontal breakpoints only
    // This listener is used for 600px (overlay vs. reflow) breakpoint
    // used for bottom drawer
    hooks.useEffect(() => {
        const resizeObserver = new ResizeObserver(() => {
            handleVerticalResize();
        });
        resizeObserver.observe(document.body);
        // Deregister resize observer when Drawer layout unmounts
        return () => {
            resizeObserver.unobserve(document.body);
        };
    }, [handleVerticalResize]);
    const measureOffset = (placement) => {
        const drawerEl = getDrawerEl(placement);
        if (drawerEl) {
            return isSidePlacement(placement) ? -getElementWidth(drawerEl) : -getElementHeight(drawerEl);
        }
        return 0;
    };
    const getOffsetState = (placement) => {
        switch (placement) {
            case stringStart:
                return startOffset;
            case stringEnd:
                return endOffset;
            case stringBottom:
                return bottomOffset;
        }
    };
    const setSideOverlayDrawerHeight = hooks.useCallback((placement) => {
        // By default PopupElements have no predefined height.
        // In 'overlay' mode drawers should be
        // of the same height as their parent <oj-drawer-layout>
        const centerSectionHeight = getElementHeightPx(centerRef.current);
        const drawerEl = getDrawerRef(placement).current;
        if (drawerEl && !isStretched() && isDrawerOpen(placement) && isOverlay(placement)) {
            drawerEl.style.height = centerSectionHeight;
        }
    }, [getElementHeightPx, isDrawerOpen, isOverlay, isStretched]);
    const handleSideDrawerFullWidth = (placement) => {
        const drawerEl = getDrawerRef(placement).current;
        if (drawerEl) {
            if (isDrawerOpen(placement)) {
                const drawerInlineStyle = drawerEl.style;
                if (isFullOverlay(placement)) {
                    drawerInlineStyle.width = getElementWidthPx(rootRef.current);
                }
                else {
                    drawerInlineStyle.removeProperty('width');
                }
            }
        }
    };
    const setBottomOverlayDrawerWidth = hooks.useCallback(() => {
        const bottomDrawerElement = bottomDrawerRef.current;
        if (bottomDrawerElement && isDrawerOpen(stringBottom) && isOverlay(stringBottom)) {
            const centerSectionWidth = getElementWidthPx(centerRef.current);
            bottomDrawerElement.style.width = centerSectionWidth;
        }
    }, [getElementWidthPx, isDrawerOpen, isOverlay]);
    hooks.useEffect(() => {
        // Stretched case - set side drawer size
        const start = 'start';
        const end = 'end';
        [start, end].forEach((placement) => {
            if (isDrawerOpen(placement) && isStretched()) {
                // When opening the drawer its ref and its clipping area
                // are not present on the first run of this effect.
                // That's why we are using question mark when manipulating their styles.
                // Remove residual inline style when changing overlayHeight
                // from 'inset' to 'stretch' at Runtime
                // In 'inset' mode we calculate the height to fit the parent container.
                getDrawerEl(placement)?.style.removeProperty('height');
                // Do the same removal also on the wrapping clipping area.
                // DrawerLayout component is not setting this style. This is probably added by Floating.
                const clippingArea = getDrawerEl(placement)?.parentNode;
                clippingArea?.style.removeProperty('height');
            }
        });
    }, [isDrawerOpen, getDrawerEl, getElementWidth, isStretched]);
    const setDrawerSize = (placement) => {
        // Not stretched overlay drawer
        if (isSidePlacement(placement)) {
            setSideOverlayDrawerHeight(placement);
            handleSideDrawerFullWidth(placement);
        }
        if (isBottomPlacement(placement)) {
            setBottomOverlayDrawerWidth();
        }
    };
    // DrawerLayout resize observer
    const handleDrawerLayoutResize = () => {
        rescheduleObserverHandler(handleRescheduledDrawerLayoutResize);
    };
    const handleRescheduledDrawerLayoutResize = hooks.useCallback(() => {
        // If the DrawerLayout (page content) changes size,
        // adjust OVERLAY side drawers (start/end) height to fit the drawer
        // Note that these two functions checks that 'overlay' condition is fulfilled
        if (!isStretched()) {
            setSideOverlayDrawerHeight(stringStart);
            setSideOverlayDrawerHeight(stringEnd);
        }
        setBottomOverlayDrawerWidth();
    }, [setSideOverlayDrawerHeight, setBottomOverlayDrawerWidth, isStretched]);
    useResizeObserver.useResizeObserver(rootRef, handleDrawerLayoutResize);
    const setOffsetState = (placement) => {
        // This method sets offset used only in overlay mode
        if (isOverlay(placement)) {
            const offset = measureOffset(placement);
            switch (placement) {
                case stringStart:
                    // Fixed strategy calculates position from left to right.
                    // Stretched drawer needs no offset
                    setStartOffset(isStretched() ? 0 : offset);
                    break;
                case stringEnd:
                    // Fixed strategy calculates position from left to right.
                    // Stretched drawer needs no offset
                    setEndOffset(isStretched() ? offset - 20 : offset);
                    break;
                case stringBottom:
                    setBottomOffset(offset);
                    break;
            }
        }
    };
    // Start drawer resize observer
    const handleStartDrawerResize = () => {
        rescheduleObserverHandler(handleRescheduledStartDrawerResize);
    };
    const handleRescheduledStartDrawerResize = () => {
        setOffsetState(stringStart);
        setBottomOverlayDrawerWidth();
    };
    useResizeObserver.useResizeObserver(startDrawerRef, handleStartDrawerResize);
    // End drawer resize observer
    const handleEndDrawerResize = () => {
        rescheduleObserverHandler(handleRescheduledEndDrawerResize);
    };
    const handleRescheduledEndDrawerResize = () => {
        setOffsetState(stringEnd);
        setBottomOverlayDrawerWidth();
    };
    useResizeObserver.useResizeObserver(endDrawerRef, handleEndDrawerResize);
    // Bottom drawer resize observer
    const handleBottomDrawerResize = () => {
        rescheduleObserverHandler(handleRescheduledBottomDrawerResize);
    };
    const handleRescheduledBottomDrawerResize = () => {
        setOffsetState(stringBottom);
    };
    useResizeObserver.useResizeObserver(bottomDrawerRef, handleBottomDrawerResize);
    const getDrawerPreviousResolvedDisplayMode = (placement) => {
        switch (placement) {
            case stringStart:
                return startResolvedDisplayMode;
            case stringEnd:
                return endResolvedDisplayMode;
            case stringBottom:
                return bottomResolvedDisplayMode;
        }
    };
    const saveResolvedDisplayMode = (placement) => {
        const currentResolvedDisplayMode = getDrawerResolvedDisplayMode(placement);
        if (getDrawerPreviousResolvedDisplayMode(placement) != currentResolvedDisplayMode) {
            switch (placement) {
                case stringStart:
                    setStartResolvedDisplayMode(currentResolvedDisplayMode);
                    break;
                case stringEnd:
                    setEndResolvedDisplayMode(currentResolvedDisplayMode);
                    break;
                case stringBottom:
                    setBottomResolvedDisplayMode(currentResolvedDisplayMode);
                    break;
            }
            // In case of 'reflow <> overlay' change conditional rendering of a drawer happens.
            // The old DOM is destoryed and a new DOM is created. In this case focus gets lost.
            // Browser moves the focus to body.
            // We try to prevent it by eventually applying focus in the newly created DOM.
            // If at least one drawer is open, we will check whether focus lives whithin.
            // See the following method for more details.
            triggerFocusTransferStrategy();
        }
    };
    const getReflowOrOverlayDrawer = (placement) => {
        const shiftOptions = {
            mainAxis: false,
            crossAxis: false
        };
        const flipOptions = {
            mainAxis: false,
            crossAxis: false
        };
        // Save resolved display mode of a drawer so that we can compare it with 'next' value
        saveResolvedDisplayMode(placement);
        // Reflow vs. overlay drawer
        if (isOverlay(placement)) {
            setDrawerSize(placement);
            // Initial offset
            if (!getOffsetState(placement)) {
                setOffsetState(placement);
            }
            return (
            // Reconciliation issue. Reparented node must
            // be a single child of a <div>
            jsxRuntime.jsx("div", { children: jsxRuntime.jsx(Layer.Layer, { children: jsxRuntime.jsx(Floating.Floating, { anchorRef: placement === stringBottom ? centerRef : rootRef, placement: placement, class: isDrawerAnimationPending(placement) ? styles.floating : '', strategy: isStretched() && isSidePlacement(placement) ? 'fixed' : 'absolute', offsetValue: getOffsetState(placement), flipOptions: flipOptions, shiftOptions: shiftOptions, children: renderOverlayDrawer(placement) }) }) }));
        }
        else {
            // Reflow display mode - flex layout
            return renderDrawer(placement);
        }
    };
    // React calculates how your component should look and prepares the updates
    // React applies those updates to the DOM, making the changes ready for display
    //   useLayoutEffect hook runs right after the DOM is updated but before the screen shows anything. it lets you make adjustments here that will be applied before the screen updates
    // the browser then paints the updated content to the screen
    // useEffect hook runs after the screen updates, so any changes here will cause another re-render but only after the user has already seen the initial update
    // Render drawer conditionally
    const getDrawer = (placement) => {
        const isMounted = getDrawerStatus(placement) !== stringUnmounted;
        return isMounted ? getReflowOrOverlayDrawer(placement) : null;
    };
    return (jsxRuntime.jsxs("div", { ref: rootRef, className: classes, ...testIdProps, children: [getDrawer(stringStart), jsxRuntime.jsxs("div", { ref: centerRef, className: styles.centerSection, children: [jsxRuntime.jsx("div", { className: styles.mainContent, children: children }), getDrawer(stringBottom)] }), getDrawer(stringEnd)] }));
};

exports.DrawerLayout = DrawerLayout;
//# sourceMappingURL=UNSAFE_DrawerLayout.js.map
