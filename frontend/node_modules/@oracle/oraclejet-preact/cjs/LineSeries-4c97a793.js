/* @oracle/oraclejet-preact: undefined */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var Marker = require('./Marker-b40392cc.js');

var utils = require('./utils-7c1b4abe.js');
var accUtils = require('./accUtils-5c7d3255.js');
var PRIVATE_Chart_themes_ChartStyles_css = require('./PRIVATE_Chart/themes/ChartStyles.css.js');
var classNames = require('./classNames-c14c6ef3.js');
var textUtils = require('./textUtils-e779c845.js');
var lineUtils = require('./lineUtils-34a63fb2.js');

const DEFAULT_POSITION = 'center';
function MarkerLabel({ labelPosition, label, labelStyle, tx, ty, defaultFontSize, dataLabelEffect, isHighContrast, getTextDimensions }) {
    let markerLabel = null;
    const position = labelPosition ? labelPosition : DEFAULT_POSITION;
    const { dataLabelStyle, dataLabelContrast, highContrastLabelStyle } = PRIVATE_Chart_themes_ChartStyles_css.styles;
    const labelString = label;
    if (position && labelString) {
        const markerLabelStyle = {
            fontSize: defaultFontSize,
            ...textUtils.updateVisTextStyleProperties(labelStyle)
        };
        const labelDims = getTextDimensions?.(labelString, markerLabelStyle);
        const { x, y } = utils.getLabelPosition(position, tx, ty, labelDims);
        markerLabel = (jsxRuntime.jsx("text", { x: x, y: y, class: classNames.classNames([
                dataLabelStyle,
                dataLabelEffect === 'outline' ? dataLabelContrast : '',
                isHighContrast ? highContrastLabelStyle : ''
            ]), style: markerLabelStyle, children: labelString }));
    }
    return markerLabel;
}

const MARKER_DEFAULT_SIZE = 10;
function MarkersWithLabel({ yScale, xScale, color, seriesIndex, startIndex, endIndex, hiddenIds, selectedIds, highlightedIds, orientation, isLog, markerType, getDataItem, focusedItemIndex, hoveredItemIndex, isDrillEnabled, activeId, isSelectionEnabled, timeAxisType, isPointInsideMarquee, groups, defaultFontSize, dataLabelEffect, isHighContrast, isTestEnv, isDataXAxis, getTextDimensions, getItemAriaLabel }) {
    const isHoriz = orientation === 'horizontal';
    const items = [];
    for (let groupIndex = startIndex; groupIndex < endIndex + 1; groupIndex++) {
        const item = getDataItem(seriesIndex, groupIndex);
        if (!item || hiddenIds?.has(item.id)) {
            continue;
        }
        let x, y;
        const itemHasValue = 'value' in item;
        if (isDataXAxis && 'y' in item) {
            x = xScale.transform(item.x);
            y = yScale.transform(item.y);
        }
        else {
            const value = itemHasValue ? item?.value : undefined;
            if (value == null || (isLog && value <= 0)) {
                continue;
            }
            x = isHoriz
                ? yScale.transform(value)
                : utils.getGroupCenterCoord(groups[groupIndex], groupIndex, xScale, item, timeAxisType);
            y = isHoriz
                ? utils.getGroupCenterCoord(groups[groupIndex], groupIndex, xScale, item, timeAxisType)
                : yScale.transform(value);
        }
        const isFocused = focusedItemIndex === groupIndex;
        const isHovered = hoveredItemIndex === groupIndex;
        const isSelected = !!(selectedIds?.has(item.id) || isPointInsideMarquee?.(item.id, { x, y })); // TODO: tagcloud has isItemSelected we should look to leverage here
        const isDrillable = item.drilling === 'on' || (item.drilling != 'off' && isDrillEnabled);
        const isHighlighted = !highlightedIds || highlightedIds?.size === 0 || highlightedIds?.has(item.id); // TODO: tagcloud has isItemHighlighted we should look to leverage here
        const { fill, stroke, outerStroke } = utils.getMarkerFillAndStroke(!!item.isMarkerDisplayed, isSelectionEnabled, isHovered, isFocused, isSelected, color, item.markerColor);
        const itemMarkerType = item.isMarkerDisplayed ? item.markerType || markerType : markerType;
        const isActive = isFocused || isHovered;
        const ariaLabel = accUtils.supportsMobileScreenReader || isActive
            ? getItemAriaLabel(item, seriesIndex, groupIndex, isSelectionEnabled, !!isSelected, isDrillable)
            : undefined;
        const dataInfo = {
            'data-oj-private-series-index': seriesIndex,
            'data-oj-private-group-index': groupIndex,
            'data-oj-private-object': 'item',
            id: isActive ? activeId : undefined,
            role: ariaLabel ? 'img' : undefined,
            'aria-label': ariaLabel,
            'data-oj-private-item-id': isTestEnv ? item.id : undefined
        };
        const markerSize = (item.markerSize || MARKER_DEFAULT_SIZE) + 2 * Marker.MARKER_PADDING;
        items.push(jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(Marker.Marker, { type: itemMarkerType, tx: x, ty: y, isInteractive: isDrillable || isSelectionEnabled, scale: 1, fill: fill, stroke: stroke, outerStroke: outerStroke, width: markerSize, height: markerSize, dataInfo: dataInfo, preserveRectAspectRatio: true, styleClass: isHighlighted ? undefined : PRIVATE_Chart_themes_ChartStyles_css.styles.dimmed }), jsxRuntime.jsx(MarkerLabel, { labelPosition: item.labelPosition, label: item.label, labelStyle: item.labelStyle, tx: x, ty: y, defaultFontSize: defaultFontSize, dataLabelEffect: dataLabelEffect, isHighContrast: isHighContrast, getTextDimensions: getTextDimensions })] }));
    }
    return jsxRuntime.jsx(jsxRuntime.Fragment, { children: items });
}

function LineSeries({ color, isHorizontal, lineType = 'straight', lineColor, lineStyle, lineWidth = 3, isHighlighted, lineSegmentCoords, seriesIndex, groupWidth, isRtl, timeAxisType, plotAreaClipPathId }) {
    const style = {
        stroke: lineColor || color,
        strokeDasharray: lineStyle === 'dotted' ? 3 : lineStyle === 'dashed' ? 6 : undefined,
        strokeWidth: lineWidth,
        fill: 'none'
    };
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: lineSegmentCoords.map((value) => {
            if (value.length < 2) {
                return;
            }
            const cmds = lineUtils.getCmdsForLine(value, lineType, isHorizontal, groupWidth, isRtl, timeAxisType);
            return utils.isNonCurvedLine(lineType) ? (jsxRuntime.jsx("g", { "clip-path": `url(#${plotAreaClipPathId})`, children: cmds.split(' ').map((cmd) => (jsxRuntime.jsx("polyline", { points: cmd, style: style, className: isHighlighted ? undefined : PRIVATE_Chart_themes_ChartStyles_css.styles.dimmed, "data-oj-private-series-index": seriesIndex, "data-oj-private-object": 'line' }))) })) : lineType === 'curved' ? (jsxRuntime.jsx("path", { d: cmds, "clip-path": `url(#${plotAreaClipPathId})`, style: style, className: isHighlighted ? undefined : PRIVATE_Chart_themes_ChartStyles_css.styles.dimmed, "data-oj-private-series-index": seriesIndex, "data-oj-private-object": 'line' })) : undefined;
        }) }));
}

exports.LineSeries = LineSeries;
exports.MarkersWithLabel = MarkersWithLabel;
//# sourceMappingURL=LineSeries-4c97a793.js.map
