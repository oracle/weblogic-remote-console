/* @oracle/oraclejet-preact: undefined */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
var useId = require('./useId-6c0eeb27.js');
var useHover = require('./useHover-49b0430d.js');
var useFocus = require('./useFocus-1b288fb9.js');
var useTouch = require('./useTouch-4dec8729.js');
var mergeProps = require('./mergeProps-e3da7237.js');
var useAnimation = require('./useAnimation-fb11e4cc.js');
var useComponentTheme = require('./useComponentTheme-082fc8e4.js');
var useTestId = require('./useTestId-9093a54b.js');
var useThemeInterpolations = require('./useThemeInterpolations-4faece98.js');
var classNames = require('./classNames-c14c6ef3.js');
var hooks_UNSAFE_useTooltip_themes_redwood_TooltipContentTheme = require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentTheme.js');
var useColorScheme = require('./useColorScheme-23e4aab4.js');
var tooltipUtils = require('./tooltipUtils-ae48fed6.js');

const TooltipContent = ({ children, id, isOpen, isDatatip, onTransitionEnd, testId, ...props }) => {
    const wrapperRef = hooks.useRef(null);
    const popoverRef = hooks.useRef(null);
    const testIdProps = useTestId.useTestId(testId);
    const { baseTheme, variantClasses, styles } = useComponentTheme.useComponentTheme(hooks_UNSAFE_useTooltip_themes_redwood_TooltipContentTheme.TooltipContentRedwoodTheme, {
        variant: isDatatip ? 'datatip' : 'tooltip'
    });
    const schemeClass = useThemeInterpolations.useThemeInterpolations();
    const { nodeRef } = useAnimation.useAnimation(isOpen ? 'mounted' : 'unmounted', {
        animationStates: {
            mounted: (_node) => {
                const childNode = _node.firstChild;
                return {
                    from: {
                        maxHeight: '0',
                        opacity: '0%'
                    },
                    to: {
                        maxHeight: `${childNode?.offsetHeight}px`,
                        opacity: isDatatip ? '100%' : '95%'
                    },
                    options: {
                        duration: isDatatip ? 1 : 150,
                        easing: [0.0, 0.0, 0.2, 1]
                    }
                };
            },
            unmounted: (_node) => {
                return {
                    from: {
                        opacity: isDatatip ? '100%' : '95%'
                    },
                    to: {
                        maxHeight: '0',
                        opacity: '0%'
                    },
                    options: {
                        duration: isDatatip ? 1 : 150,
                        easing: [0.0, 0.0, 0.2, 1]
                    }
                };
            }
        },
        isAnimatedOnMount: true,
        onAnimationEnd: () => onTransitionEnd?.()
    });
    // Set up initial wrapper height so Tooltip can animate from the bottom to the top
    hooks.useEffect(() => {
        if (wrapperRef.current && popoverRef.current?.offsetHeight) {
            wrapperRef.current.style.height = `${popoverRef.current?.offsetHeight}px`;
        }
    }, []);
    return (jsxRuntime.jsx("div", { ref: wrapperRef, id: id, role: "tooltip", class: classNames.classNames([styles.wrapper, schemeClass, baseTheme]), ...testIdProps, children: jsxRuntime.jsx("div", { ref: nodeRef, class: styles.inner, ...props, children: jsxRuntime.jsx("div", { ref: popoverRef, class: classNames.classNames([variantClasses, styles.content]), children: children }) }) }));
};

const useTooltipControlled = ({ text, isOpen = false, variant = 'tooltip', position = 'bottom', displayOnHover = true, dismissOnClick = true, focusStrategy = 'browser', isDisabled = false, anchor = { x: 'element', y: 'element' }, offset, onToggle, testId }) => {
    // Global TooltipManager singleton instance
    const globalTooltipManager = tooltipUtils.getGlobalTooltipManager();
    const disabled = isDisabled || !text;
    const isInitialRenderState = hooks.useRef(true);
    const [state, _setState] = hooks.useState(!disabled && isOpen ? 'mounting' : 'unmounted');
    const stateRef = hooks.useRef(state);
    const setState = (newState) => {
        stateRef.current = newState;
        _setState(newState);
    };
    // const tooltipId = useRef<string>(useId());
    const [needsUpdate, setNeedsUpdate] = hooks.useState(false);
    setNeedsUpdate(false);
    const isDatatip = variant === 'datatip';
    const [isLogicalFocus, setLogicalFocus] = hooks.useState(false);
    const isLogicalFocusStrategy = focusStrategy === 'logical';
    const isInitialRenderTrigger = hooks.useRef(true);
    const { hoverProps, isHover } = useHover.useHover({ isDisabled: !displayOnHover });
    const { touchProps, isTouch } = useTouch.useTouch({ isDisabled }); // TODO replace by useLongPress actionhook
    // we only care about keyboard focus, don't enable useFocus hook if isHover or isTouch are active
    const { focusProps, isFocus } = useFocus.useFocus({
        isDisabled: isLogicalFocusStrategy
    });
    // only enable the popoverHover hook if the tooltip is actually open
    const { hoverProps: popoverHoverProps, isHover: popoverIsHover } = useHover.useHover({
        isDisabled: isDisabled || !isOpen
    });
    const isPointer = anchor.x === 'pointer' || anchor.y === 'pointer';
    const uniqueIdRef = hooks.useRef(useId.useId());
    const targetRef = hooks.useRef(null);
    const coordsRef = hooks.useRef({ x: -9999, y: -9999 });
    // if anchor is set to pointer and target does not have keyboard focus, use coords
    const usedRef = isPointer && !isFocus ? coordsRef : targetRef;
    const showDelay = isDatatip ? 0 : tooltipUtils.SHOW_TOOLTIP_DELAY;
    const hideDelay = isDatatip ? 0 : tooltipUtils.HIDE_TOOLTIP_DELAY;
    const toggleTimeoutRef = hooks.useRef(null);
    const currentColorScheme = useColorScheme.useColorScheme();
    const focusActive = hooks.useRef(false);
    const hoverActive = hooks.useRef(false);
    const toggleTimeoutClear = () => {
        if (toggleTimeoutRef.current) {
            clearTimeout(toggleTimeoutRef.current);
            toggleTimeoutRef.current = null;
        }
    };
    /*
     * This effect executes when isFocus/isLogicalFocus changes
     * - focusActive ref is set if the focus change follows a Tab key
     * - hoverActive ref is reset, if focusActive becomes true
     */
    hooks.useEffect(() => {
        if (isLogicalFocusStrategy) {
            focusActive.current = isLogicalFocus;
        }
        else {
            focusActive.current = isFocus && globalTooltipManager.isTabKeyActive();
        }
        if (focusActive.current) {
            hoverActive.current = false;
        }
    }, [isFocus, isLogicalFocus, isLogicalFocusStrategy, globalTooltipManager]);
    /*
     * This effect executes when isHover state changes
     * - focusActive ref is reset, if hoverActive becomes true
     */
    hooks.useEffect(() => {
        hoverActive.current = isHover;
    }, [isHover]);
    hooks.useEffect(() => {
        // inner function for state transitions on various trigger changes
        const updateState = (open) => {
            if (open) {
                // At least one toggle event is set to true
                switch (state) {
                    case 'unmounted':
                        setState('mountPending'); // Set mount pending state if tooltip is unmounted
                        break;
                    case 'unmounting': // Switch back to mounting when unmounting was in progress and the tooltip should stay on
                        setState('mounting');
                        onToggle?.({ value: true });
                        break;
                    case 'unmountPending':
                        toggleTimeoutClear();
                        setState('mounted'); // Clear timers immediately and keep the tooltip mounted
                        break;
                }
            }
            else {
                // No toggle events are set to true
                switch (state) {
                    case 'mounting':
                    case 'mounted':
                        setState('unmountPending'); // Set unmount pending state if tooltip is mounted or in mounting transition
                        break;
                    case 'mountPending':
                        toggleTimeoutClear();
                        __resetCoords();
                        setState('unmounted'); // Unmount tooltip immediately if mounting is pending
                        break;
                }
            }
        };
        if (isInitialRenderTrigger.current) {
            // On onitial render do not trigger rerender
            isInitialRenderTrigger.current = false;
            return;
        }
        // When pointer is used, handleMouseMove method is responsible for state updates
        // until the tooltip is mounted
        if (isPointer && isHover && state === 'unmounted') {
            return;
        }
        updateState((isHover && hoverActive.current) ||
            ((isFocus || isLogicalFocus) && focusActive.current) ||
            popoverIsHover ||
            isTouch);
    }, [isHover, isFocus, isLogicalFocus, popoverIsHover, isTouch, isPointer, state, onToggle]);
    const destroyCallback = hooks.useCallback(() => {
        focusActive.current = false;
        hoverActive.current = false;
        onToggle?.({ value: false });
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []); // don't want to depend on the 'onToggle' prop as some clients tend to pass a new callback on each render
    /*
     * Global mousedown handler to dismiss the tooltip on anchor click. This is especially needed
     * for Safari which does not fire mouse events during animations when the anchor moves (JET-72605).
     */
    const mouseDownHandler = hooks.useCallback((event) => {
        if (usedRef.current instanceof Element &&
            usedRef.current.contains(event.target) &&
            dismissOnClick) {
            toggleTimeoutClear();
            document.removeEventListener('mousedown', mouseDownHandler, true);
            destroyCallback();
        }
    }, [dismissOnClick, usedRef, destroyCallback]);
    hooks.useEffect(() => {
        if (isInitialRenderState.current) {
            // On onitial render do not trigger rerender
            isInitialRenderState.current = false;
            return;
        }
        setState(isOpen ? 'mounting' : 'unmounting');
    }, [isOpen]);
    hooks.useEffect(() => {
        return () => {
            // make sure to clear the toggle timeout on unmount
            toggleTimeoutClear();
            // reset focusActive and hoverActive refs
            focusActive.current = false;
            hoverActive.current = false;
        };
    }, []);
    /*
     * This effect executes when the component state changes.
     * On 'mounted' state, the tooltip registers itself with the global tooltip manager.
     * On 'unmounted', the tooltip unregisters from the global tooltip manager.
     */
    hooks.useEffect(() => {
        if (state === 'mounting') {
            globalTooltipManager.register(destroyCallback);
        }
        else if (state === 'unmounted') {
            globalTooltipManager.unregister(destroyCallback);
            // clean up the mousedown handler just in case
            document.removeEventListener('mousedown', mouseDownHandler, true);
        }
    }, [state, destroyCallback, globalTooltipManager, mouseDownHandler]);
    /*
     * Set a timer to toggle the state afer the 'pending' period expires
     */
    hooks.useEffect(() => {
        if (!toggleTimeoutRef.current && (state === 'mountPending' || state === 'unmountPending')) {
            if (state === 'mountPending') {
                document.addEventListener('mousedown', mouseDownHandler, true);
            }
            toggleTimeoutRef.current = setTimeout(() => {
                toggleTimeoutClear();
                // make sure the state has not changed in the mean time before onToggle
                if ((state === 'mountPending' || state === 'unmountPending') &&
                    state === stateRef.current) {
                    onToggle?.({ value: state === 'mountPending' });
                }
            }, state === 'mountPending' ? showDelay : hideDelay);
        }
        return () => {
            toggleTimeoutClear();
        };
    }, [state, showDelay, hideDelay, onToggle, mouseDownHandler]);
    const handleMouseMove = (event) => {
        // we only want track mouse move while the state is 'unmounted' or when moving a 'mounted' datatip
        if (state !== 'unmounted' && !(variant === 'datatip' && state === 'mounted')) {
            return;
        }
        const targetRect = targetRef?.current?.getBoundingClientRect();
        // Tooltip maintains static offset from left side of window
        const distanceX = document.body.scrollLeft + (targetRect?.left || 0) + (targetRect?.width || 0);
        // Tooltip maintains static offset from top side of the window
        const distanceY = document.body.scrollTop + (targetRect?.top || 0) + (targetRect?.height || 0);
        // Display tooltip at the mouse position if both anchors are set to pointer
        const x = anchor.x === 'pointer' ? event.clientX : distanceX;
        const y = anchor.y === 'pointer' ? event.clientY : distanceY;
        if (state === 'mounted') {
            coordsRef.current = { x, y };
            if (needsUpdate !== true)
                setNeedsUpdate(true);
        }
        else if (state === 'unmounted') {
            toggleTimeoutClear();
            toggleTimeoutRef.current = setTimeout(() => {
                if (state === 'unmounted') {
                    coordsRef.current = { x, y };
                    onToggle?.({ value: true });
                }
            }, hideDelay);
        }
    };
    const onLogicalFocus = (target) => {
        setLogicalFocus(true);
        targetRef.current = target;
        usedRef.current = target;
    };
    const onLogicalBlur = () => {
        setLogicalFocus(false);
    };
    const onFocusCallback = hooks.useCallback((event) => {
        targetRef.current = event.currentTarget;
    }, []);
    const onBlurCallback = hooks.useCallback((event) => {
        if (event.eventPhase === Event.AT_TARGET) {
            // reset focusActive flag
            focusActive.current = false;
        }
    }, []);
    const focusInitProps = isLogicalFocusStrategy
        ? {}
        : {
            onFocus: onFocusCallback,
            onBlur: onBlurCallback
        };
    const hoverInitProps = {
        onMouseEnter: hooks.useCallback((event) => {
            targetRef.current = event.target;
        }, [])
    };
    let actionableProps;
    const __resetCoords = () => {
        coordsRef.current = { x: -9999, y: -9999 };
    };
    if (disabled) {
        actionableProps = mergeProps.mergeProps(hoverProps, focusProps, hoverInitProps, focusInitProps);
    }
    else {
        const anchorInitProps = {
            'aria-describedby': uniqueIdRef.current,
            ...(isPointer && {
                onMouseLeave: () => {
                    if (state === 'mounting') {
                        return;
                    }
                    toggleTimeoutClear();
                },
                onMouseMove: (event) => {
                    handleMouseMove(event);
                }
            })
        };
        actionableProps = mergeProps.mergeProps(hoverProps, focusProps, touchProps, hoverInitProps, focusInitProps, anchorInitProps, isLogicalFocusStrategy ? { onLogicalFocus, onLogicalBlur } : {});
    }
    // No need to process tooltip if disabled or no text is provided
    // Include actionableProps to detect mouseenter in components
    // hovered state won't update unless actionableProps are already present in the component when mouse enters
    if (disabled) {
        toggleTimeoutClear();
        __resetCoords();
        return {
            tooltipContent: null,
            tooltipProps: actionableProps
        };
    }
    const placement = position;
    const handleTransitionEnd = () => {
        if (state === 'mounting') {
            setState('mounted');
        }
        if (state === 'unmounting') {
            __resetCoords();
            setState('unmounted');
        }
    };
    const renderRawContent = (jsxRuntime.jsx(TooltipContent, { id: uniqueIdRef.current, testId: testId, isOpen: ['mounting', 'mounted', 'unmountPending'].includes(state), ...popoverHoverProps, isDatatip: isDatatip, onTransitionEnd: handleTransitionEnd, children: text }));
    const renderContent = tooltipUtils.getWrappedTooltipContent(renderRawContent, variant, currentColorScheme, usedRef, placement, offset);
    return {
        tooltipContent: !['unmounted', 'mountPending'].includes(state) && renderContent,
        tooltipProps: actionableProps
    };
};

exports.TooltipContent = TooltipContent;
exports.useTooltipControlled = useTooltipControlled;
//# sourceMappingURL=useTooltipControlled-3c2afa53.js.map
