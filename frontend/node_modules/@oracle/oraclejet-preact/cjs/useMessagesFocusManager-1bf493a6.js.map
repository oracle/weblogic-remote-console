{"version":3,"file":"useMessagesFocusManager-1bf493a6.js","sources":["../../src/hooks/PRIVATE_useMessagesFocusManager/useMessagesFocusManager.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { RefObject, JSX } from 'preact';\nimport { useEffect, useMemo, useRef, useState } from 'preact/hooks';\nimport type { UnpackSignals } from '@oracle/oraclejet-internal-utilities/attributeUtils';\n\nexport type FocusableComponentHandle = {\n  focus: () => boolean;\n  contains: (element: HTMLElement) => boolean;\n};\n\ntype FocusableComponentCallbacks = {\n  onFocus?: () => void;\n  onFocusLeave?: () => void;\n};\n\ntype FocusManagerHandlers = Pick<\n  UnpackSignals<JSX.HTMLAttributes>,\n  'onFocusIn' | 'onFocusOut' | 'onKeyUp'\n>;\n\ntype ComponentOptions = {\n  ref: RefObject<FocusableComponentHandle>;\n  callbacks?: FocusableComponentCallbacks;\n};\n\ntype FocusManagerOptions = {\n  handleEscapeKey?: boolean;\n};\n\nconst componentsMap = new Map<symbol, ComponentOptions>();\nconst componentsOrder = [] as symbol[];\nconst priorFocusCache = new Map<symbol, Node>();\nlet hasDocumentListener = false;\nlet priorFocusedElement: HTMLElement;\nlet currentFocusedMessage: symbol | undefined;\n\n/**\n * Handles KeyDown event in the document element during the capture phase.\n *\n * @param event The keydown event object\n */\nfunction handleDocumentKeyDownCapture(event: KeyboardEvent) {\n  // Do nothing if any of the following is true:\n  // 1. No components are registered\n  // 2. Pressed key is not F6\n  // 3. Event is defaultPrevented\n  if (componentsMap.size === 0 || event.key !== 'F6' || event.defaultPrevented) {\n    return;\n  }\n\n  // Try cycling focus through the messages and if that fails\n  // set the focus to the prior focused element.\n  if (!cycleFocusThroughMessages(event)) {\n    currentFocusedMessage && togglePreviousFocus(currentFocusedMessage, event);\n  }\n}\n\n/**\n * Handles the blur event captured on the document\n * @param event Blur event object\n */\nfunction handleDocumentBlurCapture(event: FocusEvent) {\n  priorFocusedElement = event.target as HTMLElement;\n}\n\n/**\n * Handles the keyup event in the component\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param event The keyup event object\n */\nfunction handleComponentKeyUp(id: symbol, event: KeyboardEvent) {\n  // Ignore the call if the comp is not registered anymore or event default is prevented\n  if (!componentsMap.has(id) || event.defaultPrevented) {\n    return;\n  }\n\n  // Additional checks for keyup event and recognized keys\n  if (event.type === 'keyup' && ['Escape'].includes(event.key)) {\n    // toggle focus to the previously focused element\n    togglePreviousFocus(id, event);\n  }\n}\n\n/**\n * Handles the focus event in the component\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param event The focus event object\n */\nfunction handleComponentFocus(id: symbol, event: FocusEvent) {\n  // Ignore the call if the comp is not registered anymore or event default is prevented\n  if (!componentsMap.has(id) || event.defaultPrevented) {\n    return;\n  }\n\n  // Store the id of the current focused message\n  currentFocusedMessage = id;\n\n  // Track previous focus if the priorFocused element is not a part of this or any other\n  // registered component\n  const { callbacks } = componentsMap.get(id)!;\n  if (priorFocusedElement && !isPartOfRegisteredMessages(priorFocusedElement)) {\n    priorFocusCache.set(id, priorFocusedElement!);\n\n    // since the focus moved to this component from outside, call the\n    // onFocus callbacks if available\n    callbacks?.onFocus?.();\n  }\n}\n\n/**\n * Handles the blur event in the component\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param event The focus event object\n */\nfunction handleComponentBlur(id: symbol, event: FocusEvent) {\n  // Ignore the call if the comp is not registered anymore or event default is prevented\n  if (!componentsMap.has(id) || event.defaultPrevented) {\n    return;\n  }\n\n  // reset the current focus message ID\n  currentFocusedMessage = undefined;\n}\n\n/**\n * Cycles the focus through the registered messages component from the previous message of current focused\n * message to the top of the hierarchy.\n *\n * @param event The event that initiated this action\n * @returns boolean indicating the result of this action\n */\nfunction cycleFocusThroughMessages(event: Event) {\n  // At this point, we need to focus the previous message from the current focused\n  // message\n  const nextPosition =\n    indexOfOrDefaultTo(componentsOrder, currentFocusedMessage, componentsOrder.length) - 1;\n  for (let i = nextPosition; i > -1; i--) {\n    const id = componentsOrder[i];\n    const { ref } = componentsMap.get(id) ?? {};\n    if (ref?.current?.focus?.()) {\n      // prevent default action as the event has transferred focus\n      event.preventDefault();\n      // invoke callback to let the current component know the focus is left\n      if (currentFocusedMessage) {\n        const { callbacks } = componentsMap.get(currentFocusedMessage) ?? {};\n        callbacks?.onFocusLeave?.();\n      }\n      // Focus is set, so break the loop\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Checks if the provided element is a part of any of the registered messages\n *\n * @param element The candidate element\n * @returns true if is inside any of the registered messages\n */\nfunction isPartOfRegisteredMessages(element: HTMLElement) {\n  for (const { ref } of componentsMap.values()) {\n    if (ref.current?.contains(element)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Finds the index of the item in the array, if it does not exist returns the\n * default value instead\n *\n * @param arr The array to perform the search\n * @param search The item to be searched\n * @param defaultIndex The default value if the item is not found\n * @returns The index of the item or the default value\n */\nfunction indexOfOrDefaultTo<T>(arr: T[], search: T, defaultIndex = -1) {\n  const index = arr.indexOf(search);\n  if (index !== -1) return index;\n  return defaultIndex;\n}\n\n/**\n * Traverses through the priorFocusCache to fetch the last focused\n * element outside of the messages region.\n *\n * @param id The current focused message's ID\n * @returns The closest prior focused element, null if not found\n */\nfunction getClosestPriorFocusedElement(id: symbol) {\n  // F6 navigation cycles through messages in reverse order\n  // so to get the closest prior focused element we need to\n  // traverse in natural order from the current message\n  const index = componentsOrder.indexOf(id);\n  for (let i = index; i < componentsOrder.length; i++) {\n    if (priorFocusCache.has(componentsOrder[i])) {\n      return priorFocusCache.get(componentsOrder[i])!;\n    }\n  }\n\n  // No prior cache found, so return null\n  return null;\n}\n\n/**\n * Adds the component to the internal members.\n *\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param ref A ref handle to the focusable component\n * @param callbacks Optional callbacks\n */\nfunction addComponent(id: symbol, options: ComponentOptions) {\n  componentsMap.set(id, options);\n  componentsOrder.push(id);\n}\n\n/**\n * Removes the component from the internal members\n *\n * @param id A unique symbol that ids the component to be registered for managing focus\n */\nfunction removeComponent(id: symbol) {\n  if (!componentsMap.has(id)) {\n    return;\n  }\n\n  componentsMap.delete(id);\n  componentsOrder.splice(componentsOrder.indexOf(id), 1);\n}\n\n/**\n * Clears the priorFocusCache of the specified component\n *\n * @param id The id of the component whose cache is to be cleared\n */\nfunction clearFocusCache(id: symbol) {\n  priorFocusCache.delete(id);\n}\n\n/**\n * Adds event listeners to the document element\n */\nfunction addDocumentListeners() {\n  // Add the events in capture phase, as we do not want this to be stopped by the elements\n  // in the DOM tree.\n  // make sure to use keydown as we need to prevent the default behavior which is moving to\n  // the address bar in some browsers & OS.\n  document.documentElement.addEventListener('keydown', handleDocumentKeyDownCapture, true);\n  document.documentElement.addEventListener('blur', handleDocumentBlurCapture, true);\n  hasDocumentListener = true;\n}\n\n/**\n * Removes event listeners from the document element\n */\nfunction removeDocumentListeners() {\n  document.documentElement.removeEventListener('keydown', handleDocumentKeyDownCapture, true);\n  document.documentElement.removeEventListener('blur', handleDocumentBlurCapture, true);\n  hasDocumentListener = false;\n}\n\n/**\n * Registers a component for its focus to be managed.\n *\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param componentOptions An object containing component options\n * @param focusManagerOptions An object containing focus manager options\n *\n * @returns An object containing focus event listeners\n */\nfunction register(\n  id: symbol,\n  componentOptions: ComponentOptions,\n  focusManagerOptions: FocusManagerOptions = { handleEscapeKey: true }\n) {\n  if (!hasDocumentListener) {\n    addDocumentListeners();\n  }\n\n  addComponent(id, componentOptions);\n  const handlers: FocusManagerHandlers = {\n    onFocusIn: (event: FocusEvent) => handleComponentFocus(id, event),\n    onFocusOut: (event: FocusEvent) => handleComponentBlur(id, event)\n  };\n  if (focusManagerOptions.handleEscapeKey) {\n    handlers['onKeyUp'] = (event: KeyboardEvent) => handleComponentKeyUp(id, event);\n  }\n  return handlers;\n}\n\n/**\n * Focuses the element which was focused prior to the passed component.\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param event The event that initiated the focus transfer. The event will be default prevented if the focus\n *              is transferred successfully.\n * @returns true, if focus is restored. false otherwise.\n */\nfunction togglePreviousFocus(id: symbol, event?: Event) {\n  const target = getClosestPriorFocusedElement(id);\n  const { callbacks } = componentsMap.get(id) ?? {};\n  if (target && document.body.contains(target)) {\n    (target as HTMLElement).focus();\n    // invoke callback to let the component know the focus is left\n    callbacks?.onFocusLeave?.();\n    // As the prior focus is restored, empty the focus cache\n    priorFocusCache.clear();\n    event?.preventDefault();\n    return true;\n  }\n\n  // Prior focused element does not exist or\n  // Element does not exist in DOM.\n  return false;\n}\n\n/**\n * Unregisters a component from focus management\n *\n * @param id A unique symbol that ids the component to be registered for managing focus\n */\nfunction unregister(id: symbol) {\n  removeComponent(id);\n  clearFocusCache(id);\n\n  if (hasDocumentListener && componentsMap.size === 0) {\n    // no component is registered, so remove the document listeners\n    removeDocumentListeners();\n  }\n}\n\n/**\n * Moves the priority of the component with the specified id\n *\n * @param id A unique symbol that ids the component to be registered for managing focus\n */\nfunction prioritize(id: symbol) {\n  if (!componentsMap.has(id)) {\n    // Do nothing if the component is not registered\n    return;\n  }\n\n  // Remove and add the component with the same ref\n  // to move it in the priority queue\n  const options = componentsMap.get(id)!;\n  removeComponent(id);\n  addComponent(id, options);\n}\n\n/**\n * The focus manager object\n */\nconst messagesFocusManager = {\n  prioritize,\n  register,\n  togglePreviousFocus,\n  unregister\n};\n\n/**\n * A custom hook that handles focus management for the messages component.\n * @param ref The custom ref handle for the component\n * @param callbacks Optional callbacks\n * @returns The handlers and a controller\n */\nexport function useMessageFocusManager(\n  ref: ComponentOptions['ref'],\n  callbacks?: ComponentOptions['callbacks'],\n  options?: FocusManagerOptions\n) {\n  const id = useRef(Symbol());\n  const focusManager = useRef(messagesFocusManager);\n  const [handlers, setHandlers] = useState<FocusManagerHandlers>({});\n  const controller = useMemo(\n    () => ({\n      prioritize: () => focusManager.current.prioritize(id.current),\n      restorePriorFocus: () => focusManager.current.togglePreviousFocus(id.current)\n    }),\n    []\n  );\n\n  // Register handlers for focus management\n  useEffect(() => {\n    const currentFocusManager = focusManager.current;\n    const currentId = id.current;\n    setHandlers(currentFocusManager.register(currentId, { ref, callbacks }, options));\n    return () => currentFocusManager.unregister(currentId);\n    // eslint-disable-next-line\n  }, []); // we only want this to run on mount\n\n  return {\n    handlers,\n    controller\n  };\n}\n"],"names":["useRef","useState","useMemo","useEffect"],"mappings":"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"}