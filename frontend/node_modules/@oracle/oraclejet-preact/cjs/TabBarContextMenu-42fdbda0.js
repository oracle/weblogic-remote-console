/* @oracle/oraclejet-preact: undefined */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var SelectMenuGroupContext = require('./SelectMenuGroupContext-ae5e1373.js');
require('preact/hooks');
require('preact');
require('./logger-2b636482.js');
require('./LayerHost-aee0e070.js');
require('preact/compat');


require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js');
require('./tooltipUtils-ae48fed6.js');

require('./UNSAFE_Menu/themes/MenuItemStyles.css.js');
var Separator = require('./Separator-85962472.js');


require('./UNSAFE_Menu/themes/redwood/MenuSeparatorVariants.css.js');

var tabBarUtils = require('./tabBarUtils-c421fc75.js');

/**
 * The internal component used to render a custom or default context menu
 */
function TabBarContextMenu({ contextMenuConfig, contextMenuContext, ...menuProps }) {
    const accessibleLabel = contextMenuConfig.accessibleLabel;
    // We want to call itemsRenderer only when menu is open otherwise it would be called during render phase when no context is available
    const menuItems = menuProps.isOpen ? contextMenuConfig.itemsRenderer(contextMenuContext) : null;
    // If there are menu items then we construct the menu otherwise menu will be mounted unnecessarily, if menu items are null we return an empty fragment as return type needs to be a JSX
    if (menuItems != null) {
        return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: jsxRuntime.jsx(SelectMenuGroupContext.Menu, { ...menuProps, ...(accessibleLabel && {
                    'aria-label': accessibleLabel
                }), children: menuItems }) }));
    }
    return jsxRuntime.jsx(jsxRuntime.Fragment, {});
}
/**
 * Creates the default context menu items
 */
function getDefaultContextMenu({ isRemovable, handleReorder, handleRemove, itemKey, tabKeys, direction, itemLabels, handleAccStatus }) {
    const handleRemoveAction = () => {
        handleRemove?.({ value: itemKey });
        handleAccStatus?.({
            removedKey: itemKey
        });
    };
    const isReorderable = handleReorder != null;
    const isRtl = direction === 'rtl';
    const handleMoveAction = (moveDirection) => {
        if (isReorderable && tabKeys) {
            const { newArray, referenceItemIndex } = tabBarUtils.handleMove(moveDirection, tabKeys, itemKey);
            const destinationKey = tabKeys[referenceItemIndex];
            handleReorder?.({
                reorderedKeys: newArray,
                itemKeys: [itemKey],
                referenceKey: destinationKey
            });
            handleAccStatus?.({
                position: moveDirection === 'forward' ? 'after' : 'before',
                destinationKey: destinationKey
            });
        }
    };
    const allMenuItems = isReorderable
        ? {
            moveForwardItem: (jsxRuntime.jsx(SelectMenuGroupContext.MenuItem, { label: isRtl ? itemLabels?.labelMoveLeft : itemLabels?.labelMoveRight, onAction: () => handleMoveAction('forward') })),
            moveBackwardItem: (jsxRuntime.jsx(SelectMenuGroupContext.MenuItem, { label: isRtl ? itemLabels?.labelMoveRight : itemLabels?.labelMoveLeft, onAction: () => handleMoveAction('backward') })),
            removeItem: jsxRuntime.jsx(SelectMenuGroupContext.MenuItem, { label: 'Remove', onAction: handleRemoveAction }),
            remove: jsxRuntime.jsx(SelectMenuGroupContext.MenuItem, { label: 'Remove', onAction: handleRemoveAction }),
            reorder: (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(SelectMenuGroupContext.MenuItem, { label: isRtl ? itemLabels?.labelMoveLeft : itemLabels?.labelMoveRight, onAction: () => handleMoveAction('forward') }), jsxRuntime.jsx(SelectMenuGroupContext.MenuItem, { label: isRtl ? itemLabels?.labelMoveRight : itemLabels?.labelMoveLeft, onAction: () => handleMoveAction('backward') })] }))
        }
        : {
            remove: jsxRuntime.jsx(SelectMenuGroupContext.MenuItem, { label: 'Remove', onAction: handleRemoveAction }),
            removeItem: jsxRuntime.jsx(SelectMenuGroupContext.MenuItem, { label: 'Remove', onAction: handleRemoveAction })
        };
    const createMoveMenuItems = (itemKey) => {
        let moveItem;
        switch (isReorderable) {
            case itemKey === tabKeys?.[0]:
                moveItem = allMenuItems['moveForwardItem'];
                break;
            case itemKey === tabKeys?.[tabKeys.length - 1]:
                moveItem = allMenuItems['moveBackwardItem'];
                break;
            default:
                moveItem = (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [allMenuItems['moveForwardItem'], allMenuItems['moveBackwardItem']] }));
        }
        return moveItem;
    };
    const defaultMenuItems = isRemovable || isReorderable ? (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [isReorderable && tabKeys ? (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [createMoveMenuItems(itemKey), isRemovable ? jsxRuntime.jsx(Separator.Separator, {}) : undefined] })) : undefined, isRemovable ? allMenuItems['remove'] : undefined] })) : undefined;
    return {
        itemKey,
        defaultMenuItems,
        allMenuItems
    };
}

exports.TabBarContextMenu = TabBarContextMenu;
exports.getDefaultContextMenu = getDefaultContextMenu;
//# sourceMappingURL=TabBarContextMenu-42fdbda0.js.map
