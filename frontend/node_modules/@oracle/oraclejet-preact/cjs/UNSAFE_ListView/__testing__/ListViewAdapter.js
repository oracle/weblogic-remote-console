/* @oracle/oraclejet-preact: undefined */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var UNSAFE_Menu___testing___index = require('../../UNSAFE_Menu/__testing__/index.js');
var UNSAFE_Driver = require('@oracle/oraclejet-testing/UNSAFE_Driver');
var UNSAFE_Locators = require('@oracle/oraclejet-testing/UNSAFE_Locators');
var UNSAFE_TestAdapter = require('@oracle/oraclejet-testing/UNSAFE_TestAdapter');
require('../../UNSAFE_Menu/__testing__/MenuAdapter.js');

class ListViewAdapter extends UNSAFE_TestAdapter.TestAdapter {
    /**
     * Toggles the selection state of an item.
     * @param key The key of the item to select or de-select in the ListView
     * @returns Promise<void> or throw error if the key is not found
     */
    async doToggleSelection(key) {
        const driver = this.getTestDriver();
        let item;
        try {
            item = await (await this.getElement()).waitForElement(UNSAFE_Locators.byCss(`[data-oj-key="${key.toString()}"]`));
        }
        catch {
            throw new Error('The key specified is invalid or does not exist');
        }
        await driver.click(item, { modifiers: [UNSAFE_Driver.Keys['CONTROL_COMMAND']] });
    }
    /**
     * Simulates scroll down to trigger fetching of more data
     * Test author would use this to ensure the item is available before performing operations such as select or reorder on it.
     * @returns Promise<void>
     */
    async doLoadMore() {
        const driver = this.getTestDriver();
        const listView = await this.getElement();
        const listItems = await listView.waitForElements(UNSAFE_Locators.byCss('[role="row"]'));
        const itemLength = listItems.length;
        await UNSAFE_Driver.waitFor(async () => {
            driver.sendKeys(listView, UNSAFE_Driver.Keys['PAGE_DOWN']);
            if (await listView.waitForElements(UNSAFE_Locators.byCss('[class="oj-collection-loadmore"]'))) {
                return (await listView.waitForElements(UNSAFE_Locators.byCss('[role="row"]'))).length > itemLength;
            }
            return true;
        });
    }
    /**
     * Reorder an item in the ListView
     * @param key The key of the item to reorder in the ListView
     * @param position The drop position relative to the zero-based reference index or key of the item to move in front of, if the referenceKey is null, the item will move to the end of the list
     * @returns Promise<void> or throw error if the key is not found or the position is invalid
     */
    async doReorder(key, position) {
        const driver = this.getTestDriver();
        const listView = await this.getElement();
        const listItems = await listView.waitForElements(UNSAFE_Locators.byCss('[role="row"]'));
        if ('index' in position && (position.index < 0 || position.index > listItems.length - 1)) {
            throw new Error('invaild index');
        }
        let desIndex = -1;
        let srcIndex = -1;
        let item;
        try {
            item = await listView.waitForElement(UNSAFE_Locators.byCss(`[data-oj-key="${key.toString()}"]`));
            if ('index' in position && position.index) {
                desIndex = position.index;
            }
            //We will move the item at the end of the list when the referenceKey is null, so we need a check here.
            if ('referenceKey' in position && position.referenceKey === null) {
                desIndex = listItems.length;
            }
            for (let i = 0; i < listItems.length; i++) {
                const currentKey = await listItems[i].getAttribute('data-oj-key');
                if (currentKey === key.toString()) {
                    srcIndex = i;
                }
                if (desIndex === -1 &&
                    'referenceKey' in position &&
                    position.referenceKey != null &&
                    currentKey === position.referenceKey.toString()) {
                    desIndex = i;
                }
            }
            //We want to move the item in front of the the referenceKey, do the desIndex mins 1.
            if ('referenceKey' in position && srcIndex < desIndex) {
                desIndex--;
            }
            if (desIndex === -1 || srcIndex === -1) {
                throw new Error('The key specified is invalid or does not exist or the index is invaild');
            }
            await driver.click(item);
            if (srcIndex < desIndex) {
                for (let i = 0; i < desIndex - srcIndex; i++) {
                    await driver.sendKeys(listView, UNSAFE_Driver.Keys['SHIFT'], UNSAFE_Driver.Keys['CONTROL'], UNSAFE_Driver.Keys['ARROW_DOWN']);
                }
            }
            else {
                for (let i = 0; i < srcIndex - desIndex; i++) {
                    await driver.sendKeys(listView, UNSAFE_Driver.Keys['SHIFT'], UNSAFE_Driver.Keys['CONTROL'], UNSAFE_Driver.Keys['ARROW_UP']);
                }
            }
        }
        catch {
            throw new Error('The key specified is invalid or does not exist');
        }
    }
    /**
     * Perform the context menu action for an item in the ListView
     * @param key The key to the item to perform the context menu action on.
     * @param path The path that consist of the label/key of the menu item and the label/key of the submenu that leads to the menu item.
     * @returns Promise<void> or throw error if the key is not found or the path is invalid
     */
    async doContextMenuAction(key, path) {
        const driver = this.getTestDriver();
        const listView = await this.getElement();
        const testId = await listView.getAttribute('data-testid');
        try {
            const menu = await findContextMenu(driver, key, listView, testId);
            return menu.doMenuAction({ label: path.menuItemLabel, key: path.menuItemKey });
        }
        catch {
            throw new Error('The key specified is invalid or does not exist');
        }
    }
    /**
     * Perform the context menu group action for an item in the ListView
     * @param key The key to the item to perform the context menu action on.
     * @param path The path that consist of the label/key of the menu item and the label/key of the submenu that leads to the menu item. If key is specified it also include item value of the select menu item that is going to be clicked.
     * @returns Promise<void> or throw error if the key is not found or the path is invalid
     */
    async doContextMenuGroupAction(key, path) {
        const driver = this.getTestDriver();
        const listView = await this.getElement();
        const testId = await listView.getAttribute('data-testid');
        try {
            const menu = await findContextMenu(driver, key, listView, testId);
            await menu.doMenuGroupAction({
                label: path.menuItemLabel,
                key: path.menuItemKey,
                itemValue: path.menuItemValue
            });
        }
        catch {
            throw new Error('The key specified is invalid or does not exist');
        }
    }
}
// Method that to open the context menu for each list item
const findContextMenu = async (driver, key, listView, testId) => {
    const item = await listView.waitForElement(UNSAFE_Locators.byCss(`[data-oj-key="${key.toString()}"]`));
    await driver.click(item);
    await driver.sendKeys(listView, UNSAFE_Driver.Keys['SHIFT'], UNSAFE_Driver.Keys['F10']);
    await delay(100);
    return UNSAFE_Menu___testing___index.findMenu(UNSAFE_Locators.byTestId(testId + '-menu'));
};
// TODO: Adding a delay for now since in the first ms menu could not be present in DOM.
// This needs to be removed once we know what we should do in this kind of use cases
const delay = (ms) => new Promise((resolve) => setTimeout(() => {
    resolve(true);
}, ms));

exports.ListViewAdapter = ListViewAdapter;
//# sourceMappingURL=ListViewAdapter.js.map
