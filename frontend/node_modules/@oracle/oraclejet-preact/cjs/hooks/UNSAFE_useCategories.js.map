{"version":3,"file":"UNSAFE_useCategories.js","sources":["../../../src/hooks/UNSAFE_useCategories/useCategories.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useMemo, useRef } from 'preact/hooks';\nimport { isEqual } from '../../utils/UNSAFE_visUtils/eventsUtils';\n\nexport type CategoriesProps<K extends number | string> = {\n  items: { item: { id: K } }[];\n  getCategoriesFromItem: (item: { id: K }) => string[];\n  initialCategories?: string[];\n  matchCriteria?: 'any' | 'all';\n  replace?: boolean;\n  onCategoriesChange?: (categories: string[]) => void;\n};\n\n/**\n * Toggles the existing categories/id with updated categories/id.\n * @param original The set of original ids/categories\n * @param updated The set of updated ids/categories\n * @returns\n */\nconst toggle = <T>(original: Set<T>, updated: Set<T>) => {\n  const matches = new Set(original);\n  updated.forEach((item) => {\n    if (!original.has(item)) {\n      matches.add(item);\n    } else {\n      matches.delete(item);\n    }\n  });\n  return matches;\n};\n\n/**\n * Creates initial map of category and data items.\n * @param items Data item objects. If 'categories' field is not present, id will be assumed to be default category.\n */\nfunction getCategoryMap<K extends number | string>(\n  items: { item: { id: K } }[],\n  getCategory: (item: { id: K }) => string[]\n) {\n  const categoryToItem: Map<string, Set<K>> = new Map();\n  const itemToCategory: Map<K, Set<string>> = new Map();\n  items.forEach((item: any) => {\n    const id: K = item.id;\n    const categories: string[] = getCategory(item);\n    itemToCategory.set(id, new Set(categories));\n    categories.forEach((category) => {\n      if (categoryToItem.has(category)) {\n        categoryToItem.get(category)?.add(id);\n      } else {\n        categoryToItem.set(category, new Set([id]));\n      }\n    });\n  });\n  return { categoryToItem, itemToCategory };\n}\n\n/**\n * Returns the items for a given categories.\n * @param categoryToItemMap Map of categories to Item.\n * @param matchCriteria Whether to match any or all categories.\n * @param categories categories\n * @returns\n */\nfunction getItemsFromCategories<K>(\n  categoryToItemMap: Map<string, Set<K>>,\n  matchCriteria: 'any' | 'all' = 'any',\n  categories: Set<string>\n) {\n  return [...categories].reduce((acc: Set<K>, cur: string, index: number) => {\n    const curItems = categoryToItemMap.get(cur)!;\n    if (matchCriteria === 'any') {\n      return curItems ? new Set([...acc, ...curItems]) : acc;\n    }\n\n    if (!index) return curItems;\n    return new Set([...acc].filter((item) => curItems.has(item)));\n  }, new Set<K>());\n}\n\n/**\n * A hook that helps to manage getting ids that match specific categories or criterias in a set of data. It also handles partial versus exact matching.\n *\n * @param items The array of items.\n * @param getCategoriesFromItem The function that returns the categories array for given item.\n * @param initialCategories The initial categories.\n * @param matchCriteria  The matching condition for the categories.\n * By default, matchCriteria is 'all' and only items whose categories match all of the values specified in the categories array will be matched.\n * If matchCriteria is 'any', then items that match at least one of the categories values will be matched.\n * @param replace Whether the new categories should completely replace the old categories (for highlighting) or just toggle previous categories (for hideAndShow)\n * @param onCategoriesChange The callback to invoke when categories change.\n * @returns ids An array of item ids (K[]) that match the current selected categories, according to the 'matchCriteria'. This is the result of filtering items based on the categories that have been selected.\n * @returns updateCategories The function to update the selected categories/items. It modifies the current set of categories either by toggling (replace: false) or replacing (replace: true), and updates the items that match the new categories.\n */\nexport const useCategories = <K extends string | number>({\n  items,\n  getCategoriesFromItem,\n  initialCategories = [],\n  matchCriteria = 'all',\n  replace = true,\n  onCategoriesChange\n}: CategoriesProps<K>) => {\n  const categoryMap = useMemo(\n    () => getCategoryMap<K>(items, getCategoriesFromItem),\n    [items, getCategoriesFromItem]\n  );\n\n  const initialCategoriesSet = new Set(initialCategories);\n  const newIds = getItemsFromCategories(\n    categoryMap.categoryToItem,\n    matchCriteria,\n    initialCategoriesSet\n  );\n\n  const categoriesRef = useRef(initialCategoriesSet);\n  const idsRef = useRef(newIds);\n\n  if (!isEqual(newIds, idsRef.current)) {\n    idsRef.current = newIds;\n  }\n\n  if (!isEqual(categoriesRef.current, initialCategoriesSet)) {\n    categoriesRef.current = initialCategoriesSet;\n    onCategoriesChange?.([...initialCategoriesSet]);\n  }\n\n  const updateCategories = (id: K | undefined) => {\n    let updatedCategories = id != null ? categoryMap.itemToCategory.get(id)! : new Set([]);\n    let updatedItems = getItemsFromCategories(\n      categoryMap.categoryToItem,\n      matchCriteria,\n      updatedCategories\n    );\n\n    if (!replace) {\n      updatedItems = toggle(idsRef.current, updatedItems);\n      updatedCategories = toggle(categoriesRef.current, updatedCategories);\n    }\n\n    if (!isEqual(updatedItems, idsRef.current)) {\n      idsRef.current = updatedItems;\n    }\n\n    if (updatedCategories && !isEqual(updatedCategories, categoriesRef.current)) {\n      categoriesRef.current = updatedCategories;\n      onCategoriesChange?.([...updatedCategories]);\n    }\n  };\n\n  return {\n    ids: [...idsRef.current],\n    updateCategories\n  };\n};\n"],"names":["useMemo","useRef","isEqual"],"mappings":"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"}