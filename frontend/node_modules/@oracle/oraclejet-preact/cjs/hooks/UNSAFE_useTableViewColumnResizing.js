/* @oracle/oraclejet-preact: undefined */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var preact = require('preact');
var hooks = require('preact/hooks');
var useResizeObserver = require('../useResizeObserver-a9e97180.js');
require('../useAddBusyState-d19ae1fa.js');
require('../BusyStateContext-86f40d3c.js');
require('../useBusyStateContext-362eee2a.js');
require('../unsafeDomAccess-c3a492f0.js');

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const _defaultMinWidth = 16;
/**
 * Utility hook for controlling a TableView's sizing.
 */
function useTableViewColumnResizing({ columnOrder, columnWidths, onColumnWidthsChanging, onColumnWidthsChange, applyWidths = 'onResizing', minColumnWidth = _defaultMinWidth, resizeBehavior = 'redistribute' }) {
    const columnWidthsRef = hooks.useRef(columnWidths);
    columnWidthsRef.current = columnWidths;
    const [columnResizingIndicator, setColumnResizingIndicator] = hooks.useState();
    const columnResizingStartingColumnWidthsRef = hooks.useRef();
    const frozenAddColumnWidthsRef = hooks.useRef({});
    const [frozenAddColumnWidths, setFrozenAddColumnWidths] = hooks.useState({});
    // ensure all 'real' column widths are applied to the local realizedColumnWidths
    const realizedColumnWidths = {};
    const updatedKeys = [];
    if (columnWidths != null) {
        const keys = Object.keys(columnWidths);
        for (const key of keys) {
            realizedColumnWidths[key] = columnWidths[key];
            updatedKeys.push(key);
        }
    }
    // ensure all 'frozenAdd' column widths are applied to the local realizedColumnWidths
    const frozenAddKeys = Object.keys(frozenAddColumnWidths);
    for (const frozenAddKey of frozenAddKeys) {
        if (!updatedKeys.includes(frozenAddKey)) {
            realizedColumnWidths[frozenAddKey] = frozenAddColumnWidths[frozenAddKey];
        }
    }
    const addResizePaddingWidthRef = hooks.useRef(0);
    const _cloneColumnWidths = hooks.useCallback((widths) => {
        const keys = Object.keys(widths);
        const newColumnWidths = {};
        for (const key of keys) {
            newColumnWidths[key] = widths[key];
        }
        return newColumnWidths;
    }, []);
    /**
     * Helper method to update the Table's column widths while a column resize operation is ongoing.
     */
    const onColumnResizing = hooks.useCallback((detail) => {
        // save the initial state when column resize begins
        if (columnResizingStartingColumnWidthsRef.current == null) {
            columnResizingStartingColumnWidthsRef.current = detail.allColumnWidths;
        }
        const newStaticColumnWidths = _cloneColumnWidths(columnWidthsRef.current != null ? columnWidthsRef.current : {});
        const startKey = detail.key;
        const endKey = columnOrder[columnOrder.indexOf(startKey) + 1];
        const initialStartWidth = columnResizingStartingColumnWidthsRef.current[startKey];
        const initialEndWidth = columnResizingStartingColumnWidthsRef.current[endKey];
        const newStartWidth = Math.min(Math.max(initialStartWidth + detail.delta, minColumnWidth), initialStartWidth + initialEndWidth - minColumnWidth);
        newStaticColumnWidths[startKey] = newStartWidth;
        const newEndWidth = initialEndWidth + initialStartWidth - newStartWidth;
        newStaticColumnWidths[endKey] = newEndWidth;
        if (onColumnWidthsChanging != null) {
            onColumnWidthsChanging(newStaticColumnWidths);
        }
        columnWidthsRef.current = newStaticColumnWidths;
        setColumnResizingIndicator({ key: startKey, delta: 0 });
    }, [onColumnWidthsChanging, minColumnWidth, columnOrder, _cloneColumnWidths]);
    /**
     * Helper method to update the Table's column resize indicator line only.
     */
    const onColumnIndicatorResizing = hooks.useCallback((detail) => {
        const startKey = detail.key;
        const endKey = columnOrder[columnOrder.indexOf(startKey) + 1];
        const initialStartWidth = detail.allColumnWidths[startKey];
        const initialEndWidth = detail.allColumnWidths[endKey];
        const newStartWidth = Math.min(Math.max(initialStartWidth + detail.delta, minColumnWidth), initialStartWidth + initialEndWidth - minColumnWidth);
        setColumnResizingIndicator({ key: startKey, delta: newStartWidth - initialStartWidth });
    }, [columnOrder, minColumnWidth]);
    /**
     * Helper method to update the Table's column widths at the end of column resize operation. This is
     * the same as during an ongoing resize operation, but additionally pushes back the resized column widths
     * to the consumer if a 'setInitialColumnWidths' callback is provided, and removes the indicator line.
     */
    const onColumnResize = hooks.useCallback((detail) => {
        const initialWidths = columnResizingStartingColumnWidthsRef.current != null
            ? columnResizingStartingColumnWidthsRef.current
            : detail.allColumnWidths;
        const newStaticColumnWidths = _cloneColumnWidths(columnWidthsRef.current != null ? columnWidthsRef.current : {});
        const startKey = detail.key;
        const initialStartWidth = initialWidths[startKey];
        let newStartWidth;
        if (detail.type === 'absolute') {
            newStartWidth = Math.max(detail.newWidth, minColumnWidth);
            newStaticColumnWidths[startKey] = newStartWidth;
        }
        else {
            const endKey = columnOrder[columnOrder.indexOf(startKey) + 1];
            const initialEndWidth = initialWidths[endKey];
            newStartWidth = Math.min(Math.max(initialStartWidth + detail.delta, minColumnWidth), initialStartWidth + initialEndWidth - minColumnWidth);
            const newEndWidth = initialEndWidth + initialStartWidth - newStartWidth;
            newStaticColumnWidths[endKey] = newEndWidth;
        }
        newStaticColumnWidths[startKey] = newStartWidth;
        if (onColumnWidthsChange != null) {
            onColumnWidthsChange(newStaticColumnWidths);
        }
        columnWidthsRef.current = newStaticColumnWidths;
        columnResizingStartingColumnWidthsRef.current = undefined;
        setColumnResizingIndicator(undefined);
    }, [onColumnWidthsChange, minColumnWidth, columnOrder, _cloneColumnWidths]);
    /**
     * Helper method to update the Table's column widths while a column resize operation is ongoing.
     */
    const onAddBehaviorResizing = hooks.useCallback((detail) => {
        addResizePaddingWidthRef.current = detail.paddingWidth;
        // save the initial state when column resize begins
        if (columnResizingStartingColumnWidthsRef.current == null) {
            columnResizingStartingColumnWidthsRef.current = detail.allColumnWidths;
        }
        const newFrozenColumnWidths = _cloneColumnWidths(columnResizingStartingColumnWidthsRef.current != null
            ? columnResizingStartingColumnWidthsRef.current
            : detail.allColumnWidths);
        const newStaticColumnWidths = _cloneColumnWidths(columnWidthsRef.current != null ? columnWidthsRef.current : {});
        const startKey = detail.key;
        const initialStartWidth = columnResizingStartingColumnWidthsRef.current[startKey];
        const newStartWidth = Math.max(initialStartWidth + detail.delta, minColumnWidth);
        newStaticColumnWidths[startKey] = newStartWidth;
        newFrozenColumnWidths[startKey] = newStartWidth;
        if (onColumnWidthsChanging != null) {
            onColumnWidthsChanging(newStaticColumnWidths);
        }
        setFrozenAddColumnWidths(newFrozenColumnWidths);
        frozenAddColumnWidthsRef.current = newFrozenColumnWidths;
        setColumnResizingIndicator({ key: startKey, delta: 0 });
    }, [onColumnWidthsChanging, minColumnWidth, _cloneColumnWidths]);
    /**
     * Helper method to update the Table's column resize indicator line only.
     */
    const onAddBehaviorIndicatorResizing = hooks.useCallback((detail) => {
        addResizePaddingWidthRef.current = detail.paddingWidth;
        const startKey = detail.key;
        const initialStartWidth = detail.allColumnWidths[startKey];
        const newStartWidth = Math.max(initialStartWidth + detail.delta, minColumnWidth);
        setColumnResizingIndicator({ key: startKey, delta: newStartWidth - initialStartWidth });
    }, [minColumnWidth]);
    /**
     * Helper method to update the Table's column widths at the end of column resize operation. This is
     * the same as during an ongoing resize operation, but additionally pushes back the resized column widths
     * to the consumer if a 'setInitialColumnWidths' callback is provided, and removes the indicator line.
     */
    const onAddBehaviorResize = hooks.useCallback((detail) => {
        addResizePaddingWidthRef.current = detail.paddingWidth;
        const initialWidths = columnResizingStartingColumnWidthsRef.current != null
            ? columnResizingStartingColumnWidthsRef.current
            : detail.allColumnWidths;
        const newFrozenColumnWidths = _cloneColumnWidths(columnResizingStartingColumnWidthsRef.current != null
            ? columnResizingStartingColumnWidthsRef.current
            : detail.type === 'absolute'
                ? columnWidthsRef.current != null
                    ? columnWidthsRef.current
                    : {}
                : detail.allColumnWidths);
        const newStaticColumnWidths = _cloneColumnWidths(columnWidthsRef.current != null ? columnWidthsRef.current : {});
        const startKey = detail.key;
        const initialStartWidth = initialWidths[startKey];
        const newStartWidth = detail.type === 'delta'
            ? Math.max(initialStartWidth + detail.delta, minColumnWidth)
            : Math.max(detail.newWidth, minColumnWidth);
        newStaticColumnWidths[startKey] = newStartWidth;
        newFrozenColumnWidths[startKey] = newStartWidth;
        if (onColumnWidthsChange != null) {
            onColumnWidthsChange(newStaticColumnWidths);
        }
        setFrozenAddColumnWidths(newFrozenColumnWidths);
        frozenAddColumnWidthsRef.current = newFrozenColumnWidths;
        columnResizingStartingColumnWidthsRef.current = undefined;
        setColumnResizingIndicator(undefined);
    }, [onColumnWidthsChange, minColumnWidth, _cloneColumnWidths]);
    const onColumnResizingHandler = applyWidths === 'onResize'
        ? resizeBehavior === 'add'
            ? onAddBehaviorIndicatorResizing
            : onColumnIndicatorResizing
        : resizeBehavior === 'add'
            ? onAddBehaviorResizing
            : onColumnResizing;
    const tableWidthRef = hooks.useRef();
    // scrollerRef is callback-based to meet useResizeObserver hook's state management requirements
    const [scrollerRef, setScrollerRef] = hooks.useState(preact.createRef());
    const scrollerRefCallback = hooks.useCallback((unsafeDomAccess) => {
        setScrollerRef({ current: unsafeDomAccess });
    }, []);
    // setup a resize observer to unfreeze and previously 'frozen' column widths when required
    useResizeObserver.useResizeObserver(scrollerRef, hooks.useCallback((entry) => {
        const boxSize = entry.contentBoxSize;
        const newWidth = boxSize[0].inlineSize;
        if (tableWidthRef.current == null || tableWidthRef.current !== newWidth) {
            tableWidthRef.current = newWidth;
            let totalWidth = 0;
            const keys = Object.keys(frozenAddColumnWidthsRef.current);
            for (const key of keys) {
                totalWidth += frozenAddColumnWidthsRef.current[key];
            }
            if (newWidth >= totalWidth + addResizePaddingWidthRef.current) {
                setFrozenAddColumnWidths({});
                frozenAddColumnWidthsRef.current = {};
            }
        }
    }, []), { isDisabled: resizeBehavior === 'redistribute' });
    const onColumnResizeHandler = resizeBehavior === 'add' ? onAddBehaviorResize : onColumnResize;
    return {
        columnResizingProps: {
            onColumnResizing: onColumnResizingHandler,
            onColumnResize: onColumnResizeHandler,
            columnResizingIndicator: columnResizingIndicator,
            columnWidths: realizedColumnWidths,
            scrollerRef: scrollerRefCallback
        }
    };
}

exports.useTableViewColumnResizing = useTableViewColumnResizing;
//# sourceMappingURL=UNSAFE_useTableViewColumnResizing.js.map
