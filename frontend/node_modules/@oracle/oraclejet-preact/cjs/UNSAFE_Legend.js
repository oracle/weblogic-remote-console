/* @oracle/oraclejet-preact: undefined */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
var useLegendContextMenu = require('./useLegendContextMenu-2a905d60.js');
var useVisEvents = require('./useVisEvents-9b21e260.js');
var useLegendDnd = require('./useLegendDnd-47d9f5ba.js');
var mergeProps = require('./mergeProps-e3da7237.js');
var useItemFocus = require('./useItemFocus-0c5fbee7.js');
var PRIVATE_BaseLegend_themes_LegendStyles_css = require('./PRIVATE_BaseLegend/themes/LegendStyles.css.js');
var useCssVars = require('./useCssVars-cc025013.js');
var classNames = require('./classNames-c14c6ef3.js');
var useTestId = require('./useTestId-9093a54b.js');
var useVisTouchResponse = require('./useVisTouchResponse-376e11d5.js');
var stringUtils = require('./stringUtils-3e19c8af.js');
var compat = require('preact/compat');
var TrackResizeContainer = require('./TrackResizeContainer-100be103.js');
var useTextDimensions = require('./useTextDimensions-c8b41697.js');
var hooks_PRIVATE_useVisDnd_themes_VisDndStyles_css = require('./hooks/PRIVATE_useVisDnd/themes/VisDndStyles.css.js');
var LegendRendered = require('./LegendRendered-c12152bc.js');
require('./SvgSymbol-d6be74d9.js');
require('./Marker-b40392cc.js');
require('./PRIVATE_SvgShapes/themes/SvgShapesStyles.css.js');

require('./Text-436e8b56.js');
require('./mergeInterpolations-6727b536.js');
require('./mergeDeepWithKey-210b024d.js');
require('./_curry3-18677bca.js');
require('./_curry1-e8f0d7ea.js');
require('./_curry2-c15d89cd.js');
require('./_isObject-28636267.js');
require('./UNSAFE_Text/themes/TextStyles.css.js');

require('./vanilla-extract-recipes-createRuntimeFn.esm-d1301b2d.js');
require('./clientHints-c40c5250.js');
require('./useUser-f900ddf1.js');
require('./LayerHost-aee0e070.js');
require('./index-15e13649.js');
require('preact');
require('./UNSAFE_Layer/themes/LayerHostStyles.css.js');

require('./datatipUtils-d1ca81a1.js');
require('./clientUtils-a4619fcd.js');
require('./useDatatip-4f6d3759.js');
require('./Layer-28b1afce.js');
require('./UNSAFE_Layer/themes/LayerStyles.css.js');

require('./useThemeInterpolations-4faece98.js');
require('./useColorScheme-23e4aab4.js');
require('./useScale-adc62f41.js');
require('./theme-dfd6a9fe.js');
require('./Theme-f06687af.js');
require('./useDensity-022a8f80.js');
require('./unsafeDomAccess-c3a492f0.js');
require('./Floating-5a704a27.js');
require('./useFloating-13101293.js');
require('./positionUtils-a780137e.js');
require('./refUtils-a9872e75.js');
require('./useOutsideClick-c3802f86.js');
require('./arrayUtils-7d8dcfc3.js');
require('./useModal-0739a528.js');
require('./useComponentTheme-082fc8e4.js');
require('./logger-2b636482.js');
require('./utils-a66430fc.js');
require('./themeContract.css-a53fd740.js');
require('./colorUtils-01f3caa2.js');
require('./UNSAFE_Floating/themes/redwood/FloatingTheme.js');
require('./UNSAFE_Floating/themes/FloatingStyles.css.js');

require('./UNSAFE_Floating/themes/redwood/FloatingBaseTheme.css.js');

require('./UNSAFE_Floating/themes/redwood/FloatingVariants.css.js');
require('./vanilla-extract-dynamic.esm-2e1b7c25.js');
require('./UNSAFE_Floating/themes/FloatingContract.css.js');
require('./useUnsafeDomElementRef-f22a2f0c.js');
require('./hooks/PRIVATE_useDatatip/themes/useDatatip.css.js');

require('./useId-6c0eeb27.js');
require('./useVisHover-ad36112d.js');
require('./useContextMenu-e90f401c.js');
require('./SelectMenuGroupContext-ae5e1373.js');
require('./Sheet-44b25f1d.js');
require('./Modal-0cea796e.js');
require('./UNSAFE_Modal/themes/ModalStyles.css.js');

require('./tabbableUtils-7e41d383.js');
require('./head-68d0992f.js');
require('./_arity-c228159c.js');
require('./_isArray-73160ad5.js');
require('./_isString-f4443c9e.js');
require('./popupUtils-488fe8f7.js');
require('./WindowOverlay-a10f995e.js');
require('./UNSAFE_WindowOverlay/themes/WindowOverlayStyles.css.js');

require('./UNSAFE_WindowOverlay/themes/WindowOverlayContract.css.js');
require('./UNSAFE_WindowOverlay/themes/redwood/WindowOverlayTheme.js');
require('./UNSAFE_WindowOverlay/themes/redwood/WindowOverlayBaseTheme.css.js');

require('./UNSAFE_WindowOverlay/themes/redwood/WindowOverlayVariants.css.js');
require('./UNSAFE_Sheet/themes/SheetStyles.css.js');

require('./useAnimationStatus-c0c14bcc.js');
require('./useAnimation-fb11e4cc.js');
require('./animationUtils-54852d03.js');
require('./useTranslationBundle-18b7bf8b.js');
require('./Dropdown-b2579045.js');
require('./keyboardUtils-b42fe7d5.js');
require('./usePopupAnimation-18040396.js');
require('./popupAnimationUtils-dcace427.js');
require('./CollectionInteractionContext-f84ff7a1.js');
require('./UNSAFE_Dropdown/themes/dropdownStyles.css.js');

require('./useOutsideMousedown-8f913d1a.js');
require('./UNSAFE_Menu/themes/MenuStyles.css.js');

require('./UNSAFE_Menu/themes/DropdownMenuStyles.css.js');

require('./Flex-6ca216a7.js');
require('./boxalignment-6dde2812.js');
require('./size-0717c0bd.js');

require('./vanilla-extract-sprinkles-createRuntimeSprinkles.esm-d68f3e0f.js');
require('./dimensions-2fcc0acf.js');
require('./flexbox-2cae9a01.js');

require('./flexitem-fee13e26.js');


require('./Skeleton-e746e396.js');
require('./borders-4b8488cb.js');
require('./UNSAFE_Skeleton/themes/redwood/SkeletonTheme.js');
require('./UNSAFE_Skeleton/themes/SkeletonStyles.css.js');

require('./UNSAFE_Skeleton/themes/redwood/SkeletonBaseTheme.css.js');

require('./UNSAFE_Skeleton/themes/redwood/SkeletonVariants.css.js');
require('./UNSAFE_Menu/themes/MenuSkeletonStyles.css.js');

require('./LiveRegion-e410e187.js');

require('./UNSAFE_Menu/themes/redwood/MenuItemTheme.js');
require('./UNSAFE_Menu/themes/MenuItemStyles.css.js');

require('./UNSAFE_Menu/themes/redwood/MenuItemBaseTheme.css.js');

require('./UNSAFE_Menu/themes/redwood/MenuItemVariants.css.js');

require('./usePress-886180e4.js');
require('./useInteractionStyle-c203a8a0.js');
require('./useHover-49b0430d.js');
require('./useToggle-3ebba7d8.js');
require('./useActive-6770f917.js');


require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js');

require('./tooltipUtils-ae48fed6.js');
require('./EnvironmentProvider-8696a5b8.js');
require('./LayerManager-fc4df14f.js');

require('./UNSAFE_Separator/themes/SeparatorStyles.css.js');



require('./UNSAFE_Menu/themes/redwood/MenuSeparatorVariants.css.js');
require('./useContextMenuGesture-03ba6353.js');
require('./textSelectionUtils-432ab66b.js');
require('./layoutUtils-e52005dc.js');
require('./eventsUtils-d34f8647.js');
require('./useDnd-a7d9b60c.js');

require('./useTheme-09dfbb78.js');
require('./useSize-8115eae0.js');
require('./useResizeObserver-a9e97180.js');
require('./useAddBusyState-d19ae1fa.js');
require('./BusyStateContext-86f40d3c.js');
require('./useBusyStateContext-362eee2a.js');


/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
function getItem(itemInfo, items) {
    const { itemIdx } = itemInfo;
    if (itemIdx == -1) {
        return items[items.length - 1];
    }
    return items[itemIdx];
}
function getNextItemInfo(itemInfo, items) {
    let itemIdx = itemInfo.itemIdx;
    if (itemIdx == -1) {
        itemIdx = items.length - 1;
    }
    itemIdx = Math.min(items.length - 1, itemIdx + 1);
    if (items[itemIdx].actionable !== 'off') {
        return { sectionIdx: 0, itemIdx };
    }
    else if (itemIdx === items.length - 1) {
        itemIdx = itemIdx - 1;
        return { sectionIdx: 0, itemIdx };
    }
    return getNextItemInfo({ sectionIdx: 0, itemIdx }, items);
}
function getPrevItemInfo(itemInfo, items) {
    let itemIdx = itemInfo.itemIdx;
    if (itemIdx == -1) {
        itemIdx = items.length - 1;
    }
    itemIdx = Math.max(0, itemIdx - 1);
    if (items[itemIdx].actionable !== 'off') {
        return { sectionIdx: 0, itemIdx };
    }
    return getPrevItemInfo({ sectionIdx: 0, itemIdx }, items);
}
/**
 * Returns utils functions for navigation in simple legend.
 * @param items
 * @returns
 */
function getLegendNavUtils(items) {
    return {
        getItem: (itemInfo) => {
            return getItem(itemInfo, items);
        },
        getDetailFromInfo: (itemInfo) => {
            if (!itemInfo || items.length === 0) {
                return { itemId: undefined, data: undefined };
            }
            const item = getItem(itemInfo, items);
            return { itemId: item.id, data: item };
        },
        getPrevItemInfo: (itemInfo) => {
            return getPrevItemInfo(itemInfo, items);
        },
        getNextItemInfo: (itemInfo) => {
            return getNextItemInfo(itemInfo, items);
        }
    };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const getLinearLegendLayoutInfo = ({ width, getTextDimensions, resolvedVars, orientation, legendFontStylesObj = {}, symbolWidth, items }) => {
    let maxWidth = 0;
    let maxHeight = 0;
    let totalWidth = 0;
    let isWrapped = false;
    const containerWidth = width;
    if (!Object.keys(resolvedVars).length || !getTextDimensions) {
        return;
    }
    const unitLength = parseFloat(resolvedVars['unit']);
    const { maxItemWidth, maxItemHeight, horizontalSectionWidth } = getMaxWidth(items, unitLength, getTextDimensions, legendFontStylesObj, symbolWidth);
    totalWidth = horizontalSectionWidth;
    maxWidth = maxItemWidth;
    maxHeight = maxItemHeight;
    isWrapped = horizontalSectionWidth > containerWidth;
    const legendLayoutInfo = {
        totalWidth,
        maxItemWidth: Math.min(maxWidth, containerWidth),
        maxItemHeight: maxHeight,
        itemsPerRow: orientation === 'vertical' ? 1 : Math.max(1, Math.floor(containerWidth / maxWidth)),
        isWrapped
    };
    return legendLayoutInfo;
};
/**
 * Returns maximum of the width among the items in a section of legend also return the width of the entire section.
 * @param items Legend items array
 * @param unitLength Base  element
 * @param getTextDimensions Text width measurement function
 * @param legendFontStylesObj Legend text font style properties object
 * @param symbolWidth Width of legend symbol
 *
 * @returns
 */
const getMaxWidth = (items, unitLength, getTextDimensions, legendFontStylesObj, symbolWidth, symbolHeight) => {
    let maxItemWidth = 0;
    let maxItemHeight = 0;
    let horizontalSectionWidth = 0;
    let itemSymbolWidth = 0;
    let itemSymbolHeight = 0;
    if (symbolWidth) {
        itemSymbolWidth = unitLength * 1.5 + symbolWidth;
    }
    else {
        //itemSymbolWidth = marginLeft + marginRight + width below expression is simplified
        itemSymbolWidth = 4 * unitLength;
    }
    if (symbolHeight) {
        // symbolHeight/defaultSymbolHeight + symbolPaddingTopBottom
        itemSymbolHeight = symbolHeight + unitLength * 1.7;
    }
    else {
        // symbolHeight/defaultSymbolHeight + symbolPaddingTopBottom
        itemSymbolHeight = 2.5 * unitLength + unitLength * 1.7;
    }
    items?.forEach((item) => {
        const legendItem = item;
        const { width, height } = getTextDimensions(legendItem.text, legendFontStylesObj);
        //itemTextWidth = paddingLeft + paddingRight + width
        const itemTextWidth = unitLength * 2.5 + width;
        //horizontalSectionWidth = total width of the section
        horizontalSectionWidth += itemSymbolWidth + itemTextWidth;
        maxItemWidth = Math.max(maxItemWidth, itemSymbolWidth + itemTextWidth);
        maxItemHeight = Math.max(maxItemHeight, height, itemSymbolHeight);
    });
    return { maxItemWidth, maxItemHeight, horizontalSectionWidth };
};
function _getPreferredSize(_width, _height, items, resolvedVars, orientation, legendFontStylesObj, symbolWidth, symbolHeight, getTextDimensions) {
    if (!getTextDimensions) {
        return undefined;
    }
    const layoutInfo = getLinearLegendLayoutInfo({
        width: _width,
        getTextDimensions,
        resolvedVars,
        orientation,
        legendFontStylesObj,
        symbolWidth: symbolWidth,
        symbolHeight: symbolHeight,
        items
    });
    const { itemsPerCol, itemsPerRow } = useLegendDnd.getGridNums(items.length, layoutInfo, orientation);
    const unitLength = parseFloat(resolvedVars['unit']);
    const preferredWidth = Math.min(_width, itemsPerCol === 1
        ? layoutInfo.totalWidth
        : itemsPerRow
            ? layoutInfo.maxItemWidth * itemsPerRow
            : layoutInfo.totalWidth);
    const paddingLegendItems = 0.8 * unitLength;
    const paddingLegendTopBottom = 1.5 * unitLength;
    const legendHeight = itemsPerCol
        ? layoutInfo.maxItemHeight * itemsPerCol +
            (itemsPerCol - 1) * paddingLegendItems +
            paddingLegendTopBottom
        : layoutInfo.maxItemHeight + paddingLegendTopBottom;
    const preferredHeight = Math.min(_height, legendHeight);
    return { width: Math.ceil(preferredWidth), height: Math.ceil(preferredHeight) };
}

/**
 * A legend displays an interactive description of symbols, colors, etc., used in graphical information representations.
 */
const Legend = compat.forwardRef(({ orientation = 'horizontal', items, isReadOnly = true, onItemAction, onItemHover, onItemFocus, testId, contextMenuConfig, hideAndShowBehavior = 'off', hoverBehavior = 'none', halign = 'start', valign = 'top', ...props }, ref = null) => {
    // Use the context
    const { isGetPreferredSizeReady, width, height } = hooks.useContext(LegendRendered.LegendRenderedContext);
    const { textMeasureContent, getTextDimensions } = useTextDimensions.useTextDimensions();
    const { resolvedVars, cssContent } = useCssVars.useCssVars(useLegendDnd.legendVars);
    const legendFontStylesObj = useLegendDnd.getLegendTextStyle({
        fontStyle: props.textFontStyle,
        fontSize: props.textFontSize?.toString(),
        fontWeight: props.textFontWeight?.toString(),
        fontFamily: props.textFontFamily
    }, resolvedVars);
    const rootRef = hooks.useRef(null);
    compat.useImperativeHandle(ref, () => ({
        _getPreferredSize: (_width, _height) => {
            return _getPreferredSize(_width, _height, items, resolvedVars, orientation, legendFontStylesObj, props.symbolWidth, props.symbolHeight, getTextDimensions);
        }
    }), [
        getTextDimensions,
        resolvedVars,
        orientation,
        legendFontStylesObj,
        props.symbolWidth,
        props.symbolHeight,
        items
    ]);
    if (getTextDimensions &&
        resolvedVars['unit'] != undefined &&
        resolvedVars['fontSize'] != undefined) {
        isGetPreferredSizeReady?.(true);
    }
    const testIdProps = useTestId.useTestId(testId);
    const isTestEnv = testIdProps['data-testid'] !== undefined;
    const rootDimsRef = hooks.useRef();
    const { getItem, getDetailFromInfo, getPrevItemInfo, getNextItemInfo } = getLegendNavUtils(items);
    const isLegendItemActionable = useLegendDnd.getIsLegendItemActionable(items, isReadOnly);
    const hasData = items.length > 0;
    const legendKeyUpHandler = (triggerOnAction, updatefocusedItemInfo, focusedItemInfo) => useLegendDnd.getKeyUpHandler(triggerOnAction, updatefocusedItemInfo, focusedItemInfo, props.hiddenIds != null);
    const { touchResponse, touchResponseStyle } = useVisTouchResponse.useVisTouchResponse({
        type: 'touchStart'
    });
    const { focusedItemInfo, hoveredItemInfo, onContextMenuDismissed, activeId, eventsProps } = useVisEvents.useVisEvent(touchResponse, !isReadOnly, isLegendItemActionable, legendKeyUpHandler, getDetailFromInfo, getPrevItemInfo, getNextItemInfo, onItemAction, onItemHover, onItemFocus, useLegendDnd.isEqualItem, useLegendDnd.getItemInfo, { itemIdx: 0, sectionIdx: 0 }, props.hiddenIds != null);
    const { focusedItemRef } = useItemFocus.useItemFocus(focusedItemInfo);
    const datatipText = useLegendDnd.getDatatipText(items, getItem, focusedItemInfo, hoveredItemInfo);
    const [datatipDisabled, setDatatipDisabled] = hooks.useState(false);
    const { datatipContent, datatipProps: { 'aria-describedby': datatipAriaDescribedby, ...datatipProps } } = useLegendContextMenu.useLegendDatatip({
        text: datatipText,
        rootDimsRef,
        focusedItemInfo,
        focusedItemRef,
        touchResponse,
        isDisabled: datatipDisabled
    });
    const ariaProps = useLegendDnd.getAriaProps(isReadOnly, props['aria-label'], props.hiddenIds, stringUtils.l([props['aria-describedby'], datatipAriaDescribedby]), props['aria-labelledby']);
    const { contextMenuContent, contextMenuProps } = useLegendContextMenu.useLegendContextMenu({
        rootRef,
        contextMenuConfig: hasData ? contextMenuConfig : undefined,
        focusedItemInfo,
        items,
        isReadOnly,
        onContextMenuDismissed
    });
    const [dragOver, setDragOver] = hooks.useState();
    const { draggable, dndProps, dndContent } = useLegendDnd.useLegendDnd({
        onDrag: props.onDrag,
        onDragStart: props.onDragStart,
        onDragEnd: props.onDragEnd,
        onDragEnter: props.onDragEnter,
        onDragLeave: props.onDragLeave,
        onDragOver: props.onDragOver,
        onDrop: props.onDrop,
        items,
        setDragOver,
        setDatatipDisabled,
        itemDraggable: props.itemDraggable
    });
    const mergedProps = mergeProps.mergeProps(eventsProps, datatipProps, contextMenuProps, dndProps);
    const { legendStyle, renderedLegendStyle } = PRIVATE_BaseLegend_themes_LegendStyles_css.styles;
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [!isGetPreferredSizeReady && (jsxRuntime.jsx(TrackResizeContainer.TrackResizeContainer, { width: width ? `${width}px` : '100%', height: height ? `${height}px` : '100%', class: classNames.classNames([
                    PRIVATE_BaseLegend_themes_LegendStyles_css.styles.flexStyle,
                    PRIVATE_BaseLegend_themes_LegendStyles_css.styles[`${halign}HAlign`],
                    PRIVATE_BaseLegend_themes_LegendStyles_css.styles[`${valign}VAlign`]
                ]), children: function _(width) {
                    const layoutInfo = hooks.useMemo(() => getLinearLegendLayoutInfo({
                        width,
                        getTextDimensions,
                        resolvedVars,
                        orientation,
                        legendFontStylesObj,
                        symbolWidth: props.symbolWidth,
                        symbolHeight: props.symbolHeight,
                        items
                    }), [width]);
                    const { itemsPerCol, itemsPerRow } = useLegendDnd.getGridNums(items.length, layoutInfo);
                    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("div", { ref: rootRef, tabIndex: isReadOnly ? undefined : 0, role: "application", draggable: draggable, class: classNames.classNames([
                                    legendStyle,
                                    renderedLegendStyle,
                                    dragOver
                                        ? hooks_PRIVATE_useVisDnd_themes_VisDndStyles_css.styles.dndDragOverHTMLStyle
                                        : dragOver === false
                                            ? hooks_PRIVATE_useVisDnd_themes_VisDndStyles_css.styles.dndRejectedStyle
                                            : undefined
                                ]), style: touchResponseStyle, ...testIdProps, ...ariaProps, ...mergedProps, "aria-activedescendant": activeId, children: jsxRuntime.jsx(useLegendContextMenu.BaseLegend, { ...props, focusedItemRef: focusedItemRef, items: items, isReadOnly: isReadOnly, orientation: orientation, sectionIdx: 0, itemsPerRow: itemsPerRow, itemsPerCol: itemsPerCol, itemWidth: layoutInfo?.isWrapped ? layoutInfo?.maxItemWidth : undefined, focusedItemInfo: focusedItemInfo, hoveredItemInfo: hoveredItemInfo, activeId: activeId, hideAndShowBehavior: hideAndShowBehavior, hoverBehavior: hoverBehavior, isTestEnv: isTestEnv }) }), datatipContent, contextMenuContent, dndContent] }));
                } })), textMeasureContent, cssContent] }));
});

exports.Legend = Legend;
//# sourceMappingURL=UNSAFE_Legend.js.map
