/* @oracle/oraclejet-preact: undefined */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
var useAccessibleContext = require('./useAccessibleContext-c49d8d1b.js');
var useComponentTheme = require('./useComponentTheme-082fc8e4.js');
require('./FormFieldContext-69fe83d2.js');
var useFormFieldContext = require('./useFormFieldContext-4632eb73.js');
require('./TabbableModeContext-e99d527e.js');
var useTabbableMode = require('./useTabbableMode-a275583f.js');
var useTextFieldInputHandlers = require('./useTextFieldInputHandlers-850d395c.js');
var useTranslationBundle = require('./useTranslationBundle-18b7bf8b.js');
var formControlUtils = require('./formControlUtils-596c9dc3.js');
var classNames = require('./classNames-c14c6ef3.js');
var textAlign = require('./textAlign-f41f49db.js');
var mergeInterpolations = require('./mergeInterpolations-6727b536.js');
var mergeProps = require('./mergeProps-e3da7237.js');
var TextFieldUtils = require('./TextFieldUtils-96baac38.js');
var UNSAFE_TextField_themes_FormControlUtilsStyles_css = require('./UNSAFE_TextField/themes/FormControlUtilsStyles.css.js');
var UNSAFE_TextField_themes_redwood_TextFieldInputTheme = require('./UNSAFE_TextField/themes/redwood/TextFieldInputTheme.js');
var UNSAFE_Label_themes_redwood_LabelTheme = require('./UNSAFE_Label/themes/redwood/LabelTheme.js');
var LabelValueLayout = require('./LabelValueLayout-efc94d8e.js');
var UNSAFE_Skeleton_themes_redwood_SkeletonTheme = require('./UNSAFE_Skeleton/themes/redwood/SkeletonTheme.js');
var useTestId = require('./useTestId-9093a54b.js');
var LayoutStyles_css = require('./LayoutStyles.css-b4025421.js');
var compat = require('preact/compat');
require('./FormContext-d1d05967.js');
var useFormContext = require('./useFormContext-a794f7b6.js');
var Flex = require('./Flex-6ca216a7.js');
require('./InputGroupContext-05f2a46f.js');
var useInputGroupContext = require('./useInputGroupContext-4c10bd57.js');
var useTooltipControlled = require('./useTooltipControlled-3c2afa53.js');
var useUser = require('./useUser-f900ddf1.js');
var UNSAFE_TextField_themes_redwood_TextFieldTheme = require('./UNSAFE_TextField/themes/redwood/TextFieldTheme.js');
var UNSAFE_TextField_themes_redwood_ReadonlyTextFieldTheme = require('./UNSAFE_TextField/themes/redwood/ReadonlyTextFieldTheme.js');
var UNSAFE_TextField_themes_redwood_FormLayoutTheme = require('./UNSAFE_TextField/themes/redwood/FormLayoutTheme.js');

const interpolations = [...Object.values(textAlign.textInterpolations)];
const styleInterpolations = mergeInterpolations.mergeInterpolations(interpolations);
// The WHATWG forms spec specifies the following input types that support setSelectedRange
const supportsSetSelection = ['text', 'search', 'url', 'tel', 'password', 'textarea'];
/**
 * Merge multiple ids into a space-separated list
 * @param ids The ids to be merged
 * @returns The space separated string of ids
 */
function mergeIDs(...ids) {
    return ids.filter(Boolean).join(' ') || undefined;
}
const TextFieldInput = ({ as = 'input', 'aria-autocomplete': ariaAutoComplete, 'aria-controls': ariaControls, 'aria-describedby': ariaDescribedBy, 'aria-expanded': ariaExpanded, 'aria-invalid': ariaInvalid, 'aria-label': ariaLabel, 'aria-labelledby': inputLabelledBy, 'aria-valuemax': ariaValueMax, 'aria-valuemin': ariaValueMin, 'aria-valuenow': ariaValueNow, 'aria-valuetext': ariaValueText, autoComplete, autoFocus, currentCommitValue, hasEmptyLabel, hasEndContent = false, hasInsideLabel = false, hasPrefix = false, hasStartContent = false, hasSuffix = false, id, inputRef, placeholder, isRequired, role, rows, spellcheck, type, value = '', variant = 'default', onInput, onCommit, onKeyDown, onKeyUp, onBlur, onFocus, ...props }) => {
    const { isDisabled, isFocused, isLoading, isReadonly } = useFormFieldContext.useFormFieldContext();
    const { class: styleInterpolationClasses } = styleInterpolations(props);
    const hasValue = value !== '';
    const isTextArea = as === 'textarea';
    const isInput = as === 'input';
    const isPassword = type === 'password';
    const renderPrefix = !isDisabled && hasPrefix;
    const renderSuffix = !isDisabled && hasSuffix;
    const myPlaceholder = TextFieldUtils.isInputPlaceholderShown(hasInsideLabel, hasValue, isFocused)
        ? placeholder
        : undefined;
    const { classes } = useComponentTheme.useComponentTheme(UNSAFE_TextField_themes_redwood_TextFieldInputTheme.TextFieldInputRedwoodTheme, {
        type: isPassword ? 'isPassword' : 'notPassword',
        styleVariant: formControlUtils.isEmbeddedVariant(variant) ? 'embedded' : 'default',
        textarea: isTextArea ? 'isTextArea' : 'notTextArea',
        input: isInput ? 'isInput' : 'notInput',
        div: 'notDiv',
        prefix: renderPrefix ? 'hasPrefix' : 'noPrefix',
        suffix: renderSuffix ? 'hasSuffix' : 'noSuffix',
        startContent: hasStartContent ? 'hasStartContent' : 'noStartContent',
        endContent: hasEndContent ? 'hasEndContent' : 'noEndContent',
        insideLabel: hasInsideLabel ? 'hasInsideLabel' : 'noInsideLabel',
        value: hasValue ? 'hasValue' : 'noValue',
        focused: isFocused ? 'isFocused' : 'notFocused',
        disabled: isDisabled ? 'isDisabled' : 'notDisabled'
    });
    const inputClasses = classNames.classNames([
        classes,
        styleInterpolationClasses,
        // JET-72775 - Form control alignment in tables
        // When we are in legacy collection components, we want to inherit the text align
        // when it is not set explicitly.
        variant === 'legacyEmbedded' && props.textAlign === undefined && UNSAFE_TextField_themes_FormControlUtilsStyles_css.formControlInheritTextAlign
    ]);
    const Comp = as || 'input';
    // ref to hold the text selection to restore.
    const selectionRef = hooks.useRef({
        start: 0,
        end: 0
    });
    const textFieldInputHandlers = useTextFieldInputHandlers.useTextFieldInputHandlers({
        currentCommitValue,
        // Enter should not commit for textarea.
        isCommitOnEnter: as === 'input',
        value,
        onInput,
        onCommit,
        onKeyDown,
        selectionRef
    });
    const handlers = mergeProps.mergeProps(textFieldInputHandlers, { onBlur, onFocus });
    // the implicit default for tabindex on an input is 0, so do not explicitly set it.
    // JET-52914 - Implement Tabbable mode API contract in InputText
    // if not tabbable, spread tabbableModeProps on component
    const { isTabbable, tabbableModeProps } = useTabbableMode.useTabbableMode();
    // TODO: for autoComplete='off', need to configure attrs appropriately to make sure it
    // works across browsers and versions  (from review on 3/11/22)
    // JET-52089: add unsafe API for specifying an external label which is added to ariaLabelledBy on the input,
    // only when labelEdge is 'none' and label is ''. Since ariaLabelledBy takes precedence over all other
    // kinds of labels, this helps to ensure we don't override a meaningful label.
    const { UNSAFE_ariaLabelledBy } = useAccessibleContext.useAccessibleContext();
    const ariaLabelledBy = hasEmptyLabel
        ? mergeIDs(inputLabelledBy, UNSAFE_ariaLabelledBy)
        : inputLabelledBy;
    const translations = useTranslationBundle.useTranslationBundle('@oracle/oraclejet-preact');
    const loadingAriaLabel = translations.formControl_loading();
    // Restore the saved selection when the value changes.  See JET-62763 for info on why this is needed.
    hooks.useLayoutEffect(() => {
        // This should never be a function in this case, This is here because of the Ref type.
        if (typeof inputRef !== 'function') {
            const inpElem = inputRef?.current;
            // only set the selection range if the element has focus
            // only set the selection range on supported types.
            if (document.activeElement === inpElem &&
                inpElem &&
                supportsSetSelection.includes(inpElem.type)) {
                inpElem.setSelectionRange(selectionRef.current.start, selectionRef.current.end);
            }
        }
    }, [value, inputRef]);
    return (jsxRuntime.jsx(Comp, { "aria-autocomplete": ariaAutoComplete, "aria-controls": ariaControls, "aria-describedby": ariaDescribedBy, "aria-expanded": ariaExpanded, "aria-invalid": ariaInvalid, "aria-label": isLoading ? loadingAriaLabel : ariaLabel ? ariaLabel : undefined, "aria-labelledby": ariaLabelledBy, "aria-required": isRequired ? true : undefined, "aria-valuemax": ariaValueMax, "aria-valuemin": ariaValueMin, "aria-valuenow": ariaValueNow, "aria-valuetext": ariaValueText, autocomplete: autoComplete, autofocus: autoFocus, class: inputClasses, disabled: isDisabled, id: id, onKeyUp: onKeyUp, placeholder: myPlaceholder, readonly: isReadonly, 
        // @ts-expect-error TS cannot infer the type correctly for the polymorphed ref
        ref: inputRef, role: role, rows: rows, spellcheck: spellcheck, type: type, value: value, ...handlers, ...(!isTabbable && tabbableModeProps) }));
};

/**
 * A hook that calls useTooltipControlled and uses a logical focus strategy to control the tooltip.
 * When hasTruncatedLabel is true, we call onLogicalFocus to make the tooltip appear; otherwise we
 * call onLogicalBlur to dismiss it. See useTextField.ts for how we set the value of hasTruncatedLabel.
 */
const useTextFieldTooltip = ({ fieldRef, hasTruncatedLabel, isDisabled, label }) => {
    const [isOpen, setOpen] = hooks.useState(false);
    const { tooltipProps, tooltipContent } = useTooltipControlled.useTooltipControlled({
        dismissOnClick: false,
        displayOnHover: false,
        focusStrategy: 'logical',
        isDisabled,
        isOpen: isOpen,
        offset: { mainAxis: 4 },
        onToggle: ({ value }) => {
            setOpen(value);
        },
        position: 'top-start',
        text: label
    });
    // The label already has a for-id association with the input
    // and is read by AT, so we don't need aria-describedby.
    const { 'aria-describedby': notNeeded, onLogicalBlur, onLogicalFocus, ...tooltipEventHandlerProps } = tooltipProps;
    if (!isDisabled) {
        if (hasTruncatedLabel) {
            onLogicalFocus?.(fieldRef?.current);
        }
        else {
            onLogicalBlur?.();
        }
    }
    return { tooltipContent, tooltipEventHandlerProps };
};

// Renders the oj-text-field-container dom which includes the
// main (where the inside label and inputElem goes),
// and end pieces of the form component.
// This does not include user assistance because that is rendered outside the
// oj-text-field-container; that is rendered in the TextField component.
const ReadonlyTextFieldContent = ({ variant, insideLabel, labelText, mainContent, endContent, rootRef, resize, startContent }) => {
    const { isFormLayout, isReadonly: isReadonlyForm } = useFormContext.useFormContext();
    const { hasTruncatedLabel, isLoading } = useFormFieldContext.useFormFieldContext();
    const { direction } = useUser.useUser();
    const isLtr = direction === 'ltr';
    const isInsideNonReadonlyForm = isFormLayout && !isReadonlyForm;
    const hasInsideLabel = insideLabel !== undefined;
    const inputGroupContext = useInputGroupContext.useInputGroupContext();
    const hasGroupContext = inputGroupContext !== null;
    // depending on browser direction, apply the appropriate styling.
    // when 'rtl' the flex row direction is reversed.
    const inputGroupPosition = inputGroupContext
        ? inputGroupContext.last
            ? isLtr
                ? 'groupRight'
                : 'groupLeft'
            : inputGroupContext.index === 0
                ? isLtr
                    ? 'groupLeft'
                    : 'groupRight'
                : 'groupMiddle'
        : undefined;
    const { variantClasses: middleStyles, styles: { textFieldEndContent } } = useComponentTheme.useComponentTheme(UNSAFE_TextField_themes_redwood_TextFieldTheme.TextFieldRedwoodTheme, {
        middleContent: variant,
        textAreaResizeDirection: resize && variant === 'textarea' ? direction : undefined
    });
    const { classes: readonlyClassNames, styles: { readonlyTextFieldMiddleBase, readonlyTextFieldMiddleNotInEnabledForm, readonlyTextFieldMiddleInEnabledForm, readonlyTextFieldMiddleInEnabledFormNotTextarea, startContentInsideLabel, startContentMarginEnd, startContentMarginStart, startContentStartTopLabel } } = useComponentTheme.useComponentTheme(UNSAFE_TextField_themes_redwood_ReadonlyTextFieldTheme.ReadonlyTextFieldRedwoodTheme, {
        insideNonReadonlyForm: isInsideNonReadonlyForm
            ? 'isInsideNonReadonlyForm'
            : 'notInsideNonReadonlyForm',
        insideLabel: hasInsideLabel ? 'hasInsideLabel' : 'noInsideLabel',
        textarea: variant === 'textarea' ? 'isTextArea' : 'notTextArea',
        loading: isLoading ? 'isLoading' : 'notLoading',
        withinGroup: hasGroupContext ? 'isWithinGroup' : undefined,
        inputGroupPosition,
        resize: resize ?? 'none'
    });
    // JET-73911: Temporarily use style classes directly instead of getting
    // startContent styles from theming.
    const readonlyTextFieldStartContentStyles = classNames.classNames([
        hasInsideLabel ? startContentInsideLabel : startContentStartTopLabel,
        isInsideNonReadonlyForm ? startContentMarginStart : startContentMarginEnd
    ]);
    const middleClasses = classNames.classNames([
        middleStyles,
        readonlyTextFieldMiddleBase,
        isInsideNonReadonlyForm && readonlyTextFieldMiddleInEnabledForm,
        isInsideNonReadonlyForm &&
            variant !== 'textarea' &&
            readonlyTextFieldMiddleInEnabledFormNotTextarea,
        !isInsideNonReadonlyForm && readonlyTextFieldMiddleNotInEnabledForm
    ]);
    const fieldRef = hooks.useRef(null);
    const ref = rootRef ?? fieldRef;
    const { tooltipContent, tooltipEventHandlerProps } = useTextFieldTooltip({
        hasTruncatedLabel,
        fieldRef: ref,
        isDisabled: !hasInsideLabel,
        label: labelText
    });
    return (jsxRuntime.jsxs("div", { role: "presentation", class: readonlyClassNames, ref: ref, ...tooltipEventHandlerProps, children: [startContent && (jsxRuntime.jsx("span", { class: readonlyTextFieldStartContentStyles, children: jsxRuntime.jsx(Flex.Flex, { justify: "center", align: "center", hasZeroMargins: true, children: startContent }) })), jsxRuntime.jsxs("div", { class: middleClasses, children: [insideLabel, mainContent] }), endContent && (jsxRuntime.jsx("span", { class: textFieldEndContent, children: jsxRuntime.jsx(Flex.Flex, { justify: "center", align: "center", hasZeroMargins: true, children: endContent }) })), tooltipContent] }));
};

const StartTopLabelReadonlyTextField = compat.forwardRef(({ outerClassNames, columnSpan, label, labelEdge, labelStartWidth, compactUserAssistance, inlineUserAssistance, mainContent, endContent, rootRef, variant, resize, startContent, ...props }, ref) => {
    const parentComponentVariant = variant === 'textarea' ? 'textArea' : 'textField';
    return (jsxRuntime.jsxs("div", { ...props, ref: ref, class: outerClassNames, children: [compactUserAssistance, jsxRuntime.jsxs(LabelValueLayout.LabelValueLayout, { columnSpan: columnSpan, label: label, labelEdge: labelEdge, labelStartWidth: labelStartWidth, parentComponentVariant: parentComponentVariant, children: [jsxRuntime.jsx(ReadonlyTextFieldContent, { mainContent: mainContent, endContent: endContent, rootRef: rootRef, startContent: startContent, ...(variant ? { variant, resize } : {}) }), inlineUserAssistance] })] }));
});
const InsideLabelReadonlyTextField = compat.forwardRef(({ outerClassNames, compactUserAssistance, inlineUserAssistance, labelText, mainContent, endContent, label, rootRef, variant, resize, startContent, ...props }, ref) => {
    return (jsxRuntime.jsxs("div", { ...props, ref: ref, class: outerClassNames, children: [compactUserAssistance, jsxRuntime.jsx(ReadonlyTextFieldContent, { insideLabel: label, labelText: labelText, mainContent: mainContent, endContent: endContent, rootRef: rootRef, startContent: startContent, ...(variant ? { variant, resize } : {}) }), inlineUserAssistance] }));
});
const ReadonlyTextField = compat.forwardRef(({ columnSpan = 1, label, labelEdge, labelText, mainContent, endContent, variant, mainFieldRef, startContent, testId, ...props }, ref) => {
    const testIdProps = useTestId.useTestId(testId);
    const { classes, styles } = useComponentTheme.useComponentTheme(UNSAFE_TextField_themes_redwood_TextFieldTheme.TextFieldRedwoodTheme, {
        readonly: 'isReadonly'
    });
    const { baseTheme: labelBaseTheme } = useComponentTheme.useComponentTheme(UNSAFE_Label_themes_redwood_LabelTheme.LabelRedwoodTheme);
    const { baseTheme: formLayoutTheme } = useComponentTheme.useComponentTheme(UNSAFE_TextField_themes_redwood_FormLayoutTheme.FormLayoutRedwoodTheme);
    const { formControlBase } = styles;
    // because TextField components reference Skeleton scoped vars, we need to bring in the Skeleton base theme
    // to pick up the scoped var definitions.
    const { baseTheme: skeletonBaseTheme } = useComponentTheme.useComponentTheme(UNSAFE_Skeleton_themes_redwood_SkeletonTheme.SkeletonRedwoodTheme);
    const outerClassNames = classNames.classNames([
        classes,
        skeletonBaseTheme,
        formControlBase,
        formLayoutTheme,
        labelBaseTheme,
        LayoutStyles_css.layoutSpanStyles.layoutSpanColumn[columnSpan]
    ]);
    if (label !== undefined && (labelEdge === 'start' || labelEdge === 'top')) {
        return (jsxRuntime.jsx(StartTopLabelReadonlyTextField, { columnSpan: columnSpan, outerClassNames: outerClassNames, label: label, labelEdge: labelEdge, ref: ref, mainContent: mainContent, endContent: endContent, rootRef: mainFieldRef, startContent: startContent, variant: variant, ...props, ...testIdProps }));
    }
    return (jsxRuntime.jsx(InsideLabelReadonlyTextField, { outerClassNames: outerClassNames, ref: ref, label: label, labelText: labelText, mainContent: mainContent, endContent: endContent, rootRef: mainFieldRef, startContent: startContent, variant: variant, ...props, ...testIdProps }));
});

const StyledTextField = compat.forwardRef(({ columnSpan = 1, variant = 'default', ...props }, ref) => {
    // because of the mismatch of height for inputs with inside labels and no labels,
    // we'll have to set everything to the same min-height while within an input group context.
    // Here we'll look to see if it's present and apply the style as needed
    const groupContext = useInputGroupContext.useInputGroupContext();
    const { isReadonly } = useFormFieldContext.useFormFieldContext();
    const { baseTheme: formLayoutTheme } = useComponentTheme.useComponentTheme(UNSAFE_TextField_themes_redwood_FormLayoutTheme.FormLayoutRedwoodTheme);
    const { baseTheme: labelBaseTheme } = useComponentTheme.useComponentTheme(UNSAFE_Label_themes_redwood_LabelTheme.LabelRedwoodTheme);
    const { classes: textFieldClasses, styles } = useComponentTheme.useComponentTheme(UNSAFE_TextField_themes_redwood_TextFieldTheme.TextFieldRedwoodTheme, {
        readonly: isReadonly ? 'isReadonly' : 'notReadonly',
        withinGroup: groupContext !== null ? 'isWithinGroup' : undefined
    });
    const { formControlBase, textFieldBase, textFieldEmbedded } = styles;
    // because TextField components reference Skeleton scoped vars, we need to bring in the Skeleton base theme
    // to pick up the scoped var definitions.
    const { baseTheme: skeletonBaseTheme } = useComponentTheme.useComponentTheme(UNSAFE_Skeleton_themes_redwood_SkeletonTheme.SkeletonRedwoodTheme);
    const classes = classNames.classNames([
        skeletonBaseTheme,
        formControlBase,
        textFieldBase,
        formControlUtils.isEmbeddedVariant(variant) && textFieldEmbedded,
        textFieldClasses,
        formLayoutTheme,
        labelBaseTheme,
        LayoutStyles_css.layoutSpanStyles.layoutSpanColumn[columnSpan]
    ]);
    return jsxRuntime.jsx("div", { ...props, class: classes, ref: ref });
});

exports.ReadonlyTextField = ReadonlyTextField;
exports.StyledTextField = StyledTextField;
exports.TextFieldInput = TextFieldInput;
exports.useTextFieldTooltip = useTextFieldTooltip;
//# sourceMappingURL=StyledTextField-d8c8a3bf.js.map
