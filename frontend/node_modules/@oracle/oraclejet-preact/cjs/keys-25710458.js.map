{"version":3,"file":"keys-25710458.js","sources":["../../src/utils/UNSAFE_keys/keys.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nexport type ImmutableSet<V> = {\n  size: number;\n  has(value: V): boolean;\n  values(): IterableIterator<V>;\n};\n\n/**\n * Type for key set used mainly for selection and expansion\n */\nexport type Keys<K> =\n  | {\n      all: true;\n      keys?: never;\n      deletedKeys: ImmutableSet<K>;\n    }\n  | {\n      all: false;\n      keys: ImmutableSet<K>;\n      deletedKeys?: never;\n    };\n\n/**\n * Returns true if the key is contains in keys, false otherwise\n */\nexport const containsKey = <K>(keys: Keys<K> | undefined, key: K) => {\n  if (keys == null) {\n    return false;\n  }\n  if (!keys.all) {\n    return keys.keys.has(key);\n  }\n  return !keys.deletedKeys.has(key);\n};\n\n/**\n * Returns a new Keys that includes the specified key.\n * If the key is already in keys, then just return keys.\n */\nexport const addKey = <K>(keys: Keys<K>, key: K) => {\n  return addKeys(keys, [key]);\n};\n\n/**\n * Returns a new Keys that includes all the specified keys.\n * @param keys the base Keys<K>\n * @param addKeys an array of keys that we we want to include\n */\nexport const addKeys = <K>(keys: Keys<K>, addKeys: K[]) => {\n  if (keys.all) {\n    const deletedKeys = keys.deletedKeys;\n    if (deletedKeys.size === 0) {\n      return keys;\n    }\n\n    const keySet = new Set(deletedKeys.values());\n    addKeys.forEach((key) => {\n      if (deletedKeys.has(key)) {\n        keySet.delete(key);\n      }\n    });\n    keys = { all: true, deletedKeys: keySet };\n  } else {\n    const currentKeys = keys.keys;\n    const keySet = new Set(currentKeys.values());\n    addKeys.forEach((key) => {\n      if (!currentKeys.has(key)) {\n        keySet.add(key);\n      }\n    });\n    keys = { all: false, keys: keySet };\n  }\n  return keys;\n};\n\n/**\n * Returns a new Keys that excludes the specified key.\n * If the key is already in keys, then just return keys.\n * disallowEmpty if set to true, will ensure that the returning keys will not be empty.\n */\nexport const removeKey = <K>(keys: Keys<K>, key: K, disallowEmpty: boolean) => {\n  return removeKeys(keys, [key], disallowEmpty);\n};\n\n/**\n * Returns a new Keys that excludes all the specified keys.\n * @param keys the base Keys<K>\n * @param removeKeys an array of keys that we we want to exclude\n * @param disallowEmpty if set to true, will ensure that the returning keys will not be empty\n */\nexport const removeKeys = <K>(keys: Keys<K>, removeKeys: K[], disallowEmpty: boolean) => {\n  if (keys.all) {\n    const deletedKeys = keys.deletedKeys;\n    const keySet = new Set(deletedKeys.values());\n    removeKeys.forEach((key) => {\n      if (!deletedKeys.has(key)) {\n        keySet.add(key);\n      }\n    });\n    keys = { all: true, deletedKeys: keySet };\n  } else {\n    const currentKeys = keys.keys;\n    const keySet = new Set(currentKeys.values());\n    removeKeys.forEach((key) => {\n      if (currentKeys.has(key) && (!disallowEmpty || keySet.size > 1)) {\n        keySet.delete(key);\n      }\n    });\n    keys = { all: false, keys: keySet };\n  }\n  return keys;\n};\n\n/**\n * Helper function for checking for an undefined key\n * Keys can be null or undefined when not set, but falsey check is not appropriate for this as 0 is a legitimate key\n */\nexport const isKeyDefined = <K>(key: K) => key !== undefined && key !== null;\n\n/**\n * Compares two Keys and return true if the keys inside each are the same including\n * having the same order.\n */\nexport const isSameKey = <K>(key1?: Keys<K>, key2?: Keys<K>) => {\n  if (key1 == null || key2 == null) {\n    return key1 == key2;\n  }\n  if (key1.all !== key2.all) {\n    return false;\n  }\n  const arr1 = Array.from(key1.all ? key1.deletedKeys.values() : key1.keys.values());\n  const arr2 = Array.from(key2.all ? key2.deletedKeys.values() : key2.keys.values());\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n"],"names":[],"mappings":"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"}