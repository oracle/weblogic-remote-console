/* @oracle/oraclejet-preact: undefined */
'use strict';

var eventsUtils = require('./eventsUtils-d34f8647.js');
require('./accUtils-5c7d3255.js');
var hooks = require('preact/hooks');
var usePinch = require('./usePinch-741e9343.js');
var mergeProps = require('./mergeProps-e3da7237.js');

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
function getAxisBoundsByDelta(xViewportExtent, xAxisExtent, yViewportExtent, y2ViewportExtent, yAxisExtent, y2AxisExtent, xScale, yScale, y2Scale, xMin, xMax, yMin, yMax, y2Min, y2Max, isRtl, isHoriz) {
    const { viewportMin: xViewportMin, viewportMax: xViewportMax } = xViewportExtent;
    const { min: xAxisMin, max: xAxisMax } = xAxisExtent;
    const { viewportMin: yViewportMin, viewportMax: yViewportMax } = yViewportExtent;
    const { min: yAxisMin, max: yAxisMax } = yAxisExtent;
    const { viewportMin: y2ViewportMin, viewportMax: y2ViewportMax } = y2ViewportExtent;
    const { min: y2AxisMin, max: y2AxisMax } = y2AxisExtent;
    const deltas = convertToAxisCoord(xMin, xMax, yMin, yMax, y2Min, y2Max, isRtl, isHoriz);
    const xExtents = getAxisMinMaxByDelta(xViewportMin, xViewportMax, xAxisMin, xAxisMax, xScale, deltas['xMin'], deltas['xMax']);
    const yExtents = getAxisMinMaxByDelta(yViewportMin, yViewportMax, yAxisMin, yAxisMax, yScale, deltas['yMin'], deltas['yMax']);
    const y2Extents = getAxisMinMaxByDelta(y2ViewportMin, y2ViewportMax, y2AxisMin, y2AxisMax, y2Scale, deltas['y2Min'], deltas['y2Max']);
    return { xExtents, yExtents, y2Extents };
}
function convertToAxisCoord(xMin, xMax, yMin, yMax, y2Min, y2Max, isRtl, isHoriz) {
    const axisCoord = {};
    if (isHoriz) {
        axisCoord['xMin'] = yMin;
        axisCoord['xMax'] = yMax;
        axisCoord['yMin'] = isRtl ? xMax : xMin;
        axisCoord['yMax'] = isRtl ? xMin : xMax;
        axisCoord['y2Min'] = isRtl ? xMin : xMax;
        axisCoord['y2Max'] = isRtl ? xMax : xMin;
    }
    else {
        axisCoord['xMin'] = isRtl ? xMax : xMin;
        axisCoord['xMax'] = isRtl ? xMin : xMax;
        axisCoord['yMin'] = yMax;
        axisCoord['yMax'] = yMin;
        axisCoord['y2Min'] = y2Max;
        axisCoord['y2Max'] = y2Min;
    }
    return axisCoord;
}
function getAxisMinMaxByDelta(viewportMin, viewportMax, globalMin, globalMax, axisScale, minDelta, maxDelta) {
    const minDeltaVal = axisScale.invert(minDelta) - axisScale.invert(0);
    const maxDeltaVal = axisScale.invert(maxDelta) - axisScale.invert(0);
    let weight = 1;
    const newExtent = viewportMax + maxDeltaVal - (viewportMin + minDeltaVal);
    const minExtent = 1; //axisInfo.getMinExtent();
    if (minDelta != maxDelta && newExtent < minExtent)
        weight = (viewportMax - viewportMin - minExtent) / (minDeltaVal - maxDeltaVal);
    viewportMin += minDeltaVal * weight;
    viewportMax += maxDeltaVal * weight;
    // Limit to global min/max
    if (viewportMax - viewportMin >= globalMax - globalMin) {
        viewportMin = globalMin;
        viewportMax = globalMax;
    }
    else if (viewportMin < globalMin) {
        viewportMax += globalMin - viewportMin;
        viewportMin = globalMin;
    }
    else if (viewportMax > globalMax) {
        viewportMin -= viewportMax - globalMax;
        viewportMax = globalMax;
    }
    return { viewportMin, viewportMax };
}
function getAxisMinMaxDrag(offsetX, offsetY, plotAreaSpace, xViewportExtent, xAxisExtent, isHoriz, isRtl) {
    const deltaX = isRtl ? plotAreaSpace.width - offsetX : offsetX - plotAreaSpace.x;
    const deltaY = offsetY - plotAreaSpace.y;
    const deltaV = xViewportExtent.viewportMax - xViewportExtent.viewportMin;
    const delta = (isHoriz ? deltaY : deltaX) *
        ((xAxisExtent.max - xAxisExtent.min) / (isHoriz ? plotAreaSpace.height : plotAreaSpace.width));
    let xMin = delta - deltaV / 2;
    let xMax = delta + deltaV / 2;
    if (xMin < xAxisExtent.min) {
        xMin = xAxisExtent.min;
        xMax = xMin + deltaV;
    }
    if (xMax > xAxisExtent.max) {
        xMin = xAxisExtent.max - deltaV;
        xMax = xAxisExtent.max;
    }
    return {
        xMin,
        xMax
    };
}
function panBy(plotAreaSpace, isPageUp, PAN_RATIO, isHoriz, isRtl) {
    const dx = isHoriz ? 0 : (isPageUp ? -1 : 1) * PAN_RATIO;
    const dy = isHoriz ? (isPageUp ? -1 : 1) * PAN_RATIO : 0;
    const deltaX = dx * plotAreaSpace.width * (isRtl ? -1 : 1);
    const deltaY = dy * plotAreaSpace.height;
    return { deltaX, deltaY };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const VIEWPORT_SCALE = 0.05;
const PAN_RATIO = 0.25;
function useChartViewport({ plotAreaSpace, yScale, y2Scale, xScale, onViewportChange, isHoriz, zoomAndScroll, isRtl, rootRef, xAxisInfo, yAxisInfo, y2AxisInfo }) {
    const isPointerClicked = hooks.useRef(false);
    const handleViewportChange = (delta, origin) => {
        const deltaXMin = delta * (origin.x - plotAreaSpace.x);
        const deltaXMax = -delta * (plotAreaSpace.x + plotAreaSpace.width - origin.x);
        const deltaYMin = delta * (origin.y - plotAreaSpace.y);
        const deltaYMax = -delta * (plotAreaSpace.y + plotAreaSpace.height - origin.y);
        const deltaY2Min = delta * (origin.y - plotAreaSpace.y);
        const deltaY2Max = -delta * (plotAreaSpace.y + plotAreaSpace.height - origin.y);
        const extents = getAxisBoundsByDelta(xAxisInfo, xAxisInfo, yAxisInfo, y2AxisInfo, yAxisInfo, y2AxisInfo, xScale, yScale, y2Scale, deltaXMin, deltaXMax, deltaYMin, deltaYMax, deltaY2Min, deltaY2Max, isRtl, isHoriz);
        onViewportChange?.({
            xMin: extents.xExtents.viewportMin,
            yMin: extents.yExtents.viewportMin,
            xMax: extents.xExtents.viewportMax,
            yMax: extents.yExtents.viewportMax,
            y2Min: extents.y2Extents.viewportMax,
            y2Max: extents.y2Extents.viewportMax
        });
    };
    const pinchProps = usePinch.usePinch({
        captureTargetRef: rootRef,
        onPinchZoomChange: ({ delta, origin }) => {
            const d = (isHoriz ? 1 : -1) * -1 * delta * VIEWPORT_SCALE;
            handleViewportChange(d, origin);
        }
    });
    pinchProps.onPointerOut = undefined;
    const onWheel = (event) => {
        const delta = (isHoriz ? 1 : -1) * event.deltaY * VIEWPORT_SCALE;
        handleViewportChange(delta, { x: event.offsetX, y: event.offsetY });
        event.preventDefault();
    };
    const onKeyDown = (event) => {
        const key = event.key;
        const zoomIn = key === '+' || key === '=';
        const zoomOut = key === '-' || key === '_';
        const isPageUp = key === 'PageUp';
        const isPageDown = key === 'PageDown';
        if (!zoomIn && !zoomOut && !isPageUp && !isPageDown) {
            return;
        }
        const zoomRatio = zoomIn ? 1.5 : 1 / 1.5;
        const zoomShiftRatio = (1 / zoomRatio - 1) / 2;
        let deltaXMin = 0, deltaXMax = 0, deltaYMin = 0, deltaYMax = 0, deltas;
        if (zoomIn || zoomOut) {
            deltaXMin = -1 * zoomShiftRatio * plotAreaSpace.width;
            deltaXMax = zoomShiftRatio * plotAreaSpace.width;
            deltaYMin = -1 * zoomShiftRatio * plotAreaSpace.height;
            deltaYMax = zoomShiftRatio * plotAreaSpace.height;
        }
        else {
            deltas = panBy(plotAreaSpace, isPageUp, PAN_RATIO, isHoriz, isRtl);
            if (deltas) {
                deltaXMin = deltas.deltaX;
                deltaXMax = deltas.deltaX;
                deltaYMin = deltas.deltaY;
                deltaYMax = deltas.deltaY;
            }
        }
        const extents = getAxisBoundsByDelta(xAxisInfo, xAxisInfo, yAxisInfo, y2AxisInfo, yAxisInfo, y2AxisInfo, xScale, yScale, y2Scale, deltaXMin, deltaXMax, deltaYMin, deltaYMax, deltaYMin, deltaYMax, isRtl, isHoriz);
        onViewportChange?.({
            xMin: extents.xExtents.viewportMin,
            yMin: extents.yExtents.viewportMin,
            xMax: extents.xExtents.viewportMax,
            yMax: extents.yExtents.viewportMax,
            y2Min: extents.y2Extents.viewportMax,
            y2Max: extents.y2Extents.viewportMax
        });
    };
    const onPointerDown = (event) => {
        isPointerClicked.current = true;
        const obj = eventsUtils.getElementData(rootRef, event.target);
        if (obj && obj['ojPrivateObject'] === 'scrollBar') {
            event.target.setPointerCapture(event.pointerId);
            const { xMin, xMax } = getAxisMinMaxDrag(event.offsetX, event.offsetY, plotAreaSpace, xAxisInfo, xAxisInfo, isHoriz, isRtl);
            onViewportChange?.({
                xMin,
                yMin: yAxisInfo.viewportMin,
                xMax,
                yMax: yAxisInfo.viewportMax
            });
        }
    };
    const onPointerUp = () => {
        isPointerClicked.current = false;
    };
    const onPointerMove = (event) => {
        if (!isPointerClicked.current) {
            return;
        }
        const obj = eventsUtils.getElementData(rootRef, event.target);
        if (obj && obj['ojPrivateObject'] === 'scrollBar') {
            const { xMin, xMax } = getAxisMinMaxDrag(event.offsetX, event.offsetY, plotAreaSpace, xAxisInfo, xAxisInfo, isHoriz, isRtl);
            onViewportChange?.({
                xMin,
                yMin: yAxisInfo.viewportMin,
                xMax,
                yMax: yAxisInfo.viewportMax
            });
        }
    };
    return onViewportChange && zoomAndScroll === 'live'
        ? mergeProps.mergeProps({ onWheel, onKeyDown, onPointerMove, onPointerDown, onPointerUp }, pinchProps)
        : {};
}

exports.useChartViewport = useChartViewport;
//# sourceMappingURL=useChartViewport-d2e8c46f.js.map
