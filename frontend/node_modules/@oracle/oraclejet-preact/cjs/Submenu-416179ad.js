/* @oracle/oraclejet-preact: undefined */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
var useId = require('./useId-6c0eeb27.js');
var Check = require('./Check-da5641a4.js');
var SelectMenuGroupContext = require('./SelectMenuGroupContext-ae5e1373.js');
var UNSAFE_Menu_themes_MenuItemStyles_css = require('./UNSAFE_Menu/themes/MenuItemStyles.css.js');
var compat = require('preact/compat');
var DirectionalExpandArrowIcon = require('./DirectionalExpandArrowIcon-33ebe393.js');
var themeContract_css = require('./themeContract.css-a53fd740.js');
var useScale = require('./useScale-adc62f41.js');
var DirectionalCollapseArrowIcon = require('./DirectionalCollapseArrowIcon-c6d6750f.js');

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Utility hook for consuming the MenuContext
 *
 * @returns The value of MenuContext provider
 */
function useSelectMenuGroupContext() {
    return hooks.useContext(SelectMenuGroupContext.SelectMenuGroupContext);
}

function SelectMenuItem({ value, label, isDisabled, endIcon }) {
    const { isMultiple, value: selectedValue, onCommit, groupKey } = useSelectMenuGroupContext();
    const uniqueID = useId.useId();
    const id = hooks.useMemo(() => `oj-menu-item-${uniqueID}`, [uniqueID]);
    const { isSelected, memoizedOnCommit } = hooks.useMemo(() => {
        if (!isMultiple) {
            return {
                isSelected: selectedValue === value,
                memoizedOnCommit: () => {
                    onCommit?.({ value, previousValue: selectedValue });
                }
            };
        }
        return {
            isSelected: !!selectedValue?.includes(value),
            memoizedOnCommit: () => {
                const proposedValue = isSelected
                    ? selectedValue?.filter((val) => val !== value) || []
                    : [...(selectedValue || []), value];
                onCommit?.({ value: proposedValue, previousValue: selectedValue });
            }
        };
    }, [selectedValue, value, onCommit, isMultiple]);
    return (jsxRuntime.jsx(SelectMenuGroupContext.BaseMenuItem, { id: id, type: "select", role: isMultiple ? 'menuitemcheckbox' : 'menuitemradio', isChecked: isSelected, isDisabled: isDisabled, startIcon: isSelected ? jsxRuntime.jsx(Check.SvgCheck, {}) : jsxRuntime.jsx("span", { class: UNSAFE_Menu_themes_MenuItemStyles_css.styles.noSelectedIcon }), label: label, onAction: memoizedOnCommit, endIcon: endIcon, itemKey: `${groupKey}-${value}` }));
}

function SelectSingleMenuGroup({ value, onCommit, children, groupKey }) {
    return (jsxRuntime.jsx(SelectMenuGroupContext.SelectMenuGroupContext.Provider, { value: { isMultiple: false, value, onCommit, groupKey }, children: children }));
}

const DropdownSubmenu = ({ label, children, startIcon, itemKey }) => {
    //Id of the submenu that will be used to connect via aria-owns, menuItem with its submenu
    const submenuId = useId.useId();
    const preProcessedMenuItemID = useId.useId();
    //MenuItem id
    const menuItemId = compat.useMemo(() => `oj-menu-item-${preProcessedMenuItemID}`, [preProcessedMenuItemID]);
    const { changeKey, currentKey } = SelectMenuGroupContext.useMenuContainerContext();
    const submenuMenuItemRef = compat.useRef(null);
    const dropdownSubmenuRef = compat.useRef(null);
    const [isOpen, setIsOpen] = compat.useState(false);
    const [currentFocus, setCurrentFocus] = compat.useState('none');
    const [pxPerUnit, setPxPerUnit] = compat.useState(DEFAULT_PX_PER_UNIT);
    const scale = useScale.useScale();
    compat.useEffect(() => {
        // Important to have scale as a posible reason for running this effect since changing scale would produce a need of updating px per unit
        if (!scale || !themeContract_css.scaleVars?.size?.units) {
            setPxPerUnit(0.25 * remInPx());
        }
        else {
            // We asume scale vars has the form of var(x), due to that we obtain string inside parenthesis, if not found empty string is passed
            const cssVar = /\(([^)]+)\)/.exec(themeContract_css.scaleVars.size.units)?.[1] || '';
            // We try to get css var value, if this could not be obtained we use 0.25rem as fallback value
            const valueofCSSVar = window
                .getComputedStyle(submenuMenuItemRef.current)
                .getPropertyValue(cssVar);
            if (valueofCSSVar.endsWith('px')) {
                setPxPerUnit(parseFloat(valueofCSSVar));
            }
            else if (valueofCSSVar.endsWith('rem')) {
                setPxPerUnit(parseFloat(valueofCSSVar) * remInPx());
            }
            else {
                setPxPerUnit(0.25 * remInPx());
            }
        }
    }, [scale]);
    compat.useEffect(() => {
        if (menuItemId !== currentKey) {
            setIsOpen(false);
        }
    }, [currentKey, menuItemId]);
    //This function is used when pressing submenuitem and hovering over it
    const openSubmenuAction = compat.useCallback((e) => {
        submenuMenuItemRef.current?.focus();
        //If not click/touch we set the focus on the first item
        setIsOpen(true);
        if (e.type === 'keyup') {
            setCurrentFocus('firstItem');
        }
        else {
            setCurrentFocus('none');
        }
    }, []);
    //TODO: There is a bug in a Icon, once that bug is solved we have to check this again. JET-56980
    const hoverStatus = compat.useRef({
        recentClose: false,
        pendingUnhover: false
    });
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(SelectMenuGroupContext.BaseMenuItem, { itemKey: itemKey, startIcon: startIcon, id: menuItemId, submenuId: submenuId, ref: submenuMenuItemRef, label: label, endIcon: jsxRuntime.jsx(DirectionalExpandArrowIcon.DirectionalExpandArrowIcon, {}), type: "submenu", role: "menuitem", onAction: openSubmenuAction, hoverInfo: {
                    //Specific hover events of submenuItem
                    hoverProps: {
                        onMouseEnter: (e) => {
                            openSubmenuAction(e);
                        }
                    },
                    hoverStatus
                }, 
                //Open submenu using right/left key
                openSubmenu: () => {
                    setIsOpen(true);
                    setCurrentFocus('firstItem');
                }, submenuRef: dropdownSubmenuRef, isSubmenuOpen: isOpen }), jsxRuntime.jsx(SelectMenuGroupContext.DropdownMenu, { isOpen: isOpen, menuLevel: "sub", menuId: submenuId, 
                //Close submenu with left/right key
                closeSubmenu: () => {
                    hoverStatus.current.recentClose = true;
                    changeKey({ key: currentKey, reason: 'keyboard' });
                    setTimeout(() => {
                        hoverStatus.current.recentClose = false;
                    }, HOVER_SHIFT_TIMEOUT);
                    setIsOpen(false);
                    //CurrentKey can be the same as submenuItem, because of that we explicitly focus it
                    submenuMenuItemRef.current?.focus();
                }, 
                /*For now we are exposing ref if this is exposed at some point we would look for other
                    mechanisms to use this ref */
                ref: dropdownSubmenuRef, anchorRef: submenuMenuItemRef, defaultPlacement: "end-top", currentFocus: currentFocus, offsetValue: {
                    mainAxis: -(2 * pxPerUnit), //TODO: need to figure out how to make this themable.
                    crossAxis: -(2 * pxPerUnit + 1)
                }, flipOptions: {
                    crossAxis: true,
                    mainAxis: true,
                    fallbackPlacements: ['start-top', 'end-bottom', 'start-bottom']
                }, children: children })] }));
};
const HOVER_SHIFT_TIMEOUT = 100;
const DEFAULT_PX_PER_UNIT = 4;
const remInPx = () => {
    return parseInt(window.getComputedStyle(document.documentElement).fontSize || '16px', 10);
};

const SheetSubmenu = ({ label, children, startIcon, itemKey }) => {
    const { isMobile } = SelectMenuGroupContext.useMenuContext();
    const submenuId = useId.useId();
    const submenuItemId = useId.useId();
    const submenuTitleId = useId.useId();
    const submenuMenuItemRef = hooks.useRef(null);
    const [isOpen, setIsOpen] = hooks.useState(false);
    const [initialFocus, setInitialFocus] = hooks.useState('menu');
    const { menuContainerRef, changeKey } = SelectMenuGroupContext.useMenuContainerContext();
    const openSubmenuDirectional = hooks.useCallback(() => {
        openSubmenu();
        setInitialFocus('secondItem');
    }, []);
    const openSubmenuAction = hooks.useCallback((e) => {
        openSubmenu();
        //If the submenu is open using keyboard focus has to go to second item(first is the title), if not to the menu Container
        if (e.type === 'keyup') {
            setInitialFocus('secondItem');
        }
        else {
            if (isMobile) {
                setInitialFocus('secondItemDueToTouch');
            }
            else {
                setInitialFocus('menu');
            }
        }
    }, []);
    const returnFocusToSubmenuItem = hooks.useCallback(() => {
        changeKey({ key: submenuItemId, reason: 'keyboard' });
        submenuMenuItemRef.current?.focus();
    }, [changeKey, submenuItemId, submenuMenuItemRef]);
    /* No need to "save" these functions with useCallback */
    const openSubmenu = () => {
        /* Menu hidden instead of unmounted for two main reasons:
          1. Children need to be updated even if menu is not present.
          2. We can't unmount parent since all the submenus are children of main menu */
        menuContainerRef.current.style.display = 'none';
        setIsOpen(true);
    };
    const closeSubmenu = () => {
        setIsOpen(false);
        if (menuContainerRef.current) {
            //Submenu is unmounted and prev menu is visible again.
            /*Dom manipulation is kind of dirty. Have to check for new approaches. JET-57239 */
            menuContainerRef.current.style.display = 'block';
        }
    };
    const closeSubmenuPressingTitleItem = (e) => {
        closeSubmenu();
        //If the submenu is closed using keyboard focus has to go to submenuItem that opened submenu, if not to the menu Container
        if (e.type === 'keyup') {
            returnFocusToSubmenuItem();
        }
        else {
            if (isMobile) {
                changeKey({ key: submenuItemId, reason: 'touch' });
                // We need to add a little delay due to VO double tap producing focusing wrong item. Will be removed once animation is added for sheet submenus
                setTimeout(() => {
                    submenuMenuItemRef.current?.focus();
                }, 0);
            }
            else {
                changeKey({ key: undefined, reason: 'click' });
                menuContainerRef.current?.focus();
            }
        }
    };
    const closeDirectional = () => {
        closeSubmenu();
        returnFocusToSubmenuItem();
    };
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(SelectMenuGroupContext.BaseMenuItem, { itemKey: itemKey, startIcon: startIcon, id: submenuItemId, submenuId: submenuId, ref: submenuMenuItemRef, label: label, endIcon: jsxRuntime.jsx(DirectionalExpandArrowIcon.DirectionalExpandArrowIcon, {}), type: "submenu", role: "menuitem", onAction: openSubmenuAction, openSubmenu: openSubmenuDirectional, isSubmenuOpen: isOpen }), !isOpen
                ? null
                : // We need to use portal to ensure all submenus are siblings so if one dissapear not every submenu dissapear
                    compat.createPortal(jsxRuntime.jsxs(SelectMenuGroupContext.MenuContainer, { display: "sheet", "aria-label": label, menuId: submenuId, closeSubmenu: closeDirectional, menuLevel: "sub", anchorRef: submenuMenuItemRef, 
                        //TODO: We need to check if this initial focus is desired based on some W3C specs
                        currentFocus: initialFocus, children: [jsxRuntime.jsx(SelectMenuGroupContext.BaseMenuItem, { id: submenuTitleId, menuItemLabelWeight: "bold", role: "menuitem", type: "submenu", startIcon: jsxRuntime.jsx(DirectionalCollapseArrowIcon.DirectionalCollapseArrowIcon, {}), onAction: closeSubmenuPressingTitleItem, label: label }), children] }), menuContainerRef.current?.parentElement)] }));
};

/*Submenu behaves differently depending the device */
const Submenu = (props) => {
    const { isMobile } = SelectMenuGroupContext.useMenuContext();
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: isMobile ? (jsxRuntime.jsx(SheetSubmenu, { ...props })) : (jsxRuntime.jsx(DropdownSubmenu, { ...props })) }));
};

exports.SelectMenuItem = SelectMenuItem;
exports.SelectSingleMenuGroup = SelectSingleMenuGroup;
exports.Submenu = Submenu;
//# sourceMappingURL=Submenu-416179ad.js.map
