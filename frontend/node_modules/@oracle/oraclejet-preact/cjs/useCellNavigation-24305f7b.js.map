{"version":3,"file":"useCellNavigation-24305f7b.js","sources":["../../src/UNSAFE_DatePicker/useFocusableCell.ts","../../src/UNSAFE_DatePicker/useCellNavigation.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useTabbableMode } from '#hooks/UNSAFE_useTabbableMode';\nimport { useLayoutEffect, useRef } from 'preact/compat';\n\ntype UseFocusableCellProps = {\n  /**\n   * Specifies if this cell is the one that will be focused when\n   * one tabs into the grid view.\n   */\n  isFocusable: boolean;\n\n  /**\n   * Specifies whether or not the cell is currently focused.\n   */\n  isFocused: boolean;\n};\n\n/**\n * A custom hook that handles focus for a month or year cell.\n */\nexport const useFocusableCell = <T extends HTMLElement = HTMLElement>({\n  isFocusable,\n  isFocused\n}: UseFocusableCellProps) => {\n  const cellRef = useRef<T>(null);\n  const { isTabbable } = useTabbableMode();\n\n  // Using layout effect here to set the focus as we want to focus the element\n  // before the browser has a chance to paint. This way the browser don't have to\n  // repaint the focused state.\n  useLayoutEffect(() => {\n    if (isFocusable && isFocused) {\n      cellRef.current?.focus();\n    }\n  }, [isFocusable, isFocused]);\n\n  return { ref: cellRef, tabIndex: isFocusable && isTabbable ? 0 : -1 };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { useCallback } from 'preact/compat';\n\ntype SupportedKeyBindings =\n  | 'ArrowLeft'\n  | 'ArrowRight'\n  | 'ArrowUp'\n  | 'ArrowDown'\n  | 'End'\n  | 'Home'\n  | 'PageUp'\n  | 'PageDown'\n  | 'ShiftPageUp'\n  | 'ShiftPageDown'\n  | 'CtrlAltT';\ntype NavigationValue<T extends string> = T | { ltr: T; rtl: T };\ntype NavigationMap<T extends string> = Partial<Record<SupportedKeyBindings, NavigationValue<T>>>;\n\ntype UseCellNavigationProps<Payload extends object, Navigation extends string> = {\n  /**\n   * Payload for the callbacks from this cell.\n   */\n  payload: Payload;\n\n  /**\n   * An object that maps the key codes to the direction of navigation. The onNavigation\n   * callback will be invoked only for the key codes provided in the map and specifies the\n   * direction as provided in the value.\n   */\n  navigationMap: NavigationMap<Navigation>;\n\n  /**\n   * A callback that will be invoked when a selection action is performed on the DatePicker cell.\n   * @param payload The provided payload.\n   */\n  onAction: (payload: Payload) => void;\n\n  /**\n   * A callback that will be invoked when a navigation action is performed on the DatePicker cell.\n   * @param details The object specifying the direction of the navigation performed and the payload.\n   */\n  onNavigation: (details: { direction: Navigation } & Payload) => void;\n};\n\n// Utility for killing handled events.\nconst killEvent = (event: Event) => {\n  event.preventDefault();\n  event.stopPropagation();\n};\n\n/**\n * A custom hook that handles navigation for a DatePicker cell.\n */\nexport const useCellNavigation = <T extends object, U extends string>({\n  navigationMap,\n  payload,\n  onAction,\n  onNavigation\n}: UseCellNavigationProps<T, U>) => {\n  const { direction } = useUser();\n  const handleSelection = useCallback(() => {\n    onAction(payload);\n  }, [payload, onAction]);\n\n  // JET-67580: Prevent InputDatePicker dropdown from re-opening by performing\n  // selection onKeyUp. After a selection is made, IDP transfers focus to the\n  // calendar icon. If we use key down, then IconButton gets the key up which\n  // causes it to fire its action handler and reopen the picker.\n  const handleKeyUp = useCallback<NonNullable<GlobalEventHandlers['onkeyup']>>(\n    (event) => {\n      if (['Enter', 'Space'].includes(event.code)) {\n        // since we are handling the event, we need to kill the event here\n        // so that no other action is performed\n        killEvent(event);\n        handleSelection();\n        return;\n      }\n    },\n    [handleSelection]\n  );\n\n  // Although we handle the Space/Enter keys in onKeyUp, the rest of the events\n  // (like arrow keys, home, end, etc.) are still handled on key down which feels\n  // more natural. It also lets you hold keys down - like arrow keys - to keep\n  // navigating through day cells.\n  const handleKeyDown = useCallback<NonNullable<GlobalEventHandlers['onkeydown']>>(\n    (event) => {\n      if (event.code === 'Space') {\n        // Even though we handle Space on key up, we need to call preventDefault on\n        // key down to prevent browser scrolling on some browsers.\n        event.preventDefault();\n        return;\n      }\n\n      // Handle Ctrl + Alt + T\n      if (event.code === 'KeyT' && event.ctrlKey && event.altKey) {\n        const navigationDirection = navigationMap['CtrlAltT'];\n        if (navigationDirection !== undefined) {\n          // since we are handling the event, we need to kill the event here\n          // so that no other action is performed\n          killEvent(event);\n          onNavigation({\n            direction: getLogicalValue(navigationDirection, direction),\n            ...payload\n          });\n        }\n      }\n\n      const { key, shiftKey } = event;\n\n      switch (key) {\n        // since we are handling the event, we need to kill the event here\n        // so that no other action is performed\n        case 'ArrowLeft':\n        case 'ArrowRight':\n        case 'ArrowUp':\n        case 'ArrowDown':\n        case 'End':\n        case 'Home':\n        case 'PageUp':\n        case 'PageDown': {\n          const mapKey: SupportedKeyBindings =\n            shiftKey && (key === 'PageUp' || key === 'PageDown') ? `Shift${key}` : key;\n          if (navigationMap[mapKey] !== undefined) {\n            killEvent(event);\n            const navigationDirection = navigationMap[mapKey]!;\n            onNavigation({\n              direction: getLogicalValue(navigationDirection, direction),\n              ...payload\n            });\n          }\n        }\n      }\n    },\n    [direction, navigationMap, onNavigation, payload]\n  );\n\n  return {\n    onClick: handleSelection,\n    onKeyDown: handleKeyDown,\n    onKeyUp: handleKeyUp\n  };\n};\n\n/**\n * Determines the logical value for the navigation direction.\n * @param value The value representing the navigation direction\n * @param dir The reading direction from the user preferences\n * @returns The logical navigation direction\n */\nconst getLogicalValue = <T extends string>(value: NavigationValue<T>, dir: 'ltr' | 'rtl') =>\n  typeof value === 'string' ? value : value[dir];\n"],"names":["useRef","useTabbableMode","useLayoutEffect","useUser","useCallback"],"mappings":"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"}