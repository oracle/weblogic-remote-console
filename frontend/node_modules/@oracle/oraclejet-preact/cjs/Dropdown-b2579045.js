/* @oracle/oraclejet-preact: undefined */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
var Floating = require('./Floating-5a704a27.js');
var Layer = require('./Layer-28b1afce.js');
require('preact/compat');
require('./LayerHost-aee0e070.js');
var keyboardUtils = require('./keyboardUtils-b42fe7d5.js');
var tabbableUtils = require('./tabbableUtils-7e41d383.js');
var usePopupAnimation = require('./usePopupAnimation-18040396.js');
var popupAnimationUtils = require('./popupAnimationUtils-dcace427.js');
var CollectionInteractionContext = require('./CollectionInteractionContext-f84ff7a1.js');
var UNSAFE_Dropdown_themes_dropdownStyles_css = require('./UNSAFE_Dropdown/themes/dropdownStyles.css.js');
var useOutsideMousedown = require('./useOutsideMousedown-8f913d1a.js');
var animationUtils = require('./animationUtils-54852d03.js');
var unsafeDomAccess = require('./unsafeDomAccess-c3a492f0.js');

const DEFAULT_PLACEMENT = 'bottom-start';
const DEFAULT_OFFSET = { mainAxis: 4, crossAxis: 0 };
const DEFAULT_SIZE_OPTIONS = { isMaxWidthAdjusted: true, isMaxHeightAdjusted: true };
const DEFAULT_FLIP_OPTIONS = { mainAxis: true, crossAxis: true };
const animationStates = {
    opening: (node) => {
        return animationUtils.mergeAnimationStateObjects([
            animationUtils.SCALE_UP_FULL,
            {
                from: { transformOrigin: popupAnimationUtils.getTransformOrigin(node.placement, node.direction) },
                to: { transformOrigin: popupAnimationUtils.getTransformOrigin(node.placement, node.direction) }
            }
        ], {
            duration: animationUtils.DURATION_LARGE
        });
    }
};
//TODO: Add animation to dropdown. JET-62628
//TODO: Investigate best approach to have different virtual padding depending on the position and implement it.JET-57950
function Dropdown({ isOpen = false, anchorRef, children, id, onClose, minWidth, placement = DEFAULT_PLACEMENT, offset = DEFAULT_OFFSET, onPosition, flipOptions = DEFAULT_FLIP_OPTIONS, sizeOptions = DEFAULT_SIZE_OPTIONS, shiftOptions, initialFocus = 'none' }) {
    const dropdownRef = hooks.useRef(null);
    const onTransitionEnd = hooks.useCallback((isOpen) => {
        if (isOpen && initialFocus === 'firstFocusable') {
            const dropdownElement = dropdownRef.current;
            if (dropdownElement) {
                tabbableUtils.focusWithin(dropdownElement);
            }
        }
    }, [initialFocus]);
    const { status, setAnimationElementRef, onPosition: onPositionAnimated } = usePopupAnimation.usePopupAnimation({
        isOpen,
        placement,
        isAnimatedOnMount: true,
        animationStates,
        onPosition,
        onTransitionEnd
    });
    const handleMousedownClose = hooks.useCallback((event) => {
        onClose?.({ reason: 'outsideMousedown', target: event.target });
    }, [onClose]);
    const handleKeyDown = hooks.useCallback((event) => {
        if (event.defaultPrevented) {
            return;
        }
        switch (event.code) {
            case keyboardUtils.KEYS.ESC:
                onClose?.({ reason: 'dismissed' });
                break;
            case keyboardUtils.KEYS.TAB:
                onClose?.({ reason: 'dismissed' });
                break;
        }
    }, [onClose]);
    // use the mousedown event to be consistent with legacy JET
    useOutsideMousedown.useOutsideMousedown({
        isDisabled: false,
        ref: [dropdownRef],
        handler: handleMousedownClose
    });
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: status !== 'unmounted' ? (jsxRuntime.jsx(Layer.Layer, { logicalParentRef: toLogicalParentRef(anchorRef), children: jsxRuntime.jsx(Floating.Floating, { anchorRef: anchorRef, ref: setAnimationElementRef, placement: placement, flipOptions: flipOptions, shiftOptions: shiftOptions, sizeOptions: sizeOptions, offsetValue: offset, onPosition: onPositionAnimated, boundaryOptions: { padding: { top: 8, bottom: 8, left: 0, right: 0 } }, children: jsxRuntime.jsx("div", { ref: dropdownRef, id: id, class: UNSAFE_Dropdown_themes_dropdownStyles_css.dropdownStyles.base, style: { minWidth: `${minWidth || 0}px` }, onKeyDown: handleKeyDown, children: jsxRuntime.jsx(CollectionInteractionContext.CollectionInteractionContext.Provider, { value: 'embedded', children: children }) }) }) })) : null }));
}
function toLogicalParentRef(anchorRef) {
    const current = anchorRef.current;
    if (current) {
        if (current instanceof Element) {
            return anchorRef;
        }
        else if (current[unsafeDomAccess.UNSAFE_DOM_ACCESS]) {
            return anchorRef;
        }
    }
    return null;
}

exports.Dropdown = Dropdown;
//# sourceMappingURL=Dropdown-b2579045.js.map
