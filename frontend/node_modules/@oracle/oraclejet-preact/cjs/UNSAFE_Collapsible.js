/* @oracle/oraclejet-preact: undefined */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
var useId = require('./useId-6c0eeb27.js');
var preact = require('preact');
var classNames = require('./classNames-c14c6ef3.js');
var useComponentTheme = require('./useComponentTheme-082fc8e4.js');
require('./TabbableModeContext-e99d527e.js');
var useTabbableMode = require('./useTabbableMode-a275583f.js');
var Flex = require('./Flex-6ca216a7.js');
var Separator = require('./Separator-85962472.js');
var ChevronDown = require('./ChevronDown-25b749b9.js');
var CollapseIcon = require('./CollapseIcon-7612943e.js');
var ChevronUp = require('./ChevronUp-a4e4b6ef.js');
var UNSAFE_Collapsible_themes_redwood_CollapsibleTheme = require('./UNSAFE_Collapsible/themes/redwood/CollapsibleTheme.js');
var useAnimation = require('./useAnimation-fb11e4cc.js');
var useTestId = require('./useTestId-9093a54b.js');
require('./logger-2b636482.js');
require('./boxalignment-6dde2812.js');
require('./size-0717c0bd.js');
require('./utils-a66430fc.js');
require('./themeContract.css-a53fd740.js');
require('./colorUtils-01f3caa2.js');
require('./_curry1-e8f0d7ea.js');
require('./arrayUtils-7d8dcfc3.js');

require('./vanilla-extract-sprinkles-createRuntimeSprinkles.esm-d68f3e0f.js');
require('./dimensions-2fcc0acf.js');
require('./flexbox-2cae9a01.js');

require('./flexitem-fee13e26.js');

require('./mergeInterpolations-6727b536.js');
require('./mergeDeepWithKey-210b024d.js');
require('./_curry3-18677bca.js');
require('./_curry2-c15d89cd.js');
require('./_isObject-28636267.js');

require('./UNSAFE_Separator/themes/SeparatorStyles.css.js');

require('./vanilla-extract-recipes-createRuntimeFn.esm-d1301b2d.js');
require('./Icon-bc05e7bd.js');
require('./useTooltip-8728f2ff.js');
require('./useTooltipControlled-3c2afa53.js');
require('./useHover-49b0430d.js');
require('./useToggle-3ebba7d8.js');
require('./useFocus-1b288fb9.js');
require('./useTouch-4dec8729.js');
require('./mergeProps-e3da7237.js');
require('./useThemeInterpolations-4faece98.js');
require('./useColorScheme-23e4aab4.js');
require('./LayerHost-aee0e070.js');
require('./index-15e13649.js');
require('preact/compat');
require('./UNSAFE_Layer/themes/LayerHostStyles.css.js');

require('./useScale-adc62f41.js');
require('./theme-dfd6a9fe.js');
require('./Theme-f06687af.js');
require('./useDensity-022a8f80.js');
require('./unsafeDomAccess-c3a492f0.js');
require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentTheme.js');
require('./hooks/UNSAFE_useTooltip/themes/TooltipContentStyles.css.js');

require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentBaseTheme.css.js');

require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js');

require('./tooltipUtils-ae48fed6.js');
require('./EnvironmentProvider-8696a5b8.js');
require('./LayerManager-fc4df14f.js');
require('./Floating-5a704a27.js');
require('./useFloating-13101293.js');
require('./useUser-f900ddf1.js');
require('./positionUtils-a780137e.js');
require('./refUtils-a9872e75.js');
require('./useOutsideClick-c3802f86.js');
require('./Layer-28b1afce.js');
require('./UNSAFE_Layer/themes/LayerStyles.css.js');

require('./useModal-0739a528.js');
require('./UNSAFE_Floating/themes/redwood/FloatingTheme.js');
require('./UNSAFE_Floating/themes/FloatingStyles.css.js');

require('./UNSAFE_Floating/themes/redwood/FloatingBaseTheme.css.js');

require('./UNSAFE_Floating/themes/redwood/FloatingVariants.css.js');
require('./vanilla-extract-dynamic.esm-2e1b7c25.js');
require('./UNSAFE_Floating/themes/FloatingContract.css.js');
require('./useUnsafeDomElementRef-f22a2f0c.js');
require('./UNSAFE_Icon/themes/IconStyle.css.js');

require('./clientHints-c40c5250.js');
require('./ChevronRight-2019bb77.js');
require('./ChevronLeft-54f429b3.js');
require('./withDirectionIcon-edb93142.js');
require('./UNSAFE_Collapsible/themes/CollapsibleStyles.css.js');

require('./UNSAFE_Collapsible/themes/redwood/CollapsibleVariants.css.js');


/**
 * Header icon subcomponent
 */
const CollapsibleHeaderIcon = ({ isExpanded, isDisabled, iconPosition }) => {
    const color = isDisabled ? 'disabled' : 'primary';
    const startIcon = iconPosition === 'start' && isExpanded ? ChevronDown.SvgChevronDown : CollapseIcon.CollapseIcon;
    const endIcon = iconPosition === 'end' && isExpanded ? ChevronUp.SvgChevronUp : ChevronDown.SvgChevronDown;
    const Icon = iconPosition === 'start' ? startIcon : endIcon;
    return jsxRuntime.jsx(Icon, { size: "6x", color: color });
};

const DefaultSettings = {
    isDisabled: false
};
/**
 * Returns a click handler that can make a target element either clickable or keyboard pressable.
 *
 * @param onPressHandler function
 * @param isDisabled boolean
 * @returns
 */
function useCollapsiblePress(onPressHandler, settings = DefaultSettings) {
    const [isPressed, setIsPressed] = hooks.useState(false);
    const mergedSettings = hooks.useMemo(() => {
        return { ...DefaultSettings, ...settings };
    }, [settings]);
    const onKeyDown = hooks.useCallback((event) => {
        if (event.code === 'Space' || event.code === 'Enter') {
            // event.preventDefault();
            setIsPressed(true);
        }
    }, [setIsPressed]);
    const onKeyUp = hooks.useCallback((event) => {
        if (event.code === 'Space' || event.code === 'Enter') {
            setIsPressed(false);
            event.preventDefault();
            onPressHandler(event);
        }
    }, [onPressHandler, setIsPressed]);
    const onBlur = hooks.useCallback(() => {
        setIsPressed(false);
    }, [setIsPressed]);
    const onClickSingle = hooks.useCallback((event) => {
        // See note above about why propagation is stopped: to prevent nested component bubbling clicks issue
        event.stopPropagation();
        if (!isPressed) {
            onPressHandler(event);
        }
    }, [onPressHandler, isPressed]);
    const pressProps = mergedSettings.isDisabled
        ? {}
        : {
            onKeyDown,
            onKeyUp,
            onBlur,
            onClick: onClickSingle
        };
    return {
        pressProps
    };
}

/**
 * Header subcomponent
 */
const CollapsibleHeader = ({ children, id, contentId, isDisabled, isExpanded, iconPosition, variant = 'basic', toggleHandler, accessibleLabel, accessibleLabelId }) => {
    const [hasFocus, setFocus] = hooks.useState(false);
    const isMouseDown = hooks.useRef(false);
    const { isTabbable } = useTabbableMode.useTabbableMode();
    const { classes, styles } = useComponentTheme.useComponentTheme(UNSAFE_Collapsible_themes_redwood_CollapsibleTheme.CollapsibleRedwoodTheme, {
        disabled: isDisabled ? 'isDisabled' : 'notDisabled',
        divider: variant === 'horizontal-rule' ? 'hasDivider' : 'noDivider',
        focused: hasFocus ? 'isFocused' : 'notFocused'
    });
    const childrenClasses = classNames.classNames([
        styles.headerChildrenStyle,
        iconPosition === 'end' && styles.iconEndStyle,
        iconPosition === 'start' && styles.iconStartStyle
    ]);
    const pressHandler = hooks.useCallback((event) => {
        toggleHandler(event.target);
        // if the header has focus highlight and the toggle was caused by a pointer action,
        // remove focus highlight from the header div
        // the test environment may not support PointerEvent, make sure it is supported
        if (hasFocus) {
            const hasPointerEvent = window && 'PointerEvent' in window;
            if ((hasPointerEvent && event instanceof PointerEvent) || event instanceof MouseEvent) {
                setFocus(false);
            }
        }
    }, [toggleHandler, hasFocus]);
    const { pressProps } = useCollapsiblePress(pressHandler, {
        isDisabled
    });
    // if focused, we want to render the focus highlight on the collapsible header div
    const onFocus = hooks.useCallback((event) => {
        if (event.type === 'focusin' && !isMouseDown.current) {
            setFocus(true);
        }
        else {
            setFocus(false);
        }
    }, []);
    const mouseDownHandler = () => {
        isMouseDown.current = true;
    };
    const mouseUpHandler = () => {
        isMouseDown.current = false;
    };
    // Resolve accessible label. By default, the expand button is labelled by the header content.
    // If accessibleLabel or accessibleLabeleId is specified, they get used instead.
    const ariaLabelProp = accessibleLabel
        ? { 'aria-label': accessibleLabel }
        : accessibleLabelId
            ? { 'aria-labelledby': accessibleLabelId }
            : { 'aria-labelledby': id };
    const getHeader = () => (jsxRuntime.jsxs(preact.Fragment, { children: [iconPosition === 'end' && jsxRuntime.jsx("div", { className: childrenClasses, children: children }), jsxRuntime.jsx("div", { tabIndex: isTabbable && !isDisabled ? 0 : -1, role: 'button', "aria-controls": contentId, "aria-expanded": isExpanded, onFocus: onFocus, onBlur: onFocus, onMouseDown: mouseDownHandler, onMouseUp: mouseUpHandler, className: styles.chevronStyle, ...ariaLabelProp, children: jsxRuntime.jsx(CollapsibleHeaderIcon, { iconPosition: iconPosition, isExpanded: isExpanded, isDisabled: isDisabled }) }), iconPosition === 'start' && jsxRuntime.jsx("div", { className: childrenClasses, children: children })] }));
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("div", { id: id, className: classes, ...pressProps, children: jsxRuntime.jsx(Flex.Flex, { align: "center", justify: iconPosition === 'start' ? 'start' : 'between', children: getHeader() }) }), variant === 'horizontal-rule' && jsxRuntime.jsx(Separator.Separator, {})] }));
};

const CollapsibleContent = ({ children, id, isExpanded, onTransitionEnd }) => {
    const [state, setState] = hooks.useState(isExpanded ? 'expanding' : 'unmounted');
    const { styles } = useComponentTheme.useComponentTheme(UNSAFE_Collapsible_themes_redwood_CollapsibleTheme.CollapsibleRedwoodTheme);
    /**
     * 1. On initial render, Preact sets style.maxHeight field to 0 or 'none'.
     * 2. During expanding animation, useAnimation hook uses WAAPI to animate the maxHeight out
     *    to the expanded value.
     * 3. On subsequent re-renders, Preact does never updates the style.maxHeight value
     *    because even though we are telling Preact that maxHeight should be 0 or 'none', Preact
     *    considers the maxHeight value is 0 or 'none' as it is not aware that we changed this value
     *    in step 2. So from Preact's perspective there is no difference.
     */
    const contentInitialStyle = hooks.useRef({
        overflowY: 'hidden',
        maxHeight: isExpanded ? 'none' : '0'
    });
    const classes = classNames.classNames([
        styles.contentChildrenStyle,
        state === 'unmounted' && styles.contentHiddenStyle
    ]);
    hooks.useEffect(() => {
        // Ignore state update on initial render
        if (state === 'unmounted' && !isExpanded) {
            return;
        }
        setState(isExpanded ? 'expanding' : 'collapsing');
    }, [isExpanded, state]);
    const { nodeRef } = useAnimation.useAnimation(state, {
        animationStates,
        onAnimationEnd: ({ animationState }) => {
            if (animationState === 'collapsing') {
                setState('unmounted');
            }
            onTransitionEnd?.();
        }
    });
    return (jsxRuntime.jsx("div", { className: classes, ref: nodeRef, id: id, tabIndex: -1, style: contentInitialStyle.current, "aria-hidden": !isExpanded || undefined, children: children }));
};
/**
 * The transition from collapsed to expanded works as follows:
 * 1. When the component is initially rendered in the collapsed state, we
 *    explicitly set maxHeight and overflowY from "to" configuration.
 * 2. When the expanded prop changes from false to true, we first mount the content children.
 * 3. Once this is mounted we trigger an animation updating animationState value of useAnimationHook.
 * 4. Configuration is represented inside hook. Passed config depends if previous animation was completed or not.
 *    We could check that based on node.style.maxHeight.
 *
 * The transition from expanded to collapsed is similar:
 * 1. We trigger an animation updating animationState value of useAnimationHook.
 * 2. Once animation is completed, with the help of end config,we set max-Height as 'none'.
 *    This will allow us to keep adding content.
 * 3. Once this is done, onAnimationEnd is called(as 'from collapsed to expanded"). Here, content children are unmouunted.
 */
const animationStates = {
    expanding: (node) => ({
        to: {
            maxHeight: `${node.scrollHeight}px`
        },
        options: {
            duration: 400
        },
        end: {
            maxHeight: 'none'
        }
    }),
    collapsing: (node) => ({
        ...(node.style.maxHeight === 'none' && {
            from: {
                maxHeight: `${node.scrollHeight}px`
            }
        }),
        to: {
            maxHeight: '0'
        },
        options: {
            duration: 400
        }
    })
};

/**
 * A collapsible displays a header that can be expanded to show its content.
 */
const Collapsible = ({ header, children, isDisabled = false, isExpanded = false, iconPosition = 'start', variant = 'basic', onToggle, onTransitionEnd, 'aria-label': accessibleLabel, 'aria-labelledby': accessibleLabelId, testId }) => {
    const uniqueID = useId.useId();
    const headerId = `oj-collapsible-header-${uniqueID}`;
    const contentId = `oj-collapsible-content-${uniqueID}`;
    const testIdProps = useTestId.useTestId(testId);
    /**
     * Function handling toggle and invoking callback for collapsing/expanding
     */
    const toggleHandler = hooks.useCallback((target) => {
        if (isDisabled) {
            return;
        }
        onToggle?.({
            value: !isExpanded,
            target
        });
    }, [isDisabled, onToggle, isExpanded]);
    /**
     * Function that is triggerd when animation ends
     */
    const transitionEndHandler = hooks.useCallback(() => {
        onTransitionEnd?.({
            value: isExpanded
        });
    }, [onTransitionEnd, isExpanded]);
    return (jsxRuntime.jsxs("div", { ...testIdProps, children: [jsxRuntime.jsx(CollapsibleHeader, { id: headerId, contentId: contentId, toggleHandler: toggleHandler, isDisabled: isDisabled, isExpanded: isExpanded, iconPosition: iconPosition, variant: variant, accessibleLabel: accessibleLabel, accessibleLabelId: accessibleLabelId, children: header }), jsxRuntime.jsx(CollapsibleContent, { id: contentId, isExpanded: isExpanded, onTransitionEnd: transitionEndHandler, children: children })] }));
};

exports.Collapsible = Collapsible;
//# sourceMappingURL=UNSAFE_Collapsible.js.map
