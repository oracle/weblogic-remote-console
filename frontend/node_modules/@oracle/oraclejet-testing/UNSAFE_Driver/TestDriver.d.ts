import { ElementLocator } from '../UNSAFE_Locators';
import { type WaitForOptions } from './waitFor';
/**
 * A TestDriver implements the platform-specific commands needed for testing
 * with adapters.
 */
export interface TestDriver {
    /**
     * Click on the given TestElement
     * @param element The TestElement on which to click
     */
    click(element: TestElement, options?: ClickOptions): Promise<void>;
    /**
     * Execute a script in the browser environment.
     * Note that if passing a TestElement as an argument, you must first call {@link unwrapElement}
     * on it to pass the driver-specific element to the script.
     * @example
     * const testEl = await this.getElement();
     * await driver.executeScript<number>((el: HTMLElement) => el.clientHeight), unwrapElement(testEl));
     *
     * @param script The script to execute
     * @param args Any arguments to pass to the script. Access each argument through
     * the <code>arguments</code> array.
     */
    executeScript<T>(script: string | ((...args: any) => T), ...args: any): Promise<T>;
    /**
     * Find an element in the browser environment that matches the given ElementLocator.
     * If an element doesn't exist, this method will wait up to the timeout defined by
     * {@link getTimeouts().elementExistsTimeout}
     * This method throws an exception if no matching elements are found.
     * @param locator
     */
    waitForElement(locator: ElementLocator): Promise<TestElement>;
    /**
     * Find elements in the browser environment matching the given ElementLocator. If no
     * matching elements are found, return a blank array.
     * @param locator
     */
    waitForElements(locator: ElementLocator): Promise<TestElement[]>;
    /**
     * Send text as keystrokes to the browser. If modifier keys are used, all key parameters in the
     * sequence will be combined into a single chord.
     * @param element The element to receive the keystrokes
     * @param text The text value to send, or an array of KeyMap strings to send as a chord of keys
     */
    sendKeys(element: TestElement, ...text: (string | KeyType)[]): Promise<void>;
    /**
     * Unwrap the given TestElement into its driver-specific element
     * @param element
     */
    unwrapElement<T>(element: TestElement): T;
}
/**
 * A base class for implementing the TestDriver interface. Platform-specific TestDrivers should
 * extend this class to inherit behavior for waiting on conditions.
 */
export declare abstract class TestDriverBase implements TestDriver {
    /**
     * Wait for a condition to pass.
     * @param callback The function to run. Return truthy to stop the wait; anything else will retry
     * the callback. The truthy return value of the callback will be returned to the caller.
     * @param options Options for wait time/interval
     * @returns A Promise resolving to the returned value from the callback
     */
    waitFor<T>(callback: () => T | Promise<T>, options?: WaitForOptions): Promise<T>;
    abstract click(element: TestElement, options?: ClickOptions): Promise<void>;
    abstract executeScript<T>(script: string | ((...args: any) => T), ...args: any): Promise<T>;
    abstract waitForElement(locator: ElementLocator): Promise<TestElement>;
    abstract waitForElements(locator: ElementLocator): Promise<TestElement[]>;
    abstract sendKeys(element: TestElement, ...text: (string | KeyType)[]): Promise<void>;
    abstract unwrapElement<T>(element: TestElement): T;
}
/**
 * A TestElement represents the DOM element in the browser environment. This interface
 * is used by test adapters to work with elements without being bound to a specific
 * platform implementation.
 */
export interface TestElement {
    /**
     * Find an element in the browser environment that matches the given ElementLocator.
     * This method should throw an exception if no matching elements are found.
     * @param locator
     */
    waitForElement(locator: ElementLocator): Promise<TestElement>;
    /**
     * Find elements in the browser environment matching the given ElementLocator. If no
     * matching elements are found, return a blank array.
     * @param locator
     */
    waitForElements(locator: ElementLocator): Promise<TestElement[]>;
    /**
     * Get the element's attribute value from the given attrName.
     * @param attrName
     */
    getAttribute(attrName: string): Promise<string | null>;
}
declare const ModifierKeys: {
    readonly ALT: {
        readonly key: "ALT";
    };
    readonly CONTROL: {
        readonly key: "CONTROL";
    };
    readonly CONTROL_COMMAND: {
        readonly key: "CONTROL_COMMAND";
    };
    readonly SHIFT: {
        readonly key: "SHIFT";
    };
};
export type ClickOptions = {
    modifiers?: (typeof ModifierKeys)[keyof typeof ModifierKeys][];
};
export declare const Keys: {
    readonly BACKSPACE: {
        readonly key: "BACKSPACE";
    };
    readonly TAB: {
        readonly key: "TAB";
    };
    readonly ENTER: {
        readonly key: "ENTER";
    };
    readonly ESCAPE: {
        readonly key: "ESCAPE";
    };
    readonly PAGE_UP: {
        readonly key: "PAGE_UP";
    };
    readonly PAGE_DOWN: {
        readonly key: "PAGE_DOWN";
    };
    readonly END: {
        readonly key: "END";
    };
    readonly HOME: {
        readonly key: "HOME";
    };
    readonly ARROW_LEFT: {
        readonly key: "ARROW_LEFT";
    };
    readonly ARROW_UP: {
        readonly key: "ARROW_UP";
    };
    readonly ARROW_RIGHT: {
        readonly key: "ARROW_RIGHT";
    };
    readonly ARROW_DOWN: {
        readonly key: "ARROW_DOWN";
    };
    readonly DELETE: {
        readonly key: "DELETE";
    };
    readonly F1: {
        readonly key: "F1";
    };
    readonly F2: {
        readonly key: "F2";
    };
    readonly F3: {
        readonly key: "F3";
    };
    readonly F4: {
        readonly key: "F4";
    };
    readonly F5: {
        readonly key: "F5";
    };
    readonly F6: {
        readonly key: "F6";
    };
    readonly F7: {
        readonly key: "F7";
    };
    readonly F8: {
        readonly key: "F8";
    };
    readonly F9: {
        readonly key: "F9";
    };
    readonly F10: {
        readonly key: "F10";
    };
    readonly F11: {
        readonly key: "F11";
    };
    readonly F12: {
        readonly key: "F12";
    };
    readonly ALT: {
        readonly key: "ALT";
    };
    readonly CONTROL: {
        readonly key: "CONTROL";
    };
    readonly CONTROL_COMMAND: {
        readonly key: "CONTROL_COMMAND";
    };
    readonly SHIFT: {
        readonly key: "SHIFT";
    };
};
type KeysType = Record<keyof typeof Keys, {
    key: string;
}>;
export type KeyType = KeysType[keyof KeysType];
/**
 * Set the TestDriver instance to be used for testing. This method should be called by
 * tests during setup, before calling any test adapter methods.
 *
 * @param driver The TestDriver instance
 */
export declare function setTestDriver(driver: TestDriver): void;
/**
 * Get the configured TestDriver instance to be used for testing. This method should
 * only be called by test adapters to interact with the browser environment.
 *
 * @returns The TestDriver instance
 */
export declare function getTestDriver(): TestDriver;
/**
 * Unwrap the given TestElement into its driver-specific element
 * @param element
 */
export declare function unwrapElement(element: TestElement): unknown;
export {};
